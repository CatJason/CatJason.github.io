<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android 性能专题 - 插件化预热-拼多多为什么只有26M-GPT4快问快答</title>
      <link href="/2024/02/21/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E6%8F%92%E4%BB%B6%E5%8C%96%E9%A2%84%E7%83%AD-%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%8926M-GPT4%E5%BF%AB%E9%97%AE%E5%BF%AB%E7%AD%94/"/>
      <url>/2024/02/21/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E6%8F%92%E4%BB%B6%E5%8C%96%E9%A2%84%E7%83%AD-%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%8926M-GPT4%E5%BF%AB%E9%97%AE%E5%BF%AB%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h1><p>双亲委派机制（Parent Delegation Model）是Java类加载器（ClassLoader）使用的一种特定模型，在这个模型中，类加载器在尝试加载类或资源时，会首先委托给其父类加载器进行加载，这个过程会一直递归下去，直到达到最顶层的启动类加载器（Bootstrap ClassLoader）。如果父类加载器可以完成类加载工作，就使用父类加载器的定义，如果父类加载器无法完成加载工作（即它搜索的路径中没有找到所需的类），子类加载器才会尝试自己去加载这个类。</p><p>双亲委派机制的优点包括：</p><ol><li><p><strong>避免类的重复加载</strong>：由于在顶层开始尝试加载类，因此类在JVM中只会被加载一次，这样就保证了Java虚拟机中存在的类，都是由唯一的类加载器加载的，从而避免了类的多次加载。</p></li><li><p><strong>保护程序安全</strong>：通过给予Java核心库的加载工作委托给顶层的启动类加载器，保证了Java核心库的类型安全，防止核心API库被随意替换。用户自定义的类加载器不会去尝试加载这些Java核心类库，这样可以防止一些恶意代码替代了这些核心API，从而破坏JVM的安全性。</p></li><li><p><strong>促进正向的类加载工作流</strong>：这种委派模式促进了类加载器之间的协作，遵循了一种从顶层到底层的工作流，使得类加载过程更加清晰。</p></li></ol><p>尽管双亲委派模型带来了上述好处，但在某些情况下，比如在一个Java程序中需要加载一些运行时生成的类，或者是从网络上下载的类，这时可能需要自定义类加载器，并打破双亲委派模型。在Java中，可以通过重写<code>ClassLoader</code>的<code>loadClass</code>方法来实现自定义的类加载逻辑，从而在必要时绕过双亲委派模型。</p><h1 id="为什么可以避免类的重复加载"><a href="#为什么可以避免类的重复加载" class="headerlink" title="为什么可以避免类的重复加载"></a>为什么可以避免类的重复加载</h1><p>双亲委派模型可以避免类的重复加载主要是因为它采用了一种层次化的类加载方式，确保了每个类由一个确定的类加载器负责加载。具体来说，这种机制避免类重复加载的原理和机制包括以下几点：</p><ol><li><p><strong>层次化的类加载器结构</strong>：在Java中，类加载器通常有三层结构（启动类加载器、扩展类加载器、应用程序类加载器），加上可能的自定义类加载器。每个类加载器都有可能有自己的父加载器（除了启动类加载器，它是最顶层的加载器，没有父加载器）。当一个类加载器接收到类加载的请求时，它首先不会尝试自己去加载这个类，而是把这个请求委托给它的父加载器去执行，这样一层层向上直到启动类加载器。</p></li><li><p><strong>委托机制确保类的唯一性</strong>：因为加载请求最终会传递到启动类加载器，如果这个类能被启动类加载器加载，那么它就会由启动类加载器完成加载。如果启动类加载器加载不了，它会返回到下一级加载器尝试，依此类推，直到找到合适的加载器加载这个类。这样一来，无论是哪个类加载器加载的类，都确保了在JVM中的唯一性，因为同一个类在JVM中只会被加载一次。</p></li><li><p><strong>缓存机制</strong>：类加载器在加载类的过程中，会将加载过的类缓存起来。当再次请求加载这个类时，类加载器会首先检查这个类是否已经加载过了，如果已经加载，就直接从缓存中返回这个类的Class对象，而不会再次加载。这个缓存机制进一步保证了类的唯一性和避免重复加载。</p></li><li><p><strong>安全性考虑</strong>：双亲委派模型还有一个重要的安全考量。通过让启动类加载器（负责加载Java核心库的加载器）在加载类的最前线，可以避免核心API被恶意替换。因为用户自定义的类加载器无法直接加载核心API类，所以即使有类的全限定名相同，也不会影响到JVM内部的类实现，这样就避免了核心类库的污染和重复加载。</p></li></ol><p>通过上述机制，双亲委派模型不仅避免了类的重复加载，而且还提升了Java程序的运行时安全性和稳定性。</p><h1 id="向我解释启动类加载器、扩展类加载器、应用程序类加载器"><a href="#向我解释启动类加载器、扩展类加载器、应用程序类加载器" class="headerlink" title="向我解释启动类加载器、扩展类加载器、应用程序类加载器"></a>向我解释启动类加载器、扩展类加载器、应用程序类加载器</h1><p>Java虚拟机（JVM）使用类加载器（ClassLoader）来动态加载类文件到内存中。在JVM中，类加载器遵循双亲委派模型，并且主要分为三种类型：启动（Bootstrap）类加载器、扩展（Extension）类加载器、应用程序（Application）类加载器。它们的作用和层次结构如下：</p><h2 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h2><ul><li><strong>作用</strong>：这是Java类加载器层次结构中的最顶层加载器。它负责加载JVM基础核心类库，如<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>以及类路径中指定的类。这些库位于JDK的<code>jre/lib</code>目录或者是<code>JAVA_HOME/lib</code>目录下。</li><li><strong>实现</strong>：启动类加载器并不是Java实现的，而是由JVM自身的底层代码（如C&#x2F;C++）实现的。这意味着它不继承自<code>java.lang.ClassLoader</code>，不能被Java代码直接引用。</li><li><strong>特点</strong>：由于其加载的是Java的核心类库，因此它不会被Java程序直接控制。它提供了Java运行时环境的基础类，保证了JVM的稳定性和安全性。</li></ul><h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><ul><li><strong>作用</strong>：扩展类加载器负责加载Java的扩展库，即位于JDK的<code>jre/lib/ext</code>目录或者由系统属性<code>java.ext.dirs</code>指定位置的类库。这些库提供了标准Java类库之外的扩展功能。</li><li><strong>实现</strong>：扩展类加载器是用Java实现的，并且它是<code>java.lang.ClassLoader</code>类的一个实例。在类加载器的层次结构中，它是启动类加载器的子加载器。</li><li><strong>特点</strong>：扩展类加载器使得用户可以通过放置jar文件到<code>ext</code>目录来扩展JVM的功能，而不需要放到JVM核心类库目录中去。</li></ul><h2 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h2><ul><li><strong>作用</strong>：应用程序类加载器负责加载用户类路径（Classpath）上的类库，这包括来自于<code>CLASSPATH</code>环境变量、<code>-classpath</code>或<code>-cp</code>命令行选项指定的所有类库。它是程序中默认的类加载器，通常用来加载我们自己写的类和第三方库。</li><li><strong>实现</strong>：这个加载器也是用Java实现的，并且是<code>ClassLoader</code>的一个直接子类。在类加载器的层次结构中，它是扩展类加载器的子加载器。</li><li><strong>特点</strong>：大部分应用程序中的类都是由这个加载器加载的。它保证了应用程序类是由用户定义的路径加载，而不是由JVM的内部路径决定。</li></ul><p>这三个类加载器共同协作，确保了Java应用程序在运行时可以动态加载类，同时保障了系统的安全性和类加载机制的高效性。</p><h1 id="向我介绍什么是Android的插件化"><a href="#向我介绍什么是Android的插件化" class="headerlink" title="向我介绍什么是Android的插件化"></a>向我介绍什么是Android的插件化</h1><p>Android的插件化是一种在Android开发中实现模块化、动态加载和运行时集成第三方组件或模块的技术手段。它允许应用在不需要重新安装或更新整个应用的情况下，动态加载和卸载功能模块。这种技术为应用提供了极高的灵活性和扩展性，使得应用能够根据需要加载新功能或更新现有功能，同时减少了应用的初始下载大小。</p><h2 id="Android插件化的关键特点"><a href="#Android插件化的关键特点" class="headerlink" title="Android插件化的关键特点"></a>Android插件化的关键特点</h2><ol><li><strong>动态性</strong>：插件可以在应用运行时被动态加载和替换，无需重新安装或更新整个应用。</li><li><strong>模块化</strong>：应用的不同功能可以被封装成独立的模块（插件），便于单独开发和管理。</li><li><strong>减小体积</strong>：通过插件化，可以减少应用的初始下载大小，用户可以根据需要下载额外的功能模块。</li><li><strong>更新灵活</strong>：可以单独更新某个功能模块而不影响整个应用，提高了更新的灵活性和效率。</li></ol><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>Android插件化的实现通常涉及到以下几个关键技术点：</p><ul><li><strong>类加载器（ClassLoader）</strong>：利用Android的ClassLoader机制动态加载插件中的类。通过自定义ClassLoader实现类的加载，避免了插件和宿主应用之间的类冲突。</li><li><strong>资源管理</strong>：动态加载插件中的资源（如布局、图片、字符串等），并确保宿主应用和插件能够正常使用这些资源。</li><li><strong>四大组件激活</strong>：动态注册和管理插件中的四大组件（Activity、Service、BroadcastReceiver、ContentProvider），由于这些组件需要在AndroidManifest.xml中静态声明，插件化技术需要绕过这一限制，通过宿主代理或其他机制实现组件的动态激活。</li><li><strong>上下文隔离</strong>：保证插件运行时的上下文（Context）环境与宿主应用隔离，避免相互干扰。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>功能模块化</strong>：将应用的不同功能模块化，按需加载，减轻应用初始体积。</li><li><strong>热更新</strong>：修复bug或更新应用的某部分功能而无需更新整个应用。</li><li><strong>组件共享</strong>：实现跨应用的组件共享和复用。</li></ul><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>尽管插件化为Android应用开发带来了诸多好处，但它也引入了一些挑战，包括复杂的实现机制、性能优化、资源管理、安全性问题等。因此，实现一个稳定、高效的插件化框架需要深入理解Android的底层机制和高级特性。</p><h1 id="双亲委派机制在Android插件化中的作用"><a href="#双亲委派机制在Android插件化中的作用" class="headerlink" title="双亲委派机制在Android插件化中的作用"></a>双亲委派机制在Android插件化中的作用</h1><p>在Android插件化中，双亲委派机制扮演着至关重要的角色，主要体现在插件的加载和运行时隔离方面。由于Android基于Java开发，而Java的类加载器采用双亲委派模型，这对Android插件化的实现产生了直接影响。以下是双亲委派机制在Android插件化中作用的几个关键点：</p><h2 id="确保类的唯一性"><a href="#确保类的唯一性" class="headerlink" title="确保类的唯一性"></a>确保类的唯一性</h2><p>双亲委派机制通过优先委托父加载器加载类的方式，确保了JVM中每个类的唯一性。在Android插件化框架中，这一点尤为重要，因为它可以防止插件中的类与宿主应用或其他插件中的类发生冲突。例如，如果插件和宿主应用都使用了同一个库的不同版本，双亲委派机制可以确保在同一个类加载器上下文中，这个库的类只被加载一次，从而避免版本冲突。</p><h2 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h2><p>双亲委派机制通过限制类的加载来源，提高了应用的安全性。在插件化环境中，通过自定义类加载器加载插件，可以控制插件的权限，防止插件访问或修改宿主应用的私有数据。同时，由于双亲委派模型优先使用父加载器加载类，它还可以防止恶意代码通过插件覆盖或篡改系统类库。</p><h2 id="实现运行时隔离"><a href="#实现运行时隔离" class="headerlink" title="实现运行时隔离"></a>实现运行时隔离</h2><p>在Android插件化中，通常需要实现插件之间以及插件与宿主之间的运行时隔离。双亲委派机制允许插件化框架通过自定义类加载器为每个插件创建独立的命名空间，从而实现隔离。这种隔离机制确保了插件可以独立运行，互不干扰，同时也方便了插件的管理和更新。</p><h2 id="动态加载插件"><a href="#动态加载插件" class="headerlink" title="动态加载插件"></a>动态加载插件</h2><p>插件化框架通常需要动态加载和卸载插件，<strong>双亲委派机制使得这种动态性成为可能</strong>。通过使用自定义的类加载器加载插件，可以在运行时根据需要加载或替换插件，而不需要重新启动应用。这种机制不仅提高了应用的灵活性，也支持了热更新和模块化部署。</p><h2 id="绕过双亲委派模型的挑战"><a href="#绕过双亲委派模型的挑战" class="headerlink" title="绕过双亲委派模型的挑战"></a>绕过双亲委派模型的挑战</h2><p>虽然双亲委派机制有诸多优点，但在实现Android插件化时，有时也需要绕过这种机制。例如，当插件需要使用不同版本的共享库时，可能需要设计复杂的类加载策略来加载正确的类版本，而不是由双亲委派机制自动选择。这就需要插件化框架能够灵活控制类加载过程，可能通过反射或者使用自定义类加载器来实现。</p><p>总的来说，双亲委派机制为Android插件化提供了一个强大的基础，使得插件化框架能够高效、安全地管理和加载插件。但同时，它也带来了一定的挑战，需要开发者深入理解其工作原理，才能有效地利用这一机制实现高质量的插件化方案。</p><h1 id="双亲委派机制如何使得这种动态性成为可能"><a href="#双亲委派机制如何使得这种动态性成为可能" class="headerlink" title="双亲委派机制如何使得这种动态性成为可能"></a>双亲委派机制如何使得这种动态性成为可能</h1><p>双亲委派机制本身是一种类加载机制，确保了类加载的有序性和安全性。在讨论它如何使得动态性成为可能时，我们主要关注的是这种机制如何被用于实现和优化Android插件化中的动态加载和动态更新功能。</p><h2 id="实现动态加载"><a href="#实现动态加载" class="headerlink" title="实现动态加载"></a>实现动态加载</h2><p>在Android插件化中，动态加载指的是应用运行时按需加载外部或者附加的代码和资源，而不是在应用安装时就固定下来。双亲委派机制通过以下方式促进这种动态加载：</p><ul><li><strong>自定义类加载器</strong>：开发者可以通过创建自定义的类加载器来绕过双亲委派机制的一些限制，使得在应用运行时可以加载或替换插件。这些自定义类加载器可以直接或间接继承自<code>ClassLoader</code>类，通过重写<code>findClass</code>方法来实现对插件类的加载。</li><li><strong>隔离和独立</strong>：自定义类加载器可以为每个插件创建独立的命名空间，这意味着即使多个插件包含相同的类名，它们也能够被独立加载和运行，互不干扰。这种隔离保证了插件之间的动态性和独立性。</li></ul><h2 id="支持动态更新"><a href="#支持动态更新" class="headerlink" title="支持动态更新"></a>支持动态更新</h2><p>动态更新是指在不重启应用的情况下更新应用的部分内容或功能。双亲委派机制在这方面的作用体现在：</p><ul><li><strong>类版本的控制</strong>：通过自定义类加载器，应用可以动态地卸载旧的插件类和加载新的插件类。这是因为Java虚拟机(JVM)允许同一个类可以被不同的类加载器加载，只要这些类加载器是不同的实例。因此，通过更新类加载器或者使用不同的类加载器实例，可以实现插件的动态更新。</li><li><strong>资源的动态加载</strong>：除了代码之外，插件化还涉及到资源的动态加载，如图片、布局文件等。自定义类加载器也可以被用来加载这些资源，使得应用能够在运行时不仅更新代码，还可以更新资源。</li></ul><h2 id="如何绕过双亲委派机制"><a href="#如何绕过双亲委派机制" class="headerlink" title="如何绕过双亲委派机制"></a>如何绕过双亲委派机制</h2><p>虽然双亲委派机制的初衷是为了保证安全和一致性，但在插件化场景下，有时需要绕过这一机制以实现更高级的动态性。这通常通过以下方式实现：</p><ul><li><strong>反射和Hook技术</strong>：通过反射调用或修改Android内部的API行为，或者使用Hook技术，可以在不违背双亲委派原则的前提下，实现对类加载过程的控制和干预。</li><li><strong>自定义类加载策略</strong>：通过实现自定义的类加载器，并在其中实现特定的加载策略，可以有选择性地加载或替换特定的类或资源，从而实现对双亲委派机制的有效绕过。</li></ul><p>总的来说，双亲委派机制在Android插件化中的作用并不直接关联到动态性的实现，而是通过自定义类加载器和策略，以及对这一机制的细致控制和适当绕过，使得动态加载和更新成为可能。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Glide 三种池子</title>
      <link href="/2024/02/10/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Glide-%E4%B8%89%E7%A7%8D%E6%B1%A0%E5%AD%90/"/>
      <url>/2024/02/10/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Glide-%E4%B8%89%E7%A7%8D%E6%B1%A0%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Glide 中 LruPoolStrategy 是如何设计的</span><br><span class="line"></span><br><span class="line">三个子类 SizeConfigStrategy AttributeStrategy SizeStrategy 的区别</span><br><span class="line"></span><br><span class="line">从精细度管理的角度，对三种池子进行排序</span><br><span class="line"></span><br><span class="line">如果图片都使用 <span class="string">`ARGB_8888`</span> 应该使用哪个池子</span><br></pre></td></tr></table></figure><h1 id="LruPoolStrategy-接口设计"><a href="#LruPoolStrategy-接口设计" class="headerlink" title="LruPoolStrategy 接口设计"></a>LruPoolStrategy 接口设计</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了在LRU（最近最少使用）缓存中管理可重用位图池的策略接口。</span></span><br><span class="line"><span class="comment"> * 该接口的实现负责定义位图的存储、检索和根据缓存策略及位图的属性（如大小和配置）的逐出机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">interface</span> <span class="title class_">LruPoolStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将位图放入池中。实现应根据其大小、配置或其他属性决定如何将位图添加到池中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap 要添加到池中的位图。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试从池中检索并返回与指定宽度、高度和配置匹配的位图。如果没有找到合适的位图，此方法返回null。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width 请求的位图宽度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 请求的位图高度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 所需位图的Bitmap.Config配置。可以为null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 匹配请求属性的位图，如果没有合适的位图可用则返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从池中移除并返回最近最少使用的位图。如果池为空，此方法返回null。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最近最少使用的位图，如果池为空则返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成并返回指定位图属性的日志友好型字符串表示，如其大小和配置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap 要为其生成日志字符串的位图。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 位图属性的字符串表示，用于日志记录目的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的宽度、高度和配置生成并返回一个位图属性的日志友好型字符串表示。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width 位图的宽度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 位图的高度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 位图的Bitmap.Config配置。可以为null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定属性的字符串表示，用于日志记录目的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定位图的大小（以字节为单位）。实现应根据位图的尺寸和配置计算大小。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap 要计算大小的位图。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 位图的字节大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SizeConfigStrategy"><a href="#SizeConfigStrategy" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h1><p><code>SizeConfigStrategy</code> 是一个实现了 <code>LruPoolStrategy</code> 接口的类，用于管理和重用 <code>Bitmap</code> 对象，其核心目标是通过控制 <code>Bitmap</code> 对象的尺寸和配置来优化内存使用。</p><p>这个策略通过将 <code>Bitmap</code> 对象分类存储在一个组织良好的结构中，并在需要时提供快速访问，以减少内存分配和回收的开销。下面是对这个类的关键部分的详细解析：</p><h2 id="核心数据结构和方法"><a href="#核心数据结构和方法" class="headerlink" title="核心数据结构和方法"></a>核心数据结构和方法</h2><ul><li><p><strong>ARGB_8888_IN_CONFIGS</strong></p></li><li><p><strong>RGA_F16_IN_CONFIGS</strong></p></li><li><p><strong>RGB_565_IN_CONFIGS</strong></p></li><li><p><strong>ARGB_4444_IN_CONFIGS</strong></p></li><li><p><strong>ALPHA_8_IN_CONFIGS</strong><br>这些数组定义了在不同 Android 版本下，根据请求的 <code>Bitmap.Config</code> 所能接受的配置类型。例如，如果请求的是 <code>ARGB_8888</code>，那么可能接受的配置就包括了 <code>ARGB_8888</code> 和 <code>RGBA_F16</code>（在支持的 Android 版本上）。</p></li><li><p><strong>keyPool</strong>:<br><code>KeyPool</code>  实例，用于重用 <code>Key</code> 对象。每个 <code>Key</code> 对象代表一个 <code>Bitmap</code> 的尺寸和配置，这样可以减少内存分配。</p></li><li><p><strong>groupedMap</strong>:<br><code>GroupedLinkedMap&lt;Key?, Bitmap&gt;</code> 实例，用于根据 <code>Key</code> 存储和检索 <code>Bitmap</code> 对象。这种结构支持快速查找、插入和删除操作。</p></li><li><p><strong>sortedSizes</strong>:<br><code>NavigableMap&lt;Int, Int&gt;</code> 的映射，用于跟踪每种配置下不同大小的 <code>Bitmap</code> 数量。这对于找到最匹配的 <code>Bitmap</code> 尺寸非常有用。</p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p><strong>put(bitmap: Bitmap)</strong>:<br>将 <code>Bitmap</code> 添加到池中。这个方法计算 <code>Bitmap</code> 的字节大小，创建或获取一个对应的 <code>Key</code>，并更新 <code>groupedMap</code> 和 <code>sortedSizes</code>。</p></li><li><p><strong>get(width: Int, height: Int, config: Bitmap.Config?)</strong>:<br>尝试根据提供的宽度、高度和配置从池中获取一个最匹配的 <code>Bitmap</code>。这涉及到查找一个尺寸合适、配置兼容的 <code>Bitmap</code>，如果找到，就对其进行重新配置并返回。</p></li><li><p><strong>removeLast()</strong>:<br>移除并返回池中最后一个 <code>Bitmap</code>，这通常是最近最少使用的一个。这个方法还会更新 <code>sortedSizes</code> 以反映      变化。</p></li><li><p><strong>logBitmap(bitmap: Bitmap)</strong> 和 <strong>logBitmap(width: Int, height: Int, config: Bitmap.Config?)</strong>:<br>生成表示 <code>Bitmap</code> 尺寸和配置的字符串，用于日志记录和调试。</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><strong>KeyPool</strong> 和 <strong>Key</strong>:<br>这些类支持 <code>Bitmap</code> 尺寸和配置的高效存储和检索。<code>KeyPool</code> 用于管理 <code>Key</code> 对象的池，以减少创建新对象的需要。<code>Key</code> 对象表示一个 <code>Bitmap</code> 的尺寸和配置，用作 <code>groupedMap</code> 中的键。</li></ul><h2 id="整体设计思路"><a href="#整体设计思路" class="headerlink" title="整体设计思路"></a>整体设计思路</h2><p><code>SizeConfigStrategy</code> 的设计旨在通过细致管理 <code>Bitmap</code> 对象的存储和重用来优化内存使用。它通过精确匹配请求的 <code>Bitmap</code> 尺寸和配置，尽量减少创建新 <code>Bitmap</code> 对象的需要，从而降低了内存压力和提高了性能。这个策略特别适用于图片密集型的应用，比如图片浏览器或社交媒体应用，其中频繁地加载和显示图片。</p><h1 id="AttributeStrategy"><a href="#AttributeStrategy" class="headerlink" title="AttributeStrategy"></a>AttributeStrategy</h1><p>这段代码定义了一个名为 <code>AttributeStrategy</code> 的内部类，实现了 <code>LruPoolStrategy</code> 接口，用于管理位图（Bitmap）的缓存策略。这个策略通过位图的宽度、高度和配置（Bitmap.Config）来唯一标识和管理位图。下面是对这个类的主要组成部分和逻辑的解析：</p><h2 id="类的主要组成部分"><a href="#类的主要组成部分" class="headerlink" title="类的主要组成部分"></a>类的主要组成部分</h2><ol><li><p><strong>KeyPool 类</strong>：一个用于管理 <code>Key</code> 对象池的内部类。它通过重写 <code>create()</code> 方法来创建新的 <code>Key</code> 对象，并提供了一个获取 <code>Key</code> 的方法，该方法接受位图的宽度、高度和配置作为参数，用于初始化 <code>Key</code>。</p></li><li><p><strong>Key 类</strong>：一个内部类，实现了 <code>Poolable</code> 接口。每个 <code>Key</code> 对象包含位图的宽度、高度和配置属性。<code>Key</code> 类提供了 <code>init</code> 方法来设置这些属性，<code>equals</code> 和 <code>hashCode</code> 方法被重写以确保 <code>Key</code> 对象可以根据其宽度、高度和配置被唯一地标识和比较。</p></li><li><p><strong>groupedMap</strong>：一个 <code>GroupedLinkedMap</code> 对象，用于根据 <code>Key</code>（位图的宽度、高度和配置）分组存储和管理位图。</p></li></ol><h2 id="类的主要方法"><a href="#类的主要方法" class="headerlink" title="类的主要方法"></a>类的主要方法</h2><ul><li><p><code>put(bitmap: Bitmap)</code>：将位图添加到缓存中。首先通过 <code>keyPool</code> 获取与位图尺寸和配置对应的 <code>Key</code>，然后将位图和 <code>Key</code> 添加到 <code>groupedMap</code> 中。</p></li><li><p><code>get(width: Int, height: Int, config: Bitmap.Config?)</code>：尝试获取一个符合指定尺寸和配置的位图。首先通过 <code>keyPool</code> 获取与指定尺寸和配置对应的 <code>Key</code>，然后从 <code>groupedMap</code> 中查找和返回相应的位图。</p></li><li><p><code>removeLast()</code>：移除并返回最近最少使用的位图。这是通过从 <code>groupedMap</code> 中移除最后一个位图来实现的。</p></li><li><p><code>logBitmap(bitmap: Bitmap)</code> 和 <code>logBitmap(width: Int, height: Int, config: Bitmap.Config?)</code>：用于生成表示位图尺寸和配置的日志字符串。</p></li><li><p><code>getSize(bitmap: Bitmap)</code>：返回位图占用的字节大小。</p></li></ul><h2 id="特点和用途"><a href="#特点和用途" class="headerlink" title="特点和用途"></a>特点和用途</h2><p><code>AttributeStrategy</code> 通过精确地考虑位图的尺寸和配置来管理位图缓存，使其能够更有效地利用内存并提高缓存的效率。通过使用对象池来管理 <code>Key</code> 对象，还可以减少内存分配和垃圾回收的压力。这种策略特别适用于需要存储和管理多种尺寸和配置位图的应用场景。</p><h1 id="SizeStrategy"><a href="#SizeStrategy" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h1><p>这段代码是一个用于管理位图（Bitmap）缓存策略的内部类 <code>SizeStrategy</code>，它实现了 <code>LruPoolStrategy</code> 接口。这个策略的核心是通过位图大小来管理和回收位图资源，以优化内存使用。下面是对这个类和它的主要组成部分的分析：</p><h2 id="成员变量介绍："><a href="#成员变量介绍：" class="headerlink" title="成员变量介绍："></a><strong>成员变量介绍</strong>：</h2><ul><li><p><code>keyPool</code>: 一个 <code>KeyPool</code> 对象，用于管理 <code>Key</code> 对象的池。每个 <code>Key</code> 对象都与一个特定大小的位图相关联。</p></li><li><p><code>groupedMap</code>: 一个 <code>GroupedLinkedMap&lt;Key, Bitmap&gt;</code> 对象，用于根据 <code>Key</code> 分组存储 <code>Bitmap</code> 对象。这允许快速查找和回收特定大小的位图。</p></li><li><p><code>sortedSizes</code>: 一个 <code>NavigableMap&lt;Int?, Int&gt;</code> 对象，存储每个大小的位图数量。这是一个 <code>PrettyPrintTreeMap</code>，可能是为了便于调试和打印。</p><h2 id="方法解析："><a href="#方法解析：" class="headerlink" title="方法解析："></a><strong>方法解析</strong>：</h2></li><li><p><code>put(bitmap: Bitmap)</code>: 将一个位图添加到缓存中。它计算位图的大小，获取或创建相应大小的 <code>Key</code>，将位图和 <code>Key</code> 添加到 <code>groupedMap</code> 中，并更新 <code>sortedSizes</code> 中对应大小的计数。</p></li><li><p><code>get(width: Int, height: Int, config: Bitmap.Config?)</code>: 尝试获取一个符合指定宽度、高度和配置的位图。它计算所需位图的大小，查找是否有足够大的可用位图，如果有，则从 <code>groupedMap</code> 中取出并返回该位图。</p></li><li><p><code>removeLast()</code>: 移除并返回最近最少使用（LRU）的位图。这是通过从 <code>groupedMap</code> 中移除最后一个位图来实现的，并更新 <code>sortedSizes</code> 中的计数。</p></li><li><p><code>decrementBitmapOfSize(size: Int?)</code>: 减少特定大小的位图数量。如果该大小的位图只有一个，则从 <code>sortedSizes</code> 中移除该大小；否则，减少其计数。</p><h2 id="辅助类："><a href="#辅助类：" class="headerlink" title="辅助类："></a><strong>辅助类</strong>：</h2></li><li><p><code>KeyPool</code>: 用于管理 <code>Key</code> 对象池的类。它重写了 <code>create()</code> 方法来生成新的 <code>Key</code> 对象，并提供了一个重载的 <code>get(size: Int)</code> 方法来获取或创建一个初始化了特定大小的 <code>Key</code>。</p></li><li><p><code>Key</code>: 实现了 <code>Poolable</code> 接口的类，表示与位图大小相关联的键。包含一个 <code>size</code> 属性和 <code>init(size: Int)</code> 方法来设置键的大小。重写了 <code>equals()</code> 和 <code>hashCode()</code> 方法以支持正确的键比较和哈希操作。</p></li></ul><h2 id="常量和辅助方法："><a href="#常量和辅助方法：" class="headerlink" title="常量和辅助方法："></a><strong>常量和辅助方法</strong>：</h2><ul><li><code>MAX_SIZE_MULTIPLE</code>: 一个常量，定义了在查找时可以接受的最大位图大小倍数。</li><li><code>getBitmapString(bitmap: Bitmap)</code> 和 <code>getBitmapString(size: Int)</code>: 辅助方法，用于生成表示位图大小的字符串。</li></ul><p>这个类的设计目的是提高位图缓存的效率和灵活性，通过精细地管理不同大小的位图来优化内存使用。通过维护一个有序的大小映射和一个根据大小分组的位图映射，它可以快速地存取和回收位图资源。</p><p> <code>SizeConfigStrategy</code>、<code>AttributeStrategy</code>、和<code>SizeStrategy</code>是Glide图像加载库用于位图缓存管理的三种不同策略，它们在位图的存储、查找和回收方式上各有特点。这些策略优化了内存使用，并改善了图像加载的性能。以下是它们的区别和各自适用的场景：</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><h2 id="SizeConfigStrategy-1"><a href="#SizeConfigStrategy-1" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><p><strong>特点</strong>：<code>SizeConfigStrategy</code>使用位图的大小（以字节为单位）和<code>Bitmap.Config</code>配置作为键来管理缓存。这种方法允许区分具有相同像素大小但不同像素配置的位图，如<code>ARGB_8888</code>和<code>RGB_565</code>。</p><p><strong>适用场景</strong>：这种策略适用于需要根据位图的内存大小和配置精细管理缓存的应用。例如，如果应用中同时使用了不同配置的位图（以优化显示质量和内存使用），<code>SizeConfigStrategy</code>能有效地区分和管理这些位图。</p><h2 id="AttributeStrategy-1"><a href="#AttributeStrategy-1" class="headerlink" title="AttributeStrategy"></a>AttributeStrategy</h2><p><strong>特点</strong>：<code>AttributeStrategy</code>基于位图的宽度、高度和配置（<code>Bitmap.Config</code>）来识别和管理位图。这种方法提供了对缓存的精确控制，允许缓存系统区分尺寸相同但配置不同的位图。</p><p><strong>适用场景</strong>：当应用需要在相同的尺寸下缓存不同配置的位图，且这些配置对位图的使用和性能有明显影响时，<code>AttributeStrategy</code>非常适用。它确保了即使是细微的配置差异也能被正确管理，适合对图像质量和性能有高要求的应用。</p><h2 id="SizeStrategy-1"><a href="#SizeStrategy-1" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h2><p><strong>特点</strong>：<code>SizeStrategy</code>仅基于位图占用的内存大小来管理缓存，不考虑位图的配置或尺寸。这种策略通过一种更简单的方式来回收和重用位图内存，忽略了位图的其他属性。</p><p><strong>适用场景</strong>：对于那些不需要考虑位图配置差异，主要关注于减少内存占用和简化缓存管理的应用，<code>SizeStrategy</code>是一个理想的选择。它适合内存使用更为紧张，或者位图配置较为统一的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>SizeConfigStrategy</code></strong> 和 <strong><code>AttributeStrategy</code></strong> 提供了更细粒度的缓存管理，能够根据位图的具体特征（如配置和尺寸）进行优化，适合需要高度优化内存使用和图像质量的场景。</p><p><strong><code>SizeStrategy</code></strong> 通过一个更简单的方法来管理缓存，适用于对缓存管理的要求相对简单，更关注于减少内存占用的应用。</p><p>选择哪种策略取决于应用的具体需求，包括对内存管理的敏感度、图像的多样性以及性能的要求。</p><h1 id="三种池子的特点"><a href="#三种池子的特点" class="headerlink" title="三种池子的特点"></a>三种池子的特点</h1><h2 id="SizeConfigStrategy-2"><a href="#SizeConfigStrategy-2" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><ul><li><strong>内存大小</strong>：使用位图的内存大小作为缓存的关键因素之一。</li><li><strong>配置敏感</strong>：考虑了<code>Bitmap.Config</code>，区分了相同大小但配置不同的位图。</li><li><strong>精细管理</strong>：允许对缓存的位图进行更精细的管理，适用于内存和显示质量都很重要的场景。</li></ul><h2 id="AttributeStrategy-2"><a href="#AttributeStrategy-2" class="headerlink" title="AttributeStrategy"></a>AttributeStrategy</h2><ul><li><strong>尺寸配置</strong>：基于位图的宽度、高度和<code>Bitmap.Config</code>来管理位图。</li><li><strong>高度区分</strong>：能够精确区分尺寸相同但配置不同的位图。</li><li><strong>细节控制</strong>：提供对位图缓存的细节控制，适用于对图像显示细节有高要求的应用。</li></ul><h2 id="SizeStrategy-2"><a href="#SizeStrategy-2" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h2><ul><li><strong>简化内存</strong>：仅基于位图占用的内存大小来管理缓存，简化了缓存管理。</li><li><strong>统一处理</strong>：不区分位图的尺寸或配置，统一处理所有位图。</li><li><strong>内存优化</strong>：优先考虑内存使用效率，适用于内存敏感且配置统一的应用场景。</li></ul><p>这些关键字概括了每种策略的核心特点和适用场景，有助于在实际开发中根据应用的需求选择最合适的位图缓存管理策略。</p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><h2 id="SizeConfigStrategy-3"><a href="#SizeConfigStrategy-3" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SizeConfigStrategy</span> : <span class="type">LruPoolStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SIZE_MULTIPLE = <span class="number">8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ARGB_8888_IN_CONFIGS: Array&lt;Bitmap.Config?&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = arrayOf(</span><br><span class="line">            Bitmap.Config.ARGB_8888, <span class="comment">// The value returned by Bitmaps with the hidden Bitmap config.</span></span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                result = result.copyOf(result.size + <span class="number">1</span>)</span><br><span class="line">                result[result.size - <span class="number">1</span>] = Bitmap.Config.RGBA_F16</span><br><span class="line">            &#125;</span><br><span class="line">            ARGB_8888_IN_CONFIGS = result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> RGB_565_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.RGB_565)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> ARGB_4444_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.ARGB_4444)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> ALPHA_8_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.ALPHA_8)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[<span class="variable">$size</span>](<span class="variable">$config</span>)&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInConfigs</span><span class="params">(requested: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Array&lt;Bitmap.Config?&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Bitmap.Config.RGBA_F16 == requested) &#123; <span class="comment">// NOPMD - Avoid short circuiting sdk checks.</span></span><br><span class="line">                    <span class="keyword">return</span> RGBA_F16_IN_CONFIGS</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (requested) &#123;</span><br><span class="line">                Bitmap.Config.ARGB_8888 -&gt; ARGB_8888_IN_CONFIGS</span><br><span class="line">                Bitmap.Config.RGB_565 -&gt; RGB_565_IN_CONFIGS</span><br><span class="line">                Bitmap.Config.ARGB_4444 -&gt; ARGB_4444_IN_CONFIGS</span><br><span class="line">                Bitmap.Config.ALPHA_8 -&gt; ALPHA_8_IN_CONFIGS</span><br><span class="line">                <span class="keyword">else</span> -&gt; arrayOf(requested)</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyPool = KeyPool()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupedMap = GroupedLinkedMap&lt;Key?, Bitmap&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sortedSizes: MutableMap&lt;Bitmap.Config?, NavigableMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = EnumMap(Bitmap.Config::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">    <span class="keyword">val</span> key = keyPool[size, bitmap.config]</span><br><span class="line">    groupedMap.put(key, bitmap)</span><br><span class="line">    <span class="keyword">val</span> sizes = getSizesForConfig(bitmap.config)</span><br><span class="line">    <span class="keyword">val</span> current = sizes[key!!.size]</span><br><span class="line">    sizes[key.size] = <span class="keyword">if</span> (current == <span class="literal">null</span>) <span class="number">1</span> <span class="keyword">else</span> current + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap? &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">    <span class="keyword">val</span> bestKey = findBestKey(size, config)</span><br><span class="line">    <span class="keyword">val</span> result = groupedMap[bestKey]</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            decrementBitmapOfSize(bestKey!!.size, result)</span><br><span class="line">            result.reconfigure(width, height, config)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findBestKey</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Key? &#123;</span><br><span class="line">    <span class="keyword">var</span> result = keyPool[size, config]</span><br><span class="line">        <span class="keyword">for</span> (possibleConfig <span class="keyword">in</span> getInConfigs(config)) &#123;</span><br><span class="line">            <span class="keyword">val</span> sizesForPossibleConfig = getSizesForConfig(possibleConfig)</span><br><span class="line">            <span class="keyword">val</span> possibleSize = sizesForPossibleConfig.ceilingKey(size)</span><br><span class="line">            <span class="keyword">if</span> (possibleSize != <span class="literal">null</span> &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleSize != size</span><br><span class="line">                    || <span class="keyword">if</span> (possibleConfig == <span class="literal">null</span>) config != <span class="literal">null</span> <span class="keyword">else</span> possibleConfig != config</span><br><span class="line">                ) &#123;</span><br><span class="line">                    keyPool.offer(result)</span><br><span class="line">                    result = keyPool[possibleSize, possibleConfig]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">    <span class="keyword">val</span> removed = groupedMap.removeLast()</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> removedSize = getBitmapByteSize(removed)</span><br><span class="line">            decrementBitmapOfSize(removedSize, removed)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> removed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">decrementBitmapOfSize</span><span class="params">(size: <span class="type">Int</span>, removed: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> config = removed.config</span><br><span class="line">        <span class="keyword">val</span> sizes = getSizesForConfig(config)</span><br><span class="line">        <span class="keyword">val</span> current = sizes[size]?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">            <span class="string">&quot;Tried to decrement empty size&quot;</span></span><br><span class="line">            + <span class="string">&quot;, size: &quot;</span></span><br><span class="line">            + size</span><br><span class="line">            + <span class="string">&quot;, removed: &quot;</span></span><br><span class="line">            + logBitmap(removed)</span><br><span class="line">            + <span class="string">&quot;, this: &quot;</span></span><br><span class="line">            + <span class="keyword">this</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">1</span>) &#123;</span><br><span class="line">            sizes.remove(size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sizes[size] = current - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSizesForConfig</span><span class="params">(config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: NavigableMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> sizes = sortedSizes[config]</span><br><span class="line">        <span class="keyword">if</span> (sizes == <span class="literal">null</span>) &#123;</span><br><span class="line">            sizes = TreeMap()</span><br><span class="line">            sortedSizes[config] = sizes</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sizes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">    <span class="keyword">return</span> getBitmapString(size, bitmap.config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">    <span class="keyword">return</span> getBitmapString(size, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getBitmapByteSize(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        .append(<span class="string">&quot;SizeConfigStrategy&#123;groupedMap=&quot;</span>)</span><br><span class="line">        .append(groupedMap)</span><br><span class="line">        .append(<span class="string">&quot;, sortedSizes=(&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> ((key, value) <span class="keyword">in</span> sortedSizes) &#123;</span><br><span class="line">            sb.append(key).append(<span class="string">&#x27;[&#x27;</span>).append(value).append(<span class="string">&quot;], &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sortedSizes.isNotEmpty()) &#123;</span><br><span class="line">        sb.replace(sb.length - <span class="number">2</span>, sb.length, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.append(<span class="string">&quot;)&#125;&quot;</span>).toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">KeyPool</span> : <span class="type">BaseKeyPool</span>&lt;<span class="type">Key?</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Key? &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">get</span>()</span><br><span class="line">            result!!.<span class="keyword">init</span>(size, config)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: Key &#123;</span><br><span class="line">    <span class="keyword">return</span> Key(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Key</span>(<span class="keyword">private</span> <span class="keyword">val</span> pool: KeyPool) : Poolable &#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> config: Bitmap.Config? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">constructor</span>(pool: KeyPool, size: <span class="built_in">Int</span>, config: Bitmap.Config?) : <span class="keyword">this</span>(pool) &#123;</span><br><span class="line">    <span class="keyword">init</span>(size, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size</span><br><span class="line">    <span class="keyword">this</span>.config = config</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool.offer(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> getBitmapString(size, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">is</span> Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (size == other.size &amp;&amp; config == <span class="literal">null</span>) other.config == <span class="literal">null</span> <span class="keyword">else</span> config == other.config</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = size</span><br><span class="line">        result = <span class="number">31</span> * result + <span class="keyword">if</span> (config != <span class="literal">null</span>) config.hashCode() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AttributeStategy"><a href="#AttributeStategy" class="headerlink" title="AttributeStategy"></a>AttributeStategy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.max.hbbitmappool.pool.impl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap</span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.VisibleForTesting</span><br><span class="line"><span class="keyword">import</span> com.max.hbbitmappool.utils.getBitmapByteSize</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AttributeStrategy</span> : <span class="type">LruPoolStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyPool = KeyPool()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupedMap = GroupedLinkedMap&lt;Key?, Bitmap&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> key = keyPool[bitmap.width, bitmap.height, bitmap.config]</span><br><span class="line">        groupedMap.put(key, bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">val</span> key = keyPool[width, height, config]</span><br><span class="line">        <span class="keyword">return</span> groupedMap[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">return</span> groupedMap.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(width, height, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapByteSize(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AttributeStrategy:\n  <span class="variable">$groupedMap</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">KeyPool</span> : <span class="type">BaseKeyPool</span>&lt;<span class="type">Key?</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Key? &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">get</span>()</span><br><span class="line">            result?.<span class="keyword">init</span>(width, height, config)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: Key &#123;</span><br><span class="line">            <span class="keyword">return</span> Key(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Key</span>(<span class="keyword">private</span> <span class="keyword">val</span> pool: KeyPool) : Poolable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> config: Bitmap.Config? = <span class="literal">null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.width = width</span><br><span class="line">            <span class="keyword">this</span>.height = height</span><br><span class="line">            <span class="keyword">this</span>.config = config</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (other <span class="keyword">is</span> Key) &#123;</span><br><span class="line">                <span class="keyword">return</span> width == other.width &amp;&amp; height == other.height &amp;&amp; config == other.config</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = width</span><br><span class="line">            result = <span class="number">31</span> * result + height</span><br><span class="line">            result = <span class="number">31</span> * result + <span class="keyword">if</span> (config != <span class="literal">null</span>) config.hashCode() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(width, height, config)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">()</span></span> &#123;</span><br><span class="line">            pool.offer(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(bitmap.width, bitmap.height, bitmap.config)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + width + <span class="string">&quot;x&quot;</span> + height + <span class="string">&quot;], &quot;</span> + config</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SizeStrategy-3"><a href="#SizeStrategy-3" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">SizeStrategy</span> : <span class="type">LruPoolStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyPool = KeyPool()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupedMap = GroupedLinkedMap&lt;Key, Bitmap&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sortedSizes: NavigableMap&lt;<span class="built_in">Int</span>?, <span class="built_in">Int</span>&gt; = PrettyPrintTreeMap()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">        <span class="keyword">val</span> key = keyPool[size]</span><br><span class="line">        groupedMap.put(key, bitmap)</span><br><span class="line">        <span class="keyword">val</span> current = sortedSizes[key.size]</span><br><span class="line">        sortedSizes[key.size] = <span class="keyword">if</span> (current == <span class="literal">null</span>) <span class="number">1</span> <span class="keyword">else</span> current + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">        <span class="keyword">var</span> key = keyPool[size]</span><br><span class="line">        <span class="keyword">val</span> possibleSize = sortedSizes.ceilingKey(size)</span><br><span class="line">        <span class="keyword">if</span> (possibleSize != <span class="literal">null</span> &amp;&amp; possibleSize != size &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class="line">            keyPool.offer(key)</span><br><span class="line">            key = keyPool[possibleSize]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result = groupedMap[key]</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.reconfigure(width, height, config)</span><br><span class="line">            decrementBitmapOfSize(possibleSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">val</span> removed = groupedMap.removeLast()</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> removedSize = getBitmapByteSize(removed)</span><br><span class="line">            decrementBitmapOfSize(removedSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">decrementBitmapOfSize</span><span class="params">(size: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> current = sortedSizes[size]</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">1</span>) &#123;</span><br><span class="line">            sortedSizes.remove(size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sortedSizes[size] = current!! - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapByteSize(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SizeStrategy:\n  <span class="variable">$groupedMap</span>\n  SortedSizes<span class="variable">$sortedSizes</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-final for mocking.</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">KeyPool</span> : <span class="type">BaseKeyPool</span>&lt;<span class="type">Key?</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Key &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">super</span>.<span class="keyword">get</span>()!!</span><br><span class="line">            result.<span class="keyword">init</span>(size)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: Key &#123;</span><br><span class="line">            <span class="keyword">return</span> Key(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Key</span>(<span class="keyword">private</span> <span class="keyword">val</span> pool: KeyPool) : Poolable &#123;</span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(size: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(o: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">is</span> Key) &#123;</span><br><span class="line">                <span class="keyword">return</span> size == o.size</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">()</span></span> &#123;</span><br><span class="line">            pool.offer(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SIZE_MULTIPLE = <span class="number">8</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(size: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[<span class="variable">$size</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种池子精细化管理排序</p><ol><li><strong>AttributeStrategy</strong></li><li><strong>SizeConfigStrategy</strong></li><li><strong>SizeStrategy</strong></li></ol><h3 id="1-AttributeStrategy"><a href="#1-AttributeStrategy" class="headerlink" title="1. AttributeStrategy"></a>1. AttributeStrategy</h3><ul><li><strong>精细化等级：最高</strong></li><li><strong>原因</strong>：<code>AttributeStrategy</code>基于位图的宽度、高度和<code>Bitmap.Config</code>配置来管理位图，提供了最细致的控制。这允许它区分具有相同像素数量但不同尺寸或配置的位图，实现了对位图缓存的高度精细化管理。</li></ul><h3 id="2-SizeConfigStrategy"><a href="#2-SizeConfigStrategy" class="headerlink" title="2. SizeConfigStrategy"></a>2. SizeConfigStrategy</h3><ul><li><strong>精细化等级：中等</strong></li><li><strong>原因</strong>：<code>SizeConfigStrategy</code>结合了位图的内存大小和配置（如<code>ARGB_8888</code>、<code>RGB_565</code>等）来管理位图。虽然它不如<code>AttributeStrategy</code>能够精确到位图的具体尺寸，但通过考虑配置信息，它在位图的管理上提供了比仅基于大小更精细的控制。</li></ul><h3 id="3-SizeStrategy"><a href="#3-SizeStrategy" class="headerlink" title="3. SizeStrategy"></a>3. SizeStrategy</h3><ul><li><strong>精细化等级：最低</strong></li><li><strong>原因</strong>：<code>SizeStrategy</code>仅基于位图占用的内存大小来管理位图，完全忽略了位图的尺寸和配置信息。这种策略提供了最简单的管理方式，适合于那些内存使用效率是主要关注点、对位图的具体属性（如尺寸和配置）关注较少的场景。</li></ul><p>总结来说，如果需要对缓存中的位图进行非常精细化的管理，优先选择<code>AttributeStrategy</code>；<br>如果希望在精细化管理和简化逻辑之间取得平衡，<code>SizeConfigStrategy</code>是一个好的选择；<br>而如果主要关注简化缓存管理和优化内存使用，<code>SizeStrategy</code>将是最合适的策略。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - router-annotation 路由注解模块</title>
      <link href="/2023/09/10/Android/ARouter/01-ARouter/"/>
      <url>/2023/09/10/Android/ARouter/01-ARouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li><a href="#Autowired">Autowired.java</a> 自动注入的注解</li><li><a href="#Interceptor">Interceptor.java</a> 拦截器的注解</li><li><a href="#Param(%E5%BA%9F%E5%BC%83)">Param.java(废弃)</a> 参数注解: 被 Autowired 淘汰</li><li><a href="#Route">Route.java</a> 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li><a href="#RouteType">RouteType.java</a> 路由类型的枚举</li><li><a href="#TypeKind">TypeKind.java</a> 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li><a href="#RouteMeta">RouteMeta.java</a> 路由元信息的模型类</li><li><a href="#TypeWrapper">TypeWrapper.java</a> 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="router-annotation-路由注解模块"><a href="#router-annotation-路由注解模块" class="headerlink" title="router-annotation 路由注解模块"></a>router-annotation 路由注解模块</h3><h4 id="annotation-存放各种注解类的包"><a href="#annotation-存放各种注解类的包" class="headerlink" title="annotation 存放各种注解类的包"></a>annotation 存放各种注解类的包</h4><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h5><p>自动注入的注解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation for field, which need autowired.</span></span><br><span class="line"><span class="comment"> * 用于需要自动注入的字段的注解。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/20 下午4:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FIELD)</span> <span class="comment">// 表示该注解只能用于字段上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Autowired</span>( <span class="comment">// Mark param&#x27;s name or service name.</span></span><br><span class="line">    <span class="comment">// 标记参数的名称或服务名称</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,  <span class="comment">// If required, app will be crash when value is null.</span></span><br><span class="line">    <span class="comment">// Primitive type wont be check!</span></span><br><span class="line">    <span class="comment">// 如果设置为true，在数值为null时应用程序将崩溃。不会检查原始类型！</span></span><br><span class="line">    <span class="keyword">val</span> required: <span class="built_in">Boolean</span> = <span class="literal">false</span>,  <span class="comment">// Description of the field</span></span><br><span class="line">    <span class="comment">// 字段的描述信息</span></span><br><span class="line">    <span class="keyword">val</span> desc: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>标记需要注入的字段</strong>：在你的类中，标记需要进行自动注入的字段。使用 <code>@Autowired</code> 注解，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyDependency myDependency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>myDependency</code> 字段被标记为需要自动注入的依赖对象。</p><p>假设你有两个相同类型的依赖对象 <code>MyDependency</code>，但它们在功能上略有不同，你需要指定要注入哪一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(name = &quot;dependencyA&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyDependency dependencyA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(name = &quot;dependencyB&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyDependency dependencyB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记拦截器以拦截路由。</span></span><br><span class="line"><span class="comment"> * 注意：此注解仅可用于标记#&#123;IInterceptor&#125;的实现！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/23 14:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)</span> <span class="comment">// 表示该注解只能用于类上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器的优先级，ARouter将按优先级执行它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> priority: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器的名称，可能用于生成javadoc。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;Default&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要使用 <code>@Interceptor</code> 注解，你需要将其标记在实现了 <code>IInterceptor</code> 接口的类上，以定义一个拦截器。然后，你可以使用这个拦截器来拦截路由操作。下面是使用 <code>@Interceptor</code> 注解的一般步骤：</p><p>创建一个实现了 <code>IInterceptor</code> 接口的类，该类将用作拦截器。确保类实现了接口中的 <code>process</code> 方法，该方法定义了拦截器的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kotlinCopy code</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.annotation.Interceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.callback.InterceptorCallback</span><br><span class="line"></span><br><span class="line"><span class="meta">@Interceptor(priority = 1, name = &quot;ExampleInterceptor&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleInterceptor</span> : IInterceptor &#123;</span><br><span class="line">    override fun <span class="title function_">process</span><span class="params">(postcard: Postcard?, callback: InterceptorCallback?)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里编写拦截器的逻辑</span></span><br><span class="line">        <span class="comment">// 可以在进入路由之前或之后执行一些操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后，调用 callback.onContinue(postcard) 继续路由操作，或者 callback.onInterrupt(exception) 中断路由操作</span></span><br><span class="line">        callback?.onContinue(postcard)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Param-废弃"><a href="#Param-废弃" class="headerlink" title="Param(废弃)"></a>Param(废弃)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于标记页面参数的注解。</span></span><br><span class="line"><span class="comment"> * 此注解已被弃用，请使用 &#x27;Autowired&#x27; 代替！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2016/11/22 18:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FIELD)</span> <span class="comment">// 表示该注解只能用于字段上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;&quot;</span>)</span> <span class="comment">// 表示该注解已被弃用</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Param</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段的描述信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> desc: String = <span class="string">&quot;No desc.&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>既已废弃，不浪费时间</p><h5 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记页面可由路由器路由。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/15 下午9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)</span> <span class="comment">// 表示该注解只能用于类上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Route</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> path: String,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于合并路由，组名必须使用常见单词!!!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> group: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的名称，用于生成javadoc。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外的数据，可以由用户设置。</span></span><br><span class="line"><span class="comment">     * 注意：您应该使用整数数值表示开关，通过位进行标记。例如：10001010101010</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> extras: <span class="built_in">Int</span> = <span class="built_in">Int</span>.MIN_VALUE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的优先级。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> priority: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个类定义了一个用于标记页面可由路由器路由的注解 <code>@Route</code>。该注解包含了五个元素，分别表示路由的路径、组名、名称、额外数据和优先级。</p><p>创建一个页面类，并在该类上添加 <code>@Route</code> 注解，以标记这个页面可以被路由器路由。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @Route 注解标记这个页面</span></span><br><span class="line"><span class="meta">@Route(path = <span class="string">&quot;/example/activity&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="comment">// 页面的代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为 <code>ExampleActivity</code> 的页面类，并使用 <code>@Route</code> 注解标记了这个页面的路由路径为 <code>&quot;/example/activity&quot;</code>。</p><h4 id="enums-包含各种枚举类型的包"><a href="#enums-包含各种枚举类型的包" class="headerlink" title="enums 包含各种枚举类型的包"></a>enums 包含各种枚举类型的包</h4><h5 id="RouteType"><a href="#RouteType" class="headerlink" title="RouteType"></a>RouteType</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.enums</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由类型的枚举。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/23 22:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">RouteType</span>(<span class="comment">// 未知类型的路由</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> className: String</span><br><span class="line">) &#123;</span><br><span class="line">    ACTIVITY(<span class="number">0</span>, <span class="string">&quot;android.app.Activity&quot;</span>),  <span class="comment">// Activity类型的路由</span></span><br><span class="line">    SERVICE(<span class="number">1</span>, <span class="string">&quot;android.app.Service&quot;</span>),  <span class="comment">// Service类型的路由</span></span><br><span class="line">    PROVIDER(<span class="number">2</span>, <span class="string">&quot;com.alibaba.android.arouter.facade.template.IProvider&quot;</span>),  <span class="comment">// Provider类型的路由</span></span><br><span class="line">    CONTENT_PROVIDER(-<span class="number">1</span>, <span class="string">&quot;android.app.ContentProvider&quot;</span>),  <span class="comment">// ContentProvider类型的路由</span></span><br><span class="line">    BOARDCAST(-<span class="number">1</span>, <span class="string">&quot;&quot;</span>),  <span class="comment">// Broadcast类型的路由</span></span><br><span class="line">    METHOD(-<span class="number">1</span>, <span class="string">&quot;&quot;</span>),  <span class="comment">// Method类型的路由</span></span><br><span class="line">    FRAGMENT(-<span class="number">1</span>, <span class="string">&quot;android.app.Fragment&quot;</span>),  <span class="comment">// Fragment类型的路由</span></span><br><span class="line">    UNKNOWN(-<span class="number">1</span>, <span class="string">&quot;Unknown route type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setId</span><span class="params">(id: <span class="type">Int</span>)</span></span>: RouteType &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClassName</span><span class="params">(className: <span class="type">String</span>)</span></span>: RouteType &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(name: <span class="type">String</span>)</span></span>: RouteType &#123;</span><br><span class="line">            <span class="keyword">for</span> (routeType <span class="keyword">in</span> values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (routeType.className == name) &#123;</span><br><span class="line">                    <span class="keyword">return</span> routeType</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TypeKind"><a href="#TypeKind" class="headerlink" title="TypeKind"></a>TypeKind</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.enums</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段类型的种类枚举。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017-03-16 19:13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">TypeKind</span> &#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    BOOLEAN,  <span class="comment">// 布尔类型</span></span><br><span class="line">    BYTE,  <span class="comment">// 字节类型</span></span><br><span class="line">    SHORT,  <span class="comment">// 短整型</span></span><br><span class="line">    INT,  <span class="comment">// 整型</span></span><br><span class="line">    LONG,  <span class="comment">// 长整型</span></span><br><span class="line">    CHAR,  <span class="comment">// 字符类型</span></span><br><span class="line">    FLOAT,  <span class="comment">// 单精度浮点型</span></span><br><span class="line">    DOUBLE,  <span class="comment">// 双精度浮点型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他类型</span></span><br><span class="line">    STRING,  <span class="comment">// 字符串类型</span></span><br><span class="line">    SERIALIZABLE,  <span class="comment">// 可序列化类型</span></span><br><span class="line">    PARCELABLE,  <span class="comment">// Parcelable类型</span></span><br><span class="line">    OBJECT <span class="comment">// 对象类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="model-包含模型类的包"><a href="#model-包含模型类的包" class="headerlink" title="model 包含模型类的包"></a>model 包含模型类的包</h4><h5 id="RouteMeta"><a href="#RouteMeta" class="headerlink" title="RouteMeta"></a>RouteMeta</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Autowired</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"><span class="keyword">import</span> com.miao.router.RouteType</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含基本路由信息的类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/24 09:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RouteMeta</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> type: RouteType? = <span class="literal">null</span> <span class="comment">// 路由类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rawType: javax.lang.model.element.Element? = <span class="literal">null</span> <span class="comment">// 路由的原始类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> destination : Class&lt;*&gt;? = <span class="literal">null</span> <span class="comment">// 目标类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> path : String? = <span class="literal">null</span> <span class="comment">// 路由路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> group: String? = <span class="literal">null</span> <span class="comment">// 路由分组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> priority = -<span class="number">1</span> <span class="comment">// 优先级，数值越小优先级越高</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> extra = <span class="number">0</span><span class="comment">// 额外数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> paramsType: Map&lt;String?, <span class="built_in">Int</span>?&gt;? = <span class="literal">null</span> <span class="comment">// 参数类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> injectConfig: Map&lt;String, Autowired&gt;? = <span class="literal">null</span> <span class="comment">// 缓存注入配置信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> route       路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        route: Route,</span><br><span class="line">        destination: Class&lt;*&gt;?,</span><br><span class="line">        type: RouteType?</span><br><span class="line">    ) : <span class="keyword">this</span>(</span><br><span class="line">        type,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        destination,</span><br><span class="line">        route.name(),</span><br><span class="line">        route.path(),</span><br><span class="line">        route.group(),</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        route.priority(),</span><br><span class="line">        route.extras()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> route      路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawType    原始类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type       类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramsType 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        route: Route,</span><br><span class="line">        rawType: javax.lang.model.element.Element?,</span><br><span class="line">        type: RouteType?,</span><br><span class="line">        paramsType: Map&lt;String?, <span class="built_in">Int</span>?&gt;?</span><br><span class="line">    ) : <span class="keyword">this</span>(</span><br><span class="line">        type,</span><br><span class="line">        rawType,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        route.name(),</span><br><span class="line">        route.path(),</span><br><span class="line">        route.group(),</span><br><span class="line">        paramsType,</span><br><span class="line">        route.priority(),</span><br><span class="line">        route.extras()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawType     原始类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path        路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group       分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramsType  参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priority    优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extra       额外数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        type: RouteType?,</span><br><span class="line">        rawType: javax.lang.model.element.Element?,</span><br><span class="line">        destination: Class&lt;*&gt;?,</span><br><span class="line">        name: String?,</span><br><span class="line">        path: String?,</span><br><span class="line">        group: String?,</span><br><span class="line">        paramsType: Map&lt;String?, <span class="built_in">Int</span>?&gt;?,</span><br><span class="line">        priority: <span class="built_in">Int</span>,</span><br><span class="line">        extra: <span class="built_in">Int</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.destination = destination</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType</span><br><span class="line">        <span class="keyword">this</span>.path = path</span><br><span class="line">        <span class="keyword">this</span>.group = group</span><br><span class="line">        <span class="keyword">this</span>.paramsType = paramsType</span><br><span class="line">        <span class="keyword">this</span>.priority = priority</span><br><span class="line">        <span class="keyword">this</span>.extra = extra</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setParamsType</span><span class="params">(paramsType: <span class="type">Map</span>&lt;<span class="type">String</span>?, <span class="built_in">Int</span>?&gt;?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.paramsType = paramsType</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRawType</span><span class="params">()</span></span>: javax.lang.model.element.Element? &#123;</span><br><span class="line">        <span class="keyword">return</span> rawType</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setRawType</span><span class="params">(rawType: <span class="type">javax</span>.<span class="type">lang</span>.<span class="type">model</span>.<span class="type">element</span>.<span class="type">Element</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setType</span><span class="params">(type: <span class="type">RouteType</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setDestination</span><span class="params">(destination: <span class="type">Class</span>&lt;*&gt;?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.destination = destination</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setPath</span><span class="params">(path: <span class="type">String</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setGroup</span><span class="params">(group: <span class="type">String</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.group = group</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setPriority</span><span class="params">(priority: <span class="type">Int</span>)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setExtra</span><span class="params">(extra: <span class="type">Int</span>)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.extra = extra</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RouteMeta&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;type=&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;, rawType=&quot;</span> + rawType +</span><br><span class="line">                <span class="string">&quot;, destination=&quot;</span> + destination +</span><br><span class="line">                <span class="string">&quot;, path=&#x27;&quot;</span> + path + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, group=&#x27;&quot;</span> + group + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, priority=&quot;</span> + priority +</span><br><span class="line">                <span class="string">&quot;, extra=&quot;</span> + extra +</span><br><span class="line">                <span class="string">&quot;, paramsType=&quot;</span> + paramsType +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * For versions of &#x27;compiler&#x27; less than 1.0.7, contain 1.0.7</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> path        路径</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> group       分组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> priority    优先级</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> extra       额外数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            type: <span class="type">RouteType</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            destination: <span class="type">Class</span>&lt;*&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            group: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            priority: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            extra: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: RouteMeta &#123;</span><br><span class="line">            <span class="keyword">return</span> RouteMeta(type, <span class="literal">null</span>, destination, <span class="literal">null</span>, path, group, <span class="literal">null</span>, priority, extra)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * For versions of &#x27;compiler&#x27; greater than 1.0.7</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> path        路径</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> group       分组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> paramsType  参数类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> priority    优先级</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> extra       额外数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            type: <span class="type">RouteType</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            destination: <span class="type">Class</span>&lt;*&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            group: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            paramsType: <span class="type">Map</span>&lt;<span class="type">String</span>?, <span class="built_in">Int</span>?&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">            priority: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            extra: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: RouteMeta &#123;</span><br><span class="line">            <span class="keyword">return</span> RouteMeta(</span><br><span class="line">                type,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                destination,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                path,</span><br><span class="line">                group,</span><br><span class="line">                paramsType,</span><br><span class="line">                priority,</span><br><span class="line">                extra</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private RouteType type</code>：表示路由的类型，可能是普通路由、自动注入、或者其他类型。<br><code>private Element rawType</code>：表示路由的原始类型的元素。<br><code>private Class&lt;?&gt; destination</code>：表示目标类，即路由到哪个页面。<br><code>private String path</code>：表示路由的路径，用于唯一标识一个路由。<br><code>private String group</code>：表示路由的分组，通常用于组织路由。<br><code>private int priority</code>：表示路由的优先级，数值越小表示优先级越高。<br><code>private int extra</code>：表示额外的数据，可以用于传递一些标记或开关。<br><code>private Map&lt;String, Integer&gt; paramsType</code>：表示参数类型的映射。<br><code>private String name</code>：表示路由的名称。</p><p>RouteMeta 是 Route 原子信息与其构建类</p><h5 id="TypeWrapper"><a href="#TypeWrapper" class="headerlink" title="TypeWrapper"></a>TypeWrapper</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于获取目标对象的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 17/10/26 11:56:22</span></span><br><span class="line"><span class="comment">&lt;/T&gt; */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeWrapper</span>&lt;<span class="type">T</span>&gt; <span class="keyword">protected</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标对象的类型。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标对象的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> type: Type <span class="comment">// 存储目标对象的类型信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> superClass = javaClass.genericSuper<span class="keyword">class</span></span><br><span class="line">        <span class="title class_">type</span> =</span><br><span class="line">            (superClass <span class="keyword">as</span> ParameterizedType).actualTypeArguments[<span class="number">0</span>] <span class="comment">// 获取泛型类型参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Java 反射获取当前类的父类，然后从父类中获取泛型参数的类型信息，并将其赋值给 <code>type</code> 字段。这样，这个类就能够存储目标对象的泛型类型信息。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - base 基础功能 与 core 核心功能</title>
      <link href="/2023/09/10/Android/ARouter/02-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/02-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li><p>base 基础功能相关的包</p><ul><li><a href="#UniqueKeyTreeMap">UniqueKeyTreeMap.java</a> 唯一键树形映射的类</li></ul></li><li><p>core 核心功能相关的包</p><ul><li><a href="#AutowiredLifecyleCallback(%E5%BA%9F%E5%BC%83)">AutowiredLifecyleCallback.java(废弃)</a> 自动注入生命周期回调的类</li><li><a href="#AutowiredServiceImp">AutowiredServiceImpl.java</a> 自动注入服务的实现类</li><li><a href="#InstrumentationHook(%E5%BA%9F%E5%BC%83)">InstrumentationHook.java(废弃)</a> 仪表钩子的类</li><li><a href="#InterceptorServiceImpl">InterceptorServiceImpl.java</a> 拦截器服务的实现类</li><li><a href="#LogisticsCenter">LogisticsCenter.java</a> 物流中心的类</li><li><a href="#Warehouse">Warehouse.java</a> 仓库的类</li></ul></li><li><p>exception 异常相关的包</p><ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li><p>facade 提供各种服务和回调的包</p><ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li><p>service 服务相关的包</p><ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li><p>template 模板相关的包</p><ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li><p>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。</p><ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li><p>thread （线程）包含了与线程管理相关的类。</p><ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li><p>utils 工具类。</p><ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="arouter-api-ARouter框架的API模块"><a href="#arouter-api-ARouter框架的API模块" class="headerlink" title="arouter-api  ARouter框架的API模块"></a>arouter-api  ARouter框架的API模块</h3><h4 id="base-基础功能相关的包"><a href="#base-基础功能相关的包" class="headerlink" title="base 基础功能相关的包"></a>base 基础功能相关的包</h4><h5 id="UniqueKeyTreeMap"><a href="#UniqueKeyTreeMap" class="headerlink" title="UniqueKeyTreeMap"></a>UniqueKeyTreeMap</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.base</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap with unique key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/22 下午5:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueKeyTreeMap</span>&lt;<span class="type">K, V</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> tipText: String) :</span><br><span class="line">    TreeMap&lt;K, V&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: V? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(String.format(tipText, key))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.put(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="core-核心功能相关的包"><a href="#core-核心功能相关的包" class="headerlink" title="core 核心功能相关的包"></a>core 核心功能相关的包</h4><h5 id="AutowiredLifecyleCallback-废弃"><a href="#AutowiredLifecyleCallback-废弃" class="headerlink" title="AutowiredLifecyleCallback(废弃)"></a>AutowiredLifecyleCallback(废弃)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.TargetApi</span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.app.Application.ActivityLifecycleCallbacks</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LifecycleCallback for autowired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/21 上午11:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutowiredLifecycleCallback</span> : <span class="type">ActivityLifecycleCallbacks</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ARouter.getInstance().inject(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStarted</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResumed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityPaused</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(activity: <span class="type">Activity</span>, outState: <span class="type">Bundle</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经废弃，不废话</p><h5 id="AutowiredServiceImpl"><a href="#AutowiredServiceImpl" class="headerlink" title="AutowiredServiceImpl"></a>AutowiredServiceImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.LruCache</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.service.AutowiredService</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.ISyringe</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_AUTOWIRED</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动注入服务的实现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作者: zhilong [联系我](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * 版本: 1.0</span></span><br><span class="line"><span class="comment"> * 创建日期: 2017年2月28日 下午6:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Route(path = <span class="string">&quot;/arouter/service/autowired&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutowiredServiceImpl</span> : <span class="type">AutowiredService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> classCache: LruCache&lt;String, ISyringe&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> blackList: MutableList&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        classCache = LruCache&lt;String, ISyringe&gt;(<span class="number">50</span>)</span><br><span class="line">        blackList = ArrayList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注入方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance 要进行注入的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">autowire</span><span class="params">(instance: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        doInject(instance, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归注入方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance 调用该方法的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent   父类的Class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInject</span><span class="params">(instance: <span class="type">Any</span>, parent: <span class="type">Class</span>&lt;*&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果提供了父类的 Class 对象，则使用父类的 Class；否则，使用实例的 Class</span></span><br><span class="line">        <span class="keyword">val</span> clazz = parent ?: instance.javaClass</span><br><span class="line">        <span class="comment">// 获取适用于当前类的注入器实例</span></span><br><span class="line">        <span class="keyword">val</span> syringe: ISyringe? = getSyringe(clazz)</span><br><span class="line">        <span class="comment">// 如果存在适用的注入器实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != syringe) &#123;</span><br><span class="line">            <span class="comment">// 使用注入器进行注入</span></span><br><span class="line">            syringe.inject(instance)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前类的父类的 Class 对象</span></span><br><span class="line">        <span class="keyword">val</span> superClazz = clazz.superclass</span><br><span class="line">        <span class="comment">// 如果存在父类，并且父类不是 Android 框架类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != superClazz &amp;&amp; !superClazz.name.startsWith(<span class="string">&quot;android&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用 doInject 方法，继续为父类进行自动注入</span></span><br><span class="line">            doInject(instance, superClazz)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注入器实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类的Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入器实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSyringe</span><span class="params">(clazz: <span class="type">Class</span>&lt;*&gt;)</span></span>: ISyringe? &#123;</span><br><span class="line">        <span class="comment">// 获取类的完整名称</span></span><br><span class="line">        <span class="keyword">val</span> className = clazz.name</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查类名是否在黑名单中，如果不在，则尝试获取对应的注入器</span></span><br><span class="line">            <span class="keyword">if</span> (!blackList!!.contains(className)) &#123;</span><br><span class="line">                <span class="comment">// 从缓存中尝试获取注入器实例</span></span><br><span class="line">                <span class="keyword">var</span> syringeHelper: ISyringe? = classCache!![className]</span><br><span class="line">                <span class="comment">// 如果缓存中没有该注入器实例</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == syringeHelper) &#123;</span><br><span class="line">                    <span class="comment">// 动态加载并创建注入器实例</span></span><br><span class="line">                    syringeHelper = Class.forName(</span><br><span class="line">                      clazz.name + SUFFIX_AUTOWIRED</span><br><span class="line">                    ).getConstructor()</span><br><span class="line">                        .newInstance() <span class="keyword">as</span> ISyringe</span><br><span class="line">                    <span class="comment">// 将创建的注入器实例缓存起来，以便下次使用</span></span><br><span class="line">                    classCache!!.put(className, syringeHelper)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回获取到的注入器实例</span></span><br><span class="line">                <span class="keyword">return</span> syringeHelper</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="comment">// 如果在获取注入器的过程中发生异常，将类名添加到黑名单中，表示该实例无需自动注入</span></span><br><span class="line">            blackList!!.add(className)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果无法获取注入器实例，返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doInject</code> 方法用于自动注入依赖到给定的实例（<code>instance</code>）中。</p><h5 id="InstrumentationHook-废弃"><a href="#InstrumentationHook-废弃" class="headerlink" title="InstrumentationHook(废弃)"></a>InstrumentationHook(废弃)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.app.Instrumentation</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.TextUtils</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 ARouter.getInstance().inject(this) 来进行注入！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hook Instrumentation，为 Activity 的字段注入值。</span></span><br><span class="line"><span class="comment"> * 仅支持普通 Activity，不包括单元测试。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作者：Alex [联系我](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * 版本：1.0</span></span><br><span class="line"><span class="comment"> * 创建日期：2016年11月24日 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InstrumentationHook</span> : <span class="type">Instrumentation</span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hook Instrumentation 的 newActivity 方法，进行注入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 执行进程的 [Activity] 对象的实例化。默认实现提供正常的系统行为。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl        用于实例化对象的类加载器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 实现 Activity 对象的类的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent    指定要实例化的活动类的 Intent 对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新创建的 Activity 对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Throws(</span></span><br><span class="line"><span class="meta">        InstantiationException::class,</span></span><br><span class="line"><span class="meta">        IllegalAccessException::class,</span></span><br><span class="line"><span class="meta">        ClassNotFoundException::class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        cl: <span class="type">ClassLoader</span>, className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        intent: <span class="type">Intent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Activity &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        return (Activity)cl.loadClass(className).newInstance();</span></span><br><span class="line">        <span class="comment">// 使用类加载器加载目标 Activity 类的定义</span></span><br><span class="line">        <span class="keyword">val</span> targetActivity = cl.loadClass(className)</span><br><span class="line">        <span class="comment">// 创建目标 Activity 的实例</span></span><br><span class="line">        <span class="keyword">val</span> instanceOfTarget = targetActivity.newInstance()</span><br><span class="line">        <span class="comment">// 检查是否可以自动注入</span></span><br><span class="line">        <span class="keyword">if</span> (ARouter.canAutoInject()) &#123;</span><br><span class="line">            <span class="comment">// 从 Intent 中获取自动注入的参数</span></span><br><span class="line">            <span class="keyword">val</span> autoInjectParams = intent.getStringArrayExtra(ARouter.AUTO_INJECT)</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != autoInjectParams &amp;&amp; autoInjectParams.isNotEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 遍历参数列表</span></span><br><span class="line">                <span class="keyword">for</span> (paramsName <span class="keyword">in</span> autoInjectParams) &#123;</span><br><span class="line">                    <span class="comment">// 从 Intent 的 extras 中获取参数值</span></span><br><span class="line">                    <span class="keyword">val</span> value = intent.extras!![TextUtils.getLeft(paramsName)]</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != value) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取目标 Activity 中的字段</span></span><br><span class="line">                            <span class="keyword">val</span> injectField =</span><br><span class="line">                                targetActivity.getDeclaredField(TextUtils.getLeft(paramsName))</span><br><span class="line">                            <span class="comment">// 设置字段可访问</span></span><br><span class="line">                            injectField.isAccessible = <span class="literal">true</span></span><br><span class="line">                            <span class="comment">// 将提取的值注入到目标 Activity 的字段中</span></span><br><span class="line">                            injectField[instanceOfTarget] = value</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                            <span class="comment">// 记录错误日志，包括异常信息</span></span><br><span class="line">                            ARouter.logger.error(</span><br><span class="line">                                Consts.TAG,</span><br><span class="line">                                <span class="string">&quot;为 Activity 注入值时发生错误！[&quot;</span> + e.message + <span class="string">&quot;]&quot;</span></span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回已注入值的目标 Activity 实例</span></span><br><span class="line">        <span class="keyword">return</span> instanceOfTarget <span class="keyword">as</span> Activity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已废弃，不废话</p><h5 id="InterceptorServiceImpl"><a href="#InterceptorServiceImpl" class="headerlink" title="InterceptorServiceImpl"></a>InterceptorServiceImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.exception.HandlerException</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.Postcard</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.callback.InterceptorCallback</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.service.InterceptorService</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter.logger</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.thread.CancelableCountDownLatch</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.TAG</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.MapUtils</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有拦截器的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [联系我](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/23 下午2:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Route(path = <span class="string">&quot;/arouter/service/interceptor&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorServiceImpl</span> : <span class="type">InterceptorService</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行拦截操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postcard 路由信息，包含了路由的相关信息和配置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 拦截回调，用于在拦截器流程中通知下一步操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doInterceptions</span><span class="params">(postcard: <span class="type">Postcard</span>, callback: <span class="type">InterceptorCallback</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">        <span class="comment">// 检查拦截器是否已经初始化</span></span><br><span class="line">        checkInterceptorsInitStatus()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果拦截器未初始化完成，中断导航并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptorHasInit) &#123;</span><br><span class="line">            callback.onInterrupt(HandlerException(<span class="string">&quot;拦截器初始化花费太长时间。&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在后台线程中执行拦截器操作</span></span><br><span class="line">        LogisticsCenter.executor.execute(Runnable &#123;</span><br><span class="line">            <span class="keyword">val</span> interceptorCounter = CancelableCountDownLatch(Warehouse.interceptors.size())</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 依次执行拦截器</span></span><br><span class="line">                _execute(<span class="number">0</span>, interceptorCounter, postcard)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 等待拦截器执行完成，超时时间由路由配置决定</span></span><br><span class="line">                interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果有未执行的拦截器，取消导航</span></span><br><span class="line">                <span class="keyword">if</span> (interceptorCounter.getCount() &gt; <span class="number">0</span>) &#123;    <span class="comment">// 如果没有返回任何内容，取消导航。</span></span><br><span class="line">                    callback.onInterrupt(HandlerException(<span class="string">&quot;拦截器处理超时。&quot;</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != postcard.getTag()) &#123;    <span class="comment">// 如果标签中有异常信息。</span></span><br><span class="line">                    callback.onInterrupt(postcard.getTag() <span class="keyword">as</span> Throwable)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 所有拦截器执行完毕，继续路由导航</span></span><br><span class="line">                    callback.onContinue(postcard)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                <span class="comment">// 拦截器执行过程中出现异常，中断导航并传递异常信息</span></span><br><span class="line">                callback.onInterrupt(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有注册拦截器，直接继续路由导航</span></span><br><span class="line">        callback.onContinue(postcard)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 上下文对象，用于在拦截器初始化时可能需要的上下文信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">    LogisticsCenter.executor.execute(Runnable &#123;</span><br><span class="line">        <span class="comment">// 检查是否有已注册的拦截器</span></span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">            <span class="keyword">for</span> ((_, interceptorClass): Map.Entry&lt;<span class="built_in">Int</span>?, Class&lt;<span class="keyword">out</span> IInterceptor?&gt;&gt; <span class="keyword">in</span> Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 实例化拦截器</span></span><br><span class="line">                    <span class="keyword">val</span> iInterceptor: IInterceptor =</span><br><span class="line">                        interceptorClass.getConstructor().newInstance()</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 调用拦截器的初始化方法，传入上下文信息</span></span><br><span class="line">                    iInterceptor.<span class="keyword">init</span>(context)</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将拦截器添加到仓库中，以供后续使用</span></span><br><span class="line">                    Warehouse.interceptors.add(iInterceptor)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ex: Exception) &#123;</span><br><span class="line">                    <span class="comment">// 如果初始化过程中发生异常，抛出自定义的异常</span></span><br><span class="line">                    <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;ARouter初始化拦截器错误！名称 = [&quot;</span> + interceptorClass.name + <span class="string">&quot;]，原因 = [&quot;</span> + ex.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记拦截器已经初始化完成</span></span><br><span class="line">            interceptorHasInit = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录日志，表示拦截器初始化已完成</span></span><br><span class="line">            logger.info(TAG, <span class="string">&quot;ARouter拦截器初始化完成。&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知等待的线程，拦截器已经初始化完成</span></span><br><span class="line">            synchronized(interceptorInitLock) &#123; interceptorInitLock.notifyAll() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> interceptorHasInit = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> interceptorInitLock = Any()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行拦截器</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index    当前拦截器索引</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> counter  拦截器计数器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> postcard 路由信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">_execute</span><span class="params">(index: <span class="type">Int</span>, counter: <span class="type">CancelableCountDownLatch</span>, postcard: <span class="type">Postcard</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class="line">                <span class="keyword">val</span> iInterceptor: IInterceptor = Warehouse.interceptors.<span class="keyword">get</span>(index)</span><br><span class="line">                iInterceptor.process(postcard, <span class="keyword">object</span> : InterceptorCallback() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">fun</span> <span class="title">onContinue</span><span class="params">(postcard: <span class="type">Postcard</span>)</span></span> &#123;</span><br><span class="line">                        <span class="comment">// 最后一个拦截器执行完成，没有异常。</span></span><br><span class="line">                        counter.countDown()</span><br><span class="line">                        _execute(</span><br><span class="line">                            index + <span class="number">1</span>,</span><br><span class="line">                            counter,</span><br><span class="line">                            postcard</span><br><span class="line">                        ) <span class="comment">// 当计数器减少时，继续执行，但是索引大于拦截器的大小，此时不会继续执行。</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">fun</span> <span class="title">onInterrupt</span><span class="params">(exception: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">                        <span class="comment">// 最后一个拦截器执行出现严重异常。</span></span><br><span class="line">                        postcard.setTag(</span><br><span class="line">                            exception ?: HandlerException(<span class="string">&quot;没有消息。&quot;</span>)</span><br><span class="line">                        ) <span class="comment">// 保存异常消息以备份。</span></span><br><span class="line">                        counter.cancel()</span><br><span class="line">                        <span class="comment">// 注意，可能回调中的线程已经更改，</span></span><br><span class="line">                        <span class="comment">// 然后捕获块（L207）将无效。</span></span><br><span class="line">                        <span class="comment">// 最糟糕的情况是线程更改为主线程，然后如果抛出此异常，则应用程序将崩溃！</span></span><br><span class="line"><span class="comment">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // 如果线程是主线程，则不应抛出异常。</span></span><br><span class="line"><span class="comment">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkInterceptorsInitStatus</span><span class="params">()</span></span> &#123;</span><br><span class="line">            synchronized(interceptorInitLock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!interceptorHasInit) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        interceptorInitLock.wait((<span class="number">10</span> * <span class="number">1000</span>).toLong())</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;拦截器初始化花费太长时间错误！原因 = [&quot;</span> + e.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个类是ARouter（Android路由框架）的核心拦截器服务实现类，它具有以下作用：</p><ol><li><strong>拦截器管理：</strong> 该类负责管理ARouter框架中的拦截器。拦截器是在路由导航过程中执行的一系列操作，用于处理路由请求或者对路由进行拦截和修改。</li><li><strong>拦截器执行：</strong> 通过<code>doInterceptions</code>方法，该类执行了一系列的拦截器操作。在路由导航之前，它会依次调用已注册的拦截器，检查是否需要拦截路由请求或对请求进行修改。如果有拦截器拦截了请求，将触发拦截器的<code>onInterrupt</code>方法，否则，将继续执行下一个拦截器，直到所有拦截器都完成或者发生了异常。</li><li><strong>拦截器初始化：</strong> 通过<code>init</code>方法，该类还负责初始化所有的拦截器。在ARouter框架初始化的过程中，会注册各种拦截器，这些拦截器需要在合适的时机进行初始化，以便在路由导航时能够正确地执行。</li><li><strong>线程控制：</strong> 该类使用<code>CancelableCountDownLatch</code>来管理拦截器的执行，确保在所有拦截器执行完成或者超时时能够继续路由导航操作。同时，它还使用锁来控制拦截器的初始化过程，以确保在初始化完成之前不会执行路由导航。</li></ol><h5 id="LogisticsCenter"><a href="#LogisticsCenter" class="headerlink" title="LogisticsCenter"></a>LogisticsCenter</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.exception.HandlerException</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.exception.NoRouteFoundException</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.Postcard</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.enums.TypeKind</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.model.RouteMeta</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptorGroup</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IProvider</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IProviderGroup</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IRouteGroup</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IRouteRoot</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter.logger</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.ClassUtils</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.AROUTER_SP_CACHE_KEY</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.AROUTER_SP_KEY_MAP</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.DOT</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.ROUTE_ROOT_PAKCAGE</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SDK_NAME</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SEPARATOR</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_INTERCEPTORS</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_PROVIDERS</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_ROOT</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.TAG</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.MapUtils</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.PackageUtils</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.TextUtils</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> kotlin.Exception</span><br><span class="line"><span class="keyword">import</span> kotlin.<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">import</span> kotlin.String</span><br><span class="line"><span class="keyword">import</span> kotlin.Throwable</span><br><span class="line"><span class="keyword">import</span> kotlin.Throws</span><br><span class="line"><span class="keyword">import</span> kotlin.arrayOf</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LogisticsCenter 包含了所有的路由映射信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 在首次使用时创建实例。</span></span><br><span class="line"><span class="comment"> * 2. 处理多模块之间的映射关系(*)</span></span><br><span class="line"><span class="comment"> * 3. 解决重复组定义的复杂逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/23 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> LogisticsCenter &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mContext: Context? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> executor: ThreadPoolExecutor? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> registerByPlugin = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arouter-auto-register 插件将在这个方法中生成代码</span></span><br><span class="line"><span class="comment">     * 调用这个方法来注册所有的路由、拦截器和提供者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadRouterMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        registerByPlugin = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 自动生成的注册代码由 Gradle 插件 arouter-auto-register 生成</span></span><br><span class="line">        <span class="comment">// 看起来像下面这样：</span></span><br><span class="line">        <span class="comment">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class="line">        <span class="comment">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名注册</span></span><br><span class="line"><span class="comment">     * 为了解决主 dex 文件过大的问题，牺牲了一些效率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(className: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> clazz = Class.forName(className)</span><br><span class="line">                <span class="keyword">val</span> obj = clazz.getConstructor().newInstance()</span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">is</span> IRouteRoot) &#123;</span><br><span class="line">                    registerRouteRoot(obj <span class="keyword">as</span> IRouteRoot)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">is</span> IProviderGroup) &#123;</span><br><span class="line">                    registerProvider(obj <span class="keyword">as</span> IProviderGroup)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">is</span> IInterceptorGroup) &#123;</span><br><span class="line">                    registerInterceptor(obj <span class="keyword">as</span> IInterceptorGroup)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(</span><br><span class="line">                        TAG, <span class="string">&quot;注册失败，类名：&quot;</span> + className</span><br><span class="line">                                + <span class="string">&quot; 应该实现其中一个接口 IRouteRoot/IProviderGroup/IInterceptorGroup。&quot;</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                logger.error(TAG, <span class="string">&quot;注册类错误：<span class="variable">$className</span>&quot;</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于 arouter-auto-register 插件注册路由的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routeRoot IRouteRoot 实现类，位于包 com.alibaba.android.arouter.core.routers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerRouteRoot</span><span class="params">(routeRoot: <span class="type">IRouteRoot</span>?)</span></span> &#123;</span><br><span class="line">        markRegisteredByPlugin()</span><br><span class="line">        <span class="keyword">if</span> (routeRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">            routeRoot.loadInto(Warehouse.groupsIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于 arouter-auto-register 插件注册拦截器的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptorGroup IInterceptorGroup 实现类，位于包 com.alibaba.android.arouter.core.routers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerInterceptor</span><span class="params">(interceptorGroup: <span class="type">IInterceptorGroup</span>?)</span></span> &#123;</span><br><span class="line">        markRegisteredByPlugin()</span><br><span class="line">        <span class="keyword">if</span> (interceptorGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            interceptorGroup.loadInto(Warehouse.interceptorsIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于 arouter-auto-register 插件注册提供者的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> providerGroup IProviderGroup 实现类，位于包 com.alibaba.android.arouter.core.routers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerProvider</span><span class="params">(providerGroup: <span class="type">IProviderGroup</span>?)</span></span> &#123;</span><br><span class="line">        markRegisteredByPlugin()</span><br><span class="line">        <span class="keyword">if</span> (providerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            providerGroup.loadInto(Warehouse.providersIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记已由 arouter-auto-register 插件注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markRegisteredByPlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!registerByPlugin) &#123;</span><br><span class="line">            registerByPlugin = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LogisticsCenter 初始化，加载所有路由信息到内存中，需要在首次使用时进行初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="meta">@Throws(HandlerException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>, tpe: <span class="type">ThreadPoolExecutor</span>?)</span></span> &#123;</span><br><span class="line">        mContext = context</span><br><span class="line">        executor = tpe</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> startInit = System.currentTimeMillis()</span><br><span class="line">            <span class="comment">// 首先通过插件加载路由信息</span></span><br><span class="line">            loadRouterMap()</span><br><span class="line">            <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">&quot;通过 arouter-auto-register 插件加载路由映射信息。&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> routerMap: Set&lt;String&gt;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在调试模式或安装新版本时，每次都会重建路由映射</span></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;在调试模式下或安装新版本，重新构建路由映射。&quot;</span>)</span><br><span class="line">                    <span class="comment">// 这些类是由 arouter-compiler 自动生成的</span></span><br><span class="line">                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE)</span><br><span class="line">                    <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE)</span><br><span class="line">                            .edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply()</span><br><span class="line">                    &#125;</span><br><span class="line">                    PackageUtils.updateVersion(context) <span class="comment">// 保存新版本名，当路由映射更新完成时使用</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;从缓存中加载路由映射信息。&quot;</span>)</span><br><span class="line">                    routerMap = HashSet(</span><br><span class="line">                        context.getSharedPreferences(</span><br><span class="line">                            AROUTER_SP_CACHE_KEY,</span><br><span class="line">                            Context.MODE_PRIVATE</span><br><span class="line">                        ).getStringSet(AROUTER_SP_KEY_MAP, HashSet())</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(</span><br><span class="line">                    TAG,</span><br><span class="line">                    <span class="string">&quot;找到路由映射信息，映射大小 = &quot;</span> + routerMap.size + <span class="string">&quot;，耗时 &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; 毫秒。&quot;</span></span><br><span class="line">                )</span><br><span class="line">                startInit = System.currentTimeMillis()</span><br><span class="line">                <span class="keyword">for</span> (className <span class="keyword">in</span> routerMap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                        <span class="comment">// 这是根元素之一，加载根元素</span></span><br><span class="line">                        (Class.forName(className).getConstructor()</span><br><span class="line">                            .newInstance() <span class="keyword">as</span> IRouteRoot).loadInto(Warehouse.groupsIndex)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                        <span class="comment">// 加载拦截器映射信息</span></span><br><span class="line">                        (Class.forName(className).getConstructor()</span><br><span class="line">                            .newInstance() <span class="keyword">as</span> IInterceptorGroup).loadInto(Warehouse.interceptorsIndex)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                        <span class="comment">// 加载提供者映射信息</span></span><br><span class="line">                        (Class.forName(className).getConstructor()</span><br><span class="line">                            .newInstance() <span class="keyword">as</span> IProviderGroup).loadInto(Warehouse.providersIndex)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(</span><br><span class="line">                TAG,</span><br><span class="line">                <span class="string">&quot;加载根元素完成，耗时 &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; 毫秒。&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (Warehouse.groupsIndex.size() === <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(TAG, <span class="string">&quot;未找到映射文件，请检查您的配置！&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                logger.debug(</span><br><span class="line">                    TAG,</span><br><span class="line">                    java.lang.String.format(</span><br><span class="line">                        Locale.getDefault(),</span><br><span class="line">                        <span class="string">&quot;LogisticsCenter 已经加载，GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]&quot;</span>,</span><br><span class="line">                        Warehouse.groupsIndex.size(),</span><br><span class="line">                        Warehouse.interceptorsIndex.size(),</span><br><span class="line">                        Warehouse.providersIndex.size()</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;ARouter 初始化物流中心异常！ [&quot;</span> + e.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名构建 Postcard</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 接口名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Postcard</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">buildProvider</span><span class="params">(serviceName: <span class="type">String</span>?)</span></span>: Postcard? &#123;</span><br><span class="line">        <span class="keyword">val</span> meta: RouteMeta = Warehouse.providersIndex.<span class="keyword">get</span>(serviceName)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (<span class="literal">null</span> == meta) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Postcard(meta.getPath(), meta.getGroup())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由元信息完成 Postcard 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postcard 不完整的 Postcard，应由此方法完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">completion</span><span class="params">(postcard: <span class="type">Postcard</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == postcard) &#123;</span><br><span class="line">            <span class="keyword">throw</span> NoRouteFoundException(TAG.toString() + <span class="string">&quot;没有 Postcard！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> routeMeta: RouteMeta = Warehouse.routes.<span class="keyword">get</span>(postcard.getPath())</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == routeMeta) &#123;</span><br><span class="line">            <span class="comment">// 可能不存在或尚未加载</span></span><br><span class="line">            <span class="keyword">if</span> (!Warehouse.groupsIndex.containsKey(postcard.getGroup())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NoRouteFoundException(TAG.toString() + <span class="string">&quot;没有匹配路径 [&quot;</span> + postcard.getPath() + <span class="string">&quot;]，在组 [&quot;</span> + postcard.getGroup() + <span class="string">&quot;] 中。&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 加载路由信息并缓存到内存中，然后从路由元信息中删除</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                        logger.debug(</span><br><span class="line">                            TAG,</span><br><span class="line">                            java.lang.String.format(</span><br><span class="line">                                Locale.getDefault(),</span><br><span class="line">                                <span class="string">&quot;开始加载组 [%s]，由 [%s] 触发。&quot;</span>,</span><br><span class="line">                                postcard.getGroup(),</span><br><span class="line">                                postcard.getPath()</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                    addRouteGroupDynamic(postcard.getGroup(), <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                        logger.debug(</span><br><span class="line">                            TAG,</span><br><span class="line">                            java.lang.String.format(</span><br><span class="line">                                Locale.getDefault(),</span><br><span class="line">                                <span class="string">&quot;组 [%s] 已经加载，由 [%s] 触发。&quot;</span>,</span><br><span class="line">                                postcard.getGroup(),</span><br><span class="line">                                postcard.getPath()</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;加载组元信息时发生致命异常。 [&quot;</span> + e.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                completion(postcard) <span class="comment">// 重新加载</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postcard.setDestination(routeMeta.getDestination())</span><br><span class="line">            postcard.setType(routeMeta.getType())</span><br><span class="line">            postcard.setPriority(routeMeta.getPriority())</span><br><span class="line">            postcard.setExtra(routeMeta.getExtra())</span><br><span class="line">            <span class="keyword">val</span> rawUri: Uri = postcard.getUri()</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != rawUri) &#123;   <span class="comment">// 尝试将参数设置到 Bundle 中</span></span><br><span class="line">                <span class="keyword">val</span> resultMap: Map&lt;String, String&gt; = TextUtils.splitQueryParameters(rawUri)</span><br><span class="line">                <span class="keyword">val</span> paramsType: Map&lt;String, <span class="built_in">Int</span>?&gt; = routeMeta.getParamsType()</span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                    <span class="comment">// 根据参数类型设置值，仅对使用 @Param 注解的参数有效</span></span><br><span class="line">                    <span class="keyword">for</span> ((key, value): Map.Entry&lt;String, <span class="built_in">Int</span>?&gt; <span class="keyword">in</span> paramsType) &#123;</span><br><span class="line">                        setValue(</span><br><span class="line">                            postcard,</span><br><span class="line">                            value,</span><br><span class="line">                            key,</span><br><span class="line">                            resultMap[key]</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 保存需要自动注入的参数名</span></span><br><span class="line">                    postcard.getExtras().putStringArray(</span><br><span class="line">                        ARouter.AUTO_INJECT,</span><br><span class="line">                        paramsType.keys.toArray(arrayOf&lt;String&gt;())</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存原始 URI</span></span><br><span class="line">                postcard.withString(ARouter.RAW_URI, rawUri.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> (routeMeta.getType()) &#123;</span><br><span class="line">                PROVIDER -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 这是提供者，所以必须实现 IProvider 接口</span></span><br><span class="line">                    <span class="keyword">val</span> providerMeta: Class&lt;<span class="keyword">out</span> IProvider?&gt; = routeMeta.getDestination()</span><br><span class="line">                    <span class="keyword">var</span> instance: IProvider? = Warehouse.providers.<span class="keyword">get</span>(providerMeta)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123; <span class="comment">// 没有此提供者的实例</span></span><br><span class="line">                        <span class="keyword">val</span> provider: IProvider</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            provider = providerMeta.getConstructor().newInstance()</span><br><span class="line">                            provider.<span class="keyword">init</span>(mContext)</span><br><span class="line">                            Warehouse.providers.put(providerMeta, provider)</span><br><span class="line">                            instance = provider</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                            logger.error(TAG, <span class="string">&quot;初始化提供者失败！&quot;</span>, e)</span><br><span class="line">                            <span class="keyword">throw</span> HandlerException(<span class="string">&quot;初始化提供者失败！&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    postcard.setProvider(instance)</span><br><span class="line">                    postcard.greenChannel() <span class="comment">// 提供者应跳过所有拦截器</span></span><br><span class="line">                &#125;</span><br><span class="line">                FRAGMENT -&gt; postcard.greenChannel() <span class="comment">// Fragment 不需要拦截器</span></span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据已知类型设置值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postcard postcard</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeDef  类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(postcard: <span class="type">Postcard</span>, typeDef: <span class="type">Int</span>?, key: <span class="type">String</span>, value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(key) || TextUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != typeDef) &#123;</span><br><span class="line">                <span class="keyword">if</span> (typeDef === TypeKind.BOOLEAN.ordinal()) &#123;</span><br><span class="line">                    postcard.withBoolean(key, <span class="built_in">Boolean</span>.parseBoolean(value))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.BYTE.ordinal()) &#123;</span><br><span class="line">                    postcard.withByte(key, value!!.toByte())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.SHORT.ordinal()) &#123;</span><br><span class="line">                    postcard.withShort(key, value!!.toShort())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.INT.ordinal()) &#123;</span><br><span class="line">                    postcard.withInt(key, value!!.toInt())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.LONG.ordinal()) &#123;</span><br><span class="line">                    postcard.withLong(key, value!!.toLong())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.FLOAT.ordinal()) &#123;</span><br><span class="line">                    postcard.withFloat(key, value!!.toFloat())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.DOUBLE.ordinal()) &#123;</span><br><span class="line">                    postcard.withDouble(key, value!!.toDouble())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.STRING.ordinal()) &#123;</span><br><span class="line">                    postcard.withString(key, value)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.PARCELABLE.ordinal()) &#123;</span><br><span class="line">                    <span class="comment">// TODO : 如何使用字符串描述可传递的值？</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.OBJECT.ordinal()) &#123;</span><br><span class="line">                    postcard.withString(key, value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 兼容编译器 SDK 1.0.3，在该版本中，字符串类型 = 18</span></span><br><span class="line">                    postcard.withString(key, value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                postcard.withString(key, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;</span><br><span class="line">            logger.warning(Consts.TAG, <span class="string">&quot;LogisticsCenter setValue 失败！&quot;</span> + ex.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挂起业务，清除缓存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">suspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Warehouse.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="meta">@Throws(</span></span><br><span class="line"><span class="meta">        NoSuchMethodException::class,</span></span><br><span class="line"><span class="meta">        IllegalAccessException::class,</span></span><br><span class="line"><span class="meta">        InvocationTargetException::class,</span></span><br><span class="line"><span class="meta">        InstantiationException::class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addRouteGroupDynamic</span><span class="params">(groupName: <span class="type">String</span>?, group: <span class="type">IRouteGroup</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Warehouse.groupsIndex.containsKey(groupName)) &#123;</span><br><span class="line">            <span class="comment">// 如果已包含此组，但尚未加载</span></span><br><span class="line">            <span class="comment">// 先加载此组，因为动态路由具有较高的优先级。</span></span><br><span class="line">            Warehouse.groupsIndex.<span class="keyword">get</span>(groupName).getConstructor().newInstance()</span><br><span class="line">                .loadInto(Warehouse.routes)</span><br><span class="line">            Warehouse.groupsIndex.remove(groupName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖旧组。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != group) &#123;</span><br><span class="line">            group.loadInto(Warehouse.routes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是ARouter库的核心组件之一，它的主要作用是负责管理和维护ARouter路由框架中的各种映射关系和配置信息，以便实现路由功能。以下是这个类的主要作用描述：</p><ol><li><p><strong>加载路由映射信息：</strong> LogisticsCenter负责加载和管理所有的路由映射信息。这些路由映射信息包括路由路径、路由分组、拦截器、提供者等相关信息，它们在ARouter框架中用于实现路由跳转和服务提供。</p></li><li><p><strong>支持自动注册：</strong> 通过ARouter的插件机制，LogisticsCenter可以支持自动注册路由信息，使得开发者无需手动配置路由信息，提高了开发效率。插件会自动生成代码来调用LogisticsCenter的方法注册路由信息。</p></li><li><p><strong>初始化和管理线程池：</strong> LogisticsCenter负责初始化和管理线程池，用于异步加载路由信息和执行路由任务。线程池的管理有助于提高ARouter框架的性能和并发处理能力。</p></li><li><p><strong>动态加载路由信息：</strong> 当需要跳转到某个路由时，LogisticsCenter会根据路由信息动态加载相关的路由元信息，包括路由组信息和拦截器信息，以便进行路由跳转和拦截器处理。</p></li><li><p><strong>提供路由跳转和服务提供支持：</strong> LogisticsCenter提供了一系列方法，用于构建路由跳转的Postcard对象和获取服务提供者的实例。它还负责处理路由跳转的逻辑，包括路由路径匹配、拦截器处理和服务提供。</p></li><li><p><strong>支持路由信息的缓存和更新：</strong> LogisticsCenter支持路由信息的缓存和更新，以提高ARouter框架的性能。当路由信息有更新时，可以通过插件机制重新生成路由映射信息。</p></li></ol><p>总之，LogisticsCenter是ARouter框架中的核心组件，它通过加载、管理和动态获取路由信息，实现了路由跳转和服务提供的功能，提供了便捷的路由框架和服务化解决方案。</p><h5 id="Warehouse"><a href="#Warehouse" class="headerlink" title="Warehouse"></a>Warehouse</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.base.UniqueKeyTreeMap</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.model.RouteMeta</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IProvider</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IRouteGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由元信息和其他数据的存储仓库。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Warehouse（仓库）负责存储路由元信息以及其他相关数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/23 下午1:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> Warehouse &#123;</span><br><span class="line">    <span class="comment">// 缓存路由组和路由元信息</span></span><br><span class="line">    <span class="keyword">var</span> groupsIndex: MutableMap&lt;String, Class&lt;<span class="keyword">out</span> IRouteGroup?&gt;&gt; =</span><br><span class="line">        HashMap&lt;String, Class&lt;<span class="keyword">out</span> IRouteGroup?&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> routes: MutableMap&lt;String, RouteMeta&gt; = HashMap&lt;String, RouteMeta&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存服务提供者</span></span><br><span class="line">    <span class="keyword">var</span> providers: MutableMap&lt;Class&lt;*&gt;, IProvider&gt; = HashMap&lt;Class&lt;*&gt;, IProvider&gt;()</span><br><span class="line">    <span class="keyword">var</span> providersIndex: MutableMap&lt;String, RouteMeta&gt; = HashMap&lt;String, RouteMeta&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存拦截器</span></span><br><span class="line">    <span class="keyword">var</span> interceptorsIndex: MutableMap&lt;<span class="built_in">Int</span>, Class&lt;<span class="keyword">out</span> IInterceptor?&gt;&gt; =</span><br><span class="line">        UniqueKeyTreeMap(<span class="string">&quot;多个拦截器使用相同的优先级 [%s]&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> interceptors: MutableList&lt;IInterceptor&gt; = ArrayList&lt;IInterceptor&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空仓库中的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        routes.clear()</span><br><span class="line">        groupsIndex.clear()</span><br><span class="line">        providers.clear()</span><br><span class="line">        providersIndex.clear()</span><br><span class="line">        interceptors.clear()</span><br><span class="line">        interceptorsIndex.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是ARouter框架内部的一个存储仓库，用于缓存路由元信息、路由组信息、服务提供者信息以及拦截器信息等相关数据。这些数据在ARouter框架中用于实现路由跳转和服务提供功能。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - exception 异常与 callback 回调</title>
      <link href="/2023/09/10/Android/ARouter/03-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/03-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li>router-annotation 路由注解模块<ul><li><p>src.main.java</p><ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li><a href="#HandlerException">HandlerException.java</a> 处理异常的类</li><li><a href="#InitException">InitException.java</a> 初始化异常的类</li><li><a href="#NoRouteFoundException">NoRouteFoundException.java</a> 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li><a href="#InterceptorCallback">InterceptorCallback.java</a> 拦截器回调的接口</li><li><a href="#NavigationCallback">NavigationCallback.java</a> 导航回调的接口</li><li><a href="#NoRouteFoundException">NoRouteFoundException.java</a> 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - service 服务</title>
      <link href="/2023/09/10/Android/ARouter/04-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/04-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li><a href="#AutowiredService">AutowiredService.java</a> 自动注入服务的接口</li><li><a href="#ClassLoaderService">ClassLoaderService.java</a> 类加载器服务的接口</li><li><a href="#DegradeService">DegradeService.java</a> 降级服务的接口</li><li><a href="#InterceptorService">InterceptorService.java</a> 拦截器服务的接口</li><li><a href="#PathReplaceService">PathReplaceService.java</a> 路径替换服务的接口</li><li><a href="#PretreatmentService">PretreatmentService.java</a> 预处理服务的接口</li><li><a href="#SerializationService">SerializationService.java</a> 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - template 模板</title>
      <link href="/2023/09/10/Android/ARouter/05-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/05-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li><a href="#IInterceptor">IInterceptor.java</a> 拦截器接口</li><li><a href="#IInterceptorGroup">IInterceptorGroup.java</a> 拦截器分组接口</li><li><a href="#Ilogger">Ilogger.java</a> 日志记录器接口</li><li><a href="#IPolicy">IPolicy.java</a> 策略接口</li><li><a href="#IProvider">IProvider.java</a> 提供者接口</li><li><a href="#IProviderGroup">IProviderGroup.java</a> 提供者分组接口</li><li><a href="#IRouteGroup">IRouteGroup.java</a> 路由分组接口</li><li><a href="#IRouteRoot">IRouteRoot.java</a> 路由根接口</li><li><a href="#Isyringe">Isyringe.java</a> 注射器接口</li><li><a href="#Postcard">Postcard.java</a> 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - launcher 启动器</title>
      <link href="/2023/09/10/Android/ARouter/06-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/06-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li><a href="#_Arouter">_Arouter.java</a> ARouter框架的内部启动类，用于初始化ARouter。</li><li><a href="#Arouter">Arouter.java</a> ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li><a href="#CancelableCountDownLatch">CancelableCountDownLatch.java</a> 可取消的倒计时计数器，用于线程同步。</li><li><a href="#DefaultPoolExecutor">DefaultPoolExecutor.java</a> 默认的线程池执行器，用于执行异步任务。</li><li><a href="#DefaultThreadFactory">DefaultThreadFactory.java</a> 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - utils 工具类</title>
      <link href="/2023/09/10/Android/ARouter/07-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/07-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li><a href="#ClassUtils">ClassUtils.java</a> 用于操作类的实用工具类。</li><li><a href="#Consts">Consts.java</a> 包含一些常量值的类。</li><li><a href="#DefaultLogger">DefaultLogger.java</a> 默认的日志记录器类。</li><li><a href="#MapUtils">MapUtils.java</a> 用于操作地图数据的实用工具类。</li><li><a href="#PackageUtils">PackageUtils.java</a> 用于操作包信息的实用工具类。</li><li><a href="#TextUtils">TextUtils.java</a> 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - compiler 编译模块</title>
      <link href="/2023/09/10/Android/ARouter/08-Arouter/"/>
      <url>/2023/09/10/Android/ARouter/08-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li><p>ARouter</p><ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li><a href="#RouteDoc">RouteDoc.java</a> 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li><a href="#AutowiredProcessor">AutowiredProcessor.java</a> 自动注入处理器</li><li><a href="#BaseProcessor">BaseProcessor.java</a> 基础处理器</li><li><a href="#InterceptorProcessor">InterceptorProcessor.java</a> 拦截器处理器</li><li><a href="#RouteProcessor">RouteProcessor.java</a> 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li><a href="#Consts">Consts.java</a> 常量类</li><li><a href="#Logger">Logger.java</a> 日志记录器类</li><li><a href="#TypeUtils">TypeUtils.java</a> 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 二叉树-DFS (迭代)</title>
      <link href="/2023/09/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/11%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E8%BF%AD%E4%BB%A3)/"/>
      <url>/2023/09/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/11%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E8%BF%AD%E4%BB%A3)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="先序遍历（写法一）"><a href="#先序遍历（写法一）" class="headerlink" title="先序遍历（写法一）"></a>先序遍历（写法一）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    root ?: <span class="keyword">return</span></span><br><span class="line">    stack.addFirst(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> current = stack.removeFirst()</span><br><span class="line">        visit(current)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将右子节点入栈，再将左子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(current.right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(current.left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(root: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序遍历（写法二）"><a href="#先序遍历（写法二）" class="headerlink" title="先序遍历（写法二）"></a>先序遍历（写法二）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">var</span> cur: TreeNode = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            visit(cur)</span><br><span class="line">            stack.addFirst(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> top: TreeNode = stack.removeFirst(();</span><br><span class="line">        cur = top.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(node: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">var</span> cur: TreeNode = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visit(cur)</span><br><span class="line">        <span class="keyword">val</span> top: TreeNode = stack.removeFirst(();</span><br><span class="line">        cur = top.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(node: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorder</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack: LinkList = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> cur = root</span><br><span class="line">    <span class="keyword">var</span> last = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 左节点先入栈</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123; </span><br><span class="line">            stack.addFirst(cur)                        <span class="comment">// 第一次访问</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> top = stack.peekFirst()                    <span class="comment">// 第二次访问</span></span><br><span class="line">        <span class="keyword">if</span> (top.right == <span class="literal">null</span> || top.right == last) &#123;  <span class="comment">// 第三次访问</span></span><br><span class="line">            visit(top)</span><br><span class="line">            last = top</span><br><span class="line">            stack.removeFirst()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = top.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(node: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归后续遍历比较有意思<br>结合注释我们来一语道破天机<br>先序，中序，后序遍历<br>第一次经过结点（从双亲过来）: 先序<br>第二次经过结点（从左孩子过来）: 中序<br>第三次经过结点（右孩子过来）: 后序</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12. 二叉树-BFS</title>
      <link href="/2023/09/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/12%20%E4%BA%8C%E5%8F%89%E6%A0%91-BFS/"/>
      <url>/2023/09/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/12%20%E4%BA%8C%E5%8F%89%E6%A0%91-BFS/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue: LinkedList&lt;TreeNode&gt; = LinkedList()</span><br><span class="line">    queue.add(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node: TreeNode = queue.removeFirst()</span><br><span class="line">        visit(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node.left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(root: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(root.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10. 二叉树-DFS (递归)</title>
      <link href="/2023/09/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/10%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E9%80%92%E5%BD%92)/"/>
      <url>/2023/09/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/10%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E9%80%92%E5%BD%92)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    root?: <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// visit() // 先序遍历</span></span><br><span class="line">    dfs(root.left)  </span><br><span class="line">    <span class="comment">// visit() // 中序遍历</span></span><br><span class="line">    dfs(root.right)  </span><br><span class="line">    <span class="comment">// visit() // 后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(root: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频屏幕旋转方案</title>
      <link href="/2023/08/29/%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/"/>
      <url>/2023/08/29/%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在Android平台上，实现音视频播放过程中的屏幕旋转涉及到以下几个方面：界面布局的调整、Activity的生命周期管理、保存和恢复播放状态、以及处理屏幕旋转时可能引发的音视频播放问题。以下是一个基本的音视频屏幕旋转方案的步骤：</p><h4 id="布局调整"><a href="#布局调整" class="headerlink" title="布局调整"></a>布局调整</h4><p>在<code>res</code>文件夹中创建不同方向的布局文件，例如<code>layout/activity_main.xml</code>和<code>layout-land/activity_main.xml</code>分别表示竖屏和横屏时的布局。在这些布局文件中，你可以调整控件的摆放位置以适应不同方向的屏幕。</p><h4 id="Activity的生命周期管理"><a href="#Activity的生命周期管理" class="headerlink" title="Activity的生命周期管理"></a>Activity的生命周期管理</h4><p>当屏幕发生旋转时，Activity会经历重新创建的过程。确保你的Activity正确处理生命周期事件，特别是<code>onCreate</code>、<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>等方法。</p><h4 id="保存和恢复播放状态"><a href="#保存和恢复播放状态" class="headerlink" title="保存和恢复播放状态"></a>保存和恢复播放状态</h4><p>在<code>onSaveInstanceState</code>方法中保存当前的播放状态，例如播放位置、播放状态（播放、暂停等），以及其他相关信息。然后在<code>onCreate</code>和<code>onRestoreInstanceState</code>方法中恢复这些状态。</p><h4 id="处理屏幕旋转可能引发的问题"><a href="#处理屏幕旋转可能引发的问题" class="headerlink" title="处理屏幕旋转可能引发的问题"></a>处理屏幕旋转可能引发的问题</h4><p>屏幕旋转可能会导致播放器重新创建或重置，从而影响播放状态。你需要在Activity重新创建时恢复播放状态，并确保播放器不会中断或重置播放进度。</p><h4 id="使用ViewModel来保存播放状态（可选）"><a href="#使用ViewModel来保存播放状态（可选）" class="headerlink" title="使用ViewModel来保存播放状态（可选）"></a>使用ViewModel来保存播放状态（可选）</h4><p>使用ViewModel可以更方便地在屏幕旋转时保持数据。ViewModel会在Activity重新创建时保持其状态，因此你可以将播放状态等数据存储在ViewModel中，以确保不会丢失。</p><h4 id="锁定屏幕方向（可选）"><a href="#锁定屏幕方向（可选）" class="headerlink" title="锁定屏幕方向（可选）"></a>锁定屏幕方向（可选）</h4><p>如果你希望在播放音视频时固定屏幕方向，可以在AndroidManifest.xml中的相应Activity中使用<code>android:screenOrientation</code>属性来指定所需的屏幕方向（如<code>portrait</code>或<code>landscape</code>）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，处理音视频播放过程中的屏幕旋转需要综合考虑界面布局、生命周期管理、数据保存和恢复等方面的问题。合理使用布局文件、Activity生命周期方法、ViewModel等工具，可以帮助你实现稳定且用户友好的音视频播放体验。</p>]]></content>
      
      
      <categories>
          
          <category> 4 - 架构方案设计 </category>
          
          <category> 4.1 - 播放器架构方案设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 第一课-万物皆地址</title>
      <link href="/2023/08/29/C++/C++%E7%AC%AC%E4%B8%80%E8%AF%BE-%E4%B8%87%E7%89%A9%E7%9A%86%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/08/29/C++/C++%E7%AC%AC%E4%B8%80%E8%AF%BE-%E4%B8%87%E7%89%A9%E7%9A%86%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>作者：朕小猫与GPT4</p><h1 id="怎么理解C-万物皆地址"><a href="#怎么理解C-万物皆地址" class="headerlink" title="怎么理解C++万物皆地址"></a>怎么理解C++万物皆地址</h1><p>在 C++ 程序中，几乎所有元素（包括变量、对象、函数等）都可以通过它们的内存地址来引用或操作。这一点归根结底是因为 C++ 是一种底层的编程语言，它允许直接访问内存和底层硬件资源。这种能力带来了极高的灵活性和控制能力，但同时也要求程序员对程序的内存使用有深入的理解。下面是如何通过内存地址来引用或操作元素的几个方面：</p><ol><li><h2 id="变量和对象的内存地址："><a href="#变量和对象的内存地址：" class="headerlink" title="变量和对象的内存地址："></a><strong>变量和对象的内存地址</strong>：</h2><p>在 C++ 中，每个变量或对象都占据内存中的一个或多个连续位置。你可以使用 <code>&amp;</code> 操作符获得一个变量的内存地址，这个地址可以赋给一个指针变量。通过指针，你可以读取或修改存储在该地址的数据。这对于数组和自定义数据结构尤其有用，因为可以通过指针算术进行高效的遍历和访问。</p></li><li><h2 id="函数的地址："><a href="#函数的地址：" class="headerlink" title="函数的地址："></a><strong>函数的地址</strong>：</h2><p>C++ 允许获取函数的地址，并将其赋给函数指针。这使得程序可以在运行时决定调用哪个函数，提高了代码的灵活性和可重用性。函数指针广泛应用于回调机制、事件驱动编程和接口设计中。</p></li><li><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><strong>引用</strong>：</h2><p>C++ 的引用机制实际上是一种特殊的语法糖，它在内部使用地址来实现。引用允许你创建一个变量的别名，通过别名可以直接访问和修改原始变量，而无需显式解引用。这样不仅代码更加简洁，而且避免了指针可能带来的错误。</p></li><li><h2 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a><strong>动态内存分配</strong>：</h2><p>C++ 通过 <code>new</code> 和 <code>delete</code> 操作符提供了动态内存分配的能力。使用 <code>new</code> 分配的内存位于堆区，它会返回指向分配内存的指针。通过这个指针，程序可以在运行时动态地分配、访问和释放内存。</p></li></ol><p>通过上述机制，C++ 程序可以精确地控制内存的使用方式，从而优化程序性能和资源管理。然而，这也意呀着程序员必须对指针、内存地址以及内存管理有充分的理解，才能有效地利用这些特性编写高效、安全的代码。</p><p>编写教程时，目标是清晰、简洁且具有实用性。以下是一个关于“如何在 C++ 中使用指针和地址”教程的示例内容。这段内容旨在介绍初学者到 C++ 的指针和地址概念，帮助他们理解和运用“万物皆地址”的原则。</p><hr><h1 id="C-指针和地址入门"><a href="#C-指针和地址入门" class="headerlink" title="C++ 指针和地址入门"></a>C++ 指针和地址入门</h1><p>在 C++ 中，理解指针和地址是掌握语言的基石。本教程将引导你通过简单的步骤来理解和使用指针和地址。</p><h2 id="1-理解地址"><a href="#1-理解地址" class="headerlink" title="1. 理解地址"></a>1. 理解地址</h2><p>在 C++ 中，每个变量都存储在内存的一个特定位置，这个位置可以通过地址来访问。你可以使用 <code>&amp;</code> 操作符来获取变量的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;变量的地址: &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会输出变量 <code>var</code> 的内存地址。</p><h2 id="2-使用指针"><a href="#2-使用指针" class="headerlink" title="2. 使用指针"></a>2. 使用指针</h2><p>指针是存储另一个变量地址的变量。在 C++ 中，你可以使用 <code>*</code> 来声明指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;var;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 指向的地址: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 指向的地址上的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr</code> 是一个指向 <code>var</code> 地址的指针。通过 <code>*ptr</code>，我们可以访问这个地址上的值。</p><h2 id="3-指针的使用场景"><a href="#3-指针的使用场景" class="headerlink" title="3. 指针的使用场景"></a>3. 指针的使用场景</h2><p>指针在 C++ 中的应用非常广泛，包括：</p><ul><li><strong>动态内存管理</strong>：使用 <code>new</code> 和 <code>delete</code> 操作符分配和释放内存。</li><li><strong>函数参数传递</strong>：通过传递指针或引用来修改函数外的变量。</li><li><strong>构建复杂数据结构</strong>：如链表、树等。</li></ul><h2 id="4-练习：使用指针交换两个变量的值"><a href="#4-练习：使用指针交换两个变量的值" class="headerlink" title="4. 练习：使用指针交换两个变量的值"></a>4. 练习：使用指针交换两个变量的值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个练习演示了如何使用指针来交换两个变量的值。</p><h1 id="C-通过地址修改值"><a href="#C-通过地址修改值" class="headerlink" title="C++ 通过地址修改值"></a>C++ 通过地址修改值</h1><p>在 C++ 中，通过地址修改值是指针操作的一个基本用途。指针是一种特殊的变量，其值为另一个变量的内存地址。<br>通过指针，你可以直接访问和修改它指向的内存位置上存储的数据。<br>这一过程涉及几个关键步骤：获取变量的地址、使用指针指向该地址、通过指针修改该地址上的值。<br>下面通过一个简单的示例来说明这一过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;    <span class="comment">// 定义一个变量value并初始化为10</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;value; <span class="comment">// 定义一个指针ptr，将其初始化为value的地址</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original value: &quot;</span> &lt;&lt; value &lt;&lt; endl; <span class="comment">// 显示原始的value值</span></span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">// 通过指针ptr修改value的值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; value &lt;&lt; endl; <span class="comment">// 显示修改后的value值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中：</p><ol><li>我们首先定义了一个类型为 <code>int</code> 的变量 <code>value</code> 并初始化为 10。</li><li>然后，我们定义了一个类型为 <code>int*</code> 的指针 <code>ptr</code> 并将其初始化为 <code>value</code> 的地址（<code>&amp;value</code>）。</li><li>通过 <code>cout</code> 输出语句，我们可以看到 <code>value</code> 的原始值。</li><li>接着，我们通过指针 <code>ptr</code> 来修改 <code>value</code> 的值。这里的 <code>*ptr = 20;</code> 表示将 <code>ptr</code> 指向的内存位置（即 <code>value</code> 的位置）上的数据修改为 20。<code>*ptr</code> 是解引用操作符的应用，它获取指针指向的内存地址上存储的值。</li><li>最后，再次通过 <code>cout</code> 输出 <code>value</code> 的值，可以看到它已经被修改为 20。</li></ol><h1 id="函数传参的内存地址"><a href="#函数传参的内存地址" class="headerlink" title="函数传参的内存地址"></a>函数传参的内存地址</h1><p>在 C++ 中，理解函数传参的内存地址涉及到两个主要概念：按值传递（Pass by Value）和按引用传递（Pass by Reference）。理解这些概念有助于深入理解 C++ 如何在函数调用中处理参数的内存地址。</p><h2 id="按值传递（Pass-by-Value）"><a href="#按值传递（Pass-by-Value）" class="headerlink" title="按值传递（Pass by Value）"></a>按值传递（Pass by Value）</h2><p>当函数参数是按值传递时，函数接收的是实参的一个副本。这意味着函数内部对参数所做的任何修改都不会影响到原始数据。在内存层面，这个过程涉及到将原始数据的值复制到新的内存地址中。这个新的地址是函数参数在函数调用栈上的局部地址。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>保护了原始数据，避免了意外修改。</li><li>对于基本数据类型，这种方式简单且效率较高。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对于大型结构或类实例，复制可能导致性能下降。</li><li>无法在函数外部反映函数内部对数据的修改。</li></ul><h2 id="按引用传递（Pass-by-Reference）"><a href="#按引用传递（Pass-by-Reference）" class="headerlink" title="按引用传递（Pass by Reference）"></a>按引用传递（Pass by Reference）</h2><p>按引用传递意味着函数接收的是实参的引用（或者说是内存地址）。这样，函数内部对参数的任何修改都会直接影响到原始数据。在内存层面，这避免了数据的复制，函数参数直接使用了实参的地址。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>可以直接修改原始数据。</li><li>避免了大型数据结构的复制，提高了效率。</li><li>可以通过返回多个结果值（通过修改传入的引用或指针参数）。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果不希望修改原始数据，需要谨慎操作。</li><li>使用不当可能导致错误或数据损坏。</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设我们有一个简单的函数，目的是修改一个整数的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTenByValue</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    number += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 这里修改的是number的副本，外部的原始变量不受影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTenByReference</span><span class="params">(<span class="type">int</span> &amp;number)</span> </span>&#123;</span><br><span class="line">    number += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 这里直接修改的是传入变量的值，外部的原始变量也会被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>addTenByValue</code> 函数无法修改外部变量的值，因为它仅操作了参数的副本。而 <code>addTenByReference</code> 函数则直接操作了实参的内存地址，因此它能够修改外部变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> 5 - C++ </category>
          
          <category> 5.1 - C++理论基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数指针与指针函数,C++11 新特性</title>
      <link href="/2023/08/29/C++/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0,C++11%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/08/29/C++/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0,C++11%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>作者：朕小猫与GPT4</p><h1 id="C-函数指针"><a href="#C-函数指针" class="headerlink" title="C++函数指针"></a>C++函数指针</h1><p>在 C++ 中，函数指针是指向函数的指针，允许通过指针调用函数。这种特性让程序在运行时能够选择要调用的函数，增加了代码的灵活性和动态性。理解函数指针对于高级编程技巧，如回调函数、命令模式等是非常重要的。</p><h2 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h2><p>函数指针的定义需要指定函数的返回类型、指针名称以及函数参数的类型。定义函数指针的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (*指针变量名)(参数类型列表);</span><br></pre></td></tr></table></figure><p>例如，如果你有一个返回类型为 <code>int</code> 并接受两个 <code>int</code> 类型参数的函数，你可以这样定义一个指向该函数的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><h2 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h2><p>一旦定义了函数指针，就可以将其指向具有相应签名的任何函数，然后通过该指针调用函数。这里有一个使用函数指针的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针并使其指向add函数</span></span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">funcPtr</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum is: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针的用途"><a href="#函数指针的用途" class="headerlink" title="函数指针的用途"></a>函数指针的用途</h2><p>函数指针最常见的用途包括：</p><ul><li><strong>回调函数</strong>：允许库或框架调用在使用库的代码中定义的函数。</li><li><strong>事件处理</strong>：在发生特定事件时动态决定调用哪个函数。</li><li><strong>接口实现</strong>：通过函数指针数组或结构体实现类似于面向对象编程中接口或虚函数的功能。</li><li><strong>命令模式</strong>：将操作封装为对象，允许存储、传递和调用操作。</li></ul><h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><p>随着 C++11 的引入，现代 C++ 更倾向于使用 std::function 和 lambda 表达式来替代裸函数指针，因为它们提供了更高的灵活性和更简洁的语法。例如，<code>std::function</code> 可以存储并调用任何可调用的实体，包括普通函数、lambda 表达式、以及其他具有 <code>operator()</code> 的对象。</p><h1 id="举例子，说明函数指针使用的几种场景"><a href="#举例子，说明函数指针使用的几种场景" class="headerlink" title="举例子，说明函数指针使用的几种场景"></a>举例子，说明函数指针使用的几种场景</h1><p>函数指针在 C++ 中的应用非常广泛，提供了编程的灵活性和动态性。以下是几种典型场景，展示了函数指针的使用：</p><h2 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. 回调函数</h2><p>回调函数是由用户编写的，但由系统或库在适当的时候调用的函数。函数指针允许用户提供具体的回调函数实现，使得库或框架可以在运行时调用用户定义的代码。</p><p><strong>示例：</strong> 设计一个简单的事件处理器，当发生某个事件时，调用用户提供的回调函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回调函数类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">        callbacks.<span class="built_in">push_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(<span class="type">int</span> eventData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cb : callbacks) &#123;</span><br><span class="line">            <span class="built_in">cb</span>(eventData); <span class="comment">// 调用回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Callback&gt; callbacks; <span class="comment">// 回调函数列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户定义的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onEventTriggered</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Event triggered with data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventProcessor ep;</span><br><span class="line">    ep.<span class="built_in">registerCallback</span>(onEventTriggered); <span class="comment">// 注册回调函数</span></span><br><span class="line">    ep.<span class="built_in">triggerEvent</span>(<span class="number">42</span>); <span class="comment">// 触发事件，调用回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数指针数组"><a href="#2-函数指针数组" class="headerlink" title="2. 函数指针数组"></a>2. 函数指针数组</h2><p>函数指针数组可以存储指向不同函数的指针，使得程序可以基于运行时决策调用不同的函数。</p><p><strong>示例：</strong> 创建一个简单的菜单系统，用户输入不同的选项执行不同的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executing Function 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executing Function 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executing Function 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(*functions[<span class="number">3</span>])() = &#123;function1, function2, function3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a choice (0-2): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choice &gt;= <span class="number">0</span> &amp;&amp; choice &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        (*functions[choice])(); <span class="comment">// 调用选中的函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid choice&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-接口实现和策略模式"><a href="#3-接口实现和策略模式" class="headerlink" title="3. 接口实现和策略模式"></a>3. 接口实现和策略模式</h2><p>通过函数指针，可以模拟面向对象编程中的接口或策略模式，允许在运行时选择不同的算法或行为。</p><p><strong>示例：</strong> 设计一个简单的排序策略，用户可以选择不同的排序算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SortAlgorithm = <span class="built_in">void</span>(*)(std::vector&lt;<span class="type">int</span>&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ascendingSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">descendingSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortData</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data, SortAlgorithm algorithm)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">algorithm</span>(data); <span class="comment">// 使用指定的排序算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sortData</span>(data, ascendingSort);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : data) std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sortData</span>(data, descendingSort);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : data) std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些示例展示了函数指针在回调、决策和策略选择等不同编程场景中的应用，证明了其为 C++ 编程带来的灵活性和动态性。</p><h1 id="使用-std-function-和-lambda-表达式来替代裸函数指针，举例子"><a href="#使用-std-function-和-lambda-表达式来替代裸函数指针，举例子" class="headerlink" title="使用 std::function 和 lambda 表达式来替代裸函数指针，举例子"></a>使用 std::function 和 lambda 表达式来替代裸函数指针，举例子</h1><p><code>std::function</code> 和 lambda 表达式在 C++11 及之后的版本中提供了一种更加灵活和方便的方式来处理可调用对象。它们使得代码更加简洁且易于理解，特别是在需要函数作为参数或回调时。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式提供了一种匿名函数的实现，允许你在需要函数对象的地方快速定义一个函数。Lambda 表达式的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-std-function-和-Lambda-表达式"><a href="#使用-std-function-和-Lambda-表达式" class="headerlink" title="使用 std::function 和 Lambda 表达式"></a>使用 <code>std::function</code> 和 Lambda 表达式</h2><p><code>std::function</code> 是一个模板类，它可以用来存储任何可以调用的目标，如普通函数、Lambda 表达式、成员函数和函数对象。这提供了比裸函数指针更大的灵活性和功能。</p><p>下面是一个示例，展示了如何使用 <code>std::function</code> 和 Lambda 表达式来替代裸函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 必须包含这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个普通的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 存储普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum using a normal function: &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 存储 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lambdaFunc = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum using a lambda expression: &quot;</span> &lt;&lt; <span class="built_in">lambdaFunc</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了一个普通的函数 <code>add</code>。然后，我们创建了两个 <code>std::function</code> 对象，一个用来存储普通函数 <code>add</code>，另一个用来存储一个实现相同功能的 Lambda 表达式。通过这种方式，我们可以看到 <code>std::function</code> 和 Lambda 表达式如何提供了一种更加灵活的方式来处理可调用对象，而不必直接使用函数指针。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><code>std::function</code> 可以存储任何类型的可调用对象，提供了极大的灵活性。</li><li>Lambda 表达式使得定义和使用匿名函数变得简单，特别是在作为一次性使用函数或局部函数时非常有用。</li><li>使用 <code>std::function</code> 和 Lambda 表达式可以使代码更加清晰和易于维护，特别是在复杂的项目中。</li></ul><p>通过这种方式，C++11 提供的这些特性让处理函数和回调等场景变得更加优雅和高效。</p><h1 id="C-指针函数"><a href="#C-指针函数" class="headerlink" title="C ++ 指针函数"></a>C ++ 指针函数</h1><p>在 C++ 中，术语“指针函数”通常被误解或使用不当。实际上，人们通常是指返回指针的函数，或者简称为“函数返回指针”。这种类型的函数在使用时非常有用，尤其是当你需要从函数中返回动态分配的内存或数组、多级指针、或者指向不同数据结构的指针时。</p><h2 id="定义返回指针的函数"><a href="#定义返回指针的函数" class="headerlink" title="定义返回指针的函数"></a>定义返回指针的函数</h2><p>要定义一个返回指针的函数，你需要在函数声明的返回类型前加上<code>*</code>来指明返回的是指针。这里有一个简单的例子，说明如何定义和使用返回指针的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个返回int指针的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getIntPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="keyword">return</span> ptr; <span class="comment">// 返回指向int的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* myPtr = <span class="built_in">getIntPtr</span>(); <span class="comment">// 调用函数，获取返回的指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *myPtr &lt;&lt; std::endl; <span class="comment">// 使用指针访问值</span></span><br><span class="line">    <span class="keyword">delete</span> myPtr; <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getIntPtr</code>函数分配了一个<code>int</code>类型的动态内存，并返回一个指向这块内存的指针。在<code>main</code>函数中，我们调用了<code>getIntPtr</code>，并使用返回的指针来访问和操作内存。最后，不要忘记使用<code>delete</code>释放动态分配的内存，以避免内存泄露。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>返回局部变量的地址是危险的，因为当函数执行完毕后，局部变量的存储空间会被回收，这样返回的指针会指向一个不再有效的内存区域，导致未定义行为。</li><li>当你的函数返回指向动态分配内存的指针时，确保在适当的时候释放这些内存，以避免内存泄露。</li><li>考虑使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理动态分配的内存，这样可以自动管理内存的生命周期，减少内存泄露的风险。</li></ul><p>返回指针的函数提供了一种灵活的方式来创建和管理动态资源，但同时也需要谨慎处理指针和内存管理相关的问题。</p><h1 id="如何使用智能指针（如std-unique-ptr或std-shared-ptr）来管理动态分配的内存"><a href="#如何使用智能指针（如std-unique-ptr或std-shared-ptr）来管理动态分配的内存" class="headerlink" title="如何使用智能指针（如std::unique_ptr或std::shared_ptr）来管理动态分配的内存"></a>如何使用智能指针（如std::unique_ptr或std::shared_ptr）来管理动态分配的内存</h1><p>在 C++ 中，智能指针是一种模板类，用于自动管理动态分配的内存，确保资源在不再需要时被正确释放，从而避免内存泄露。C++11 引入了两种主要的智能指针类型：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>，它们分别用于独占所有权和共享所有权的场景。</p><h2 id="使用-std-unique-ptr"><a href="#使用-std-unique-ptr" class="headerlink" title="使用 std::unique_ptr"></a>使用 <code>std::unique_ptr</code></h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，保证同一时间只有一个 <code>std::unique_ptr</code> 指向特定的资源。当 <code>std::unique_ptr</code> 被销毁或被重新分配时，它指向的对象也会被自动删除。</p><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a><strong>基本用法：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyMethod called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;MyObject&gt; myUniquePtr = std::<span class="built_in">make_unique</span>&lt;MyObject&gt;();</span><br><span class="line">    myUniquePtr-&gt;<span class="built_in">myMethod</span>(); <span class="comment">// 使用-&gt;操作符调用成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要手动删除对象，当unique_ptr离开作用域时，对象会被自动销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-std-shared-ptr"><a href="#使用-std-shared-ptr" class="headerlink" title="使用 std::shared_ptr"></a>使用 <code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，允许多个 <code>std::shared_ptr</code> 实例指向同一个对象。内部使用引用计数来跟踪有多少个 <code>std::shared_ptr</code> 指向同一个资源，当最后一个这样的指针被销毁时，所指向的对象也会被删除。</p><h3 id="基本用法：-1"><a href="#基本用法：-1" class="headerlink" title="基本用法："></a><strong>基本用法：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyMethod called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyObject&gt; mySharedPtr1 = std::<span class="built_in">make_shared</span>&lt;MyObject&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;MyObject&gt; mySharedPtr2 = mySharedPtr1; <span class="comment">// 共享所有权</span></span><br><span class="line">        mySharedPtr2-&gt;<span class="built_in">myMethod</span>();</span><br><span class="line">        <span class="comment">// 当mySharedPtr2离开作用域时，对象不会被销毁，因为mySharedPtr1仍然存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有当最后一个指向对象的shared_ptr（这里是mySharedPtr1）离开作用域时，对象才会被销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用智能指针可以减少内存泄露的风险，但仍需要注意循环引用问题，尤其是在使用 <code>std::shared_ptr</code> 时。循环引用会阻止引用计数达到零，导致内存泄露。解决循环引用问题通常使用 <code>std::weak_ptr</code>。</li><li><code>std::unique_ptr</code> 通过移动语义实现所有权的转移，不能被复制。</li><li><code>std::shared_ptr</code> 适用于资源需要被多个所有者共享的情况，但增加了额外的开销（引用计数管理）。</li></ul><p>智能指针是现代 C++ 管理动态资源的首选方式，相比裸指针，它们提供了更安全、更简洁的资源管理机制。</p>]]></content>
      
      
      <categories>
          
          <category> 5 - C++ </category>
          
          <category> 5.1 - C++理论基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - IPC Binder 机制（一）</title>
      <link href="/2023/08/27/Android/Framework/04-Android-Framework-%E4%B8%93%E9%A1%B9-IPC-Binder-%E6%9C%BA%E5%88%B61/"/>
      <url>/2023/08/27/Android/Framework/04-Android-Framework-%E4%B8%93%E9%A1%B9-IPC-Binder-%E6%9C%BA%E5%88%B61/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure><p>Q: Binder 是什么？binder 是如何出现的</p><p>Q: Binder 通信模型是什么？</p><p>Q: Aidl 通信机制是什么？</p><p>Q: Bindservice 流程分析</p><p>Q: Binder 通信是如何走到 Native 层的</p><p>Q: ServiceManager 是什么？</p><p>Q: Binder 通信之 Client 端调度流程解析</p><h3 id="从-Android-系统设计说起"><a href="#从-Android-系统设计说起" class="headerlink" title="从 Android 系统设计说起"></a>从 Android 系统设计说起</h3><h4 id="Android-的系统的三个层次"><a href="#Android-的系统的三个层次" class="headerlink" title="Android 的系统的三个层次"></a>Android 的系统的三个层次</h4><p>application 应用层 - Framework 层- native 层</p><p>Android 中的应用层和系统服务层不在同一个进程，系统服务在单独的进程中。<br>Android 中的不同应用属于不同的进程，每一个应用是 zygote fork 出来的</p><p>为了安全，Android 的应用层与系统层之间是隔离的</p><h3 id="Android-系统-IPC-原理"><a href="#Android-系统-IPC-原理" class="headerlink" title="Android 系统 IPC 原理"></a>Android 系统 IPC 原理</h3><p><img src="/2023/08/27/Android/Framework/04-Android-Framework-%E4%B8%93%E9%A1%B9-IPC-Binder-%E6%9C%BA%E5%88%B61/binder_interprocess_communication.png" alt="IPC原理"></p><p>每个 Android 的进程，只能运行在自己进程所拥有的虚拟地址空间。<br>对应一个 4GB 的<strong>虚拟地址空间</strong>，其中 3GB 是用户空间，1GB 是内核空间，当然内核空间的大小是可以通过参数配置调整的。<br>对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。<br>Client 进程向 Server 进程通信，恰恰是<strong>利用进程间可共享的内核内存空间来完成底层通信工作的</strong>，Client 端与 Server 端进程往往采用 ioctl 等方法跟内核空间的驱动进行交互。</p><h4 id="用户空间和内核空间知识补充"><a href="#用户空间和内核空间知识补充" class="headerlink" title="用户空间和内核空间知识补充"></a>用户空间和内核空间知识补充</h4><p>怎么理解不同进程之间用户空间不能共享，而内核空间却是可共享的？</p><ol><li><strong>用户空间的共享：</strong> 在标准情况下，不同进程的用户空间是彼此隔离的，不能直接共享内存。每个进程有自己独立的虚拟地址空间，不同进程的相同虚拟地址并不会映射到相同的物理内存。这意味着一个进程不能直接访问另一个进程的用户空间。</li><li><strong>内核空间的共享：</strong> 内核空间是操作系统内核的一部分，对所有进程来说都是共享的。这是因为内核提供了操作系统的核心功能，比如进程调度、内存管理、文件系统等。不同进程需要与内核进行交互来请求服务和操作资源。因此，<strong>所有进程都共享一个操作系统内核</strong>。</li><li><strong>内核空间中的数据隔离：</strong> 尽管内核空间对所有进程来说是共享的，但<strong>内核本身会实施严格的隔离措施</strong>，以防止一个进程的操作影响其他进程。内核使用许多机制来确保不同进程的请求和数据是独立的，从而保障系统的稳定性和安全性。</li><li><strong>内核空间中的共享数据结构：</strong> 在某些情况下，内核中可能存在一些数据结构是为多个进程共享的，例如文件描述符表、进程控制块等。这种共享是通过内核维护的数据结构来实现的，而不是直接让不同进程的内核空间映射到相同的物理内存。</li></ol><p>总结起来，不同进程的用户空间通常是不能直接共享的，每个进程都有自己的独立虚拟地址空间。但所有进程共享同一个内核空间，内核提供了操作系统的核心功能。<strong>内核空间中的数据隔离和共享是通过内核内部的机制来实现的</strong>。</p><h4 id="页表知识补充"><a href="#页表知识补充" class="headerlink" title="页表知识补充"></a>页表知识补充</h4><p>页表是操作系统中用于管理虚拟内存与物理内存之间映射关系的数据结构。在计算机中，虚拟内存是指操作系统为每个进程提供的独立的内存地址空间，而物理内存则是实际的硬件内存。由于物理内存有限，虚拟内存允许多个进程同时运行，而不会受到物理内存大小的限制。</p><p>页表的主要功能是将虚拟地址转换为物理地址。当进程访问虚拟地址时，操作系统通过页表查找，找到对应的物理地址，从而实际完成内存的读写操作。</p><p>具体来说，页表包含了虚拟地址和物理地址之间的映射关系。每个进程都有自己的页表，其中的页表项记录了虚拟地址的页号（page number）与物理地址的页框号（page frame number）之间的对应关系。页框是物理内存的一个固定大小的块，而页是虚拟内存的一个固定大小的块。通过查找页表，操作系统可以找到虚拟地址对应的物理地址，从而实现内存访问。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><strong>用户空间与内核空间</strong>: IPC 机制总的操作又可以分为用户空间进行的操作和内核空间进行的操作</li><li><strong>内核空间中的数据结构不同</strong>: 不同 IPC 机制内核中的数据结构不同</li><li><strong>复制与映射</strong>: IPC 机制利用进程间可共享的内核空间来完成底层通信工作，其中我们可以简单的分为复制和虚拟内存映射两种方式</li></ol><p>我们从这几个角度来快速的区分 IPC 机制</p><h3 id="IPC-共享内存"><a href="#IPC-共享内存" class="headerlink" title="IPC-共享内存"></a>IPC-共享内存</h3><h4 id="用户空间与内核空间行为"><a href="#用户空间与内核空间行为" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建共享内存：</strong> 进程通过系统调用在用户空间申请一块共享内存，得到一个唯一的标识符。</li><li><strong>映射共享内存：</strong> 进程使用系统调用将共享内存映射到自己的虚拟地址空间，从而可以直接访问这块内存区域。这个映射实际上是指向了内核空间中设置的共享页表项。</li><li><strong>读写数据：</strong> 进程可以在映射的共享内存区域进行读写操作，与普通内存一样，无需复杂的通信操作。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>设置共享内存页表：</strong> 内核负责在共享内存的物理地址和虚拟地址之间建立映射关系，设置页表项，确保多个进程能够访问相同的物理内存。</li><li><strong>同步和权限控制：</strong> 内核维护共享内存的元信息，包括大小、权限等。在多个进程访问时，内核会处理访问的同步和权限控制问题。</li><li><strong>不同进程的映射：</strong> 当不同进程请求映射共享内存时，内核将相同的物理内存映射到不同的进程虚拟地址空间，使它们共享同一块内存。它们共享相同的页表项，由 TLB（Translation Lookaside Buffer，页表查找缓冲器）实现。</li></ol><h4 id="内核空间中的关键数据结构"><a href="#内核空间中的关键数据结构" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>共享的页表项</p><h4 id="复制与映射"><a href="#复制与映射" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>双进程分享的是共享页表项，物理地址内数据只有一份，复制次数 0</p><h3 id="IPC-管道"><a href="#IPC-管道" class="headerlink" title="IPC-管道"></a>IPC-管道</h3><h4 id="不同管道类型"><a href="#不同管道类型" class="headerlink" title="不同管道类型"></a>不同管道类型</h4><h5 id="无名管道（Unnamed-Pipe）"><a href="#无名管道（Unnamed-Pipe）" class="headerlink" title="无名管道（Unnamed Pipe）"></a>无名管道（Unnamed Pipe）</h5><ul><li>无名管道是一种单向通信机制，<strong>只能用于父子进程或者具有共同祖先的进程之间通信</strong>。</li><li>创建无名管道使用的是 <code>pipe()</code> 系统调用。该调用返回一对文件描述符，一个用于读取，一个用于写入。</li><li>无名管道的数据传输是单向的，数据写入一个描述符后可以被另一个描述符读取。</li><li>在很多系统上，<strong>无名管道的缓冲区大小是固定的</strong>，通常为一页大小（例如4KB）。这意味着管道的数据容量有限，无法容纳大规模的数据。</li></ul><h5 id="有名管道（Named-Pipe，FIFO）"><a href="#有名管道（Named-Pipe，FIFO）" class="headerlink" title="有名管道（Named Pipe，FIFO）:"></a>有名管道（Named Pipe，FIFO）:</h5><ul><li><p>有名管道是一种<strong>基于文件系统的命名管道</strong>，可以用于任意进程之间通信，<strong>不受关系限制</strong>。</p></li><li><p>使用 <code>mkfifo</code> 命令或 <code>mkfifo()</code> 系统调用创建有名管道。它在文件系统中创建一个特殊的文件节点，进程可以像读写普通文件一样读写这个节点来进行通信。</p></li><li><p>有名管道的<strong>数据传输是单向的</strong>，需要同时创建一个读取端和一个写入端。多个进程可以连接到同一个有名管道进行通信。</p></li><li><p>有名管道（Named Pipe，FIFO）的<strong>缓冲区大小是由系统内核设置</strong>的，并且<strong>通常与页大小（Page Size）有关</strong>。在大多数Linux系统中，页大小通常为4KB，因此默认情况下，有名管道的缓冲区大小也会是4KB。</p><p><strong>某些系统可能会允许你通过特定的系统参数进行配置</strong>。具体的设置方法可能会因操作系统版本和发行版而异。</p></li></ul><h4 id="管道的指针操作，写满与阻塞"><a href="#管道的指针操作，写满与阻塞" class="headerlink" title="管道的指针操作，写满与阻塞"></a>管道的指针操作，写满与阻塞</h4><p>写入从头指针开始，读取从尾指针开始。写入之后，头指针挪动，读取之后尾指针挪动。<br>如果是头指针赶上尾指针，那么管道被写满，写就会被阻塞。如果是尾指针赶上头指针，那么管道为空，read阻塞。</p><h4 id="用户空间与内核空间行为-1"><a href="#用户空间与内核空间行为-1" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建管道：</strong> 进程通过系统调用在用户空间创建一个管道，得到两个文件描述符，一个用于读取，一个用于写入。</li><li><strong>写入数据：</strong> 进程使用写入文件描述符将数据写入管道。</li><li><strong>读取数据：</strong> 进程使用读取文件描述符从管道中读取数据。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>管道管理：</strong> 内核维护管道的数据结构，包括缓冲区和读写指针。</li><li><strong>数据传递：</strong> 内核通过管道将写入的数据从一个进程的写入文件描述符复制到另一个进程的读取文件描述符。</li><li><strong>进程同步：</strong> 内核确保在多个进程访问管道时的同步，避免数据错乱。</li></ol><h4 id="内核空间中的关键数据结构-1"><a href="#内核空间中的关键数据结构-1" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>单向管道</p><h4 id="复制与映射-1"><a href="#复制与映射-1" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>在基本的管道（Pipe）IPC 机制中，数据实际上只涉及一次复制操作，因为管道是一个字节流传输机制，数据在管道中以字节为单位连续传输。</p><p>简单的说 Linux 是文件系统，管道也是文件，这个文件由两个指针进行操作，一头写入一头读取，当一个进程将数据写入管道时，数据直接写入这个文件内，即管道的缓冲区中，当另一个进程从管道中读取数据时，这些数据会被从管道的缓冲区读取到接收方进程的内存中，而<strong>管道不持有这些数据</strong>，数据的角度来看，实际上只有一次数据复制。</p><h3 id="IPC-消息队列"><a href="#IPC-消息队列" class="headerlink" title="IPC-消息队列"></a>IPC-消息队列</h3><h4 id="用户空间与内核空间行为-2"><a href="#用户空间与内核空间行为-2" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建消息队列：</strong> 进程通过系统调用在用户空间创建一个消息队列，得到一个唯一的标识符。</li><li><strong>发送消息：</strong> 进程使用系统调用将消息发送到消息队列，包括消息类型和数据（需要通信双方约定好）。</li><li><strong>接收消息：</strong> 进程使用系统调用从消息队列中接收消息，根据消息类型读取相应的数据。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>消息队列管理：</strong> 内核维护消息队列的元信息，包括消息队列的状态、大小等。</li><li><strong>消息传递：</strong> 内核<strong>将进程发送的消息复制到消息队列中</strong>，或<strong>从消息队列中复制消息给接收的进程</strong>。（跨进程消息队列<strong>两次复制</strong>）</li><li><strong>进程同步：</strong> 内核确保在多个进程访问消息队列时的同步，以避免竞态条件。</li></ol><h4 id="内核空间中的关键数据结构-2"><a href="#内核空间中的关键数据结构-2" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>消息队列</p><h4 id="复制与映射-2"><a href="#复制与映射-2" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>两次复制</p><ol><li><strong>写入数据：</strong> 当一个进程将消息写入消息队列时，消息数据会从发送方进程的内存复制到消息队列的内核缓冲区中。这是第一次复制操作。</li><li><strong>读取数据：</strong> 在接收方进程中，数据需要从内核缓冲区复制到接收方进程的内核空间中。这是第二次复制操作。</li></ol><h3 id="IPC-Socket"><a href="#IPC-Socket" class="headerlink" title="IPC-Socket"></a>IPC-Socket</h3><h4 id="用户空间与内核空间行为-3"><a href="#用户空间与内核空间行为-3" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建 Socket：</strong> 进程通过系统调用在用户空间创建一个 Socket，得到一个文件描述符，用于读写数据。</li><li><strong>发送数据：</strong> 进程使用文件描述符发送数据到指定的 Socket。</li><li><strong>接收数据：</strong> 进程使用文件描述符从 Socket 中接收数据。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>Socket 管理：</strong> 内核维护 Socket 的数据结构，包括缓冲区、连接状态等。</li><li><strong>数据传递：</strong> 内核通过 Socket 将进程发送的数据从一个进程的发送缓冲区复制到另一个进程的接收缓冲区。</li><li><strong>连接管理：</strong> 内核负责管理连接的建立、维护和断开，以及处理各种网络协议。</li></ol><p>内核空间中的关键数据结构</p><h4 id="内核空间中的关键数据结构-3"><a href="#内核空间中的关键数据结构-3" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><ol><li><strong>发送缓冲区：</strong> 发送方进程使用 Socket 发送数据时，数据首先被复制到发送缓冲区（Send Buffer）中。这个缓冲区在内核空间中，用于临时存储待发送的数据。发送缓冲区的大小可以由操作系统参数或套接字选项进行配置。</li><li><strong>接收缓冲区：</strong> 接收方进程使用 Socket 接收数据时，数据会被存储在接收缓冲区（Receive Buffer）中。这个缓冲区同样位于内核空间，用于临时存储接收到的数据。接收缓冲区的大小也可以通过操作系统参数或套接字选项进行配置</li></ol><h4 id="复制与映射-3"><a href="#复制与映射-3" class="headerlink" title="复制与映射"></a>复制与映射</h4><h5 id="linux-2-4-内核以下"><a href="#linux-2-4-内核以下" class="headerlink" title="linux 2.4 内核以下"></a>linux 2.4 内核以下</h5><p>两次用户、内核态的切换，三次数据拷贝</p><h5 id="linux-2-4-内核及其以上"><a href="#linux-2-4-内核及其以上" class="headerlink" title="linux 2.4 内核及其以上"></a>linux 2.4 内核及其以上</h5><p>两次用户、内核态的切换，两次数据拷贝</p><h6 id="内核态零拷贝原理"><a href="#内核态零拷贝原理" class="headerlink" title="内核态零拷贝原理"></a>内核态零拷贝原理</h6><p>数据不再被复制到 socket 关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到 socket 关联的缓冲区中。DMA 直接将内核中的缓冲区中的数据传输给协议引擎，消除了那一次需要 cpu 周期的数据复制。</p><h3 id="IPC-Binder"><a href="#IPC-Binder" class="headerlink" title="IPC-Binder"></a>IPC-Binder</h3><h4 id="用户空间与内核空间行为-4"><a href="#用户空间与内核空间行为-4" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p>从用户空间和内核空间的角度来看，IPC（Inter-Process Communication，进程间通信）Binder 的工作可以简洁地描述如下：</p><p><strong>用户空间：</strong></p><ol><li><strong>创建 Binder 对象：</strong> 进程通过系统调用创建 Binder 对象，通常是 <code>Binder</code> 类的子类实例。这个对象用于表示一个通信通道，可以用来发送和接收数据。</li><li><strong>发送数据：</strong> 进程通过 Binder 对象将数据（通常是 Parcel 对象）发送到另一个进程。这个过程会<strong>将数据传递给内核空间的 Binder 驱动</strong>。</li><li><strong>接收数据：</strong> 进程通过 Binder 对象接收另一个进程发送的数据。接收的数据也是以 Parcel 对象的形式返回给用户空间。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>Binder 驱动：</strong> Binder 驱动位于内核空间，负责管理 Binder 通信。当进程发送数据时，数据会传递给 Binder 驱动。</li><li><strong>数据传递：</strong> Binder 驱动将进程发送的数据<strong>从发送方进程的用户空间复制到接收方进程的用户空间</strong>，这一过程中<strong>涉及数据的复制和映射</strong>。</li><li><strong>线程池管理：</strong> Binder 驱动还管理了一个线程池，用于处理进程间的数据传递请求。这确保了数据的传递不会阻塞主线程，提高了性能。</li><li><strong>权限和安全性：</strong> Binder 驱动实施权限和安全性控制，确保只有经过授权的进程可以进行 Binder 通信。</li></ol><h4 id="内核空间中的关键数据结构-4"><a href="#内核空间中的关键数据结构-4" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>指向物理内存的内核空间虚拟内存</p><h4 id="复制与映射-4"><a href="#复制与映射-4" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>复制：发送方进程将数据复制到内核空间虚拟内存中。<br>映射：将这个内核中的虚拟内存映射给接收方进程。</p><h2 id="为什么-Android-要采用-Binder-作为-IPC-机制？"><a href="#为什么-Android-要采用-Binder-作为-IPC-机制？" class="headerlink" title="为什么 Android 要采用 Binder 作为 IPC 机制？"></a>为什么 Android 要采用 Binder 作为 IPC 机制？</h2><p><strong>在下不才，这个问题，交给大佬回答</strong></p><p>作者：Gityuan<br>链接：<a href="https://www.zhihu.com/question/39440766/answer/89210950">https://www.zhihu.com/question/39440766/answer/89210950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>在开始回答 前，先简单概括性地说说Linux现有的所有进程间IPC方式：</strong></p><ol><li><strong>管道</strong>: 在创建时分配一个page大小的内存，缓存区大小比较有限。</li><li><strong>消息队列</strong>: 信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信。</li><li><strong>共享内存</strong>: 无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快，但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决。</li><li><strong>套接字</strong>: 作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信。</li><li><strong>信号量</strong>: 常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>信号</strong>: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等。</li></ol><p><strong>Android的内核也是基于Linux内核，为何不直接采用Linux现有的进程IPC方案呢，难道Linux社区那么多优秀人员都没有考虑到有Binder这样一个更优秀的方案，是google太过于牛B吗？事实是真相并非如此，请细细往下看，您就明白了。</strong></p><hr><p><strong>接下来正面回答这个问题，从5个角度来展开对Binder的分析：</strong></p><p><strong>（1）从性能的角度</strong> <strong>数据拷贝次数：</strong>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</p><p><strong>（2）从稳定性的角度</strong><br>Binder是基于C&#x2F;S架构的，简单解释下C&#x2F;S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。</p><p>仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制，那么更重要的原因是：</p><p><strong>（3）从安全的角度</strong><br>传统Linux IPC的接收方无法获得对方进程可靠的UID&#x2F;PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。 </p><p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C&#x2F;S架构，<strong>Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID&#x2F;PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行</strong>。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。</p><p>针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但<strong>同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。</strong>对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。</p><p>Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：<br><a href="https://www.zhihu.com/question/41003297/answer/89328987?from=profile_answer_card">Android源码的Binder权限是如何控制？ -Gityuan的回答</a></p><p><strong>传统IPC</strong>只能由用户在数据包里填入UID&#x2F;PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p><p><strong>说到这，可能有人要反驳</strong>，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在<strong>Google举办的Android Bootcamp 2016</strong>大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。 </p><p>话题扯远了，继续说Binder。</p><p><strong>（4）从语言层面的角度</strong><br>大家多知道Linux是基于C语言面向过程的语言，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。</p><p><strong>另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。</strong>也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在<strong>Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制</strong>，Android中的<strong>Kill Process采用的signal（信号）机制</strong>等等。而<strong>Binder更多则用在system_server进程与上层App层的IPC交互</strong>。</p><p><strong>(5) 从公司战略的角度</strong></p><p>总所周知，Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。 </p><p>而Android 之父 Andy Rubin对于GPL显然是不能接受的，为此，Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性，仍有较大争议，但至少目前缓解Android，让GPL止步于内核空间，这是Google在GPL Linux下 开源与商业化共存的一个成功典范。</p><p><strong>有了这些铺垫，我们再说说Binder的今世前缘</strong></p><p>Binder是基于开源的 OpenBinder实现的，OpenBinder是一个开源的系统IPC机制,最初是由 Be Inc.开发，接着由 Palm, Inc. 公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择。</p><p>另外，再说一点关于OpenBinder，在2015年OpenBinder以及合入到Linux Kernel主线 3.19版本，这也算是Google对Linux的一点回馈吧。</p><p><strong>综合上述5点，可知Binder是Android系统上层进程间通信的不二选择。</strong></p><hr><p>IPC 原理来自于</p><p>gityuan: <a href="http://gityuan.com/2015/10/31/binder-prepare/">http://gityuan.com/2015/10/31/binder-prepare/</a></p><p>参考资料：《计算机操作系统》</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - Handler（三）</title>
      <link href="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/"/>
      <url>/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/</url>
      
        <content type="html"><![CDATA[<h4 id="要理解-Message-的创建，先要说内存抖动"><a href="#要理解-Message-的创建，先要说内存抖动" class="headerlink" title="要理解 Message 的创建，先要说内存抖动"></a>要理解 Message 的创建，先要说内存抖动</h4><h5 id="内存抖动的原因及引发的问题"><a href="#内存抖动的原因及引发的问题" class="headerlink" title="内存抖动的原因及引发的问题"></a>内存抖动的原因及引发的问题</h5><p>在 Android 虚拟机中，当我们在应用程序中创建大量的临时对象，并且这些对象的存在时间很短暂，虚拟机会识别这些临时对象并将它们标记为待清理的垃圾对象，以便在适当的时候回收它们。然而，这个垃圾回收过程可能会引发一个称为“stop the world”的现象。所谓“stop the world”指的是，在进行垃圾回收的过程中，虚拟机会暂停应用程序的正常执行，以便能够安全地识别和回收这些临时对象。</p><p>在 Java 字节码中，创建一个对象通常需要执行三个关键操作: <code>new</code>、<code>dup</code> 和 <code>invokespecial</code>。这三个操作合在一起构成了对象创建的原子过程。</p><p>虚拟机通常通过两种方式来判断一个对象是否是垃圾。一种方式是使用“引用计数”机制，但这种方法存在循环引用的问题，因此无法完全准确地标记垃圾对象，从而导致垃圾回收不彻底。另一种方式是使用“根可达”（或称为“根引用”）的方式，即从根对象（如线程栈、静态变量等）开始，追踪对象之间的引用关系，从而判断哪些对象是可达的，哪些是垃圾。</p><p>然而，在标记垃圾对象的过程中，如果垃圾回收线程与创建对象的线程同时工作，就可能出现问题。例如，如果一个对象刚刚被创建但尚未与变量关联，而垃圾回收线程已经扫描到这个对象并标记为垃圾，那么在后续的垃圾回收过程中，这个对象可能会被回收，而在应用程序中使用相关变量时可能会触发空指针异常。为了避免这种情况，标记垃圾的过程通常需要暂停所有工作线程，确保在标记过程中不会有对象的状态发生变化。这就是为什么在进行垃圾回收时会出现应用程序“停顿”的现象。</p><p>然而，如果垃圾回收过程耗时过长，会导致应用程序长时间无响应，造成卡顿现象。因此，我们需要尽量避免在应用中创建大量生命周期很短的临时对象，以减少垃圾回收的频率和影响。</p><p>内存抖动的原因: 创建了大量的生命周期很短的对象。<br>导致的问题: 在用户看来程序出现了卡顿。</p><h4 id="Message-中-obtain-与-recycle"><a href="#Message-中-obtain-与-recycle" class="headerlink" title="Message 中 obtain() 与 recycle()"></a>Message 中 obtain() 与 recycle()</h4><p>显而易见，Message 那真是生命周期极短数量极其庞大，是最容易内存抖动的地方<br>所以 Message 内存必须被复用</p><p>我们说说 Message 的销毁与创建</p><h5 id="创建-android-os-Message-obtain"><a href="#创建-android-os-Message-obtain" class="headerlink" title="创建: android.os.Message#obtain()"></a>创建: android.os.Message#obtain()</h5><p><strong>注意：说创建是不准确的，应该是提供</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="literal">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是用于在 Android 中创建和管理消息对象的一部分。它通过维护一个对象池，允许在需要时重复利用已有的消息对象，从而减少内存分配和垃圾回收的开销。当需要获取一个新的消息对象时，它会首先检查对象池是否有可用的对象。如果有，它会从对象池中取出一个对象并重置其状态，然后返回；如果对象池为空，它会创建一个新的消息对象并返回。这种做法有助于提高应用程序的性能和效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713203707125.png" alt="链表初始态"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713203837939.png" alt="Message m = sPool;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sPool = m.next;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713203910065.png" alt="sPool = m.next;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.next = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713203938940.png" alt="m.next = null;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.flags=<span class="number">0</span>;</span><br><span class="line">sPoolSize--;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure><h5 id="回收-android-os-Message-recycle"><a href="#回收-android-os-Message-recycle" class="headerlink" title="回收: android.os.Message#recycle()"></a>回收: android.os.Message#recycle()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a Message instance to the global pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * You MUST NOT touch the Message after calling this function because it has</span></span><br><span class="line"><span class="comment"> * effectively been freed.  It is an error to recycle a message that is currently</span></span><br><span class="line"><span class="comment"> * enqueued or that is in the process of being delivered to a Handler.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一下 gCheckRecycle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateCheckRecycle</span><span class="params">(<span class="type">int</span> targetSdkVersion)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        gCheckRecycle = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在较低版本的 Android 上 ( &lt; 5.0 )，某些检查可能会导致不必要的异常情况，如 <code>IllegalStateException</code>。这可能会影响应用程序的稳定性。通过避免这些检查，可以避免异常的抛出，提高应用程序的可靠性。</p><h5 id="回收-android-os-Message-recycleUnchecked"><a href="#回收-android-os-Message-recycleUnchecked" class="headerlink" title="回收: android.os.Message#recycleUnchecked"></a>回收: android.os.Message#recycleUnchecked</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment">  * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">      flags = FLAG_IN_USE;</span><br><span class="line">      what = <span class="number">0</span>;</span><br><span class="line">      arg1 = <span class="number">0</span>;</span><br><span class="line">      arg2 = <span class="number">0</span>;</span><br><span class="line">      obj = <span class="literal">null</span>;</span><br><span class="line">      replyTo = <span class="literal">null</span>;</span><br><span class="line">      sendingUid = UID_NONE;</span><br><span class="line">      workSourceUid = UID_NONE;</span><br><span class="line">      when = <span class="number">0</span>;</span><br><span class="line">      target = <span class="literal">null</span>;</span><br><span class="line">      callback = <span class="literal">null</span>;</span><br><span class="line">      data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="built_in">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flags = FLAG_IN_USE;</span><br><span class="line">what = <span class="number">0</span>;</span><br><span class="line">arg1 = <span class="number">0</span>;</span><br><span class="line">arg2 = <span class="number">0</span>;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">replyTo = <span class="literal">null</span>;</span><br><span class="line">sendingUid = UID_NONE;</span><br><span class="line">workSourceUid = UID_NONE;</span><br><span class="line">when = <span class="number">0</span>;</span><br><span class="line">target = <span class="literal">null</span>;</span><br><span class="line">callback = <span class="literal">null</span>;</span><br><span class="line">data = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>消息的标志位 <code>flags</code> 的含义是消息对象是否正在使用中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同步块中，检查消息池的大小是否小于最大池大小（<code>MAX_POOL_SIZE</code>）。</p><ul><li>如果是，将当前消息对象放入消息池的链表中，以供将来重用。</li><li>更新消息池的大小。</li></ul><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713204015503.png" alt="初始链表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next=sPool;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713204035066.png" alt="next=sPool;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sPool=<span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/27/Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/20160713204119209.png" alt="sPool=this;"></p><hr><p>内存抖动参考自:<br>知乎博主Android小瓜: Android 性能优化大法——内存抖动<br>原文链接: <a href="https://zhuanlan.zhihu.com/p/575959909">https://zhuanlan.zhihu.com/p/575959909</a></p><p>android.os.Message#obtain() 与 android.os.Message#recycleUnchecked 相关图片来自于:<br>版权声明：本文为CSDN博主「-_-void」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xmh19936688/article/details/51901338">https://blog.csdn.net/xmh19936688/article/details/51901338</a></p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - Handler（二）</title>
      <link href="/2023/08/23/Android/Framework/02-Android-Framework-%E4%B8%93%E9%A1%B9-Handler2/"/>
      <url>/2023/08/23/Android/Framework/02-Android-Framework-%E4%B8%93%E9%A1%B9-Handler2/</url>
      
        <content type="html"><![CDATA[<h3 id="MessageQueue-到底是什么"><a href="#MessageQueue-到底是什么" class="headerlink" title="MessageQueue 到底是什么?"></a>MessageQueue 到底是什么?</h3><h4 id="从-MessageQueue-的创建说起"><a href="#从-MessageQueue-的创建说起" class="headerlink" title="从 MessageQueue 的创建说起"></a>从 MessageQueue 的创建说起</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">     mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);<span class="comment">//保证了MessageQueue的唯一性</span></span><br><span class="line">     mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue 就是在 Looper 的构造方法里创建的，一个 <strong>Looper 就对应了一个 MessageQueue</strong>。</p><h4 id="MessageQueue-如何实现线程间的数据隔离"><a href="#MessageQueue-如何实现线程间的数据隔离" class="headerlink" title="MessageQueue 如何实现线程间的数据隔离"></a>MessageQueue 如何实现线程间的数据隔离</h4><p>线程是不持有系统资源的进程，所以同一个进程中的线程是共用的同一个进程持有的内存，说人话就是进程中持有的内存中的变量和数据每个线程都可以直接读取，MessageQueue 是存放线程要处理的消息的，我们当然不希望它是进程持有的线程之间共享的，不能被其他的线程所干扰，换句话说 MessageQueue 必须是线程隔离的</p><p>android.os.Looper#prepare(boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));<span class="comment">//把新创建的 Looper 和 ThreadLocal 关联起来，保证 looper 的唯一性</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意 <strong>Looper 是一个静态类非一个实例</strong>，在 Looper 的 prepare 阶段，会去 new Looper(quitAllowed)，并将其放入 ThreadLocal，这样就让 Looper 成为了 <em><strong>线程变量</strong></em>，而 MessageQueue 由 Looper 创建并持有，所以 MessageQueue 自然也成了 <strong>线程变量</strong>，这样就实现了每个线程有自己独立的 Looper 和 MessageQueue 实例，且相互隔离。</p><p><code>MessageQueue</code> 是每个线程独有的。每个线程都拥有自己的消息队列，因此在不同的线程之间无法直接共享消息队列。消息是在一个线程中创建和发送到该线程的消息队列，然后由该线程的 <code>Looper</code> 从队列中取出并处理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ThreadLocal` 是一个线程级别的存储，它在每个线程中维护一个独立的存储空间（`ThreadLocalMap`），每个存储空间使用 `ThreadLocal` 对象作为键。不同线程的存储空间互不干扰，实现了线程间的数据隔离；但在同一个线程内，`ThreadLocal` 对象可以共享，对应的数据副本在不同方法间保持一致。、</span><br></pre></td></tr></table></figure><h4 id="MessageQueue-同步屏障"><a href="#MessageQueue-同步屏障" class="headerlink" title="MessageQueue 同步屏障"></a>MessageQueue 同步屏障</h4><p>试想一种情况 MessageQueue 需要处理</p><h5 id="android-os-MessageQueue-next-中的另一种执行逻辑"><a href="#android-os-MessageQueue-next-中的另一种执行逻辑" class="headerlink" title="android.os.MessageQueue#next 中的另一种执行逻辑"></a>android.os.MessageQueue#next 中的另一种执行逻辑</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们重点看这一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">prevMsg = msg;</span><br><span class="line">msg = msg.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 msg !&#x3D; null，而 msg.target &#x3D;&#x3D; null 的时候，android.os.MessageQueue#next 执行了完全不同的另一种逻辑，target 就是 msg 的目标 handler，也就是说如果 msg 没有目标 handler 的时候，那么 msg 就是一个屏障消息，android.os.MessageQueue#next 就会进入无限循环读取异步消息的逻辑</p><p>从这里我们知道 MessageQueue 提供了一个屏障，这个屏障可以让 MessageQueue 越过所有同步消息优先执行异步消息</p><p>我们看看这个屏障该如何升起与取消</p><h5 id="简单的发送一个-msg-target-x3D-x3D-null-的消息升起同步屏障"><a href="#简单的发送一个-msg-target-x3D-x3D-null-的消息升起同步屏障" class="headerlink" title="简单的发送一个 msg.target &#x3D;&#x3D; null 的消息升起同步屏障"></a>简单的发送一个 msg.target &#x3D;&#x3D; null 的消息升起同步屏障</h5><p>可以简单的发送一个 msg.target &#x3D;&#x3D; null 的消息来升起这个屏障吗？<br>尝试一下你就会发现出现了”Message must have a target.”的异常</p><h5 id="android-os-MessageQueue-enqueueMessage-msg-target-x3D-x3D-null-的危险性与抛出的异常"><a href="#android-os-MessageQueue-enqueueMessage-msg-target-x3D-x3D-null-的危险性与抛出的异常" class="headerlink" title="android.os.MessageQueue#enqueueMessage msg.target &#x3D;&#x3D; null 的危险性与抛出的异常"></a>android.os.MessageQueue#enqueueMessage msg.target &#x3D;&#x3D; null 的危险性与抛出的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 android.os.MessageQueue#enqueueMessage 第一步就是检查 msg.target 是否为 null，msg.target &#x3D;&#x3D; null 极度危险，一旦消息没有正确的被处理，会导致整个 MessageQueue 进入异步消息的死循环无法退出，因此 消息屏障的触发与取消必须被管控起来</p><h5 id="严格管控下的同步屏障的触发"><a href="#严格管控下的同步屏障的触发" class="headerlink" title="严格管控下的同步屏障的触发"></a>严格管控下的同步屏障的触发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a synchronization barrier to the Looper&#x27;s message queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Message processing occurs as usual until the message queue encounters the</span></span><br><span class="line"><span class="comment"> * synchronization barrier that has been posted.  When the barrier is encountered,</span></span><br><span class="line"><span class="comment"> * later synchronous messages in the queue are stalled (prevented from being executed)</span></span><br><span class="line"><span class="comment"> * until the barrier is released by calling &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; and specifying</span></span><br><span class="line"><span class="comment"> * the token that identifies the synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method is used to immediately postpone execution of all subsequently posted</span></span><br><span class="line"><span class="comment"> * synchronous messages until a condition is met that releases the barrier.</span></span><br><span class="line"><span class="comment"> * Asynchronous messages (see &#123;<span class="doctag">@link</span> Message#isAsynchronous&#125; are exempt from the barrier</span></span><br><span class="line"><span class="comment"> * and continue to be processed as usual.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call must be always matched by a call to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; with</span></span><br><span class="line"><span class="comment"> * the same token to ensure that the message queue resumes normal operation.</span></span><br><span class="line"><span class="comment"> * Otherwise the application will probably hang!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A token that uniquely identifies the barrier.  This token must be</span></span><br><span class="line"><span class="comment"> * passed to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; to release the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是 Android 消息机制中的一部分，用于实现同步屏障（Sync Barrier）。同步屏障是一种机制，可以用来控制消息队列中的消息执行顺序，特别是用于确保后续的同步消息在某个条件满足之前被阻塞执行。下面对这段代码进行分析：</p><ul><li><p><code>postSyncBarrier()</code> 方法：</p><ul><li>这个方法是向消息队列中添加一个同步屏障。</li><li>同步屏障是一种特殊的消息，它会阻塞后续的同步消息的执行，直到同步屏障被释放。</li><li>该方法返回一个用于标识同步屏障的 token，这个 token 在稍后调用 <code>removeSyncBarrier()</code> 方法时需要使用。</li></ul></li><li><p><code>postSyncBarrier(long when)</code> 方法：</p><ul><li>这个方法是 <code>postSyncBarrier()</code> 的内部实现。</li><li>该方法会创建一个同步屏障消息，设置其触发时间（when）和一个唯一的 token。</li><li>同步屏障消息将被插入消息队列中，并根据触发时间排序。</li></ul></li><li><p>在插入同步屏障消息时：</p><ul><li>遍历消息队列，找到合适的位置插入同步屏障消息，以保持消息队列的顺序。</li><li>如果同步屏障消息需要插入的位置在已有消息之后，将同步屏障消息插入到该位置之后。</li><li>如果同步屏障消息需要插入的位置在已有消息之前，将同步屏障消息作为新的头部消息。</li></ul></li></ul><p>总结起来，这段代码实现了向消息队列中插入同步屏障消息的功能。同步屏障消息的作用是阻塞后续的同步消息的执行，直到满足某个条件后释放同步屏障。这种机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足之前某些消息不被执行。</p><h5 id="严格管控下的同步屏障的取消"><a href="#严格管控下的同步屏障的取消" class="headerlink" title="严格管控下的同步屏障的取消"></a>严格管控下的同步屏障的取消</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes a synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #postSyncBarrier&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSyncBarrier</span><span class="params">(<span class="type">int</span> token)</span> &#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; (p.target != <span class="literal">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="literal">null</span> || mMessages.target != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是用于移除同步屏障（Sync Barrier）的逻辑。它会从消息队列中移除指定的同步屏障消息，并在必要时唤醒消息队列，以继续处理后续的消息。下面对这段代码进行分析：</p><ul><li><p><code>removeSyncBarrier(int token)</code> 方法：</p><ul><li>这个方法用于移除同步屏障。</li><li>它接受一个参数 <code>token</code>，即之前调用 <code>postSyncBarrier()</code> 方法返回的标识同步屏障的 token。</li><li>如果指定的同步屏障消息被找到并移除，将会在必要时唤醒消息队列。</li></ul></li><li><p>在移除同步屏障消息时：</p><ul><li>遍历消息队列，寻找包含指定 token 的同步屏障消息。</li><li>如果找到了匹配的同步屏障消息，将其从消息队列中移除。</li><li>如果在移除同步屏障消息后，消息队列不再被其他消息阻塞，会将队列唤醒，以继续处理后续的消息。</li></ul></li><li><p><code>recycleUnchecked()</code> 方法：</p><ul><li>在移除同步屏障消息后，调用这个方法将消息对象回收，以便释放资源。</li></ul></li></ul><p>总结起来，这段代码实现了移除同步屏障消息的功能。当同步屏障条件满足后，通过调用 <code>removeSyncBarrier()</code> 方法来移除同步屏障消息，从而解除对后续同步消息的阻塞。这个机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足后执行后续的同步消息。</p><h4 id="从-ViewRootImpl-看同步屏障的使用"><a href="#从-ViewRootImpl-看同步屏障的使用" class="headerlink" title="从 ViewRootImpl 看同步屏障的使用"></a>从 ViewRootImpl 看同步屏障的使用</h4><p>android.view.ViewRootImpl#scheduleTraversals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步屏障的触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br></pre></td></tr></table></figure><p>再看一下发送消息的逻辑</p><p>android.view.Choreographer#postCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a callback to run on the next frame.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The callback runs once then is automatically removed.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callbackType The callback type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The callback action to run during the next frame.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The callback token, or null if none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #removeCallbacks</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallback</span><span class="params">(<span class="type">int</span> callbackType, Runnable action, Object token)</span> &#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.view.Choreographer#postCallbackDelayed</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a callback to run on the next frame after the specified delay.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The callback runs once then is automatically removed.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callbackType The callback type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The callback action to run during the next frame after the specified delay.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The callback token, or null if none.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delayMillis The delay time in milliseconds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #removeCallback</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayed</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Runnable action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;action must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callbackType &lt; <span class="number">0</span> || callbackType &gt; CALLBACK_LAST) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callbackType is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点</strong>: android.view.Choreographer#postCallbackDelayedInternal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType</span><br><span class="line">                + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token</span><br><span class="line">                + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看异步消息的发送逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">msg.arg1 = callbackType;</span><br><span class="line">msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">mHandler.sendMessageAtTime(msg, dueTime);</span><br></pre></td></tr></table></figure><p>android.view.ViewRootImpl#unscheduleTraversals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">unscheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        mChoreographer.removeCallbacks(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.view.ViewRootImpl#unscheduleTraversals 的调用时机比较有意思，这里暂不做更多的分析</p><h4 id="Skipped-30-frames"><a href="#Skipped-30-frames" class="headerlink" title="Skipped 30 frames!"></a>Skipped 30 frames!</h4><h6 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h6><p>在进行 UI 更新的时候，如果 UI 线程忙碌，主线程有时会抛出异常信息：Skipped 30 frames! The application may be doing too much work on its main thread.</p><h6 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h6><p>这是因为触发屏障的实际操作是发送一个 target 为 null 的 msg，但是如果这个 target 为 null 的消息被前面的耗时消息所耽误而一直没能执行，导致后面不断发送来的需要立即执行的异步消息都被耽误，触发同步屏障之后，系统发现，本该立即执行的异步消息已经积累了30帧只会，就会报出这个主线程忙碌的错误</p><h6 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h6><p>罪魁祸首就是那个耽误了 target &#x3D;&#x3D; null 的同步屏障 msg 执行的 msg，这个同步消息的执行如此之耗时，以至于我们必须考虑对其优化或者考虑是不是适合放在主线程<br>可以放到其他线程去执行</p><h4 id="MessageQueue-中的-synchronized"><a href="#MessageQueue-中的-synchronized" class="headerlink" title="MessageQueue 中的 synchronized"></a>MessageQueue 中的 synchronized</h4><h5 id="android-os-MessageQueue-next-中的-synchronized"><a href="#android-os-MessageQueue-next-中的-synchronized" class="headerlink" title="android.os.MessageQueue#next 中的 synchronized"></a>android.os.MessageQueue#next 中的 synchronized</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h6><p><code>synchronized</code> 用于同步代码块的范围涵盖了整个 <code>next()</code> 方法。具体来说，这段代码实现了一个消息循环（message loop）用于处理消息队列中的消息。在多线程环境下，有多个线程可能会调用 <code>next()</code> 方法来获取下一个消息，因此需要确保对共享资源的访问是安全的。</p><h6 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h6><p><code>mIdleHandlers.remove(idler)</code>：这行代码从 <code>mIdleHandlers</code> 集合中移除一个 <code>IdleHandler</code>。由于多个线程可能同时访问和修改 <code>mIdleHandlers</code>，因此需要确保这个操作是原子的，以避免不一致或意外的结果。</p><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>都是 synchronized 保护下的<br>MessageQueue 是 Android 框架中用于处理消息传递和线程通信的关键组件，多个线程可能会同时访问和修改消息队列，因此需要使用同步机制来避免竞态条件和其他线程安全问题。</p><h4 id="MessageQueue-中的-IdleHandler"><a href="#MessageQueue-中的-IdleHandler" class="headerlink" title="MessageQueue 中的 IdleHandler"></a>MessageQueue 中的 IdleHandler</h4><h5 id="使用与意义"><a href="#使用与意义" class="headerlink" title="使用与意义"></a>使用与意义</h5><p><code>IdleHandler</code> 是 Android 消息传递机制中的一个重要概念，它允许你在消息队列空闲时执行一些额外的操作。</p><ol><li><strong>使用：</strong> 你可以通过 <code>MessageQueue</code> 的 <code>addIdleHandler()</code> 方法将一个或多个 <code>IdleHandler</code> 添加到消息队列中。</li><li><strong>意义：</strong> <code>IdleHandler</code> 允许你在消息队列空闲时执行一些轻量级的任务，这些任务通常是一些不需要立即处理、不会阻塞主线程的操作。常见的用例包括资源回收、后台数据同步、性能优化等。通过利用空闲时间执行这些任务，可以提高应用的性能和资源利用率。</li><li><strong>执行时机：</strong> <code>IdleHandler</code> 的 <code>queueIdle()</code> 方法在消息队列没有即时任务需要处理时调用。如果 <code>queueIdle()</code> 返回 <code>true</code>，该 <code>IdleHandler</code> 将继续保持在队列中，以便在下一次空闲时调用；如果返回 <code>false</code>，则该 <code>IdleHandler</code> 将从队列中移除。</li></ol><h5 id="为什么会有多个-IdleHandler"><a href="#为什么会有多个-IdleHandler" class="headerlink" title="为什么会有多个 IdleHandler"></a>为什么会有多个 IdleHandler</h5><ol><li><strong>功能分离：</strong> 不同的 <code>IdleHandler</code> 可以用于执行不同类型的任务，如资源回收、后台数据同步、性能优化等。通过将不同的任务逻辑分离到不同的 <code>IdleHandler</code> 中，可以使代码更加模块化和可维护。</li><li><strong>任务优先级：</strong> 不同的 <code>IdleHandler</code> 可以根据优先级来执行任务。高优先级任务可以通过将对应的 <code>IdleHandler</code> 添加到队列中，确保在空闲时尽快执行。低优先级任务则可以延迟到更空闲的时候执行。</li><li><strong>动态注册和注销：</strong> 多个 <code>IdleHandler</code> 允许开发者在不同的时刻动态地注册和注销任务。这使得可以根据应用程序的状态和需求来动态地调整任务的执行。</li><li><strong>任务复用：</strong> 如果有多个相似的任务需要在空闲时执行，可以通过不同的 <code>IdleHandler</code> 实现任务的复用，避免重复编写类似的代码。</li><li><strong>提高性能：</strong> 通过将不同的任务拆分到多个 <code>IdleHandler</code> 中，可以减少单个 <code>IdleHandler</code> 的负载，从而提高任务的执行效率。</li></ol><h5 id="关键行为分析"><a href="#关键行为分析" class="headerlink" title="关键行为分析"></a>关键行为分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果首次进入空闲状态，则获取要运行的空闲处理程序数量。</span></span><br><span class="line"><span class="comment">             * 空闲处理程序仅在消息队列为空或队列中的第一个消息（可能是一个屏障）将在未来被处理时运行。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                <span class="comment">// 没有要运行的空闲处理程序。继续循环并等待一段时间。</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 运行空闲处理程序。</span></span><br><span class="line"><span class="comment">         * 我们只会在第一次迭代期间到达这个代码块。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mPendingIdleHandlers-与-mIdleHandlers"><a href="#mPendingIdleHandlers-与-mIdleHandlers" class="headerlink" title="mPendingIdleHandlers 与 mIdleHandlers"></a>mPendingIdleHandlers 与 mIdleHandlers</h4><ol><li><strong>mPendingIdleHandlers</strong>：<ul><li>类型：<code>IdleHandler[]</code></li><li>作用：用于存储当前等待执行的空闲时处理对象（<code>IdleHandler</code>）数组。在消息队列空闲时，这些处理会被调用，以执行额外的任务。</li><li>使用场景：用于临时存储等待执行的空闲时处理，直接与循环内部逻辑相关。</li></ul></li><li><strong>mIdleHandlers</strong>：<ul><li>类型：<code>ArrayList&lt;IdleHandler&gt;</code></li><li>作用：用于存储注册的空闲时处理对象。开发者可以将多个 <code>IdleHandler</code> 添加到这个列表中，以便在消息队列空闲时执行不同的任务。</li><li>使用场景：用于持久存储注册的空闲时处理，可以在任何时候添加或移除 <code>IdleHandler</code>。</li></ul></li></ol><p>总结区别：</p><ul><li><code>mPendingIdleHandlers</code> 是一个数组，用于存储当前等待执行的空闲时处理对象。它是循环内部临时使用的，用于遍历调用每个等待执行的空闲时处理。</li><li><code>mIdleHandlers</code> 是一个列表，用于持久存储注册的空闲时处理对象。开发者可以随时将 <code>IdleHandler</code> 添加到列表中，以便在消息队列空闲时执行不同的任务。</li></ul><h5 id="给-PendingIdleHandlers-分配新的数组空间"><a href="#给-PendingIdleHandlers-分配新的数组空间" class="headerlink" title="给 PendingIdleHandlers 分配新的数组空间"></a>给 PendingIdleHandlers 分配新的数组空间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是在消息队列空闲时，检查是否需要运行空闲时处理。如果当前没有消息或者队列中的第一个消息的处理时间还未到来，并且之前的 <code>pendingIdleHandlerCount</code> 小于 0，那么它会获取当前注册的空闲时处理的数量，并将其赋值给 <code>pendingIdleHandlerCount</code>。这样，当队列为空或者第一个消息处理时间未到来时，代码会准备好运行已注册的空闲时处理。通常情况下，这个检查用于确保空闲时处理在适当的时机被调度执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    <span class="comment">// 没有要运行的空闲处理程序。继续循环并等待一段时间。</span></span><br><span class="line">    mBlocked = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是在消息队列空闲时，如果没有等待执行的空闲时处理，就将消息队列标记为被阻塞状态，并继续等待更多的消息或任务进入队列。这个逻辑用于优化资源管理，确保在没有即时任务需要处理时，程序仍然能够保持运行，以便在有任务时能够立即执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">    mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：隐含的条件是 pendingIdleHandlerCount &lt;&#x3D; 0 才能走到这里，所以判断条件其实是 pendingIdleHandlerCount &lt;&#x3D; 0 &amp;&amp; mPendingIdleHandlers &#x3D;&#x3D; null，通常表示这是第一次运行空闲时处理</p><p>如果 <code>mPendingIdleHandlers</code> 为 <code>null</code>，则进入条件判断。在这里，使用 <code>Math.max(pendingIdleHandlerCount, 4)</code> 来计算数组的长度，其中 <code>pendingIdleHandlerCount</code> 是等待执行的空闲时处理的数量。如果等待执行的处理数量小于 4，则数组长度取值为 4，否则取值为 <code>pendingIdleHandlerCount</code></p><h5 id="PendingIdleHandlers-赋值"><a href="#PendingIdleHandlers-赋值" class="headerlink" title="PendingIdleHandlers 赋值"></a>PendingIdleHandlers 赋值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br></pre></td></tr></table></figure><h5 id="运行空闲时处理-PendingIdleHandlers"><a href="#运行空闲时处理-PendingIdleHandlers" class="headerlink" title="运行空闲时处理 PendingIdleHandlers"></a>运行空闲时处理 PendingIdleHandlers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the idle handlers.</span></span><br><span class="line"><span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行空闲处理程序。</span></span><br><span class="line"><span class="comment"> * 我们只会在第一次迭代期间到达这个代码块。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">    mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里注释中的第一次迭代是指的消息队列第一次处理完所有已经在队列中的消息的那一次迭代，是想说明在后续的迭代中，如果消息队列仍然处于空闲状态，那么这段代码块不会再执行，因为它只在消息队列刚刚变为空闲时运行。</p><h4 id="队列的唤醒与阻塞"><a href="#队列的唤醒与阻塞" class="headerlink" title="队列的唤醒与阻塞"></a>队列的唤醒与阻塞</h4><h5 id="android-os-MessageQueue-enqueueMessage"><a href="#android-os-MessageQueue-enqueueMessage" class="headerlink" title="android.os.MessageQueue#enqueueMessage"></a>android.os.MessageQueue#enqueueMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>mBlocked</code> 在两个地方起到了不同的作用：</p><ol><li><p><strong>第一个 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needWake = mBlocked;</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 被赋值给变量 <code>needWake</code>。这个操作是为了判断是否需要唤醒事件队列（消息循环）。具体情况如下：</p><ul><li>如果 <code>mBlocked</code> 为 <code>true</code>，表示事件队列当前正处于阻塞状态，即没有立即需要处理的消息。在这种情况下，如果新消息的插入导致事件队列不再阻塞，就需要唤醒事件队列，以便消息循环继续执行。</li><li>如果 <code>mBlocked</code> 为 <code>false</code>，表示事件队列没有阻塞，新消息的插入不会改变这个状态，因此不需要唤醒。</li></ul></li><li><p><strong>第二个 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 参与了判断条件。这个条件用于判断是否需要唤醒事件队列，以提醒消息循环处理新消息。具体情况如下：</p><ul><li>如果 <code>mBlocked</code> 为 <code>true</code>，表示事件队列当前正处于阻塞状态。然后，进一步判断消息队列中是否有异步消息，并且插入的新消息也是异步消息，那么需要唤醒事件队列，以便消息循环能够立即处理这个异步消息。</li></ul></li></ol><p>综上所述，<code>mBlocked</code> 在这段代码中的两个地方都与判断是否需要唤醒事件队列有关。第一个地方是用来判断是否需要在新消息插入时唤醒事件队列，以便消息循环继续执行。第二个地方是在特定条件下，判断是否需要唤醒事件队列来处理异步消息。</p><h5 id="android-os-MessageQueue-next"><a href="#android-os-MessageQueue-next" class="headerlink" title="android.os.MessageQueue#next"></a>android.os.MessageQueue#next</h5><p>在提供的代码片段中，有三处不同的地方使用了 <code>mBlocked</code> 参数，并且它们在不同的上下文中起到了不同的作用。以下是每个位置的详细分析：</p><p><strong>第一处 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBlocked = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 被设置为 <code>false</code>，表示消息队列不再处于阻塞状态。这是在找到了一个准备好被处理的消息后执行的操作。通过将 <code>mBlocked</code> 设置为 <code>false</code>，消息循环可以继续处理消息，而不需要等待。</p><p><strong>第二处 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBlocked = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 被设置为 <code>true</code>，表示消息队列当前处于阻塞状态。这是在判断没有可处理的消息，并且没有要运行的空闲处理程序时执行的操作。通过将 <code>mBlocked</code> 设置为 <code>true</code>，消息循环进入了等待状态，等待新的消息或者空闲处理程序的到来。</p><p><strong>第三处 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBlocked = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这里的 <code>mBlocked</code> 也被设置为 <code>true</code>，与第二处的作用相同。这是在消息队列处理完所有的空闲处理程序之后，仍然没有要运行的空闲处理程序时执行的操作。通过将 <code>mBlocked</code> 设置为 <code>true</code>，消息循环会继续等待，直到有新的消息到达或者空闲处理程序需要运行。</p><p>总结来说，<code>mBlocked</code> 在这段代码中的三处不同的作用是：</p><ol><li>在找到一个准备好被处理的消息后，将其设置为 <code>false</code>，使得消息循环可以继续处理消息。</li><li>在没有可处理的消息且没有要运行的空闲处理程序时，将其设置为 <code>true</code>，使得消息循环进入等待状态。</li><li>在所有空闲处理程序都被处理后，仍然没有要运行的空闲处理程序时，将其设置为 <code>true</code>，继续等待。</li></ol><p>通过这样的设置，消息循环能够根据不同的情况来控制阻塞和等待状态，以便有效地处理消息和任务。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - Handler（一）</title>
      <link href="/2023/08/23/Android/Framework/01-Android-Framework-%E4%B8%93%E9%A1%B9-Handler1/"/>
      <url>/2023/08/23/Android/Framework/01-Android-Framework-%E4%B8%93%E9%A1%B9-Handler1/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure><p>Q：一个线程有几个 Handler？</p><p>Q: 线程间的通信的原理是怎样的？</p><p>Q: Handler 内存泄漏的原因？为什么其他的内部类没有说过这个问题？</p><p>Q: 为何主线程可以 new Handler ？如果想要在子线程中 new Handler 要做些什么准备？</p><p>Q: 子线程中维护的 Looper，消息队列无消息的时候的处理方案是什么？有什么用？</p><p>Q: 既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个 Handler 可能处于不同线程），那它内部时如何确保线程安全的？</p><p>Q: Looper 死循环为什么不会导致应用卡死</p><p>Q: 为什么主线程不需要自己创建和管理消息循环</p><h3 id="Handler-在-Android-中的应用"><a href="#Handler-在-Android-中的应用" class="headerlink" title="Handler 在 Android 中的应用"></a>Handler 在 Android 中的应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler 是针对 Android 系统中与 UI 线程通信而专门设计的多线程通信机制</span><br></pre></td></tr></table></figure><p>Retorfit，eventbus，rxjava，Looper</p><h3 id="Handler-源代码分析"><a href="#Handler-源代码分析" class="headerlink" title="Handler 源代码分析"></a>Handler 源代码分析</h3><h4 id="子线程-发送-MSG"><a href="#子线程-发送-MSG" class="headerlink" title="子线程 发送 MSG"></a>子线程 发送 MSG</h4><p>​android.os.Handler#sendMessage -&gt;<br>​android.os.Handler#sendMessageDelayed -&gt;<br>​android.os.Handler#sendMessageAtTime -&gt;<br>​android.os.Handler#enqueueMessage -&gt;<br>​android.os.MessageQueue#enqueueMessage -&gt;<br>​android.os.Looper#loop</p><h5 id="android-os-Handler-sendMessage"><a href="#android-os-Handler-sendMessage" class="headerlink" title="android.os.Handler#sendMessage"></a>android.os.Handler#sendMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes a message onto the end of the message queue after all pending messages</span></span><br><span class="line"><span class="comment">     * before the current time. It will be received in &#123;<span class="doctag">@link</span> #handleMessage&#125;,</span></span><br><span class="line"><span class="comment">     * in the thread attached to this handler.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment">     *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">     *         looper processing the message queue is exiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有挂起的消息之后将消息推送到消息队列的末尾</span></span><br><span class="line"><span class="comment">     * 当前时间之前。它将在 &#123;<span class="doctag">@link</span> #handleMessage&#125; 中收到，</span></span><br><span class="line"><span class="comment">     * 在附加到该处理程序的线程中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果消息成功放入则返回 true</span></span><br><span class="line"><span class="comment">     * 消息队列。失败时返回 false，通常是因为</span></span><br><span class="line"><span class="comment">     * 处理消息队列的 looper 正在退出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="android-os-Handler-sendMessageDelayed"><a href="#android-os-Handler-sendMessageDelayed" class="headerlink" title="android.os.Handler#sendMessageDelayed"></a>android.os.Handler#sendMessageDelayed</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before (current time + delayMillis). You will receive it in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached to this handler.</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一条消息放入消息队列中，位于所有挂起的消息之后</span></span><br><span class="line"><span class="comment"> * 之前（当前时间+delayMillis）。您将在以下时间收到它：</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #handleMessage&#125;，在附加到该处理程序的线程中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果消息成功放入则返回 true</span></span><br><span class="line"><span class="comment"> * 消息队列。失败时返回 false，通常是因为</span></span><br><span class="line"><span class="comment"> * 处理消息队列的 looper 正在退出。请注意，一个</span></span><br><span class="line"><span class="comment"> * true 的结果并不意味着该消息将被处理 -- 如果</span></span><br><span class="line"><span class="comment"> * Looper 在消息发送之前退出</span></span><br><span class="line"><span class="comment"> * 发生则消息将被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="android-os-Handler-sendMessageAtTime"><a href="#android-os-Handler-sendMessageAtTime" class="headerlink" title="android.os.Handler#sendMessageAtTime"></a>android.os.Handler#sendMessageAtTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * Time spent in deep sleep will add an additional delay to execution.</span></span><br><span class="line"><span class="comment"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment"> * to this handler.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment"> *         delivered, using the</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将消息排队到消息队列中，在绝对时间（以毫秒为单位）&lt;var&gt;uptimeMillis&lt;/var&gt;之后的所有挂起消息之后。</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;时间基准是 &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * 在深度睡眠期间花费的时间将会额外延迟执行。</span></span><br><span class="line"><span class="comment"> * 您将在&#123;<span class="doctag">@link</span> #handleMessage&#125;中接收它，该方法会在与此处理程序连接的线程中执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis 消息应该传递的绝对时间，使用&#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;作为时间基准。</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果消息成功放置到消息队列中，则返回 true 。如果失败，则返回 false ，通常是因为处理消息队列的消息循环正在退出。</span></span><br><span class="line"><span class="comment"> * 请注意，返回true并不意味着消息将被处理 - 如果消息传递时间之前消息循环被退出，则消息将被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><h5 id="android-os-Handler-enqueueMessage"><a href="#android-os-Handler-enqueueMessage" class="headerlink" title="android.os.Handler#enqueueMessage"></a>android.os.Handler#enqueueMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，发送流程都没什么好说的</p><h5 id="重点：android-os-Handler-handleMessage"><a href="#重点：android-os-Handler-handleMessage" class="headerlink" title="重点：android.os.Handler#handleMessage"></a>重点：android.os.Handler#handleMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="msg-target-是什么"><a href="#msg-target-是什么" class="headerlink" title="msg.target 是什么"></a>msg.target 是什么</h6><p>注意：<strong>这里 msg.target 就是 msg 持有的 handler 也是 为什么会有内存泄漏风险的原因。</strong></p><p>分析代码：</p><h6 id="Handler-内存泄漏原因"><a href="#Handler-内存泄漏原因" class="headerlink" title="Handler 内存泄漏原因"></a>Handler 内存泄漏原因</h6><p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。</p><p>它的主要作用是将消息按照时间顺序插入到消息队列中，并在必要时唤醒队列以处理这些消息。下面逐步分析代码的功能和逻辑。</p><ol><li><p>首先，代码对传入的消息 <code>msg</code> 进行一些验证。它确保消息有一个非空的目标（<code>msg.target != null</code>），否则抛出 <code>IllegalArgumentException</code>。</p></li><li><p>然后，代码在同步块内执行以下操作：</p><ul><li><p>检查消息是否已经在使用中，如果是，则抛出 <code>IllegalStateException</code>。这可能是为了防止重复使用消息，确保每个消息只被处理一次。</p></li><li><p>检查当前处理器是否正在退出（<code>mQuitting</code> 标志），如果是，就回收消息并返回 false，表示消息未被成功加入队列。</p></li><li><p>将消息标记为正在使用，并设置消息的触发时间 <code>msg.when</code> 为传入的 <code>when</code>。</p></li><li><p>获取消息队列的头部消息 <code>p</code>。</p></li></ul></li><li><p>接下来，代码根据以下条件进行处理：</p><ul><li><p>如果消息队列为空，或者传入的触发时间 <code>when</code> 为 0，或者传入的 <code>when</code> 小于队列头部消息的触发时间 <code>p.when</code>，则将新消息插入到队列头部。如果队列当前被阻塞（<code>mBlocked</code> 标志），则设置需要唤醒队列（<code>needWake = true</code>）。</p></li><li><p>否则，如果消息需要插入队列中间，则根据条件判断是否需要唤醒队列。具体判断条件是：队列被阻塞、队列头部消息的目标为 null，且传入的消息是异步消息。然后，代码在一个循环中遍历消息队列，找到合适的位置插入新消息。循环会一直迭代，直到找到合适的位置或者遍历完整个队列。</p></li><li><p>在找到合适的位置后，代码将新消息 <code>msg</code> 插入到队列中。具体做法是，将 <code>msg.next</code> 设置为当前消息 <code>p</code>，然后将前一个消息 <code>prev.next</code> 设置为新消息 <code>msg</code>。</p></li></ul></li><li><p>最后，代码根据之前的标志 <code>needWake</code> 来决定是否唤醒队列。如果需要唤醒，则调用本地的 <code>nativeWake</code> 方法（可能是一个底层的本地方法）来唤醒消息队列。</p></li><li><p>整个同步块结束后，代码返回 true，表示消息已经成功加入队列。</p></li></ol><p>这段代码的核心功能是在消息队列中插入消息并进行适当的排序，以确保消息按照触发时间顺序进行处理。同时，它还处理了一些异常情况，如消息已经在使用中或者处理器正在退出。唤醒队列的逻辑也在代码的最后部分进行处理。</p><p>让我们逐步分析 MSG 插入队列的位置：</p><h6 id="第一种插入头部的情况："><a href="#第一种插入头部的情况：" class="headerlink" title="第一种插入头部的情况："></a>第一种插入头部的情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">      <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">      needWake = mBlocked;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果消息队列为空，意味着<strong>当前没有任何消息在队列中等待处理</strong>。在这种情况下，不需要比较触发时间，<strong>直接将新消息插入到队列的头部</strong>。这会让新消息成为队列的第一个要处理的消息。</li><li>如果<strong>传入的触发时间 <code>when</code> 为 0</strong>，这可能表示<strong>该消息需要尽快处理</strong>，因此同样将它插入到队列的头部。</li><li>如果<strong>传入的触发时间</strong> <code>when</code> <strong>小于队列头部消息的触发时间</strong> <code>p.when</code>，这意味着新消息应该在队列中位于当前头部消息之前，因此<strong>同样将它插入到队列的头部</strong>。</li></ol><p>综合上述情况，无论是<strong>队列为空</strong>，还是<strong>传入的 <code>when</code> 值为 0</strong>，或者<strong>传入的 <code>when</code> 值小于队列头部消息的触发时间</strong>，都会<strong>将新消息插入到队列的头部</strong>。</p><h6 id="第二种插入中间的情况："><a href="#第二种插入中间的情况：" class="headerlink" title="第二种插入中间的情况："></a>第二种插入中间的情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">       <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">       <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">       needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">       Message prev;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                needWake = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">       prev.next = msg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li>首先，如果不满足前面提到的条件（消息队列为空，传入的触发时间为0，或传入的触发时间小于队列头部消息的触发时间），那么意味着要插入的新消息 <code>msg</code> 应该位于队列中间。</li><li>在这种情况下，代码会进入一个循环。这个循环的目的是遍历消息队列，以找到合适的位置将新消息 <code>msg</code> 插入队列中。</li><li>循环的条件是 <code>for (;;)</code>，这将创建一个无限循环，直到内部的某个条件满足而跳出循环。</li><li>在每次循环迭代中，代码会做以下事情：<ul><li>将当前消息 <code>p</code> 的引用赋值给 <code>prev</code>，这样可以记录下前一个消息。</li><li>将 <code>p</code> 移动到下一个消息（<code>p = p.next</code>）。</li></ul></li><li>然后，代码检查两个条件：<ul><li>如果当前消息 <code>p</code> 为空，意味着已经遍历了整个队列，或者队列只有一个消息且当前消息是最后一个消息。</li><li>如果传入的触发时间 <code>when</code> 小于队列中当前消息 <code>p</code> 的触发时间 <code>p.when</code>。</li></ul></li><li>如果满足以上任一条件，循环会被中断，这表示找到了合适的位置将新消息 <code>msg</code> 插入到消息队列中。</li><li>在循环的每个迭代中，代码还会检查以下条件：<ul><li>如果需要唤醒队列（<code>needWake = true</code>），并且当前消息 <code>p</code> 是异步消息（<code>p.isAsynchronous()</code> 返回 true），则将 <code>needWake</code> 设置为 false。这个步骤可能是为了控制是否需要在队列中插入异步消息时唤醒队列。</li></ul></li><li>一旦找到了合适的位置，代码会执行以下操作：<ul><li>将新消息 <code>msg</code> 的 <code>next</code> 指针指向当前消息 <code>p</code>，这相当于将新消息插入到当前消息 <code>p</code> 之前。</li><li>将前一个消息 <code>prev</code> 的 <code>next</code> 指针指向新消息 <code>msg</code>，以确保队列中消息的连接关系正确。</li></ul></li><li>循环结束后，新消息 <code>msg</code> 已经被插入到队列的合适位置，保持了消息队列的有序性。</li></ol><p>总之，这段代码的目的是在消息队列中将新消息插入到适当的位置，以保持消息的时间顺序。在找到合适位置时，会根据一些条件来决定是否需要唤醒队列，这可能与队列的处理机制相关。</p><p>此外，如果当前消息队列被阻塞（<code>mBlocked</code> 为 true），则将标志 <code>needWake</code> 设置为 true。这是为了确保在需要唤醒队列以处理消息的情况下，能够在适当的时候执行唤醒操作。唤醒队列的操作可能涉及到一些底层机制，具体如何唤醒可能需要查看更多上下文代码。</p><p>总的来说，这段代码逻辑的目的是在特定条件下将新消息插入到消息队列的头部，并根据当前队列的阻塞状态决定是否需要唤醒队列以确保消息能够被及时处理。</p><h4 id="主线程-取出-MSG"><a href="#主线程-取出-MSG" class="headerlink" title="主线程 取出 MSG"></a>主线程 取出 MSG</h4><p>​android.os.Looper#loop -&gt;<br>​android.os.MessageQueue#next -&gt;<br>​android.os.Handler#dispatchMessage -&gt;<br>​android.os.Handler#handleMessage</p><h6 id="主线程中的-Loop"><a href="#主线程中的-Loop" class="headerlink" title="主线程中的 Loop"></a>主线程中的 Loop</h6><p>我们来看主线程的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format &quot;seq=114&quot;</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 handler 相关的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">  ...</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br><span class="line">      </span><br><span class="line">    Looper.loop();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>准备</strong> Looper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure><p>android.os.Looper#prepareMainLooper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.os.Looper#prepare(boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备 Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.app.ActivityThread#getHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">public</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> mH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.app.ActivityThread#mH</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br></pre></td></tr></table></figure><p>开启循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure><h5 id="重点：android-os-Looper-loop"><a href="#重点：android-os-Looper-loop" class="headerlink" title="重点：android.os.Looper#loop"></a>重点：android.os.Looper#loop</h5><h6 id="loop"><a href="#loop" class="headerlink" title="#loop"></a>#loop</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是 Android 框架中 Looper 类的 <code>loop()</code> 方法的实现，负责在当前线程的消息循环中执行消息的分发和处理。</p><ol><li>首先，通过 <code>myLooper()</code> 获取当前线程的 Looper 实例 <code>me</code>，如果没有 Looper 实例则抛出异常，表示未调用 <code>Looper.prepare()</code> 来准备 Looper。</li><li>检查 <code>me.mInLoop</code>，如果当前线程已经在消息循环中，则打印警告日志。</li><li>将 <code>me.mInLoop</code> 标志设置为 <code>true</code>，表示当前线程正在消息循环中。</li><li>使用 <code>Binder.clearCallingIdentity()</code> 来清除当前线程的调用标识，然后再次调用它并将返回的标识 <code>ident</code> 保存下来。</li><li>获取一个可能的系统属性覆盖值 <code>thresholdOverride</code>，用于调整慢分发的阈值。</li><li>将 <code>me.mSlowDeliveryDetected</code> 设置为 <code>false</code>，用于标记是否检测到慢投递。</li><li>进入一个无限循环，不断地执行消息分发和处理。</li><li>在循环中，调用 <code>loopOnce(me, ident, thresholdOverride)</code> 来执行一次消息分发。如果返回值为 <code>false</code>，表示没有更多的消息需要分发，退出循环。</li></ol><p>总之，这段代码描述了 Android 中消息循环的核心逻辑。它会在一个无限循环中，不断地从消息队列中获取消息并执行消息分发和处理，直到没有更多的消息需要处理为止。在循环中，还会检查是否有慢分发阈值的系统属性覆盖，并根据需要清除调用标识。如果发现当前线程已经在消息循环中，则会打印警告信息。</p><h6 id="loopOnce"><a href="#loopOnce" class="headerlink" title="#loopOnce"></a>#loopOnce</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">        <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">        <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">            <span class="keyword">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                    me.mSlowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是 Android 框架中 Looper 类的一个方法 <code>loopOnce</code> 的实现，主要负责处理消息队列中的消息分发过程。我会逐步解释代码的功能。</p><ol><li><p>首先，通过 <code>me.mQueue.next()</code> 获取下一个消息，如果没有消息则表示消息队列正在退出，函数返回 <code>false</code>。</p></li><li><p>如果获取到了消息，则会根据是否设置了日志打印，打印消息的分发信息。</p></li><li><p>获取当前的观察者对象和跟踪标签。</p></li><li><p>根据阈值覆盖值，更新慢分发和慢投递的阈值。</p></li><li><p>判断是否需要记录开始时间和结束时间，如果需要，则记录当前时间作为分发开始时间。</p></li><li><p>如果设置了跟踪标签且跟踪标签是启用的，则开始跟踪。</p></li><li><p>设置开始分发时间，并获取一个 token 以用于观察者的消息分发起始回调。</p></li><li><p>设置当前线程的工作源为消息的工作源 UID。</p></li><li><p>使用目标 Handler（Handler 是消息处理的目标）来分发消息。</p></li><li><p>如果设置了观察者，通知观察者消息已分发。</p></li><li><p>结束分发，记录结束时间。</p></li><li><p>如果发生异常，通知观察者分发过程中出现异常，并将异常抛出。</p></li><li><p>最终，无论是否发生异常，都会恢复线程的工作源，并根据跟踪标签是否启用，结束跟踪。</p></li><li><p>如果设置了慢投递日志，会根据条件判断是否记录慢投递日志。</p></li><li><p>如果设置了慢分发日志，会根据条件记录慢分发日志。</p></li><li><p>如果设置了日志打印，会打印消息分发完成信息。</p></li><li><p>最后，检查分发过程中线程标识是否被更改，如果发生改变，会打印警告日志。</p></li><li><p>回收消息对象并返回 <code>true</code>，表示成功分发消息。</p></li></ol><p>总之，这段代码描述了 Android 中消息队列中消息的分发过程，涵盖了消息的跟踪、日志记录、观察者通知等多个方面，确保消息能够按照正确的顺序分发到目标处理程序。</p><h5 id="重点：android-os-MessageQueue-next"><a href="#重点：android-os-MessageQueue-next" class="headerlink" title="重点：android.os.MessageQueue#next"></a>重点：android.os.MessageQueue#next</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Android 消息循环（Message Loop）的一部分，它用于处理消息队列中的消息。消息循环是 Android 应用程序的核心部分，用于处理用户界面事件、线程间通信等。</p><p>以下是代码的主要功能和逻辑：</p><ol><li><p>代码开头使用了一个注解 <code>@UnsupportedAppUsage</code>，这是 Android 的一个标记注解，用于标识不推荐使用的 API 或方法。</p></li><li><p><code>next()</code> 方法是一个消息循环的主要函数。它会循环从消息队列中获取消息，然后处理这些消息。</p></li><li><p>首先，代码会获取 <code>mPtr</code>，这是一个表示消息队列的指针。如果 <code>ptr</code> 为 0，表示消息队列已经被释放，函数会返回 <code>null</code>。</p></li><li><p>接下来，进入一个无限循环 <code>for (;;) &#123;...&#125;</code>，在循环内部做以下操作：</p><ul><li><p>如果 <code>nextPollTimeoutMillis</code> 不为 0，会刷新待处理的 Binder 命令（一种 Android 进程间通信机制）。</p></li><li><p>调用 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>，它是一个本地方法，用于轮询获取下一个消息。</p></li><li><p>进入同步块，开始处理消息队列中的消息。</p></li><li><p>首先，获取当前时间 <code>now</code>，然后尝试获取下一个消息。如果消息的目标为 <code>null</code>，表示该消息是一个异步消息（可能由于障碍而被阻塞），会查找下一个异步消息。</p></li><li><p>如果找到消息并且消息的触发时间在当前时间之后，会设置一个定时器来在消息准备好时唤醒循环。</p></li><li><p>如果消息已经准备好（触发时间已到），会将消息从队列中移除，并返回该消息。</p></li><li><p>如果没有找到消息，会将 <code>nextPollTimeoutMillis</code> 设为 -1，表示没有更多消息。</p></li><li><p>如果 <code>mQuitting</code> 为 true，表示消息队列已经被停止，会调用 <code>dispose()</code> 释放资源，并返回 <code>null</code>。</p></li><li><p>如果是第一次空闲（没有消息待处理），会获取待运行的空闲处理器数量。</p></li><li><p>如果没有空闲处理器需要运行，会将 <code>mBlocked</code> 设为 true，继续等待。</p></li><li><p>如果有待运行的空闲处理器，会将它们放入 <code>mPendingIdleHandlers</code> 数组中。</p></li><li><p>执行空闲处理器的 <code>queueIdle()</code> 方法，该方法用于处理空闲状态。</p></li><li><p>如果 <code>queueIdle()</code> 返回 false，表示该空闲处理器不再需要运行，会将其从列表中移除。</p></li><li><p>重置空闲处理器数量为 0，以防止重复运行。</p></li><li><p>在处理完空闲处理器后，将 <code>nextPollTimeoutMillis</code> 设为 0，以便立即查找待处理的消息。</p></li></ul></li></ol><p>以上就是这段代码的主要逻辑。它负责不断地从消息队列中获取消息并处理，同时也处理了一些特殊情况，如消息队列已停止、空闲处理等。这种消息循环机制保证了 Android 应用程序的响应性和流畅性。</p><h6 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h6><p>给定代码中最重要的部分是主循环，该循环处理消息并运行空闲处理程序，在Android消息循环系统中负责处理消息并及时有效地运行空闲处理程序。让我们逐步分解关键组成部分及其重要性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 收到一条消息。</span></span><br><span class="line">                mBlocked = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 从队列中移除消息并返回。</span></span><br><span class="line">                <span class="comment">// 这是消息处理的核心操作。</span></span><br><span class="line">                <span class="comment">// 它允许根据其预定时间依次执行消息。</span></span><br><span class="line">                <span class="comment">// 返回的“msg”对象包含用于处理的数据和指令。</span></span><br><span class="line">                msg.markInUse();</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有更多消息。</span></span><br><span class="line">            nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理退出消息并处理空闲处理程序。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行空闲处理程序。</span></span><br><span class="line">        <span class="comment">// 该块遍历待处理的空闲处理程序并执行它们。</span></span><br><span class="line">        <span class="comment">// 空闲处理程序用于在消息队列为空时执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置空闲处理程序计数并检查是否有新消息。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分及其重要性如下：</p><ol><li><code>nativePollOnce(ptr, nextPollTimeoutMillis);</code>：这个本地方法用于轮询来自底层系统的传入消息和事件。它等待指定的超时时间以获取新的消息。</li><li>消息处理：<ul><li>循环检查是否有待处理的消息，并根据其预定时间（<code>msg.when</code>）对其进行处理。</li><li>如果一条消息准备好执行，它会从队列中移除并返回（<code>return msg;</code>）。</li><li>这是消息循环的核心，消息按照它们被发布的顺序逐个执行。</li><li><code>markInUse()</code> 方法表示消息正在被处理。</li></ul></li><li>退出消息和空闲处理程序：<ul><li>循环检查消息循环是否正在退出（<code>mQuitting</code>）并在需要时释放资源。</li><li>还会处理空闲处理程序，这些程序在没有待处理消息时执行。</li><li>空闲处理程序是在消息循环处于非活动状态时执行任务的函数。</li></ul></li></ol><p>总的来说，这段代码片段代表了Android消息循环的核心机制，它对于管理异步任务、UI交互和基于事件的编程在Android应用中至关重要。这个循环的正常运行对于维持响应迅速、交互式的用户体验至关重要。</p><h5 id="android-os-Handler-dispatchMessage"><a href="#android-os-Handler-dispatchMessage" class="headerlink" title="android.os.Handler#dispatchMessage"></a>android.os.Handler#dispatchMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Android 消息分发方法，用于处理系统消息。在 Android 中，消息分发是消息循环的一部分，用于将消息传递给相应的处理方法或回调函数。</p><p>以下是代码的主要功能和逻辑：</p><ol><li><p>方法名为 <code>dispatchMessage</code>，接受一个非空的 <code>Message</code> 对象作为参数，用于处理系统消息。</p></li><li><p>首先，代码检查 <code>msg</code> 中是否存在一个非空的回调函数 <code>callback</code>。如果存在，表示该消息具有一个回调函数，将调用 <code>handleCallback(msg)</code> 来处理该回调函数。</p></li><li><p>如果 <code>msg</code> 中没有回调函数，代码会进入下一步判断。</p></li><li><p>首先，检查是否存在一个非空的成员变量 <code>mCallback</code>，它是一个消息处理器的回调接口。如果存在 <code>mCallback</code>，代码会调用 <code>handleMessage(msg)</code> 来处理消息。如果 <code>mCallback.handleMessage(msg)</code> 返回 <code>true</code>，表示消息已经被处理，函数会直接返回，不会继续执行后续的 <code>handleMessage(msg)</code>。</p></li><li><p>如果 <code>mCallback.handleMessage(msg)</code> 返回 <code>false</code>，表示 <code>mCallback</code> 没有处理该消息，代码会调用当前类的 <code>handleMessage(msg)</code> 方法来处理消息。</p></li></ol><p>综合起来，这段代码实现了一个消息分发的逻辑，首先检查消息是否有回调函数，然后尝试使用回调函数处理消息。如果没有回调函数，它会检查是否存在一个全局的消息处理器 <code>mCallback</code>，尝试让它处理消息。如果都没有成功处理，最后会调用当前类的 <code>handleMessage(msg)</code> 方法来处理消息。</p><p>这种消息分发机制使得消息能够在不同的处理方法和回调函数之间进行传递和处理，提高了代码的灵活性和可扩展性。</p><h5 id="android-os-Handler-handleMessage"><a href="#android-os-Handler-handleMessage" class="headerlink" title="android.os.Handler#handleMessage"></a>android.os.Handler#handleMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个方法声明，用于在子类中实现消息处理的逻辑。在 Android 中，消息处理是一种常见的模式，用于处理来自消息队列的不同类型的消息。</p><p>以下是代码的主要功能和逻辑：</p><ol><li><p>方法名为 <code>handleMessage</code>，接受一个非空的 <code>Message</code> 对象作为参数，用于处理消息。</p></li><li><p>这是一个抽象方法，没有具体的实现，因此需要在子类中进行实现。</p></li><li><p>子类必须重写这个方法，并根据具体的业务逻辑来处理传递进来的消息。</p></li><li><p>通过在子类中实现不同的 <code>handleMessage</code> 方法，可以实现不同类型的消息处理，从而达到分离不同功能的目的。</p></li></ol><p>在 Android 应用程序开发中，常常会使用这种消息处理机制来进行异步任务的处理、UI 更新、线程间通信等。子类可以根据不同的需求，实现不同的消息处理逻辑，使代码结构更加清晰和模块化。</p><h5 id="使用-handler-通信机制由主线程向子线程发送消息"><a href="#使用-handler-通信机制由主线程向子线程发送消息" class="headerlink" title="使用 handler 通信机制由主线程向子线程发送消息"></a>使用 handler 通信机制由主线程向子线程发送消息</h5><p>我们已经了解了主线程中会创建 Looper 和 handler，也明白了期运行逻辑<br>下面我们在子线程中创建这一套通信机制，用于主线程向子线程发送消息</p><h6 id="创建一个-CustomLooperThread"><a href="#创建一个-CustomLooperThread" class="headerlink" title="创建一个 CustomLooperThread"></a>创建一个 CustomLooperThread</h6><p> 手动创建子线程的 <code>Looper</code> 和关联的 <code>Handler</code>，以便在子线程中处理消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomLooperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mLooper) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mHandler.post(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            mLooper.quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二: <strong>使用 <code>HandlerThread</code>：</strong> 使用 <code>HandlerThread</code> 类封装了子线程的 <code>Looper</code> 和关联的 <code>Handler</code> 创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLooperThread</span> <span class="keyword">extends</span> <span class="title class_">HandlerThread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomLooperThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在子线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageToThread</span><span class="params">(<span class="type">int</span> what)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> mHandler.obtainMessage(what);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建一个-MyThreadManager"><a href="#创建一个-MyThreadManager" class="headerlink" title="创建一个 MyThreadManager"></a>创建一个 MyThreadManager</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyThread mThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程并启动</span></span><br><span class="line">        mThread = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在线程的消息循环中创建 Handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到线程中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> mHandler.obtainMessage(what);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务在线程中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTaskInThread</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mThread.executeTask(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程和消息循环</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mThread.quit();</span><br><span class="line">            mThread = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h5><h6 id="方式一，自定义-Looper-和-Handler-创建的-CustomLooperThread-中的-getLooper-有没有问题？"><a href="#方式一，自定义-Looper-和-Handler-创建的-CustomLooperThread-中的-getLooper-有没有问题？" class="headerlink" title="方式一，自定义 Looper 和 Handler 创建的 CustomLooperThread 中的 getLooper 有没有问题？"></a>方式一，自定义 <code>Looper</code> 和 <code>Handler</code> 创建的 CustomLooperThread 中的 getLooper 有没有问题？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mThread.start();</span><br></pre></td></tr></table></figure><p>是在子线程中执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线程的消息循环中创建 Handler</span></span><br><span class="line">mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mThread.getLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 在线程中处理消息</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;thread.start()是在子线程中</span><br></pre></td></tr></table></figure><p>是在主线程执行的<br>也就是说在 mThread.getLooper() 时，有可能 mThread.start() 还没执行完<br>所以这里有<strong>多线程并发问题</strong></p><p>我们看一下 HandlerThread 中是怎么解决的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment"> * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment"> * has been started, this method will block until the looper has been initialized.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasInterrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                wasInterrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We may need to restore the thread&#x27;s interrupted flag, because it may</span></span><br><span class="line"><span class="comment">     * have been cleared above since we eat InterruptedExceptions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h6 id="Thread-中的-Handler-和-MyThreadManager-中-Handler-有什么不同"><a href="#Thread-中的-Handler-和-MyThreadManager-中-Handler-有什么不同" class="headerlink" title="Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同"></a>Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同</h6><ol><li><strong><code>MyThread</code> 类中的 <code>Handler</code>：</strong> 在 <code>MyThread</code> 类中的 <code>Handler</code> 用于处理子线程 <code>MyThread</code> 中的消息。它负责监听并处理从 <code>MyThread</code> 类的消息循环中传递过来的消息。这个 <code>Handler</code> 是在 <code>MyThread</code> 类的 <code>run()</code> 方法中创建并与 <code>Looper</code> 关联，以便在 <code>MyThread</code> 线程中处理消息。</li><li><strong><code>MyThreadManager</code> 类中的 <code>Handler</code>：</strong> 在 <code>MyThreadManager</code> 类中的 <code>Handler</code> 用于将消息发送到 <code>MyThread</code> 线程。它负责将来自主线程或其他地方的消息发送给 <code>MyThread</code> 线程的消息循环。这个 <code>Handler</code> 负责与 <code>MyThread</code> 线程进行通信，从而实现了在主线程或其他线程中触发 <code>MyThread</code> 线程执行特定任务。</li></ol><p>  这里我们提到了消息循环，我们下一章说 MessageQueue</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Game Project 核心 Renderer.cpp</title>
      <link href="/2023/08/23/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01-Android%20GameProject%20%E4%B8%AD%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%20Renderer/"/>
      <url>/2023/08/23/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01-Android%20GameProject%20%E4%B8%AD%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%20Renderer/</url>
      
        <content type="html"><![CDATA[<h3 id="Renderer-类图组成："><a href="#Renderer-类图组成：" class="headerlink" title="Renderer 类图组成："></a>Renderer 类图组成：</h3><ul><li><p><strong>类名</strong>：Renderer</p></li><li><p><strong>属性</strong></p><ul><li><strong>EGLDisplay display_</strong>: 用于OpenGL ES渲染的显示设备。它是一个与本地显示系统相关联的EGL显示连接。</li><li><strong>EGLSurface surface_</strong>: OpenGL ES渲染的表面。这是一个EGL表面，代表可以渲染OpenGL ES图形的绘图目标。</li><li><strong>EGLContext context_</strong>: OpenGL ES渲染的上下文。它是一个封装了OpenGL ES状态机的EGL渲染上下文。</li><li><strong>int width_</strong>: 渲染表面的宽度，以像素为单位。</li><li><strong>int height_</strong>: 渲染表面的高度，以像素为单位。</li><li><strong>bool shaderNeedsNewProjectionMatrix_</strong>: 一个标志，指示是否需要为着色器生成新的投影矩阵。当渲染表面的大小改变时，这个标志会被设置为<code>true</code>。</li><li><strong>std::unique_ptr<Shader> shader_</Shader></strong>: 指向当前使用的<code>Shader</code>对象的智能指针。<code>Shader</code>对象用于编译、链接和使用顶点和片段着色器。</li><li><strong>std::vector<Model> models_</Model></strong>: 包含所有要渲染的模型的容器。每个<code>Model</code>对象包含顶点数据、索引数据和纹理数据。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><strong>析构函数 <code>~Renderer()</code></strong>: 清理<code>Renderer</code>对象，包括释放EGL资源（如显示设备、渲染表面和上下文）。</li><li><strong>void render()</strong>: 执行渲染循环的一次迭代。这包括更新渲染状态、绘制模型和交换渲染表面的缓冲区。</li><li><strong>void initRenderer()</strong>: 初始化渲染器，包括设置EGL上下文、选择EGL配置、创建渲染表面和上下文、初始化OpenGL ES状态和加载着色器。</li><li><strong>void updateRenderArea()</strong>: 更新渲染区域的大小。如果渲染表面的大小发生变化，此方法更新<code>width_</code>和<code>height_</code>属性，并标记需要为着色器生成新的投影矩阵。</li><li><strong>void createModels()</strong>: 创建演示模型。这个方法加载模型的顶点、索引和纹理数据，然后将模型添加到<code>models_</code>容器中。</li><li><strong>void handleInput()</strong>: 处理输入事件，如触摸和按键。这个方法从Android的输入事件队列中读取事件，并根据需要响应这些事件。</li></ul></li><li><p><strong>关联和依赖关系</strong>：</p><ul><li>依赖于<code>Shader</code>类：由于<code>shader_</code>属性和在<code>initRenderer()</code>方法中对<code>Shader</code>的调用。</li><li>依赖于<code>Vertex</code>和<code>Index</code>类型：在<code>createModels()</code>方法中使用这些类型来创建模型。</li><li>依赖于<code>TextureAsset</code>类：在<code>createModels()</code>方法中加载纹理资源。</li><li>使用了标准库中的类型，如<code>std::vector</code>、<code>std::unique_ptr</code>。</li></ul></li></ul><p>这个类图还可以展示<code>Renderer</code>类如何与Android的本地应用粘合层（native_app_glue）和OpenGL ES 3.0交互，特别是如何处理EGL上下文、表面创建和渲染循环。</p><p>下面是一个简化的类图表示，重点在于<code>Renderer</code>类及其直接关系：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Renderer</span>] --|&gt; [EGLDisplay]</span><br><span class="line">[<span class="meta">Renderer</span>] --|&gt; [EGLSurface]</span><br><span class="line">[<span class="meta">Renderer</span>] --|&gt; [EGLContext]</span><br><span class="line">[<span class="meta">Renderer</span>] ---&gt; [Shader]</span><br><span class="line">[<span class="meta">Renderer</span>] --* [Model]</span><br><span class="line">[<span class="meta">Model</span>] --* [Vertex]</span><br><span class="line">[<span class="meta">Model</span>] --* [Index]</span><br><span class="line">[<span class="meta">Model</span>] ---&gt; [TextureAsset]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>--|&gt;</code> 表示拥有或创建关系。</li><li><code>---&gt;</code> 表示依赖关系。</li><li><code>--*</code> 表示包含或集合关系。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;game-activity/native_app_glue/android_native_app_glue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLES3/gl3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/imagedecoder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AndroidOut.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Utility.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TextureAsset.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义，执行glGetString并将结果输出到logcat</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_GL_STRING(s) &#123;aout &lt;&lt; #s<span class="string">&quot;: &quot;</span>&lt;&lt; glGetString(s) &lt;&lt; std::endl;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义，如果glGetString返回一个空格分隔的列表，则将每个元素打印在新行上</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief if glGetString returns a space separated list of elements, prints each one on a new line</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This works by creating an istringstream of the input c-style string. Then that is used to create</span></span><br><span class="line"><span class="comment"> * a vector -- each element of the vector is a new element in the input string. Finally a foreach</span></span><br><span class="line"><span class="comment"> * loop consumes this and outputs it to logcat using @a aout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_GL_STRING_AS_LIST(s) &#123; \</span></span><br><span class="line"><span class="meta">std::istringstream extensionStream((const char *) glGetString(s));\</span></span><br><span class="line"><span class="meta">std::vector<span class="string">&lt;std::string&gt;</span> extensionList(\</span></span><br><span class="line"><span class="meta">        std::istream_iterator<span class="string">&lt;std::string&gt;</span>&#123;extensionStream&#125;,\</span></span><br><span class="line"><span class="meta">        std::istream_iterator<span class="string">&lt;std::string&gt;</span>());\</span></span><br><span class="line"><span class="meta">aout &lt;&lt; #s<span class="string">&quot;:\n&quot;</span>;\</span></span><br><span class="line"><span class="meta">for (auto&amp; extension: extensionList) &#123;\</span></span><br><span class="line"><span class="meta">    aout &lt;&lt; extension &lt;&lt; <span class="string">&quot;\n&quot;</span>;\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">aout &lt;&lt; std::endl;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一种颜色，玉米花蓝色。可以直接发送给glClearColor函数。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORNFLOWER_BLUE 100 / 255.f, 149 / 255.f, 237 / 255.f, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器和片段着色器的代码，通常这些会从资源文件中加载</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *vertex = <span class="string">R&quot;vertex(#version 300 es</span></span><br><span class="line"><span class="string">in vec3 inPosition;</span></span><br><span class="line"><span class="string">in vec2 inUV;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec2 fragUV;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform mat4 uProjection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">    fragUV = inUV;</span></span><br><span class="line"><span class="string">    gl_Position = uProjection * vec4(inPosition, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)vertex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *fragment = <span class="string">R&quot;fragment(#version 300 es</span></span><br><span class="line"><span class="string">precision mediump float;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">in vec2 fragUV;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform sampler2D uTexture;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec4 outColor;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">    outColor = texture(uTexture, fragUV);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)fragment&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 投影矩阵的半高度，这将给你一个从-2到2的高度为4的可渲染区域</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> kProjectionHalfHeight = <span class="number">2.f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 投影矩阵的近平面距离。由于这是一个正交投影矩阵，负值便于排序（避免在0处的z-fighting）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> kProjectionNearPlane = <span class="number">-1.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 投影矩阵的远平面距离。与近平面等距的设置便于处理。</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * The far plane distance for the projection matrix. Since this is an orthographic porjection</span></span><br><span class="line"><span class="comment"> * matrix, it&#x27;s convenient to have the far plane equidistant from 0 as the near plane.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> kProjectionFarPlane = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Renderer析构函数，处理EGL上下文的清理工作。</span></span><br><span class="line">Renderer::~<span class="built_in">Renderer</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (display_ != EGL_NO_DISPLAY) &#123;</span><br><span class="line">        <span class="built_in">eglMakeCurrent</span>(display_, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</span><br><span class="line">        <span class="keyword">if</span> (context_ != EGL_NO_CONTEXT) &#123;</span><br><span class="line">            <span class="built_in">eglDestroyContext</span>(display_, context_);</span><br><span class="line">            context_ = EGL_NO_CONTEXT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (surface_ != EGL_NO_SURFACE) &#123;</span><br><span class="line">            <span class="built_in">eglDestroySurface</span>(display_, surface_);</span><br><span class="line">            surface_ = EGL_NO_SURFACE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">eglTerminate</span>(display_);</span><br><span class="line">        display_ = EGL_NO_DISPLAY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数，包括渲染过程中的各种状态更新和绘制调用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if the surface has changed size. This is _necessary_ to do every frame when</span></span><br><span class="line">    <span class="comment">// using immersive mode as you&#x27;ll get no other notification that your renderable area has</span></span><br><span class="line">    <span class="comment">// changed.</span></span><br><span class="line">    <span class="built_in">updateRenderArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the renderable area changes, the projection matrix has to also be updated. This is true</span></span><br><span class="line">    <span class="comment">// even if you change from the sample orthographic projection matrix as your aspect ratio has</span></span><br><span class="line">    <span class="comment">// likely changed.</span></span><br><span class="line">    <span class="keyword">if</span> (shaderNeedsNewProjectionMatrix_) &#123;</span><br><span class="line">        <span class="comment">// a placeholder projection matrix allocated on the stack. Column-major memory layout</span></span><br><span class="line">        <span class="type">float</span> projectionMatrix[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build an orthographic projection matrix for 2d rendering</span></span><br><span class="line">        Utility::<span class="built_in">buildOrthographicMatrix</span>(</span><br><span class="line">                projectionMatrix,</span><br><span class="line">                kProjectionHalfHeight,</span><br><span class="line">                <span class="built_in">float</span>(width_) / height_,</span><br><span class="line">                kProjectionNearPlane,</span><br><span class="line">                kProjectionFarPlane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send the matrix to the shader</span></span><br><span class="line">        <span class="comment">// Note: the shader must be active for this to work. Since we only have one shader for this</span></span><br><span class="line">        <span class="comment">// demo, we can assume that it&#x27;s active.</span></span><br><span class="line">        shader_-&gt;<span class="built_in">setProjectionMatrix</span>(projectionMatrix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make sure the matrix isn&#x27;t generated every frame</span></span><br><span class="line">        shaderNeedsNewProjectionMatrix_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the color buffer</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render all the models. There&#x27;s no depth testing in this sample so they&#x27;re accepted in the</span></span><br><span class="line">    <span class="comment">// order provided. But the sample EGL setup requests a 24 bit depth buffer so you could</span></span><br><span class="line">    <span class="comment">// configure it at the end of initRenderer</span></span><br><span class="line">    <span class="keyword">if</span> (!models_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;model: models_) &#123;</span><br><span class="line">            shader_-&gt;<span class="built_in">drawModel</span>(model);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Present the rendered image. This is an implicit glFlush.</span></span><br><span class="line">    <span class="keyword">auto</span> swapResult = <span class="built_in">eglSwapBuffers</span>(display_, surface_);</span><br><span class="line">    <span class="built_in">assert</span>(swapResult == EGL_TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器，设置EGL上下文和OpenGL状态。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::initRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Choose your render attributes</span></span><br><span class="line">    <span class="keyword">constexpr</span></span><br><span class="line">    EGLint attribs[] = &#123;</span><br><span class="line">            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,</span><br><span class="line">            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,</span><br><span class="line">            EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_DEPTH_SIZE, <span class="number">24</span>,</span><br><span class="line">            EGL_NONE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The default display is probably what you want on Android</span></span><br><span class="line">    <span class="keyword">auto</span> display = <span class="built_in">eglGetDisplay</span>(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="built_in">eglInitialize</span>(display, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out how many configs there are</span></span><br><span class="line">    EGLint numConfigs;</span><br><span class="line">    <span class="built_in">eglChooseConfig</span>(display, attribs, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;numConfigs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the list of configurations</span></span><br><span class="line">    std::unique_ptr &lt; EGLConfig[] &gt; <span class="built_in">supportedConfigs</span>(<span class="keyword">new</span> EGLConfig[numConfigs]);</span><br><span class="line">    <span class="built_in">eglChooseConfig</span>(display, attribs, supportedConfigs.<span class="built_in">get</span>(), numConfigs, &amp;numConfigs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a config we like.</span></span><br><span class="line">    <span class="comment">// Could likely just grab the first if we don&#x27;t care about anything else in the config.</span></span><br><span class="line">    <span class="comment">// Otherwise hook in your own heuristic</span></span><br><span class="line">    <span class="keyword">auto</span> config = *std::<span class="built_in">find_if</span>(</span><br><span class="line">            supportedConfigs.<span class="built_in">get</span>(),</span><br><span class="line">            supportedConfigs.<span class="built_in">get</span>() + numConfigs,</span><br><span class="line">            [&amp;display](<span class="type">const</span> EGLConfig &amp;config) &#123;</span><br><span class="line">                EGLint red, green, blue, depth;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_RED_SIZE, &amp;red)</span><br><span class="line">                    &amp;&amp; <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_GREEN_SIZE, &amp;green)</span><br><span class="line">                    &amp;&amp; <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_BLUE_SIZE, &amp;blue)</span><br><span class="line">                    &amp;&amp; <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_DEPTH_SIZE, &amp;depth)) &#123;</span><br><span class="line"></span><br><span class="line">                    aout &lt;&lt; <span class="string">&quot;Found config with &quot;</span> &lt;&lt; red &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; blue &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                         &lt;&lt; depth &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">return</span> red == <span class="number">8</span> &amp;&amp; green == <span class="number">8</span> &amp;&amp; blue == <span class="number">8</span> &amp;&amp; depth == <span class="number">24</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    aout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; numConfigs &lt;&lt; <span class="string">&quot; configs&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    aout &lt;&lt; <span class="string">&quot;Chose &quot;</span> &lt;&lt; config &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the proper window surface</span></span><br><span class="line">    EGLint format;</span><br><span class="line">    <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_NATIVE_VISUAL_ID, &amp;format);</span><br><span class="line">    EGLSurface surface = <span class="built_in">eglCreateWindowSurface</span>(display, config, app_-&gt;window, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a GLES 3 context</span></span><br><span class="line">    EGLint contextAttribs[] = &#123;EGL_CONTEXT_CLIENT_VERSION, <span class="number">3</span>, EGL_NONE&#125;;</span><br><span class="line">    EGLContext context = <span class="built_in">eglCreateContext</span>(display, config, <span class="literal">nullptr</span>, contextAttribs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get some window metrics</span></span><br><span class="line">    <span class="keyword">auto</span> madeCurrent = <span class="built_in">eglMakeCurrent</span>(display, surface, surface, context);</span><br><span class="line">    <span class="built_in">assert</span>(madeCurrent);</span><br><span class="line"></span><br><span class="line">    display_ = display;</span><br><span class="line">    surface_ = surface;</span><br><span class="line">    context_ = context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make width and height invalid so it gets updated the first frame in @a updateRenderArea()</span></span><br><span class="line">    width_ = <span class="number">-1</span>;</span><br><span class="line">    height_ = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PRINT_GL_STRING</span>(GL_VENDOR);</span><br><span class="line">    <span class="built_in">PRINT_GL_STRING</span>(GL_RENDERER);</span><br><span class="line">    <span class="built_in">PRINT_GL_STRING</span>(GL_VERSION);</span><br><span class="line">    <span class="built_in">PRINT_GL_STRING_AS_LIST</span>(GL_EXTENSIONS);</span><br><span class="line"></span><br><span class="line">    shader_ = std::<span class="built_in">unique_ptr</span>&lt;Shader&gt;(</span><br><span class="line">            Shader::<span class="built_in">loadShader</span>(vertex, fragment, <span class="string">&quot;inPosition&quot;</span>, <span class="string">&quot;inUV&quot;</span>, <span class="string">&quot;uProjection&quot;</span>));</span><br><span class="line">    <span class="built_in">assert</span>(shader_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: there&#x27;s only one shader in this demo, so I&#x27;ll activate it here. For a more complex game</span></span><br><span class="line">    <span class="comment">// you&#x27;ll want to track the active shader and activate/deactivate it as necessary</span></span><br><span class="line">    shader_-&gt;<span class="built_in">activate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup any other gl related global states</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(CORNFLOWER_BLUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enable alpha globally for now, you probably don&#x27;t want to do this in a game</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get some demo models into memory</span></span><br><span class="line">    <span class="built_in">createModels</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新渲染区域的大小，如果有变化，则更新视口和投影矩阵。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::updateRenderArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EGLint width;</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display_, surface_, EGL_WIDTH, &amp;width);</span><br><span class="line"></span><br><span class="line">    EGLint height;</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display_, surface_, EGL_HEIGHT, &amp;height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (width != width_ || height != height_) &#123;</span><br><span class="line">        width_ = width;</span><br><span class="line">        height_ = height;</span><br><span class="line">        <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make sure that we lazily recreate the projection matrix before we render</span></span><br><span class="line">        shaderNeedsNewProjectionMatrix_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建演示模型的函数。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Create any demo models we want for this demo.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::createModels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a square:</span></span><br><span class="line"><span class="comment">     * 0 --- 1</span></span><br><span class="line"><span class="comment">     * | \   |</span></span><br><span class="line"><span class="comment">     * |  \  |</span></span><br><span class="line"><span class="comment">     * |   \ |</span></span><br><span class="line"><span class="comment">     * 3 --- 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::vector &lt;Vertex&gt; vertices = &#123;</span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;), <span class="comment">// 0</span></span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">1</span>, <span class="number">0</span>&#125;), <span class="comment">// 1</span></span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">1</span>, <span class="number">1</span>&#125;), <span class="comment">// 2</span></span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">0</span>, <span class="number">1</span>&#125;) <span class="comment">// 3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector &lt;Index&gt; indices = &#123;</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loads an image and assigns it to the square.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note: there is no texture management in this sample, so if you reuse an image be careful not</span></span><br><span class="line">    <span class="comment">// to load it repeatedly. Since you get a shared_ptr you can safely reuse it in many models.</span></span><br><span class="line">    <span class="keyword">auto</span> assetManager = app_-&gt;activity-&gt;assetManager;</span><br><span class="line">    <span class="keyword">auto</span> spAndroidRobotTexture = TextureAsset::<span class="built_in">loadAsset</span>(assetManager, <span class="string">&quot;android_robot.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a model and put it in the back of the render list.</span></span><br><span class="line">    models_.<span class="built_in">emplace_back</span>(vertices, indices, spAndroidRobotTexture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理输入事件的函数，如触摸和按键事件。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::handleInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// handle all queued inputs</span></span><br><span class="line">    <span class="keyword">auto</span> *inputBuffer = <span class="built_in">android_app_swap_input_buffers</span>(app_);</span><br><span class="line">    <span class="keyword">if</span> (!inputBuffer) &#123;</span><br><span class="line">        <span class="comment">// no inputs yet.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle motion events (motionEventsCounts can be 0).</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; inputBuffer-&gt;motionEventsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;motionEvent = inputBuffer-&gt;motionEvents[i];</span><br><span class="line">        <span class="keyword">auto</span> action = motionEvent.action;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the pointer index, mask and bitshift to turn it into a readable value.</span></span><br><span class="line">        <span class="keyword">auto</span> pointerIndex = (action &amp; AMOTION_EVENT_ACTION_POINTER_INDEX_MASK)</span><br><span class="line">                &gt;&gt; AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;</span><br><span class="line">        aout &lt;&lt; <span class="string">&quot;Pointer(s): &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the x and y position of this event if it is not ACTION_MOVE.</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;pointer = motionEvent.pointers[pointerIndex];</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">GameActivityPointerAxes_getX</span>(&amp;pointer);</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">GameActivityPointerAxes_getY</span>(&amp;pointer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// determine the action type and process the event accordingly.</span></span><br><span class="line">        <span class="keyword">switch</span> (action &amp; AMOTION_EVENT_ACTION_MASK) &#123;</span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_DOWN:</span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_POINTER_DOWN:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pointer.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;) &quot;</span></span><br><span class="line">                     &lt;&lt; <span class="string">&quot;Pointer Down&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_CANCEL:</span><br><span class="line">                <span class="comment">// treat the CANCEL as an UP event: doing nothing in the app, except</span></span><br><span class="line">                <span class="comment">// removing the pointer from the cache if pointers are locally saved.</span></span><br><span class="line">                <span class="comment">// code pass through on purpose.</span></span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_POINTER_UP:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pointer.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;) &quot;</span></span><br><span class="line">                     &lt;&lt; <span class="string">&quot;Pointer Up&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_MOVE:</span><br><span class="line">                <span class="comment">// There is no pointer index for ACTION_MOVE, only a snapshot of</span></span><br><span class="line">                <span class="comment">// all active pointers; app needs to cache previous active pointers</span></span><br><span class="line">                <span class="comment">// to figure out which ones are actually moved.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> index = <span class="number">0</span>; index &lt; motionEvent.pointerCount; index++) &#123;</span><br><span class="line">                    pointer = motionEvent.pointers[index];</span><br><span class="line">                    x = <span class="built_in">GameActivityPointerAxes_getX</span>(&amp;pointer);</span><br><span class="line">                    y = <span class="built_in">GameActivityPointerAxes_getY</span>(&amp;pointer);</span><br><span class="line">                    aout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pointer.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (index != (motionEvent.pointerCount - <span class="number">1</span>)) aout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                    aout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Pointer Move&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Unknown MotionEvent Action: &quot;</span> &lt;&lt; action;</span><br><span class="line">        &#125;</span><br><span class="line">        aout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear the motion input count in this buffer for main thread to re-use.</span></span><br><span class="line">    <span class="built_in">android_app_clear_motion_events</span>(inputBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle input key events.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; inputBuffer-&gt;keyEventsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;keyEvent = inputBuffer-&gt;keyEvents[i];</span><br><span class="line">        aout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; keyEvent.keyCode &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (keyEvent.action) &#123;</span><br><span class="line">            <span class="keyword">case</span> AKEY_EVENT_ACTION_DOWN:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Key Down&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AKEY_EVENT_ACTION_UP:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Key Up&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AKEY_EVENT_ACTION_MULTIPLE:</span><br><span class="line">                <span class="comment">// Deprecated since Android API level 29.</span></span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Multiple Key Actions&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Unknown KeyEvent Action: &quot;</span> &lt;&lt; keyEvent.action;</span><br><span class="line">        &#125;</span><br><span class="line">        aout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear the key input count too.</span></span><br><span class="line">    <span class="built_in">android_app_clear_key_events</span>(inputBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 5 - 渲染引擎 </category>
          
          <category> 5.1 - 基础项目拆解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Game Project 项目结构</title>
      <link href="/2023/08/23/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/02-Android%20GameProject%20%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/08/23/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/02-Android%20GameProject%20%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>author: 朕小猫-GPT4</strong></p><p>图片显示的是一个典型的Android项目目录结构，这个项目中集成了C++原生代码。以下是各个组件的结构和作用的简述：</p><ul><li><code>src</code><ul><li><code>main</code><ul><li><code>assets</code><ul><li><code>android_robot.png</code> 一个图像资产，可能用于应用的用户界面或游戏图形。</li></ul></li><li><code>cpp</code><ul><li><code>AndroidOut.cpp</code> 和 <code>AndroidOut.h</code>：C++源文件和头文件，可能用于原生代码中的日志或输出目的。</li><li><code>CMakeLists.txt</code>：CMake配置文件，CMake是用于管理原生代码编译的构建系统。</li><li><code>main.cpp</code>：主要的C++源文件，可能包含原生代码执行的入口点。</li><li><code>Model.h</code>：很可能定义了一个数据模型或对象的头文件。</li><li><code>Renderer.cpp</code> 和 <code>Renderer.h</code>：渲染相关的源文件和头文件，或许处理屏幕上图形的绘制。</li><li><code>Shader.cpp</code> 和 <code>Shader.h</code>：与着色器程序相关的源文件和头文件，用于高级图形效果。</li><li><code>TextureAsset.cpp</code> 和 <code>TextureAsset.h</code>：处理原生代码中纹理资产的源文件和头文件。</li><li><code>Utility.cpp</code> 和 <code>Utility.h</code>：在原生代码库中使用的工具函数或类的源文件和头文件。</li></ul></li><li><code>java</code><ul><li><code>com.jason.game</code><ul><li><code>MainActivity</code></li></ul></li></ul></li><li><code>res</code>：<ul><li><code>AndroidManifest.xml</code></li></ul></li></ul></li></ul></li><li><code>.gitignore</code>：Git的配置文件，指定在版本控制中忽略哪些文件或目录。</li><li><code>build.gradle.kts</code>：用Kotlin脚本编写的Gradle构建系统的构建配置文件，指定依赖和构建设置。</li><li><code>proguard-rules.pro</code>：ProGuard的配置文件，ProGuard是一个用于代码缩减和混淆的工具，以防止应用发布构建的反向工程。</li></ul><p>这个结构表明这是一个复杂的Android项目，它使用Java&#x2F;Kotlin来实现Android特定功能，并使用C++来处理性能密集型任务，可能用于游戏开发或计算密集型应用。 </p>]]></content>
      
      
      <categories>
          
          <category> 5 - 渲染引擎 </category>
          
          <category> 5.1 - 基础项目拆解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染引擎开篇</title>
      <link href="/2023/08/21/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%BC%80%E7%AF%87/"/>
      <url>/2023/08/21/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="我亲爱的达瓦里氏，罗马不是一日建成的，但是终会有那一天"><a href="#我亲爱的达瓦里氏，罗马不是一日建成的，但是终会有那一天" class="headerlink" title="我亲爱的达瓦里氏，罗马不是一日建成的，但是终会有那一天"></a>我亲爱的达瓦里氏，罗马不是一日建成的，但是终会有那一天</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Bitmap 性能专题 - Bitmap 内存从申请到回收</title>
      <link href="/2023/08/15/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/"/>
      <url>/2023/08/15/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure><p>Q：Bitmap 如何开辟内存？</p><p>Q：Bitmap 内存是怎么复用和销毁的？本地资源图片应该怎么去做适配？</p><p>Q：该如何去优化这些占用较大内存的本地资源图片？</p><p>Q：如何判断和优化 Bitmap OOM，如何 dump 线上内存来做优化分析？</p><h3 id="从-Bitmap-的创建说起"><a href="#从-Bitmap-的创建说起" class="headerlink" title="从 Bitmap 的创建说起"></a>从 Bitmap 的创建说起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private constructor that must received an already allocated native bitmap</span></span><br><span class="line"><span class="comment"> * int (pointer).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">        <span class="type">boolean</span> isMutable, <span class="type">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="type">byte</span>[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;internal error: native bitmap is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mIsMutable = isMutable;</span><br><span class="line">    mRequestPremultiplied = requestPremultiplied;</span><br><span class="line"></span><br><span class="line">    mNinePatchChunk = ninePatchChunk;</span><br><span class="line">    mNinePatchInsets = ninePatchInsets;</span><br><span class="line">    <span class="keyword">if</span> (density &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mDensity = density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line">    <span class="type">NativeAllocationRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(</span><br><span class="line">        Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ResourcesImpl.TRACE_FOR_DETAILED_PRELOAD) &#123;</span><br><span class="line">        sPreloadTracingNumInstantiatedBitmaps++;</span><br><span class="line">        sPreloadTracingTotalBitmapsSize += nativeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>called from JNI 这个解释其实已经很明确了，也就是说这个对象是 Native 层构建返回的。因此我们跟踪到 BitmapFactory.decodeResource() 中去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">decodeResource</span><span class="params">(Resources res, <span class="type">int</span> id, Options opts)</span> &#123;</span><br><span class="line">    validate(opts);</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypedValue</span>();</span><br><span class="line">        is = res.openRawResource(id, value);</span><br><span class="line"></span><br><span class="line">        bm = decodeResourceStream(res, value, is, <span class="literal">null</span>, opts);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">/*  do nothing.</span></span><br><span class="line"><span class="comment">            If the exception happened on open, bm will be null.</span></span><br><span class="line"><span class="comment">            If it happened on close, bm is still valid.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bm == <span class="literal">null</span> &amp;&amp; opts != <span class="literal">null</span> &amp;&amp; opts.inBitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Problem decoding into existing bitmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">decodeResourceStream</span><span class="params">(<span class="meta">@Nullable</span> Resources res, <span class="meta">@Nullable</span> TypedValue value,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> InputStream is, <span class="meta">@Nullable</span> Rect pad, <span class="meta">@Nullable</span> Options opts)</span> &#123;</span><br><span class="line">    validate(opts);</span><br><span class="line">    <span class="keyword">if</span> (opts == <span class="literal">null</span>) &#123;</span><br><span class="line">        opts = <span class="keyword">new</span> <span class="title class_">Options</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">density</span> <span class="operator">=</span> value.density;</span><br><span class="line">        <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">            opts.inDensity = density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前手机设备的 dpi </span></span><br><span class="line">    <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="literal">null</span>) &#123;</span><br><span class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略部分跟踪代码 ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title function_">nativeDecodeStream</span><span class="params">(InputStream is, <span class="type">byte</span>[] storage,</span></span><br><span class="line"><span class="params">        Rect padding, Options opts)</span>;</span><br></pre></td></tr></table></figure><p>最终调用的是 native 方法 nativeDecodeStream</p><p>这里以 Android N 版本为例:</p><p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;BitmapFactory.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">nativeDecodeStream</span><span class="params">(JNIEnv *env, jobject clazz, jobject is, jbyteArray storage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line">    jobject bitmap = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SkStream&gt; <span class="title">stream</span><span class="params">(CreateJavaInputStreamAdaptor(env, is, storage))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;SkStreamRewindable&gt; <span class="title">bufferedStream</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                SkFrontBufferedStream::Create(stream.release(), SkCodec::MinBufferedBytesNeeded()))</span></span>;</span><br><span class="line">        <span class="built_in">SkASSERT</span>(bufferedStream.<span class="built_in">get</span>() != <span class="literal">NULL</span>);</span><br><span class="line">        bitmap = <span class="built_in">doDecode</span>(env, bufferedStream.<span class="built_in">release</span>(), padding, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv *env, SkStreamRewindable *stream, jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function takes ownership of the input stream.  Since the SkAndroidCodec</span></span><br><span class="line">    <span class="comment">// will take ownership of the stream, we don&#x27;t necessarily need to take ownership</span></span><br><span class="line">    <span class="comment">// here.  This is a precaution - if we were to return before creating the codec,</span></span><br><span class="line">    <span class="comment">// we need to make sure that we delete the stream.</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;SkStreamRewindable&gt; <span class="title">streamDeleter</span><span class="params">(stream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set default values for the options parameters.</span></span><br><span class="line">    <span class="type">int</span> sampleSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否只是获取图片的大小</span></span><br><span class="line">    <span class="type">bool</span> onlyDecodeSize = <span class="literal">false</span>;</span><br><span class="line">    SkColorType prefColorType = kN32_SkColorType;</span><br><span class="line">    <span class="type">bool</span> isMutable = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> scale = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">bool</span> requireUnpremultiplied = <span class="literal">false</span>;</span><br><span class="line">    jobject javaBitmap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update with options supplied by the client.</span></span><br><span class="line">    <span class="comment">// 解析 options 参数</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sampleSize = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_sampleSizeFieldID);</span><br><span class="line">        <span class="comment">// Correct a non-positive sampleSize.  sampleSize defaults to zero within the</span></span><br><span class="line">        <span class="comment">// options object, which is strange.</span></span><br><span class="line">        <span class="keyword">if</span> (sampleSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sampleSize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_justBoundsFieldID)) &#123;</span><br><span class="line">            onlyDecodeSize = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize these, in case we fail later on</span></span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_widthFieldID, <span class="number">-1</span>);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_heightFieldID, <span class="number">-1</span>);</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectField</span>(options, gOptions_mimeFieldID, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 解析 ColorType ，复用参数等等</span></span><br><span class="line">        jobject jconfig = env-&gt;<span class="built_in">GetObjectField</span>(options, gOptions_configFieldID);</span><br><span class="line">        prefColorType = GraphicsJNI::<span class="built_in">getNativeBitmapColorType</span>(env, jconfig);</span><br><span class="line">        isMutable = env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_mutableFieldID);</span><br><span class="line">        requireUnpremultiplied = !env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_premultipliedFieldID);</span><br><span class="line">        javaBitmap = env-&gt;<span class="built_in">GetObjectField</span>(options, gOptions_bitmapFieldID);</span><br><span class="line">        <span class="comment">// 计算缩放的比例</span></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">            <span class="comment">// 获取图片当前 xhdpi 的 density</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> density = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_densityFieldID);</span><br><span class="line">            <span class="comment">// 获取当前设备的 dpi</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> targetDensity = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_targetDensityFieldID);</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> screenDensity = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_screenDensityFieldID);</span><br><span class="line">            <span class="keyword">if</span> (density != <span class="number">0</span> &amp;&amp; targetDensity != <span class="number">0</span> &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">                <span class="comment">// scale = 当前设备的 dpi / xhdpi 的 density</span></span><br><span class="line">                <span class="comment">// scale = 420/320 = 1.3125</span></span><br><span class="line">                scale = (<span class="type">float</span>) targetDensity / density;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the codec.</span></span><br><span class="line">    NinePatchPeeker peeker;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SkAndroidCodec&gt; <span class="title">codec</span><span class="params">(SkAndroidCodec::NewFromStream(streamDeleter.release(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                        <span class="number">280</span> &amp; peeker))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!codec.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;SkAndroidCodec::NewFromStream returned null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not allow ninepatch decodes to 565.  In the past, decodes to 565</span></span><br><span class="line">    <span class="comment">// would dither, and we do not want to pre-dither ninepatches, since we</span></span><br><span class="line">    <span class="comment">// know that they will be stretched.  We no longer dither 565 decodes,</span></span><br><span class="line">    <span class="comment">// but we continue to prevent ninepatches from decoding to 565, in order</span></span><br><span class="line">    <span class="comment">// to maintain the old behavior.</span></span><br><span class="line">    <span class="keyword">if</span> (peeker.mPatch &amp;&amp; kRGB_565_SkColorType == prefColorType) &#123;</span><br><span class="line">        prefColorType = kN32_SkColorType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前图片的大小</span></span><br><span class="line">    <span class="comment">// Determine the output size.</span></span><br><span class="line">    SkISize size = codec-&gt;<span class="built_in">getSampledDimensions</span>(sampleSize);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> scaledWidth = size.<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">int</span> scaledHeight = size.<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">bool</span> willScale = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 处理 simpleSize 压缩，我们这里没穿，上面默认是 1 </span></span><br><span class="line">    <span class="comment">// Apply a fine scaling step if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">needsFineScale</span>(codec-&gt;<span class="built_in">getInfo</span>().<span class="built_in">dimensions</span>(), size, sampleSize)) &#123;</span><br><span class="line">        willScale = <span class="literal">true</span>;</span><br><span class="line">        scaledWidth = codec-&gt;<span class="built_in">getInfo</span>().<span class="built_in">width</span>() / sampleSize;</span><br><span class="line">        scaledHeight = codec-&gt;<span class="built_in">getInfo</span>().<span class="built_in">height</span>() / sampleSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the options and return if the client only wants the size.</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jstring mimeType = <span class="built_in">encodedFormatToString</span>(env, codec-&gt;<span class="built_in">getEncodedFormat</span>());</span><br><span class="line">        <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;OOM in encodedFormatToString()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 options 对象中的 outWidth 和 outHeight</span></span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_widthFieldID, scaledWidth);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_heightFieldID, scaledHeight);</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectField</span>(options, gOptions_mimeFieldID, mimeType);</span><br><span class="line">        <span class="comment">// 如果只是获取大小直接 return null 这里是 nullptr 而不是 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (onlyDecodeSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale is necessary due to density differences.</span></span><br><span class="line">    <span class="keyword">if</span> (scale != <span class="number">1.0f</span>) &#123;</span><br><span class="line">        willScale = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 计算 scaledWidth 和 scaledHeight</span></span><br><span class="line">        <span class="comment">// scaledWidth = 864 * 1.3125 + 0.5f = 1134 + 0.5f = 1134</span></span><br><span class="line">        scaledWidth = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(scaledWidth * scale + <span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">// scaledHeight = 582 * 1.3125 + 0.5f = 763.875 + 0.5f = 764</span></span><br><span class="line">        scaledHeight = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(scaledHeight * scale + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有复用的 Bitmap</span></span><br><span class="line">    android::Bitmap *reuseBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> existingBufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reuseBitmap = GraphicsJNI::<span class="built_in">getBitmap</span>(env, javaBitmap);</span><br><span class="line">        <span class="keyword">if</span> (reuseBitmap-&gt;<span class="built_in">peekAtPixelRef</span>()-&gt;<span class="built_in">isImmutable</span>()) &#123;</span><br><span class="line">            <span class="comment">// 无法重用一个不变的位图图像解码器的目标。</span></span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Unable to reuse an immutable bitmap as an image decoder target.&quot;</span>);</span><br><span class="line">            javaBitmap = <span class="literal">NULL</span>;</span><br><span class="line">            reuseBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            existingBufferSize = GraphicsJNI::<span class="built_in">getBitmapAllocationByteCount</span>(env, javaBitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">JavaPixelAllocator <span class="title">javaAllocator</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="function">RecyclingPixelAllocator <span class="title">recyclingAllocator</span><span class="params">(reuseBitmap, existingBufferSize)</span></span>;</span><br><span class="line">    <span class="function">ScaleCheckingAllocator <span class="title">scaleCheckingAllocator</span><span class="params">(scale, existingBufferSize)</span></span>;</span><br><span class="line">    SkBitmap::HeapAllocator heapAllocator;</span><br><span class="line">    SkBitmap::Allocator *decodeAllocator;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span> &amp;&amp; willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.  This allocator</span></span><br><span class="line">        <span class="comment">// also checks that the recycled javaBitmap is large enough.</span></span><br><span class="line">        decodeAllocator = &amp;scaleCheckingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        decodeAllocator = &amp;recyclingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.</span></span><br><span class="line">        decodeAllocator = &amp;heapAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeAllocator = &amp;javaAllocator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the decode colorType.  This is necessary because we can&#x27;t always support</span></span><br><span class="line">    <span class="comment">// the requested colorType.</span></span><br><span class="line">    SkColorType decodeColorType = codec-&gt;<span class="built_in">computeOutputColorType</span>(prefColorType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a color table for the decode if necessary</span></span><br><span class="line">    SkAutoTUnref &lt;SkColorTable&gt; <span class="built_in">colorTable</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    SkPMColor *colorPtr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> *colorCount = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> maxColors = <span class="number">256</span>;</span><br><span class="line">    SkPMColor colors[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">if</span> (kIndex_8_SkColorType == decodeColorType) &#123;</span><br><span class="line">        colorTable.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SkColorTable</span>(colors, maxColors));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SkColorTable expects us to initialize all of the colors before creating an</span></span><br><span class="line">        <span class="comment">// SkColorTable.  However, we are using SkBitmap with an Allocator to allocate</span></span><br><span class="line">        <span class="comment">// memory for the decode, so we need to create the SkColorTable before decoding.</span></span><br><span class="line">        <span class="comment">// It is safe for SkAndroidCodec to modify the colors because this SkBitmap is</span></span><br><span class="line">        <span class="comment">// not being used elsewhere.</span></span><br><span class="line">        colorPtr = <span class="built_in">const_cast</span>&lt;SkPMColor *&gt;(colorTable-&gt;<span class="built_in">readColors</span>());</span><br><span class="line">        colorCount = &amp;maxColors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the alpha type for the decode.</span></span><br><span class="line">    SkAlphaType alphaType = codec-&gt;<span class="built_in">computeOutputAlphaType</span>(requireUnpremultiplied);</span><br><span class="line">    <span class="comment">// 创建 SkImageInfo 信息，宽，高，ColorType，alphaType</span></span><br><span class="line">    <span class="type">const</span> SkImageInfo decodeInfo = SkImageInfo::<span class="built_in">Make</span>(size.<span class="built_in">width</span>(), size.<span class="built_in">height</span>(), decodeColorType,</span><br><span class="line">                                                     alphaType);</span><br><span class="line">    SkImageInfo bitmapInfo = decodeInfo;</span><br><span class="line">    <span class="keyword">if</span> (decodeColorType == kGray_8_SkColorType) &#123;</span><br><span class="line">        <span class="comment">// The legacy implementation of BitmapFactory used kAlpha8 for</span></span><br><span class="line">        <span class="comment">// grayscale images (before kGray8 existed).  While the codec</span></span><br><span class="line">        <span class="comment">// recognizes kGray8, we need to decode into a kAlpha8 bitmap</span></span><br><span class="line">        <span class="comment">// in order to avoid a behavior change.</span></span><br><span class="line">        bitmapInfo = SkImageInfo::<span class="built_in">MakeA8</span>(size.<span class="built_in">width</span>(), size.<span class="built_in">height</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析 SkBitmap 设置 bitmapInfo，tryAllocPixels 开辟内存，具体分析在后面 </span></span><br><span class="line">    SkBitmap decodingBitmap;</span><br><span class="line">    <span class="keyword">if</span> (!decodingBitmap.<span class="built_in">setInfo</span>(bitmapInfo) ||</span><br><span class="line">        !decodingBitmap.<span class="built_in">tryAllocPixels</span>(decodeAllocator, colorTable)) &#123;</span><br><span class="line">        <span class="comment">// SkAndroidCodec should recommend a valid SkImageInfo, so setInfo()</span></span><br><span class="line">        <span class="comment">// should only only fail if the calculated value for rowBytes is too</span></span><br><span class="line">        <span class="comment">// large.</span></span><br><span class="line">        <span class="comment">// tryAllocPixels() can fail due to OOM on the Java heap, OOM on the</span></span><br><span class="line">        <span class="comment">// native heap, or the recycled javaBitmap being too small to reuse.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SkAndroidCodec to perform the decode.</span></span><br><span class="line">    SkAndroidCodec::AndroidOptions codecOptions;</span><br><span class="line">    codecOptions.fZeroInitialized = (decodeAllocator == &amp;javaAllocator) ?</span><br><span class="line">    SkCodec::kYes_ZeroInitialized : SkCodec::kNo_ZeroInitialized;</span><br><span class="line">    codecOptions.fColorPtr = colorPtr;</span><br><span class="line">    codecOptions.fColorCount = colorCount;</span><br><span class="line">    codecOptions.fSampleSize = sampleSize;</span><br><span class="line">    <span class="comment">// 解析获取像素值</span></span><br><span class="line">    SkCodec::Result result = codec-&gt;<span class="built_in">getAndroidPixels</span>(decodeInfo, decodingBitmap.<span class="built_in">getPixels</span>(),</span><br><span class="line">                                                     decodingBitmap.<span class="built_in">rowBytes</span>(), &amp;codecOptions);</span><br><span class="line">    <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">        <span class="keyword">case</span> SkCodec::kSuccess:</span><br><span class="line">        <span class="keyword">case</span> SkCodec::kIncompleteInput:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;codec-&gt;getAndroidPixels() failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jbyteArray ninePatchChunk = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (peeker.mPatch != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">            <span class="built_in">scaleNinePatchChunk</span>(peeker.mPatch, scale, scaledWidth, scaledHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> ninePatchArraySize = peeker.mPatch-&gt;<span class="built_in">serializedSize</span>();</span><br><span class="line">        ninePatchChunk = env-&gt;<span class="built_in">NewByteArray</span>(ninePatchArraySize);</span><br><span class="line">        <span class="keyword">if</span> (ninePatchChunk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;ninePatchChunk == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jbyte *array = (jbyte *) env-&gt;<span class="built_in">GetPrimitiveArrayCritical</span>(ninePatchChunk, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;primitive array == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(array, peeker.mPatch, peeker.mPatchSize);</span><br><span class="line">        env-&gt;<span class="built_in">ReleasePrimitiveArrayCritical</span>(ninePatchChunk, array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject ninePatchInsets = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (peeker.mHasInsets) &#123;</span><br><span class="line">        ninePatchInsets = env-&gt;<span class="built_in">NewObject</span>(gInsetStruct_class, gInsetStruct_constructorMethodID,</span><br><span class="line">        peeker.mOpticalInsets[<span class="number">0</span>], peeker.mOpticalInsets[<span class="number">1</span>], peeker.mOpticalInsets[<span class="number">2</span>], peeker.mOpticalInsets[<span class="number">3</span>],</span><br><span class="line">                peeker.mOutlineInsets[<span class="number">0</span>], peeker.mOutlineInsets[<span class="number">1</span>], peeker.mOutlineInsets[<span class="number">2</span>], peeker.mOutlineInsets[<span class="number">3</span>],</span><br><span class="line">                peeker.mOutlineRadius, peeker.mOutlineAlpha, scale);</span><br><span class="line">        <span class="keyword">if</span> (ninePatchInsets == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;nine patch insets == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (javaBitmap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            env-&gt;<span class="built_in">SetObjectField</span>(javaBitmap, gBitmap_ninePatchInsetsFieldID, ninePatchInsets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 SkBitmap 这个才是最终的</span></span><br><span class="line">    SkBitmap outputBitmap;</span><br><span class="line">    <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// 如果需要缩放，那需要重新创建一张图片，上面加载的是图片的本身大小</span></span><br><span class="line">        <span class="comment">// This is weird so let me explain: we could use the scale parameter</span></span><br><span class="line">        <span class="comment">// directly, but for historical reasons this is how the corresponding</span></span><br><span class="line">        <span class="comment">// Dalvik code has always behaved. We simply recreate the behavior here.</span></span><br><span class="line">        <span class="comment">// The result is slightly different from simply using scale because of</span></span><br><span class="line">        <span class="comment">// the 0.5f rounding bias applied when computing the target image size</span></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> sx = scaledWidth / <span class="built_in">float</span>(decodingBitmap.<span class="built_in">width</span>());</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> sy = scaledHeight / <span class="built_in">float</span>(decodingBitmap.<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the allocator for the outputBitmap.</span></span><br><span class="line">        SkBitmap::Allocator *outputAllocator;</span><br><span class="line">        <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            outputAllocator = &amp;recyclingAllocator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputAllocator = &amp;javaAllocator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkColorType scaledColorType = <span class="built_in">colorTypeForScaledOutput</span>(decodingBitmap.<span class="built_in">colorType</span>());</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">        <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">        <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">        <span class="comment">// 设置 SkImageInfo ，注意这里是 scaledWidth ，scaledHeight </span></span><br><span class="line">        outputBitmap.<span class="built_in">setInfo</span>(SkImageInfo::<span class="built_in">Make</span>(scaledWidth, scaledHeight,</span><br><span class="line">        scaledColorType, decodingBitmap.<span class="built_in">alphaType</span>()));</span><br><span class="line">        <span class="comment">// 开辟当前 Bitmap 图片的内存</span></span><br><span class="line">        <span class="keyword">if</span> (!outputBitmap.<span class="built_in">tryAllocPixels</span>(outputAllocator, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// This should only fail on OOM.  The recyclingAllocator should have</span></span><br><span class="line">            <span class="comment">// enough memory since we check this before decoding using the</span></span><br><span class="line">            <span class="comment">// scaleCheckingAllocator.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;allocation failed for scaled bitmap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkPaint paint;</span><br><span class="line">        <span class="comment">// kSrc_Mode instructs us to overwrite the unininitialized pixels in</span></span><br><span class="line">        <span class="comment">// outputBitmap.  Otherwise we would blend by default, which is not</span></span><br><span class="line">        <span class="comment">// what we want.</span></span><br><span class="line">        paint.<span class="built_in">setXfermodeMode</span>(SkXfermode::kSrc_Mode);</span><br><span class="line">        paint.<span class="built_in">setFilterQuality</span>(kLow_SkFilterQuality);</span><br><span class="line">        <span class="comment">// decodingBitmap -&gt; 画到 outputBitmap</span></span><br><span class="line">        <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(outputBitmap)</span></span>;</span><br><span class="line">        canvas.<span class="built_in">scale</span>(sx, sy);</span><br><span class="line">        canvas.<span class="built_in">drawBitmap</span>(decodingBitmap, <span class="number">0.0f</span>, <span class="number">0.0f</span>, &amp;paint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outputBitmap.<span class="built_in">swap</span>(decodingBitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peeker.mPatch != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            GraphicsJNI::<span class="built_in">set_jrect</span>(env, padding,</span><br><span class="line">            peeker.mPatch-&gt;paddingLeft, peeker.mPatch-&gt;paddingTop,</span><br><span class="line">            peeker.mPatch-&gt;paddingRight, peeker.mPatch-&gt;paddingBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GraphicsJNI::<span class="built_in">set_jrect</span>(env, padding, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we get here, the outputBitmap should have an installed pixelref.</span></span><br><span class="line">    <span class="keyword">if</span> (outputBitmap.<span class="built_in">pixelRef</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;Got null SkPixelRef&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isMutable &amp;&amp; javaBitmap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// promise we will never change our pixels (great for sharing and pictures)</span></span><br><span class="line">        outputBitmap.<span class="built_in">setImmutable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有复用返回原来的 javaBitmap</span></span><br><span class="line">    <span class="type">bool</span> isPremultiplied = !requireUnpremultiplied;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        GraphicsJNI::<span class="built_in">reinitBitmap</span>(env, javaBitmap, outputBitmap.<span class="built_in">info</span>(), isPremultiplied);</span><br><span class="line">        outputBitmap.<span class="built_in">notifyPixelsChanged</span>();</span><br><span class="line">        <span class="comment">// If a java bitmap was passed in for reuse, pass it back</span></span><br><span class="line">        <span class="keyword">return</span> javaBitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bitmapCreateFlags = <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isMutable) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Mutable;</span><br><span class="line">    <span class="keyword">if</span> (isPremultiplied) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Premultiplied;</span><br><span class="line">    <span class="comment">// 没有复用的 Bitmap 创建一个新的 Bitmap</span></span><br><span class="line">    <span class="comment">// now create the java bitmap</span></span><br><span class="line">    <span class="keyword">return</span> GraphicsJNI::<span class="built_in">createBitmap</span>(env, javaAllocator.<span class="built_in">getStorageObjAndReset</span>(),</span><br><span class="line">    bitmapCreateFlags, ninePatchChunk, ninePatchInsets, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">GraphicsJNI::createBitmap</span><span class="params">(JNIEnv *env, android::Bitmap *bitmap,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> bitmapCreateFlags, jbyteArray ninePatchChunk,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  jobject ninePatchInsets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> density)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> isMutable = bitmapCreateFlags &amp; kBitmapCreateFlag_Mutable;</span><br><span class="line">    <span class="type">bool</span> isPremultiplied = bitmapCreateFlags &amp; kBitmapCreateFlag_Premultiplied;</span><br><span class="line">    <span class="comment">// The caller needs to have already set the alpha type properly, so the</span></span><br><span class="line">    <span class="comment">// native SkBitmap stays in sync with the Java Bitmap.</span></span><br><span class="line">    <span class="built_in">assert_premultiplied</span>(bitmap-&gt;<span class="built_in">info</span>(), isPremultiplied);</span><br><span class="line"></span><br><span class="line">    jobject obj = env-&gt;<span class="built_in">NewObject</span>(gBitmap_class, gBitmap_constructorMethodID,</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(bitmap), bitmap-&gt;<span class="built_in">javaByteArray</span>(),</span><br><span class="line">            bitmap-&gt;<span class="built_in">width</span>(), bitmap-&gt;<span class="built_in">height</span>(), density, isMutable, isPremultiplied,</span><br><span class="line">            ninePatchChunk, ninePatchInsets);</span><br><span class="line">    <span class="built_in">hasException</span>(env); <span class="comment">// For the side effect of logging.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来比较长，其实是非常简单的，相信大家都能看得懂，这里我对上面的流程再做一些总结：</p><ol><li>解析 java 层传递过来的 Options 的参数，如 simpleSize ，isMutable，javaBitmap 等等，同时计算出 scale 。</li><li>获取当前图片的大小，根据 sampleSize 判断是否需要压缩，同时计算出 scaledWidth ，scaledHeight。</li><li>设置 options 宽高为 scaledWidth ，scaledHeight ，如果只是解析宽高那么就直接返回，也就是 options.inJustDecodeBounds &#x3D; true 时，但是这里需要注意返回的是，资源图片的宽高并不是 Bitmap 最终的宽高。（我们大部分人对这个有误解）</li><li>创建 native 层的 SkImageInfo 和 SkBitmap ，然后调用 tryAllocPixels 去开辟图片的内存空间，然后调用 getAndroidPixels 去解析像素值 ，这里的 decodingBitmap 也并不是最终需要返回的 Bitmap ，而是原资源图片的 Bitmap 。</li><li>构建需要返回的 outputBitmap ，如果需要缩放那么重新去开辟一块内存空间，如果不需要缩放直接调用 swap 方法即可。最后判断有没有复用的 JavaBitmap ,如果有复用调用 reinitBitmap 然后直接返回，如果没有则调用 createBitmap 去创建一个新的 Bitmap 。</li></ol><h4 id="究竟需要多少内存？"><a href="#究竟需要多少内存？" class="headerlink" title="究竟需要多少内存？"></a>究竟需要多少内存？</h4><p><strong>通过上面的分析，我们可能会有疑问？我们调用了两次 tryAllocPixels ，那如果加载一张 (1440x2560) 10M 的图片，岂不是需要 20M 的内存？</strong></p><p>在 Android 平台上，Bitmap 的内存申请操作通常涉及到 Java 层和 Native 层的协作，而 tryAllocPixels 方法的多次调用可能是由于内部的内存分配和管理流程所致。</p><p>在 Android 4.4 及以上版本中，当你尝试为 Bitmap 对象申请内存时，tryAllocPixels 方法可能会在底层进行两次调用。这个行为在底层库中被设计用来提高内存分配的成功率。</p><p>第一次调用 tryAllocPixels 旨在检查是否有足够的内存来分配 Bitmap 的像素数据。如果这次调用失败，系统会尝试触发一次垃圾回收（GC）操作，以释放一些已不再使用的内存资源。</p><p>第二次调用 tryAllocPixels 发生在垃圾回收之后，此时系统期望能够分配足够的内存来满足 Bitmap 的需求。如果第二次调用仍然失败，那么可能会抛出 OutOfMemoryError 错误。</p><p>这种设计的目的是为了提高 Bitmap 内存分配的成功率。由于 Android 平台上的内存管理和垃圾回收机制是相对复杂的，经过多次尝试分配内存和触发垃圾回收，可以增加 Bitmap 成功分配内存的可能性。</p><p>在 Android 中，<code>Bitmap</code> 对象的内存使用量取决于图像的像素数量、每个像素的位深度和像素数据的存储方式。一个 10MB 的图片通常指的是文件大小，而不是图像的像素数量，因此具体的内存使用量会根据图像的属性而有所不同。</p><p>假设你有一张 10MB 的图片，我们可以估算一下将其加载为 <code>Bitmap</code> 时可能需要的内存量。请注意，以下是一个粗略的估算，实际内存使用量可能会受到压缩、图像格式和设备性能的影响。</p><ol><li><p><strong>图像大小：</strong> 假设你的图片大小为 10MB，这指的是文件的大小。这并不直接表示图像的像素数量，因为图像可以使用不同的压缩算法和格式存储。通常情况下，JPEG 格式的图像文件较小，而无损格式如 PNG 或 BMP 文件较大。</p></li><li><p><strong>解码后的像素数据：</strong> 当你将图片解码为 <code>Bitmap</code> 时，其像素数据将被加载到内存中。假设该图片是一个 24 位的彩色图片（每个像素使用 8 位红、绿、蓝通道），那么像素数据的大小将是图像的宽度乘以高度乘以 3（每个像素 3 个通道）字节。这个估算不考虑额外的颜色通道、Alpha 通道等。</p></li></ol><p>所以，一个粗略的估算如下：</p><p>假设图片的像素数据大小为 <code>pixelsSize</code> 字节，则需要的内存量约为：<code>pixelsSize + Overhead</code>。</p><p><code>Overhead</code> 是 <code>Bitmap</code> 对象的开销，它通常取决于设备的位数、对象头信息、内存对齐等因素。对于一个普通的 24 位彩色图片，<code>Overhead</code> 大约在 4-8MB 左右。</p><p>需要注意的是，这只是一个估算，并且实际情况可能因为图片格式、加载库的实现、设备性能等因素而有所不同。在实际开发中，你可以使用一些工具来测量实际的内存使用量，例如 Android Studio 的内存分析工具。</p><h3 id="Bitmap-的内存申请"><a href="#Bitmap-的内存申请" class="headerlink" title="Bitmap 的内存申请"></a>Bitmap 的内存申请</h3><p>Bitmap 的内存申请不同版本间有些许差异，在 3.0-7.0 的 bitmap 像素内存都是存放在 Java heap 中的，而 8.0 以后则是放在 Native heap 中的</p><h4 id="8-0-Bitmap-内存申请"><a href="#8-0-Bitmap-内存申请" class="headerlink" title="8.0 Bitmap  内存申请"></a>8.0 Bitmap  内存申请</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    logMemory();</span><br><span class="line"></span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> Bitmap.createBitmap(<span class="number">1024</span>, <span class="number">1024</span> * <span class="number">500</span>, Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><br><span class="line">    logMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ActivityManager</span> <span class="variable">activityManager</span> <span class="operator">=</span> (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.<span class="type">MemoryInfo</span> <span class="variable">memoryInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityManager</span>.MemoryInfo();</span><br><span class="line">    activityManager.getMemoryInfo(memoryInfo);</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;AvailMem :&quot;</span> + memoryInfo.availMem / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;lowMemory：&quot;</span> + memoryInfo.lowMemory);</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;NativeHeapAllocatedSize :&quot;</span> + Debug.getNativeHeapAllocatedSize() / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们创建了一张 2G 大小的 bitmap 我们在 8.0 以下的版本运行是会 OOM 的，而我们在 8.0 以上的版本运行是完全没问题，但 Native 内存多了 2G 的内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E/TAG: AvailMem :1654</span><br><span class="line">E/TAG: lowMemory：<span class="literal">false</span></span><br><span class="line">E/TAG: NativeHeapAllocatedSize :4</span><br><span class="line"></span><br><span class="line">E/TAG: AvailMem :1656</span><br><span class="line">E/TAG: lowMemory：<span class="literal">false</span></span><br><span class="line">E/TAG: NativeHeapAllocatedSize :2052</span><br></pre></td></tr></table></figure><h4 id="为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况"><a href="#为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况" class="headerlink" title="为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况"></a>为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况</h4><p>在 Android 应用中，一张大图片的像素数据如果放在 Java 层可能会导致 OutOfMemoryError (OOM) 错误，而放在 Native 层不会出现这个问题。这涉及到 Java 层和 Native 层内存管理的不同方式以及底层实现的细节。</p><ol><li><p><strong>Java 层内存管理：</strong> 在 Java 层，对象的内存管理由 Java 虚拟机 (JVM) 负责。当你创建一个 <code>Bitmap</code> 对象并加载大图片的像素数据时，这些像素数据会在 Java 堆内存中分配。Android 应用的 Java 堆内存限制通常较小，这是为了确保系统的稳定性，避免应用占用过多内存影响其他应用和系统的运行。Java 堆内存受到限制，当堆内存用尽时就会触发 OutOfMemoryError 错误。由于 Java 层的内存管理涉及垃圾回收和其他 Java 虚拟机机制，加载大量像素数据可能会导致内存碎片和性能问题，最终导致 OOM 错误。</p></li><li><p><strong>Native 层内存管理：</strong> 在 Native 层，像素数据的内存分配和释放由底层操作系统和 C&#x2F;C++ 代码负责。通过在 Native 层使用本地代码（如 C&#x2F;C++），你可以更好地控制内存的分配和释放。Native 层不受 Java 堆内存限制，因此可以更灵活地处理大量的像素数据，减少内存碎片问题，并降低 OOM 风险。</p></li></ol><h4 id="7-0-与-8-0-Bitmap-内存申请-tryAllocPixels-方法"><a href="#7-0-与-8-0-Bitmap-内存申请-tryAllocPixels-方法" class="headerlink" title="7.0 与 8.0 Bitmap 内存申请 tryAllocPixels 方法"></a>7.0 与 8.0 Bitmap 内存申请 tryAllocPixels 方法</h4><p>通过之前的源码分析可知 bitmap 的内存创建都是通过 tryAllocPixels 方法来申请的，我们通过源码来对比一下他们之间的区别，我们首先来看下 7.0 的代码：</p><p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="title class_">SkBitmap</span>::<span class="title function_ invoke__">tryAllocPixels</span>(Allocator *allocator, SkColorTable *ctable) &#123;</span><br><span class="line">    HeapAllocator stdalloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nullptr == allocator) &#123;</span><br><span class="line">        allocator = &amp;stdalloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocator-&gt;<span class="title function_ invoke__">allocPixelRef</span>(this, ctable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="title class_">JavaPixelAllocator</span>::<span class="title function_ invoke__">allocPixelRef</span>(SkBitmap *bitmap, SkColorTable *ctable) &#123;</span><br><span class="line">    JNIEnv *env = <span class="title function_ invoke__">vm2env</span>(mJavaVM);</span><br><span class="line"></span><br><span class="line">    mStorage = GraphicsJNI::<span class="title function_ invoke__">allocateJavaPixelRef</span>(env, bitmap, ctable);</span><br><span class="line">    <span class="keyword">return</span> mStorage != nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android::<span class="variable constant_">Bitmap</span> *GraphicsJNI::<span class="title function_ invoke__">allocateJavaPixelRef</span>(JNIEnv *env, SkBitmap *bitmap,</span><br><span class="line">                                                    SkColorTable *ctable) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">SkImageInfo</span> &amp;info = bitmap-&gt;<span class="title function_ invoke__">info</span>();</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="title function_ invoke__">colorType</span>() == kUnknown_SkColorType) &#123;</span><br><span class="line">        <span class="title function_ invoke__">doThrowIAE</span>(env, <span class="string">&quot;unknown bitmap configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">computeAllocationSize</span>(*bitmap, &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we must respect the rowBytes value already set on the bitmap instead of</span></span><br><span class="line">    <span class="comment">// attempting to compute our own.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">size_t</span> rowBytes = bitmap-&gt;<span class="title function_ invoke__">rowBytes</span>();</span><br><span class="line"></span><br><span class="line">    jbyteArray arrayObj = (jbyteArray) env-&gt;<span class="title function_ invoke__">CallObjectMethod</span>(gVMRuntime,</span><br><span class="line">                                                             gVMRuntime_newNonMovableArray,</span><br><span class="line">                                                             gByte_class, size);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="title function_ invoke__">ExceptionCheck</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">SkASSERT</span>(arrayObj);</span><br><span class="line">    jbyte *addr = (jbyte *) env-&gt;<span class="title function_ invoke__">CallLongMethod</span>(gVMRuntime, gVMRuntime_addressOf, arrayObj);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="title function_ invoke__">ExceptionCheck</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">SkASSERT</span>(addr);</span><br><span class="line">    android::<span class="variable constant_">Bitmap</span> *wrapper = <span class="keyword">new</span> android::<span class="title function_ invoke__">Bitmap</span>(env, arrayObj, (<span class="keyword">void</span> *) addr, info, rowBytes,</span><br><span class="line">                                                   ctable);</span><br><span class="line">    wrapper-&gt;<span class="title function_ invoke__">getSkBitmap</span>(bitmap);</span><br><span class="line">    <span class="comment">// since we&#x27;re already allocated, we lockPixels right away</span></span><br><span class="line">    <span class="comment">// HeapAllocator behaves this way too</span></span><br><span class="line">    bitmap-&gt;<span class="title function_ invoke__">lockPixels</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面就可以看到, new android::Bitmap 见：<br> frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bitmap::<span class="built_in">Bitmap</span>(JNIEnv *env, jbyteArray storageObj, <span class="type">void</span> *address,</span><br><span class="line">               <span class="type">const</span> SkImageInfo &amp;info, <span class="type">size_t</span> rowBytes, SkColorTable *ctable)</span><br><span class="line">        : <span class="built_in">mPixelStorageType</span>(PixelStorageType::Java) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">GetJavaVM</span>(&amp;mPixelStorage.java.jvm);</span><br><span class="line">    mPixelStorage.java.jweakRef = env-&gt;<span class="built_in">NewWeakGlobalRef</span>(storageObj);</span><br><span class="line">    mPixelStorage.java.jstrongRef = <span class="literal">nullptr</span>;</span><br><span class="line">    mPixelRef.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">WrappedPixelRef</span>(<span class="keyword">this</span>, address, info, rowBytes, ctable));</span><br><span class="line">    <span class="comment">// Note: this will trigger a call to onStrongRefDestroyed(), but</span></span><br><span class="line">    <span class="comment">// we want the pixel ref to have a ref count of 0 at this point</span></span><br><span class="line">    mPixelRef-&gt;<span class="built_in">unref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>address 获取的是 arrayObj 的地址，而 arrayObj 是 jbyteArray 数据类型，也就是说这里是通过 JNI 进入了 Java 世界开辟了内存，好比 Zygote 进入 Java 世界是通过 JNI 调用 com.android.internal.os.ZygoteInit 类的 main 函数是一个道理~ 我们还可以继续跟到 gVMRuntime_newNonMovableArray 中去看看实现，最后是 runtime-&gt;GetHeap() 上分配内存也就是 Java heap 内存。</p><p>我们还得看下 8.0 的源码，比较一下它与 7.0 之间的区别：<br> <a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/external/skia/src/core/SkBitmap.cpp">external&#x2F;skia&#x2F;src&#x2F;core&#x2F;SkBitmap.cpp</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> SkBitmap::<span class="title function_ invoke__">tryAllocPixels</span>(Allocator *allocator, SkColorTable *ctable) &#123;</span><br><span class="line">    HeapAllocator stdalloc;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">if</span> (nullptr == allocator) &#123;</span><br><span class="line">        allocator = &amp;stdalloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocator<span class="punctuation">-&gt;</span><span class="title function_ invoke__">allocPixelRef</span>(this, ctable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> HeapAllocator::<span class="title function_ invoke__">allocPixelRef</span>(SkBitmap *bitmap, SkColorTable *ctable) &#123;</span><br><span class="line">    mStorage = android::Bitmap::<span class="title function_ invoke__">allocateHeapBitmap</span>(bitmap, ctable);</span><br><span class="line">    <span class="keyword">return</span> !!mStorage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocateHeapBitmap方法会最终new Bitmap,分配内存 ,见:<br> <a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp">&#x2F;frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;hwui&#x2F;Bitmap.cpp</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sk_sp &lt;Bitmap&gt; <span class="title class_">Bitmap</span>::<span class="title function_ invoke__">allocateHeapBitmap</span>(SkBitmap *bitmap, SkColorTable *ctable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">allocateBitmap</span>(bitmap, ctable, &amp;android::<span class="variable constant_">allocateHeapBitmap</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static</span> sk_sp &lt;Bitmap&gt; <span class="title function_ invoke__">allocateBitmap</span>(SkBitmap *bitmap, SkColorTable *ctable, AllocPixeRef alloc) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">SkImageInfo</span> &amp;info = bitmap-&gt;<span class="title function_ invoke__">info</span>();</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="title function_ invoke__">colorType</span>() == kUnknown_SkColorType) &#123;</span><br><span class="line">        <span class="title function_ invoke__">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;unknown bitmap configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we must respect the rowBytes value already set on the bitmap instead of</span></span><br><span class="line">    <span class="comment">// attempting to compute our own.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">size_t</span> rowBytes = bitmap-&gt;<span class="title function_ invoke__">rowBytes</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">computeAllocationSize</span>(rowBytes, bitmap-&gt;<span class="title function_ invoke__">height</span>(), &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto wrapper = <span class="title function_ invoke__">alloc</span>(size, info, rowBytes, ctable);</span><br><span class="line">    <span class="keyword">if</span> (wrapper) &#123;</span><br><span class="line">        wrapper-&gt;<span class="title function_ invoke__">getSkBitmap</span>(bitmap);</span><br><span class="line">        <span class="comment">// since we&#x27;re already allocated, we lockPixels right away</span></span><br><span class="line">        <span class="comment">// HeapAllocator behaves this way too</span></span><br><span class="line">        bitmap-&gt;<span class="title function_ invoke__">lockPixels</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bitmap-内存模型"><a href="#Bitmap-内存模型" class="headerlink" title="Bitmap 内存模型"></a>Bitmap 内存模型</h3><table><thead><tr><th>0-2.3</th><th>3.0-4.4</th><th>5.0-7.1</th><th>8.0</th></tr></thead><tbody><tr><td>Bitmap对象</td><td>Java Heap</td><td>Java Heap</td><td>Java Heap</td></tr><tr><td>像素数据</td><td>Native Heap</td><td>Java Heap</td><td>Native Heap</td></tr><tr><td>迁移原因</td><td></td><td>解决Native Bitmap内存泄漏</td><td>共享整个系统的内存减少OOM</td></tr></tbody></table><h3 id="Android-Bitmap-回收机制源代码分析-从2-3到7-0，8-0"><a href="#Android-Bitmap-回收机制源代码分析-从2-3到7-0，8-0" class="headerlink" title="Android Bitmap 回收机制源代码分析 (从2.3到7.0，8.0)"></a>Android Bitmap 回收机制源代码分析 (从2.3到7.0，8.0)</h3><h4 id="android-2-3-3-和-更低的版本"><a href="#android-2-3-3-和-更低的版本" class="headerlink" title="android 2.3.3 和 更低的版本"></a>android 2.3.3 和 更低的版本</h4><p>在 Android 2.3.3 之前开发者必须手动调用 recycle 方法去释放 Native 内存，因为那个时候管理Bitmap内存比较复杂，需要手动维护引用计数器</p><p>官网解释:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On Android <span class="number">2.3</span><span class="number">.3</span> (API level <span class="number">10</span>) <span class="keyword">and</span> lower, <span class="function"><span class="keyword">using</span> <span class="title">recycle</span>() <span class="keyword">is</span> recommended. If you&#x27;re displaying large amounts of bitmap data <span class="keyword">in</span> your app, you&#x27;re likely to run <span class="keyword">into</span> OutOfMemoryError errors. The <span class="title">recycle</span>()method allows an app to reclaim memory <span class="keyword">as</span> soon <span class="keyword">as</span> possible.</span></span><br><span class="line"><span class="function">Caution: You should use <span class="title">recycle</span>() only <span class="keyword">when</span> you are sure that the bitmap <span class="keyword">is</span> no longer being used. If you call <span class="title">recycle</span>() <span class="keyword">and</span> later attempt to draw the bitmap, you will <span class="keyword">get</span> the error: &quot;Canvas: trying to use a recycled bitmap&quot;.</span></span><br><span class="line"><span class="function">The following code snippet gives an example of calling <span class="title">recycle</span>(). It uses reference <span class="title">counting</span> (<span class="params"><span class="keyword">in</span> the variables mDisplayRefCount <span class="keyword">and</span> mCacheRefCount</span>) to track whether a bitmap <span class="keyword">is</span> currently being displayed <span class="keyword">or</span> <span class="keyword">in</span> the cache. The code recycles the bitmap <span class="keyword">when</span> these conditions are met:</span></span><br><span class="line"><span class="function">The reference count <span class="keyword">for</span> both mDisplayRefCount <span class="keyword">and</span> mCacheRefCount <span class="keyword">is</span> 0.</span></span><br><span class="line"><span class="function">The bitmap <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>, <span class="keyword">and</span> it hasn&#x27;t been recycled yet.</span></span><br></pre></td></tr></table></figure><p>在 Android 2.3.3 以后不需要开发者主动调用 recycle 方法来回收内存了，但 Android K,L,M,N,O 版本上，都还能看到 recycle 方法，为什么没有干掉呢? 调用它会不会真正的释放内存呢？既然不需要手动释放 Native Bitmap ，那 Native 层的对象是怎么自动释放的？我们先来看下 7.0 和 8.0 中 recycle 的方法实现。</p><h4 id="7-0-和-8-0-中-recycle-的方法实现"><a href="#7-0-和-8-0-中-recycle-的方法实现" class="headerlink" title="7.0 和 8.0 中 recycle 的方法实现"></a>7.0 和 8.0 中 recycle 的方法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Free the native object associated with this bitmap, and clear the</span></span><br><span class="line"><span class="comment">  * reference to the pixel data. This will not free the pixel data synchronously;</span></span><br><span class="line"><span class="comment">  * it simply allows it to be garbage collected if there are no other references.</span></span><br><span class="line"><span class="comment">  * The bitmap is marked as &quot;dead&quot;, meaning it will throw an exception if</span></span><br><span class="line"><span class="comment">  * getPixels() or setPixels() is called, and will draw nothing. This operation</span></span><br><span class="line"><span class="comment">  * cannot be reversed, so it should only be called if you are sure there are no</span></span><br><span class="line"><span class="comment">  * further uses for the bitmap. This is an advanced call, and normally need</span></span><br><span class="line"><span class="comment">  * not be called, since the normal GC process will free up this memory when</span></span><br><span class="line"><span class="comment">  * there are no more references to this bitmap.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放与此位图关联的本机对象，并清除对像素数据的引用。这不会立即释放像素数据；</span></span><br><span class="line"><span class="comment"> * 它只是允许在没有其他引用时进行垃圾回收。该位图被标记为&quot;无效&quot;，这意味着如果调用   </span></span><br><span class="line"><span class="comment"> * getPixels()或setPixels()，它将抛出异常，</span></span><br><span class="line"><span class="comment"> * 并且不会绘制任何内容。此操作无法撤销，因此只有在确保不再需要位图时才应调用此方法。</span></span><br><span class="line"><span class="comment"> * 这是一个高级调用，通常不需要调用，因为正常的垃圾回收过程将在不再引用该位图时释放此内</span></span><br><span class="line"><span class="comment"> * 存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRecycled &amp;&amp; mNativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nativeRecycle(mNativePtr)) &#123;</span><br><span class="line">        <span class="comment">// return value indicates whether native pixel object was actually recycled.</span></span><br><span class="line">        <span class="comment">// false indicates that it is still in use at the native level and these</span></span><br><span class="line">        <span class="comment">// objects should not be collected now. They will be collected later when the</span></span><br><span class="line">        <span class="comment">// Bitmap itself is collected.</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 返回值指示本机像素对象是否实际已被回收。</span></span><br><span class="line">      <span class="comment">// false 表示它仍在本机级别上使用，现在不应收集这些对象。它们将在位图本身被回收时稍后收集。 </span></span><br><span class="line">        mNinePatchChunk = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mRecycled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">nativeRecycle</span><span class="params">(<span class="type">long</span> nativeBitmap)</span>;</span><br></pre></td></tr></table></figure><p>都是调用了native方法，下面看一下native方法</p><p>8.0 见：<br><a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp">&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv *env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    <span class="function">LocalScopedBitmap <span class="title">bitmap</span><span class="params">(bitmapHandle)</span></span>;</span><br><span class="line">    bitmap-&gt;<span class="built_in">freePixels</span>();</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mInfo = mBitmap-&gt;<span class="built_in">info</span>();</span><br><span class="line">    mHasHardwareMipMap = mBitmap-&gt;<span class="built_in">hasHardwareMipMap</span>();</span><br><span class="line">    mAllocationSize = mBitmap-&gt;<span class="built_in">getAllocationByteCount</span>();</span><br><span class="line">    mRowBytes = mBitmap-&gt;<span class="built_in">rowBytes</span>();</span><br><span class="line">    mGenerationId = mBitmap-&gt;<span class="built_in">getGenerationID</span>();</span><br><span class="line">    mIsHardware = mBitmap-&gt;<span class="built_in">isHardware</span>();</span><br><span class="line">    <span class="comment">// 清空了数据</span></span><br><span class="line">    mBitmap.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure><p>7.0 见：<br><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp">&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv *env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    <span class="function">LocalScopedBitmap <span class="title">bitmap</span><span class="params">(bitmapHandle)</span></span>;</span><br><span class="line">    bitmap-&gt;<span class="built_in">freePixels</span>();</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bitmap::doFreePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mPixelStorageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Invalid:</span><br><span class="line">            <span class="comment">// already free&#x27;d, nothing to do</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::External:</span><br><span class="line">            mPixelStorage.external.<span class="built_in">freeFunc</span>(mPixelStorage.external.address,</span><br><span class="line">            mPixelStorage.external.context);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Ashmem:</span><br><span class="line">            <span class="built_in">munmap</span>(mPixelStorage.ashmem.address, mPixelStorage.ashmem.size);</span><br><span class="line">            <span class="built_in">close</span>(mPixelStorage.ashmem.fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Java:</span><br><span class="line">            <span class="comment">// 只是释放了 Java 层之前创建的引用</span></span><br><span class="line">            JNIEnv *env = <span class="built_in">jniEnv</span>();</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(</span><br><span class="line">              mPixelStorage.java.jstrongRef,</span><br><span class="line">              <span class="string">&quot;Deleting a bitmap wrapper while there are outstanding strong &quot;</span></span><br><span class="line">                    <span class="string">&quot;references! mPinnedRefCount = %d&quot;</span>, mPinnedRefCount);</span><br><span class="line">            env-&gt;<span class="built_in">DeleteWeakGlobalRef</span>(mPixelStorage.java.jweakRef);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (android::uirenderer::Caches::<span class="built_in">hasInstance</span>()) &#123;</span><br><span class="line">        android::uirenderer::Caches::<span class="built_in">getInstance</span>().textureCache.<span class="built_in">releaseTexture</span>(</span><br><span class="line">                mPixelRef-&gt;<span class="built_in">getStableID</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-0-和-8-0-中-手动调用-recycle-的方法，像素数据会被回收吗"><a href="#7-0-和-8-0-中-手动调用-recycle-的方法，像素数据会被回收吗" class="headerlink" title="7.0 和 8.0 中 手动调用 recycle 的方法，像素数据会被回收吗"></a>7.0 和 8.0 中 手动调用 recycle 的方法，像素数据会被回收吗</h4><p>从上面的源码可以看出，如果是<br>        <strong>8.0</strong> : 我们手动调用 recycle 方法，数据是会立即释放的，因为像素数据本身就是在 Native 层开辟的。<br>        <strong>8.0 以下</strong>，就算我们手动调用 recycle 方法，数据也是不会立即释放的，而是 DeleteWeakGlobalRef 交由 Java GC 来回收。</p><p><strong>注意：以上的所说的释放数据仅代表释放像素数据，并未释放 Native 层的 Bitmap 对象。</strong></p><h4 id="Android-M-版本及以前的版本-Bitmap-的内存回收"><a href="#Android-M-版本及以前的版本-Bitmap-的内存回收" class="headerlink" title="Android M 版本及以前的版本, Bitmap 的内存回收"></a>Android M 版本及以前的版本, Bitmap 的内存回收</h4><p>Android M 版本及以前的版本, Bitmap 的内存回收主要是通过 BitmapFinalizer 来完成的见:<br> <a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.0_r1/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">&#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">byte</span>[] buffer, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">        <span class="type">boolean</span> isMutable, <span class="type">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="type">byte</span>[] ninePatchChunk, NinePatchInsetStruct ninePatchInsets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;internal error: native bitmap is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mIsMutable = isMutable;</span><br><span class="line">    mRequestPremultiplied = requestPremultiplied;</span><br><span class="line">    mBuffer = buffer;</span><br><span class="line"></span><br><span class="line">    mNinePatchChunk = ninePatchChunk;</span><br><span class="line">    mNinePatchInsets = ninePatchInsets;</span><br><span class="line">    <span class="keyword">if</span> (density &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mDensity = density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    <span class="comment">// 这个对象对象来回收</span></span><br><span class="line">    mFinalizer = <span class="keyword">new</span> <span class="title class_">BitmapFinalizer</span>(nativeBitmap);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nativeAllocationByteCount</span> <span class="operator">=</span> (buffer == <span class="literal">null</span> ? getByteCount() : <span class="number">0</span>);</span><br><span class="line">    mFinalizer.setNativeAllocationByteCount(nativeAllocationByteCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BitmapFinalizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mNativeBitmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Native memory allocated for the duration of the Bitmap,</span></span><br><span class="line">    <span class="comment">// if pixel data allocated into native memory, instead of java byte[]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mNativeAllocationByteCount;</span><br><span class="line"></span><br><span class="line">    BitmapFinalizer(<span class="type">long</span> nativeBitmap) &#123;</span><br><span class="line">        mNativeBitmap = nativeBitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNativeAllocationByteCount</span><span class="params">(<span class="type">int</span> nativeByteCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeAllocationByteCount != <span class="number">0</span>) &#123;</span><br><span class="line">            VMRuntime.getRuntime().registerNativeFree(mNativeAllocationByteCount);</span><br><span class="line">        &#125;</span><br><span class="line">        mNativeAllocationByteCount = nativeByteCount;</span><br><span class="line">        <span class="keyword">if</span> (mNativeAllocationByteCount != <span class="number">0</span>) &#123;</span><br><span class="line">            VMRuntime.getRuntime().registerNativeAllocation(mNativeAllocationByteCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// finalize 这里是 GC 回收该对象时会调用</span></span><br><span class="line">            setNativeAllocationByteCount(<span class="number">0</span>);</span><br><span class="line">            nativeDestructor(mNativeBitmap);</span><br><span class="line">            mNativeBitmap = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeDestructor</span><span class="params">(<span class="type">long</span> nativeBitmap)</span>;</span><br></pre></td></tr></table></figure><h4 id="Android-N-和-Android-O-后，Bitmap-的内存回收"><a href="#Android-N-和-Android-O-后，Bitmap-的内存回收" class="headerlink" title="Android N 和 Android O 后，Bitmap 的内存回收"></a>Android N 和 Android O 后，Bitmap 的内存回收</h4><p>没有了 BitmapFinalizer 类，但在 new Bitmap 时会注册 native 的 Finalizer 方法见: <a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">&#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java</a></p><p>使用 NativeAllocationRegistry 回收 native 内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private constructor that must received an already allocated native bitmap</span></span><br><span class="line"><span class="comment"> * int (pointer).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">        <span class="type">boolean</span> isMutable, <span class="type">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="type">byte</span>[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;internal error: native bitmap is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mIsMutable = isMutable;</span><br><span class="line">    mRequestPremultiplied = requestPremultiplied;</span><br><span class="line"></span><br><span class="line">    mNinePatchChunk = ninePatchChunk;</span><br><span class="line">    mNinePatchInsets = ninePatchInsets;</span><br><span class="line">    <span class="keyword">if</span> (density &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mDensity = density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line">    <span class="type">NativeAllocationRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(</span><br><span class="line">            Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bitmap-的-Java-对象-GC-之后，对应的-native-内存如何回收"><a href="#Bitmap-的-Java-对象-GC-之后，对应的-native-内存如何回收" class="headerlink" title="Bitmap 的 Java 对象 GC 之后，对应的 native 内存如何回收"></a>Bitmap 的 Java 对象 GC 之后，对应的 native 内存如何回收</h3><h4 id="NativeAllocationRegistry-的原理与设计思想"><a href="#NativeAllocationRegistry-的原理与设计思想" class="headerlink" title="NativeAllocationRegistry 的原理与设计思想"></a>NativeAllocationRegistry 的原理与设计思想</h4><p><code>NativeAllocationRegistry</code>是<code>Android 8.0（API 27）</code>引入的一种辅助回收<code>native</code>内存的机制</p><ul><li><p>Bitmap 的内存分配分外两块：Java 堆和 native 堆。我们都知道 JVM 有垃圾回收机制，那么当 Bitmap的Java对象GC之后，对应的 native 堆内存会回收吗？</p></li><li><h4 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h4><p>掌握了<code>NativeAllocationRegistry</code>的作用和使用步骤后，很自然地会有一些疑问：</p><ul><li><strong>为什么在<code>Java</code>层对象被垃圾回收后，<code>native</code>内存会自动被回收呢？</strong></li><li><strong><code>NativeAllocationRegistry</code>是从<code>Android 8.0（API 27）</code>开始引入，那么在此之前，<code>native</code>内存是如何回收的呢？</strong></li></ul></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>从<code>Android 8.0（API 27）</code>开始，<code>Android</code>中很多地方可以看到<code>NativeAllocationRegistry</code>的身影，我们以<code>Bitmap</code>为例子介绍<code>NativeAllocationRegistry</code>的使用步骤，涉及文件：<a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">Bitmap.java</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.h">Bitmap.h</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp">Bitmap.cpp</a></p><h5 id="步骤1：创建-NativeAllocationRegistry"><a href="#步骤1：创建-NativeAllocationRegistry" class="headerlink" title="步骤1：创建 NativeAllocationRegistry"></a>步骤1：创建 NativeAllocationRegistry</h5><p>首先，我们看看实例化<code>NativeAllocationRegistry</code>的地方，具体在<code>Bitmap</code>的构造函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # Android 8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap,...)&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【分析点 1：native 层需要的内存大小】</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line">    <span class="comment">// 【分析点 2：回收函数 nativeGetNativeFinalizer()】</span></span><br><span class="line">    <span class="comment">// 【分析点 3：加载回收函数的类加载器：Bitmap.class.getClassLoader()】</span></span><br><span class="line">    <span class="type">NativeAllocationRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(</span><br><span class="line">        Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    <span class="comment">// 注册 Java 层对象引用与 native 层对象的地址</span></span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NATIVE_ALLOCATION_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeGetNativeFinalizer</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Bitmap</code>的构造函数（在从<code>JNI</code>中调用）中实例化了<code>NativeAllocationRegistry</code>，并传递了三个参数：</p><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>classLoader</code></td><td align="left">加载<code>freeFunction</code>函数的类加载器</td></tr><tr><td align="left"><code>freeFunction</code></td><td align="left">回收<code>native</code>内存的<code>native</code>函数直接地址</td></tr><tr><td align="left"><code>size</code></td><td align="left">分配的<code>native</code>内存大小（单位：字节）</td></tr></tbody></table><h5 id="步骤2：注册对象"><a href="#步骤2：注册对象" class="headerlink" title="步骤2：注册对象"></a>步骤2：注册对象</h5><p>紧接着，调用了<code>registerNativeAllocation(...)</code>，并传递两个参数：</p><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>referent</code></td><td align="left"><code>Java</code>层对象的引用</td></tr><tr><td align="left"><code>nativeBitmap</code></td><td align="left"><code>native</code>层对象的地址</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line"><span class="built_in">Bitmap</span>(<span class="type">long</span> nativeBitmap,...)&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line">    <span class="comment">// 注册 Java 层对象引用与 native 层对象的地址</span></span><br><span class="line">    registry.<span class="built_in">registerNativeAllocation</span>(<span class="keyword">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">registerNativeAllocation</span><span class="params">(Object referent, <span class="type">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码省略，下文补充...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3：回收内存"><a href="#步骤3：回收内存" class="headerlink" title="步骤3：回收内存"></a>步骤3：回收内存</h5><p>完成前面两步后，当<code>Java</code>层对象被垃圾回收后，<code>NativeAllocationRegistry</code>会自动回收注册的<code>native</code>内存。例如，我们加载几张图片，随后释放<code>Bitmap</code>的引用，可以观察到<code>GC</code>之后，<code>native</code>层的内存也自动回收了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tv.setOnClickListener&#123;</span><br><span class="line">    val map = <span class="built_in">HashSet</span>&lt;Any&gt;()</span><br><span class="line">    <span class="keyword">for</span>(index in <span class="number">0</span> .. <span class="number">2</span>)&#123;</span><br><span class="line">        map.<span class="built_in">add</span>(BitmapFactory.<span class="built_in">decodeResource</span>(resources,R.drawable.test))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>GC 前的内存分配情况 —— Android 8.0</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10107787-56315037f2269bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><ul><li>GC 后的内存分配情况 —— Android 8.0</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10107787-96f6ad82c89a00f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><hr><p>- </p><p>通过分析<code>NativeAllocationRegistry</code>源码，我们将一步步解答这些问题，请继续往下看。</p><hr><h4 id="NativeAllocationRegistry-源码分析"><a href="#NativeAllocationRegistry-源码分析" class="headerlink" title="NativeAllocationRegistry 源码分析"></a>NativeAllocationRegistry 源码分析</h4><p>现在我们将视野回到到<code>NativeAllocationRegistry</code>的源码，涉及文件：<a href="https://links.jianshu.com/go?to=http://androidxref.com/9.0.0_r3/xref/libcore/luni/src/main/java/libcore/util/NativeAllocationRegistry.java">NativeAllocationRegistry.java</a> 、<a href="https://links.jianshu.com/go?to=http://androidxref.com/9.0.0_r3/xref/frameworks/layoutlib/bridge/src/libcore/util/NativeAllocationRegistry_Delegate.java">NativeAllocationRegistry_Delegate.java</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/9.0.0_r3/xref/libcore/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp">libcore_util_NativeAllocationRegistry.cpp</a></p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeAllocationRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 加载 freeFunction 函数的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    <span class="comment">// 回收 native 内存的 native 函数直接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> freeFunction;</span><br><span class="line">    <span class="comment">// 分配的 native 内存大小（字节）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> size;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NativeAllocationRegistry</span><span class="params">(ClassLoader classLoader, <span class="type">long</span> freeFunction, <span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid native allocation size: &quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.classLoader = classLoader;</span><br><span class="line">        <span class="built_in">this</span>.freeFunction = freeFunction;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>NativeAllocationRegistry</code>的构造函数只是将三个参数保存下来，并没有执行额外操作。以<code>Bitmap</code>为例，三个参数在<code>Bitmap</code>的构造函数中获得，我们继续上一节未完成的分析过程：</p><ul><li><strong>分析点 1：native 层需要的内存大小</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【分析点 1：native 层需要的内存大小】</span></span><br><span class="line"><span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAllocationByteCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRecycled) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Called getAllocationByteCount() on a recycle()&#x27;d bitmap! &quot;</span></span><br><span class="line">                    + <span class="string">&quot;This is undefined behavior!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 native 方法</span></span><br><span class="line">    <span class="keyword">return</span> nativeGetAllocationByteCount(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NATIVE_ALLOCATION_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>nativeSize</code>由固定的<code>32</code>字节加上<code>getAllocationByteCount()</code>，总之，<code>NativeAllocationRegistry</code>需要一个<code>native</code>层内存大小的参数。</p><ul><li><strong>分析点 2：回收函数 nativeGetNativeFinalizer()</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【分析点 2：回收函数 nativeGetNativeFinalizer()】</span></span><br><span class="line">NativeAllocationRegistry registry = <span class="keyword">new</span> <span class="built_in">NativeAllocationRegistry</span>(</span><br><span class="line">    Bitmap.<span class="keyword">class</span>.<span class="built_in">getClassLoader</span>(), <span class="built_in">nativeGetNativeFinalizer</span>(), nativeSize);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> native <span class="type">long</span> <span class="title">nativeGetNativeFinalizer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 层</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// native 层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">Bitmap_getNativeFinalizer</span><span class="params">(JNIEnv*, jobject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转为long</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;jlong&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;Bitmap_destruct));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bitmap_destruct</span><span class="params">(BitmapWrapper* bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>nativeGetNativeFinalizer()</code>是一个<code>native</code>函数，返回值是一个<code>long</code>，这个值其实相当于<code>Bitmap_destruct()</code>函数的直接地址。很明显，<code>Bitmap_destruct()</code>就是用来回收<code>native</code>层内存的。</p><p>那么，<code>Bitmap_destruct()</code>是在哪里调用的呢？继续往下看！</p><ul><li><strong>分析点 3：加载回收函数的类加载器</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line">Bitmap.<span class="keyword">class</span>.getClassLoader()</span><br></pre></td></tr></table></figure><p>另外，<code>NativeAllocationRegistry</code>还需要<code>ClassLoader</code>参数，文档注释指出：**<code>classloader</code>是加载<code>freeFunction</code>所在<code>native</code>库的类加载器**，但是<code>NativeAllocationRegistry</code>内部并没有使用这个参数。这里笔者也不理解为什么需要传递这个参数，如果有知道答案的小伙伴请告诉我一下~</p><h5 id="注册对象"><a href="#注册对象" class="headerlink" title="注册对象"></a>注册对象</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Java 层对象引用与 native 层对象的地址</span></span><br><span class="line">registry.registerNativeAllocation(<span class="keyword">this</span>, nativeBitmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">registerNativeAllocation</span>(<span class="params">Object referent, <span class="built_in">long</span> nativePtr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (referent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;referent is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nativePtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;nativePtr is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CleanerThunk thunk;</span><br><span class="line">    CleanerRunner result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thunk = <span class="keyword">new</span> CleanerThunk();</span><br><span class="line">        Cleaner cleaner = Cleaner.create(referent, thunk);</span><br><span class="line">        result = <span class="keyword">new</span> CleanerRunner(cleaner);</span><br><span class="line">        registerNativeAllocation(<span class="keyword">this</span>.size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (VirtualMachineError vme <span class="comment">/* probably OutOfMemoryError */</span>) &#123;</span><br><span class="line">        applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">        <span class="keyword">throw</span> vme;</span><br><span class="line">        <span class="comment">// Other exceptions are impossible.</span></span><br><span class="line">        <span class="comment">// Enable the cleaner only after we can no longer throw anything, including OOME.</span></span><br><span class="line">        thunk.setNativePtr(nativePtr);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>registerNativeAllocation (...)</code>方法参数是**<code>Java</code>层对象引用与<code>native</code>层对象的地址**。函数体乍一看是有点绕，笔者在这里也停留了好长一会。我们简化一下代码，<code>try-catch</code>代码先省略，函数返回值<code>Runnable</code>暂时用不到也先省略，瘦身后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （简化）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerNativeAllocation</span><span class="params">(Object referent, <span class="type">long</span> nativePtr)</span> &#123;</span><br><span class="line">    CleanerThunk <span class="type">thunk</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CleanerThunk</span>();</span><br><span class="line">    <span class="comment">// Cleaner 绑定 Java 对象与回收函数</span></span><br><span class="line">    <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create(referent, thunk);</span><br><span class="line">    <span class="comment">// 注册 native 内存</span></span><br><span class="line">    registerNativeAllocation(<span class="built_in">this</span>.size);</span><br><span class="line">    thunk.setNativePtr(nativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CleanerThunk</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 代码省略，下文补充...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，上文提出的第一个疑问就可以解释了，原来<code>NativeAllocationRegistry</code>内部是利用了<code>sun.misc.Cleaner.java</code>机制，简单来说：<strong>使用虚引用得知对象被GC的时机，在GC前执行额外的回收工作</strong>。</p><blockquote><h6 id="举一反三"><a href="#举一反三" class="headerlink" title="# 举一反三"></a># 举一反三</h6><p><code>DirectByteBuffer</code>内部也是利用了<code>Cleaner</code>实现堆外内存的释放的。若不了解，请务必阅读：<a href="https://www.jianshu.com/p/993206508d35">《Java | 堆内存与堆外内存》</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CleanerThunk</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// native 层对象的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nativePtr;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CleanerThunk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nativePtr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【分析点 4：执行内存回收方法】</span></span><br><span class="line">            applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">            <span class="comment">// 【分析点 5：注销 native 内存】</span></span><br><span class="line">            registerNativeFree(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNativePtr</span><span class="params">(<span class="type">long</span> nativePtr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nativePtr = nativePtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，<code>CleanerThunk</code>其实是<code>Runnable</code>的实现类，<code>run()</code>在<code>Java</code>层对象被垃圾回收时触发，主要做了两件事：</p><ul><li><strong>分析点 4：执行内存回收方法</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> native <span class="type">void</span> <span class="title">applyFreeFunction</span><span class="params">(<span class="type">long</span> freeFunction, <span class="type">long</span> nativePtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeAllocationRegistry.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FreeFunction)</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NativeAllocationRegistry_applyFreeFunction</span><span class="params">(JNIEnv*,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       jclass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       jlong freeFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* nativePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr));</span><br><span class="line">    FreeFunction nativeFreeFunction = <span class="built_in">reinterpret_cast</span>&lt;FreeFunction&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(freeFunction));</span><br><span class="line">    <span class="comment">// 调用回收函数</span></span><br><span class="line">    <span class="built_in">nativeFreeFunction</span>(nativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>applyFreeFunction(...)</code>最终就是执行到了前面提到的<strong>内存回收函数</strong>，对于<code>Bitmap</code>就是<code>Bitmap_destruct()</code></p><ul><li><strong>分析点 5：注册 &#x2F; 注销native内存</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 native 内存</span></span><br><span class="line"><span class="built_in">registerNativeAllocation</span>(<span class="keyword">this</span>.size);</span><br><span class="line"><span class="comment">// 注销 native 内存</span></span><br><span class="line"><span class="built_in">registerNativeFree</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示：这一层函数其实就是为了将参数转为long</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">registerNativeAllocation</span><span class="params">(<span class="type">long</span> size)</span> </span>&#123;</span><br><span class="line">    VMRuntime.<span class="built_in">getRuntime</span>().<span class="built_in">registerNativeAllocation</span>((<span class="type">int</span>)Math.<span class="built_in">min</span>(size, Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">registerNativeFree</span><span class="params">(<span class="type">long</span> size)</span> </span>&#123;</span><br><span class="line">    VMRuntime.<span class="built_in">getRuntime</span>().<span class="built_in">registerNativeFree</span>((<span class="type">int</span>)Math.<span class="built_in">min</span>(size, Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向<code>VM</code>注册<code>native</code>内存，比便在内存占用达到界限时触发<code>GC</code>，在该<code>native</code>内存回收时，需要向<code>VM</code>注销该内存量</p><hr><h4 id="对比-Android-8-0-之前回收-native-内存的方式"><a href="#对比-Android-8-0-之前回收-native-内存的方式" class="headerlink" title="对比 Android 8.0 之前回收 native 内存的方式"></a>对比 Android 8.0 之前回收 native 内存的方式</h4><p>前面我们已经分析完<code>NativeAllocationRegistry</code>的源码了，我们看一看在<code>Android 8.0</code>之前，<code>Bitmap</code>是用什么方法回收<code>native</code>内存的，涉及文件： <a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.0_r1/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">&#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java</a></p><ul><li>共同点：<ul><li><strong>分配的<code>native</code>层内存需要向<code>VM</code>注册 &#x2F; 注销</strong></li><li><strong>通过一个<code>native</code>层的内存回收函数来回收内存</strong></li></ul></li><li>不同点：<ul><li><strong><code>NativeAllocationRegistry</code>依赖于<code>sun.misc.Cleaner.java</code></strong></li><li><strong><code>BitmapFinalizer</code>依赖于<code>Object#finalize()</code></strong></li></ul></li></ul><p>我们知道，<code>finalize()</code>在<code>Java</code>对象被垃圾回收时会调用，<code>BitmapFinalizer</code>就是利用了这个机制来回收<code>native</code>层内存的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以下是关于 finalize() 方法的一些要点：</span><br><span class="line"></span><br><span class="line">finalize() 方法的定义： finalize() 是一个在 <span class="selector-tag">Object</span> 类中定义的方法，所有的 Java 类都可以选择覆盖它。它的签名为 protected void finalize() throws Throwable。</span><br><span class="line">垃圾回收触发： 当垃圾回收器决定要回收一个对象时（即对象变得不可达），在回收对象之前，会调用对象的 finalize() 方法。这个方法可能会在对象被回收之前执行一些清理操作，例如释放底层资源或资源的解引用。</span><br><span class="line">finalize() 方法的调用时机不确定： 由于垃圾回收的时机是不确定的，因此 finalize() 方法的调用时机也是不确定的。这意味着不能依赖于它来进行资源的及时释放或其他重要的清理操作。</span><br><span class="line">避免过度依赖 finalize()： 由于 finalize() 方法的调用时机不确定，且可能会影响性能，通常不建议过度依赖它。更好的做法是使用显式的资源管理，例如使用 try-finally 块来确保资源的释放。</span><br><span class="line">不同的垃圾回收方式： Java 使用不同的垃圾回收策略，包括标记-清除、标记-压缩等。在不同的垃圾回收方式中，finalize() 方法的调用时机可能会有所不同。</span><br><span class="line">需要注意的是，自从 Java <span class="number">9</span> 开始，finalize() 方法已经被标记为废弃（deprecated），这意味着在未来的 Java 版本中可能会被移除。推荐的做法是使用更可靠的资源管理和垃圾回收机制，例如使用 AutoCloseable 接口和 try-with-resources 语句来确保资源的正确释放。</span><br></pre></td></tr></table></figure><p>再举几个常用的类在<code>Android 8.0</code>之前的源码为例子，原理都大同小异：<a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.1_r10/xref/frameworks/base/graphics/java/android/graphics/Matrix.java">Matrix.java (before Android 8.0)</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.1_r10/xref/frameworks/base/graphics/java/android/graphics/Canvas.java">Canvas.java (before Android 8.0)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        finalizer(native_instance);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">finalizer</span><span class="params">(<span class="type">long</span> native_instance)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Canvas.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CanvasFinalizer mFinalizer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CanvasFinalizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mNativeCanvasWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CanvasFinalizer</span><span class="params">(<span class="type">long</span> nativeCanvas)</span> &#123;</span><br><span class="line">        mNativeCanvasWrapper = nativeCanvas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeCanvasWrapper != <span class="number">0</span>) &#123;</span><br><span class="line">            finalizer(mNativeCanvasWrapper);</span><br><span class="line">            mNativeCanvasWrapper = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Canvas</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line">    mFinalizer = <span class="keyword">new</span> <span class="title class_">CanvasFinalizer</span>(mNativeCanvasWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题回归"><a href="#问题回归" class="headerlink" title="问题回归"></a>问题回归</h4><ul><li><strong><code>NativeAllocationRegistry</code>利用虚引用感知<code>Java</code>对象被回收的时机，来回收<code>native</code>层内存</strong></li><li><strong>在<code>Android 8.0 (API 27)</code>之前，<code>Android</code>通常使用<code>Object#finalize()</code>调用时机来回收<code>native</code>层内存</strong></li></ul><h3 id="Bitmap-的内存复用"><a href="#Bitmap-的内存复用" class="headerlink" title="Bitmap 的内存复用"></a>Bitmap 的内存复用</h3><p>Bitmap 绝对是我们 Android 开发中最容易引起 OOM 的对象之一，因为其占用的像素数据内存比较大，而加载图片又是很常见的操作。如果不断反复的去开辟和销毁 Bitmap 数据内存，势必可能会引起应用的内存抖动，因此 Google 的开发者也为我们想了一些办法，那就是允许 Bitmap 内存复用，具体如下：</p><ul><li><p>被复用的 Bitmap 必须为 Mutable（通过 BitmapFactory.Options 设置）</p><p>这是因为复用操作涉及对 Bitmap 对象像素数据的修改，而只有 Mutable 的 Bitmap 才允许对其像素数据进行修改。</p></li><li><p>4.4 之前</p><ol><li><strong>图像格式：</strong> 被复用的 Bitmap 和要解码的图像必须具有相同的像素格式，通常是 ARGB_8888 或 RGB_565 格式。这是因为像素格式的不匹配可能导致解码失败或图像显示异常。</li><li><strong>图像尺寸：</strong> 被复用的 Bitmap 和要解码的图像必须具有相同的尺寸。如果尺寸不匹配，复用操作将被忽略。</li><li><strong>图像类型：</strong> 在 Android 4.4 之前，被复用的 Bitmap 和要解码的图像必须是 JPEG 或 PNG 格式。其他格式的图像将无法被复用。</li><li><strong>inSampleSize 设置：</strong> <code>BitmapFactory.Options</code> 的 <code>inSampleSize</code> 字段必须设置为 1，以表示不进行图像的缩放。这是因为在进行图像缩放的情况下，图像的尺寸和复用的 Bitmap 尺寸可能不匹配。</li></ol></li><li><p>4.4 以后</p><p><code>BitmapFactory.Options</code> 的 <code>inBitmap</code> 字段用于指定要复用的 <code>Bitmap</code> 对象。通过设置这个字段，你可以告诉解码器将解码后的图像数据存储在已经存在的 <code>Bitmap</code> 中，以便进行复用。</p><p>同时，要注意以下几点：</p><ol><li>被解码的图像的内存大小不应该超过要复用的 <code>Bitmap</code> 的内存大小。</li><li>被解码的图像和要复用的 <code>Bitmap</code> 的像素格式和尺寸应该匹配。</li><li>解码时需要设置 <code>inSampleSize</code> 为 1，以确保图像不会被缩放。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不复用的写法，消耗内存 32 M</span></span><br><span class="line"><span class="built_in">logMemory</span>();</span><br><span class="line">Bitmap bitmap1 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2);</span><br><span class="line">Bitmap bitmap2 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2);</span><br><span class="line"><span class="built_in">logMemory</span>();</span><br><span class="line"><span class="comment">// 复用的写法，消耗内存 16 M</span></span><br><span class="line"><span class="built_in">logMemory</span>();</span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.<span class="built_in">Options</span>();</span><br><span class="line">options.inMutable = <span class="literal">true</span>;</span><br><span class="line">Bitmap bitmap1 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2, options);</span><br><span class="line">options.inBitmap = bitmap1;</span><br><span class="line">Bitmap bitmap2 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2, options);</span><br><span class="line"><span class="built_in">logMemory</span>();</span><br></pre></td></tr></table></figure><p>在 Glide 中，Bitmap 复用是通过使用 <code>BitmapPool</code> 接口来实现的。<code>BitmapPool</code> 是一个用于管理和复用 Bitmap 对象的接口，它允许 Glide 在加载和显示图像时复用之前分配的 Bitmap 对象，从而减少内存分配和垃圾回收的开销。</p><p>以下是简要的 Glide Bitmap 复用的流程：</p><ol><li>Glide 首先会尝试从 <code>BitmapPool</code> 中获取一个可复用的 Bitmap 对象。如果 <code>BitmapPool</code> 中存在满足条件的 Bitmap，就会使用它。</li><li>如果 <code>BitmapPool</code> 中没有可复用的 Bitmap，Glide 会根据要加载的图像的尺寸和像素格式创建一个新的 Bitmap 对象。</li><li>加载和显示图像时，Glide 会将 Bitmap 对象放入 <code>BitmapPool</code>，以便以后可以复用。</li></ol><p>为了更深入地了解 Glide 中 Bitmap 复用的实现，你可以查阅 Glide 的源代码，并关注以下关键部分：</p><ol><li><code>BitmapPool</code> 接口及其实现类：Glide 使用 <code>BitmapPool</code> 接口来管理 Bitmap 对象的复用。<code>BitmapPool</code> 接口定义了一系列的方法，如 <code>get()</code> 获取可复用的 Bitmap，<code>put()</code> 将 Bitmap 放回池中等。在 Glide 源代码中，你可以查看 <code>LruBitmapPool</code> 和其他的 <code>BitmapPool</code> 实现类。</li><li><code>BitmapImageViewTarget</code>：Glide 使用 <code>BitmapImageViewTarget</code> 来将 Bitmap 显示在 ImageView 中。在这个类中，你可以看到 Glide 如何从 <code>BitmapPool</code> 中获取可复用的 Bitmap 对象。</li><li>图片加载流程：Glide 的图片加载流程涉及到许多类和接口，包括请求管理、数据加载、资源解码等。在这些类中，你可以找到 Glide 如何利用 Bitmap 复用来优化内存使用。</li></ol><h4 id="Glide-Bitmap-复用源代码分析"><a href="#Glide-Bitmap-复用源代码分析" class="headerlink" title="Glide Bitmap 复用源代码分析"></a>Glide Bitmap 复用源代码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bumptech.glide.load.engine.bitmap_recycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.annotation.TargetApi;</span><br><span class="line"><span class="keyword">import</span> android.content.ComponentCallbacks2;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.util.Synthetic;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool&#125; implementation that uses an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.bumptech.glide.load.engine.bitmap_recycle.LruPoolStrategy&#125; to bucket &#123;<span class="doctag">@link</span> Bitmap&#125;s</span></span><br><span class="line"><span class="comment"> * and then uses an LRU eviction policy to evict &#123;<span class="doctag">@link</span> android.graphics.Bitmap&#125;s from the least</span></span><br><span class="line"><span class="comment"> * recently used bucket in order to keep the pool below a given maximum size limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruBitmapPool</span> <span class="keyword">implements</span> <span class="title class_">BitmapPool</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;LruBitmapPool&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bitmap.<span class="type">Config</span> <span class="variable">DEFAULT_CONFIG</span> <span class="operator">=</span> Bitmap.Config.ARGB_8888;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LruPoolStrategy strategy;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Bitmap.Config&gt; allowedConfigs;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> initialMaxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BitmapTracker tracker;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> maxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> currentSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> hits;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> misses;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> puts;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> evictions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exposed for testing only.</span></span><br><span class="line">  LruBitmapPool(<span class="type">long</span> maxSize, LruPoolStrategy strategy, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123;</span><br><span class="line">    <span class="built_in">this</span>.initialMaxSize = maxSize;</span><br><span class="line">    <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    <span class="built_in">this</span>.allowedConfigs = allowedConfigs;</span><br><span class="line">    <span class="built_in">this</span>.tracker = <span class="keyword">new</span> <span class="title class_">NullBitmapTracker</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for LruBitmapPool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxSize The initial maximum size of the pool in bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LruBitmapPool</span><span class="params">(<span class="type">long</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for LruBitmapPool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxSize The initial maximum size of the pool in bytes.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> allowedConfigs A white listed put of &#123;<span class="doctag">@link</span> android.graphics.Bitmap.Config&#125; that are</span></span><br><span class="line"><span class="comment">   *     allowed to be put into the pool. Configs not in the allowed put will be rejected.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LruBitmapPool</span><span class="params">(<span class="type">long</span> maxSize, Set&lt;Bitmap.Config&gt; allowedConfigs)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(maxSize, getDefaultStrategy(), allowedConfigs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of cache hits for bitmaps in the pool. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">hitCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hits;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of cache misses for bitmaps in the pool. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">missCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> misses;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of bitmaps that have been evicted from the pool. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">evictionCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evictions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the current size of the pool in bytes. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCurrentSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMaxSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setSizeMultiplier</span><span class="params">(<span class="type">float</span> sizeMultiplier)</span> &#123;</span><br><span class="line">    maxSize = Math.round(initialMaxSize * sizeMultiplier);</span><br><span class="line">    evict();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Bitmap must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!bitmap.isMutable()</span><br><span class="line">        || strategy.getSize(bitmap) &gt; maxSize</span><br><span class="line">        || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(</span><br><span class="line">            TAG,</span><br><span class="line">            <span class="string">&quot;Reject bitmap from pool&quot;</span></span><br><span class="line">                + <span class="string">&quot;, bitmap: &quot;</span></span><br><span class="line">                + strategy.logBitmap(bitmap)</span><br><span class="line">                + <span class="string">&quot;, is mutable: &quot;</span></span><br><span class="line">                + bitmap.isMutable()</span><br><span class="line">                + <span class="string">&quot;, is allowed config: &quot;</span></span><br><span class="line">                + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class="line">      &#125;</span><br><span class="line">      bitmap.recycle();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> strategy.getSize(bitmap);</span><br><span class="line">    strategy.put(bitmap);</span><br><span class="line">    tracker.add(bitmap);</span><br><span class="line"></span><br><span class="line">    puts++;</span><br><span class="line">    currentSize += size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Put bitmap in pool=&quot;</span> + strategy.logBitmap(bitmap));</span><br><span class="line">    &#125;</span><br><span class="line">    dump();</span><br><span class="line"></span><br><span class="line">    evict();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> Bitmap <span class="title function_">get</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> getDirtyOrNull(width, height, config);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Bitmaps in the pool contain random data that in some cases must be cleared for an image</span></span><br><span class="line">      <span class="comment">// to be rendered correctly. we shouldn&#x27;t force all consumers to independently erase the</span></span><br><span class="line">      <span class="comment">// contents individually, so we do so here. See issue #131.</span></span><br><span class="line">      result.eraseColor(Color.TRANSPARENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = createBitmap(width, height, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Bitmap <span class="title function_">getDirty</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> getDirtyOrNull(width, height, config);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      result = createBitmap(width, height, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title function_">createBitmap</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="meta">@Nullable</span> Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(width, height, config != <span class="literal">null</span> ? config : DEFAULT_CONFIG);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.O)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotHardwareConfig</span><span class="params">(Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="comment">// Avoid short circuiting on sdk int since it breaks on some versions of Android.</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config == Bitmap.Config.HARDWARE) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">          <span class="string">&quot;Cannot create a mutable Bitmap with config: &quot;</span></span><br><span class="line">              + config</span><br><span class="line">              + <span class="string">&quot;. Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your&quot;</span></span><br><span class="line">              + <span class="string">&quot; RequestOptions and/or in GlideBuilder.setDefaultRequestOptions&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> Bitmap <span class="title function_">getDirtyOrNull</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> width, <span class="type">int</span> height, <span class="meta">@Nullable</span> Bitmap.Config config)</span> &#123;</span><br><span class="line">    assertNotHardwareConfig(config);</span><br><span class="line">    <span class="comment">// Config will be null for non public config types, which can lead to transformations naively</span></span><br><span class="line">    <span class="comment">// passing in null as the requested config here. See issue #194.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> strategy.get(width, height, config != <span class="literal">null</span> ? config : DEFAULT_CONFIG);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Missing bitmap=&quot;</span> + strategy.logBitmap(width, height, config));</span><br><span class="line">      &#125;</span><br><span class="line">      misses++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hits++;</span><br><span class="line">      currentSize -= strategy.getSize(result);</span><br><span class="line">      tracker.remove(result);</span><br><span class="line">      normalize(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Get bitmap=&quot;</span> + strategy.logBitmap(width, height, config));</span><br><span class="line">    &#125;</span><br><span class="line">    dump();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setting these two values provides Bitmaps that are essentially equivalent to those returned</span></span><br><span class="line">  <span class="comment">// from Bitmap.createBitmap.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normalize</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">    bitmap.setHasAlpha(<span class="literal">true</span>);</span><br><span class="line">    maybeSetPreMultiplied(bitmap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maybeSetPreMultiplied</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      bitmap.setPremultiplied(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;clearMemory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressLint(&quot;InlinedApi&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimMemory</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;trimMemory, level=&quot;</span> + level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND)</span><br><span class="line">        || ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)</span><br><span class="line">            &amp;&amp; (level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN))) &#123;</span><br><span class="line">      clearMemory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN)</span><br><span class="line">        || (level == ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL)) &#123;</span><br><span class="line">      trimToSize(getMaxSize() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">removed</span> <span class="operator">=</span> strategy.removeLast();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> This shouldn&#x27;t ever happen, see #331.</span></span><br><span class="line">      <span class="keyword">if</span> (removed == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">          Log.w(TAG, <span class="string">&quot;Size mismatch, resetting&quot;</span>);</span><br><span class="line">          dumpUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">        currentSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tracker.remove(removed);</span><br><span class="line">      currentSize -= strategy.getSize(removed);</span><br><span class="line">      evictions++;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Evicting bitmap=&quot;</span> + strategy.logBitmap(removed));</span><br><span class="line">      &#125;</span><br><span class="line">      dump();</span><br><span class="line">      removed.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dump</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      dumpUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.v(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;Hits=&quot;</span></span><br><span class="line">            + hits</span><br><span class="line">            + <span class="string">&quot;, misses=&quot;</span></span><br><span class="line">            + misses</span><br><span class="line">            + <span class="string">&quot;, puts=&quot;</span></span><br><span class="line">            + puts</span><br><span class="line">            + <span class="string">&quot;, evictions=&quot;</span></span><br><span class="line">            + evictions</span><br><span class="line">            + <span class="string">&quot;, currentSize=&quot;</span></span><br><span class="line">            + currentSize</span><br><span class="line">            + <span class="string">&quot;, maxSize=&quot;</span></span><br><span class="line">            + maxSize</span><br><span class="line">            + <span class="string">&quot;\nStrategy=&quot;</span></span><br><span class="line">            + strategy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LruPoolStrategy <span class="title function_">getDefaultStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> LruPoolStrategy strategy;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      strategy = <span class="keyword">new</span> <span class="title class_">SizeConfigStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strategy = <span class="keyword">new</span> <span class="title class_">AttributeStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.O)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Bitmap.Config&gt; getDefaultAllowedConfigs() &#123;</span><br><span class="line">    Set&lt;Bitmap.Config&gt; configs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(Bitmap.Config.values()));</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      <span class="comment">// GIFs, among other types, end up with a native Bitmap config that doesn&#x27;t map to a java</span></span><br><span class="line">      <span class="comment">// config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured</span></span><br><span class="line">      <span class="comment">// and are suitable for re-use.</span></span><br><span class="line">      configs.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">      configs.remove(Bitmap.Config.HARDWARE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(configs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">BitmapTracker</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bitmap bitmap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Bitmap bitmap)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">  <span class="comment">// Only used for debugging</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThrowingBitmapTracker</span> <span class="keyword">implements</span> <span class="title class_">BitmapTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Bitmap&gt; bitmaps = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Bitmap&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (bitmaps.contains(bitmap)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t add already added bitmap: &quot;</span></span><br><span class="line">                + bitmap</span><br><span class="line">                + <span class="string">&quot; [&quot;</span></span><br><span class="line">                + bitmap.getWidth()</span><br><span class="line">                + <span class="string">&quot;x&quot;</span></span><br><span class="line">                + bitmap.getHeight()</span><br><span class="line">                + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      bitmaps.add(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!bitmaps.contains(bitmap)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot remove bitmap not in tracker&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      bitmaps.remove(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NullBitmapTracker</span> <span class="keyword">implements</span> <span class="title class_">BitmapTracker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synthetic</span></span><br><span class="line">    NullBitmapTracker() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对代码进行逐段分析：</p><ol><li>导入相关的包和类。</li><li>定义了一个名为 “LruBitmapPool” 的类，实现了 “BitmapPool” 接口，用于管理位图内存池。</li><li>定义了一些常量，如默认的位图配置和日志标签。</li><li>声明了一些成员变量，包括内存池策略、允许的位图配置、最大大小、当前大小、命中次数、未命中次数、添加次数和驱逐次数等。</li><li>构造函数，初始化内存池大小、策略和允许的位图配置等。</li><li>提供了一些公开方法用于获取统计信息，如命中次数、未命中次数、驱逐次数、当前大小等。</li><li>实现了 “BitmapPool” 接口中的一些方法，包括 setSizeMultiplier、put、get、getDirty、clearMemory、trimMemory 等。</li><li>定义了一些辅助方法，如 evict、assertNotHardwareConfig、normalize、maybeSetPreMultiplied、getDirtyOrNull、trimToSize、dump 和 dumpUnchecked 等。</li><li>定义了 “BitmapTracker” 接口，其中包含了添加和移除位图的方法。</li><li>定义了一些实现了 “BitmapTracker” 接口的类，如 “ThrowingBitmapTracker” 和 “NullBitmapTracker”。</li></ol><p>总体来说，这段代码实现了一个基于 LRU（Least Recently Used）算法的位图内存池，用于管理位图对象的内存分配和回收。它可以跟踪位图的使用情况，限制内存池的大小，通过策略进行位图的管理和驱逐，以及提供一些统计信息用于优化和调试。</p><h4 id="Gilde-是如何实现-Bitmap-复用的？"><a href="#Gilde-是如何实现-Bitmap-复用的？" class="headerlink" title="Gilde 是如何实现 Bitmap 复用的？"></a>Gilde 是如何实现 Bitmap 复用的？</h4><p>在这段代码中，实现位图复用的核心思想是通过内存池策略（<code>LruPoolStrategy</code>）来管理位图的存储和获取。下面我将详细解释如何实现位图的复用：</p><ol><li><p><code>put(Bitmap bitmap)</code> 方法：<br>当你想要回收一个位图时，会调用这个方法。它会首先判断位图是否为空、是否已经被回收、是否是可变的位图，位图大小是否超过了内存池的最大大小，以及位图的配置是否允许被放入内存池。如果这些条件都满足，它会将位图放入内存池策略中，并更新当前内存池的大小。</p></li><li><p><code>get(int width, int height, Bitmap.Config config)</code> 和 <code>getDirty(int width, int height, Bitmap.Config config)</code> 方法：<br>当你想要获取一个位图时，会调用这两个方法之一。它首先会尝试从内存池策略中获取满足条件的位图，如果找到则返回该位图，否则会创建一个新的位图并返回。这里的位图创建使用了 <code>Bitmap.createBitmap()</code> 方法，确保了返回的位图是可复用的。</p></li><li><p><code>trimToSize(long size)</code> 方法：<br>当内存池的当前大小超过了最大限制时，会调用这个方法进行驱逐。它会循环地从内存池策略中移除最近未使用的位图，直到当前内存池大小小于等于指定的大小。</p></li><li><p><code>LruPoolStrategy</code> 接口的实现：<br>这个接口定义了位图内存池策略的规范，包括位图的添加、获取、移除等操作。在这段代码中，有两个实现类：<code>SizeConfigStrategy</code> 和 <code>AttributeStrategy</code>，分别在不同的 Android 版本上进行位图的管理。</p></li></ol><p>通过这些机制，当位图被回收时，它会被添加到内存池中，下次需要位图时会优先从内存池中获取，以达到位图复用的效果。这样可以减少内存分配和回收的开销，提高性能和效率。</p><hr><p>BitMap 创建，内存申请与内存模型相关内容整理参考自</p><p>作者：红橙Darren<br>链接：<a href="https://www.jianshu.com/p/8e8ad414237e">https://www.jianshu.com/p/8e8ad414237e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>具体回收细节参考自</p><p>版权声明：本文为CSDN博主「shihongyu12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/shihongyu12345/article/details/89681948">https://blog.csdn.net/shihongyu12345/article/details/89681948</a></p><p>NativeAllocationRegistry 的原理与设计思想 摘录自</p><p>作者：彭旭锐<br>链接：<a href="https://www.jianshu.com/p/6f042f9e47a8">https://www.jianshu.com/p/6f042f9e47a8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>部分相关知识来自于 chat-GPT 3.5</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>协程中的取消和异常 （取消操作详解）</title>
      <link href="/2023/08/11/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/"/>
      <url>/2023/08/11/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在开发中，我们要避免不必要的的任务来节约设备的内存和电量的使用，协程也是如此。在使用的过程我们需要控制好它的生命周期，在不需要它的取消它。</p><h3 id="调用cancel方法"><a href="#调用cancel方法" class="headerlink" title="调用cancel方法"></a>调用cancel方法</h3><h4 id="取消作用域会取消它的子协程"><a href="#取消作用域会取消它的子协程" class="headerlink" title="取消作用域会取消它的子协程"></a>取消作用域会取消它的子协程</h4><p>当启动了很多个协程，我们一个个协程的取消比较麻烦，我们可以通过取消整个作用域来解决这个问题，因为取消作用域可以取消该作用域创建的所有协程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ 假设我们已经定义了一个作用域</span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">job1</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">job2</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"></span><br><span class="line">scope.cancel()</span><br></pre></td></tr></table></figure><p>假设我们创建了一个作用域scope,并创建了两个协程job1和job2。我们通过调用scope.cancel()，取消作用域，将会把job1 和job2两个协程都取消。</p><h4 id="单独取消某个协程，不会影响他的兄弟协程"><a href="#单独取消某个协程，不会影响他的兄弟协程" class="headerlink" title="单独取消某个协程，不会影响他的兄弟协程"></a>单独取消某个协程，不会影响他的兄弟协程</h4><p>我们创建了两个协程，job1和job2.我们单独取消job1，不会影响到job2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们已经定义了一个作用域</span></span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">job1</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">job2</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个协程将会被取消，而另一个则不受任何影响</span></span><br><span class="line">job1.cancel()</span><br></pre></td></tr></table></figure><h4 id="协程通过抛出一个特殊的异常-CancellationException-来处理取消操作"><a href="#协程通过抛出一个特殊的异常-CancellationException-来处理取消操作" class="headerlink" title="协程通过抛出一个特殊的异常 CancellationException 来处理取消操作"></a>协程通过抛出一个特殊的异常 CancellationException 来处理取消操作</h4><p>在调用cancel函数的时候，我们需要传入一个CancellationException对象,如果我们没有传入，那就用默认的defaultCancellationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// external cancel with cause, never invoked implicitly from internal machinery</span></span><br><span class="line">   <span class="keyword">public</span> override fun <span class="title function_">cancel</span><span class="params">(cause: CancellationException?)</span> &#123;</span><br><span class="line">       cancelInternal(cause ?: defaultCancellationException())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一旦抛出了CancellationException，我们就可以通过这一机制来处理协程的取消。在底层的实现中，子协程会通过抛出异常的方式将取消的情况通知它的父级，父协程通过传入的取消原因决定是否处理该异常。</p><h4 id="不能在已取消的作用域中再次启动新的协程"><a href="#不能在已取消的作用域中再次启动新的协程" class="headerlink" title="不能在已取消的作用域中再次启动新的协程"></a>不能在已取消的作用域中再次启动新的协程</h4><h4 id="调用了-cancel-方法为什么协程处理的任务没有停止？"><a href="#调用了-cancel-方法为什么协程处理的任务没有停止？" class="headerlink" title="调用了 cancel 方法为什么协程处理的任务没有停止？"></a>调用了 cancel 方法为什么协程处理的任务没有停止？</h4><p>不同的Diapatcher不同的区别，下一篇文章将介绍。<br> 我们以Dispatchers.Default为例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line">suspend fun <span class="title function_">main</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line">    <span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">nextTime</span> <span class="operator">=</span> startTime</span><br><span class="line">        <span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;这是第$&#123;i&#125;次&quot;</span>)</span><br><span class="line">                i++</span><br><span class="line">                <span class="comment">//1000毫秒执行一次</span></span><br><span class="line">                nextTime += <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;取消&quot;</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    println(<span class="string">&quot;取消完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是第<span class="number">0</span>次</span><br><span class="line">这是第<span class="number">1</span>次</span><br><span class="line">取消</span><br><span class="line">取消完毕</span><br><span class="line">这是第<span class="number">2</span>次</span><br><span class="line">这是第<span class="number">3</span>次</span><br><span class="line">这是第<span class="number">4</span>次</span><br></pre></td></tr></table></figure><p>调用cancel方法之后，协程的任务依然在运行。调用cancel方法的时候，此时协程处于cancelling正在取消的状态，接着我们打印了2，3，4，处理任务结束之后，协程变成cancelled已经取消的状态，这是以Default举例，Default调度会等待协程任务处理完毕才取消。</p><h4 id="让协程可以被取消"><a href="#让协程可以被取消" class="headerlink" title="让协程可以被取消"></a>让协程可以被取消</h4><p>协程处理任务都是协作式的，协作的意思就是我们的处理任务要配合协程取消做处理。因此在执行任务期间我们要定时检查协程的状态是否已经取消，例如我们从磁盘读取文件之前我们先检查协程是否被取消了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">    <span class="keyword">for</span>(file in files) &#123;</span><br><span class="line">        <span class="comment">// TODO 检查协程是否被取消</span></span><br><span class="line">        readFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程中的挂起函数都是可取消的，使用他们的时候，我们不需要检查协程是否已取消。例如withContext，delay 。如果没有这些挂起函数，为了让我们的代码配合协程取消，可以使用一下两种方法：</p><ul><li>检查 job.isActive 或者使用 ensureActive()</li><li>使用 yield() 来让其他任务进行</li></ul><h4 id="检查-job-的活跃状态"><a href="#检查-job-的活跃状态" class="headerlink" title="检查 job 的活跃状态"></a>检查 job 的活跃状态</h4><p>先看一下第一种方法，在我们的 while(i&lt;5) 循环中添加对于协程状态的检查:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为处于 launch 的代码块中，可以访问到 job.isActive 属性</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive)</span><br></pre></td></tr></table></figure><h4 id="使用-yield-函数运行其他任务"><a href="#使用-yield-函数运行其他任务" class="headerlink" title="使用 yield() 函数运行其他任务"></a>使用 yield() 函数运行其他任务</h4><h4 id="Job-join-和-Deferred-await-cancellation"><a href="#Job-join-和-Deferred-await-cancellation" class="headerlink" title="Job.join 和 Deferred.await cancellation"></a>Job.join 和 Deferred.await cancellation</h4><p>等待协程处理结果有两种方法，launch启动的job可以调用join，async 返回的Deferred 可以调用await方法</p><ul><li>job.join会让协程挂起，直到等待协程处理任务完毕，我们可以配合cancel使用</li><li>deferred.await()如果我们关心协程的处理结果，我们可以使用deferred。结果由deferred.await返回。也是job类型，也可以被取消。</li></ul><h4 id="处理协程取消的副作用"><a href="#处理协程取消的副作用" class="headerlink" title="处理协程取消的副作用"></a>处理协程取消的副作用</h4><p>当我们需要在协程取消 后处理一些清理的工作，或者做一些打印日志。我们有几种办法：</p><ul><li>通过检查协程的状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (…) &#123;</span><br><span class="line">        println(“Hello $&#123;i++&#125;”)</span><br><span class="line">        nextPrintTime += <span class="number">500L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 协程所处理的任务已经完成，因此我们可以做一些清理工作</span></span><br><span class="line">println(“Clean up!”</span><br></pre></td></tr></table></figure><p>当判断协程不是isActive状态的时候，我们可以做一些清理</p><ul><li>try catch finally<br> 我们知道协程的取消会抛出CancellationException 异常，我们可以在协程提中使用try catch finally，在finally中做我们的一些清理的工作，或者打印日志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      work()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: CancellationException)&#123;</span><br><span class="line">      println(“Work cancelled!”)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(“Clean up!”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000L</span>)</span><br><span class="line">println(“Cancel!”)</span><br><span class="line">job.cancel()</span><br><span class="line">println(“Done!</span><br></pre></td></tr></table></figure><h4 id="已经取消的协程，不能再被挂起"><a href="#已经取消的协程，不能再被挂起" class="headerlink" title="已经取消的协程，不能再被挂起"></a>已经取消的协程，不能再被挂起</h4><p>已经取消的协程，不能再被挂起，但是当我们需要在取消的协程中调用挂起函数，那么我们可以在finally中使用NonCancellable ，意思是让协程挂起，直到处理挂起函数中的代码完毕，协程才会取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      work()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: CancellationException)&#123;</span><br><span class="line">      println(“Work cancelled!”)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      withContext(NonCancellable)&#123;</span><br><span class="line">         delay(<span class="number">1000L</span>) <span class="comment">// 或一些其他的挂起函数</span></span><br><span class="line">         println(“Cleanup done!”)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000L</span>)</span><br><span class="line">println(“Cancel!”)</span><br><span class="line">job.cancel()</span><br><span class="line">println(“Done!</span><br></pre></td></tr></table></figure><p>在jetpack中使用viewModelScope 或者lifecycleScope 中定义的作用域，他们在scope完成后取消他们的处理任务。如果我们手动创建自己的作用域CoroutineScope，我们需要协作协程，将我们的作用域和job绑定，在需要的时候取消。</p>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.1 - Kotlin 协程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 的协程本质到底什么</title>
      <link href="/2023/08/11/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/"/>
      <url>/2023/08/11/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>几乎就是用阻塞的写法来完成非阻塞的任务。<br>Kotlin-JVM中所谓的协程是假协程<br>Kotlin-JVM中所谓的 协程挂起 ，就是开启了一个子线程去执行任务</p><p>对于Java来说，不管你用什么方法，只要你没有魔改JVM，那么最终你代码里start几个线程，操作系统就会创建几个线程，是1比1的关系。<br>Kotlin官网中那个创建10w个Kotlin协程没有oom的例子其实有误导性，本质上那10w个Kotlin协程就是10w个并发任务仅此而已，他下面运行的就是一个单线程的线程池。你往一个线程池里面丢多少个任务都不会OOM的（前提是你的线程池创建的时候设定了对应的拒绝策略，否则无界队列下，任务过多一定会OOM），因为在运行的始终是那几个线程。</p><p>创建协程的方式有五种：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope<span class="selector-class">.launch</span>&#123;&#125;</span><br><span class="line">launch&#123;&#125;</span><br><span class="line">runBlocking&#123;&#125;</span><br><span class="line">coroutineScope&#123;&#125;</span><br><span class="line">async&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.1 - Kotlin 协程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>协程核心概念的理解与应用(一)--翻译翻译什么是 CoroutineScope</title>
      <link href="/2023/08/11/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/"/>
      <url>/2023/08/11/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s21.ax1x.com/2024/03/09/pFymrC9.jpg" alt="图片描述"></p><p>作者：朕小猫与GPT4</p><h1 id="Android-如何在一个非-LifecycleOwner-的类中使用协程"><a href="#Android-如何在一个非-LifecycleOwner-的类中使用协程" class="headerlink" title="Android 如何在一个非 LifecycleOwner 的类中使用协程"></a>Android 如何在一个非 LifecycleOwner 的类中使用协程</h1><p>在非<code>LifecycleOwner</code>的类中使用协程，你不能直接使用与生命周期相关的作用域，如<code>lifecycleScope</code>或<code>viewModelScope</code>。不过，你可以使用<code>CoroutineScope</code>来创建自己的作用域。使用<code>CoroutineScope</code>，你可以定义一个作用域，并指定一个<code>Dispatcher</code>来控制协程的执行线程。此外，你还需要手动管理协程的生命周期，以避免内存泄漏。</p><p>以下是如何在非<code>LifecycleOwner</code>类中使用协程的一个基本示例：</p><ol><li><p><strong>定义协程作用域</strong>：首先，定义一个协程作用域，通常是类的成员变量。这个作用域应当与你希望协程执行的生命周期绑定。例如，如果你在一个普通类中工作，你可能需要在类被销毁时取消所有协程。</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.CoroutineScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Job</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> job = Job()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutineScope = CoroutineScope(Dispatchers.Main + job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在协程作用域内启动协程</strong>：使用定义的协程作用域启动协程，执行异步操作。</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ...前面的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineScope.launch &#123;</span><br><span class="line">            <span class="comment">// 在这里执行协程代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>管理协程生命周期</strong>：为避免内存泄漏，确保在不需要协程运行时取消它们。如果你的类有一个明确的生命周期结束点（如自定义视图的<code>onDetachedFromWindow</code>或者一个对象的<code>close</code>方法），你应当在那里取消作用域中的所有协程。</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    job.cancel() <span class="comment">// 取消与这个作用域相关的所有协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以在不依赖于<code>LifecycleOwner</code>的情况下，安全地在任何类中使用协程。记住，手动管理协程的生命周期是避免内存泄漏的关键。</p><h1 id="如何理解-CoroutineContext"><a href="#如何理解-CoroutineContext" class="headerlink" title="如何理解 CoroutineContext"></a>如何理解 CoroutineContext</h1><p><code>CoroutineContext</code>是Kotlin协程中用于持有协程相关配置的接口。它由一组元素组成，每个元素都实现了<code>CoroutineContext.Element</code>接口，并且通过一个唯一的<code>Key</code>进行标识。<code>CoroutineContext</code>的实现并不限于某些固定的子类，而是通过组合不同的<code>Element</code>实例来扩展其功能。这意味着<code>CoroutineContext</code>的“子类”实际上是指一系列标准库或自定义库中定义的实现了<code>CoroutineContext.Element</code>接口的类，这些类代表了不同的协程配置和特性。以下是一些常见的<code>CoroutineContext.Element</code>实现，它们在Kotlin协程的使用中扮演着关键角色：</p><ol><li><p><strong><code>Job</code></strong>: 控制协程的生命周期，允许启动、取消、和查询协程的状态。<code>Job</code>是协程工作的基本单位，可以被用来取消协程。</p></li><li><p><strong><code>CoroutineDispatcher</code></strong>: 决定协程在哪个线程或线程池上执行。<code>Dispatchers.Main</code>、<code>Dispatchers.IO</code>、和<code>Dispatchers.Default</code>是最常用的几种调度器。</p></li><li><p><strong><code>CoroutineName</code></strong>: 提供协程的名称，有助于调试。</p></li><li><p><strong><code>CoroutineExceptionHandler</code></strong>: 定义了协程如何处理未捕获的异常。可以用来全局或局部地处理异常。</p></li></ol><p>除了上述提到的标准元素外，开发者还可以实现自定义的<code>CoroutineContext.Element</code>来扩展协程的功能。每个元素都可以通过其<code>Key</code>加入到<code>CoroutineContext</code>中，同时保证<code>CoroutineContext</code>中的每个<code>Key</code>都是唯一的。</p><p>在实际应用中，这些元素可以通过<code>+</code>操作符组合在一起，形成一个包含多个配置的<code>CoroutineContext</code>，用于启动和管理协程。这种设计允许协程上下文在保持灵活性的同时，能够非常精确地控制协程的行为和环境。</p><h1 id="协程的-号代表什么"><a href="#协程的-号代表什么" class="headerlink" title="协程的 + 号代表什么"></a>协程的 + 号代表什么</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a context containing elements from this context and elements from  other [context].</span></span><br><span class="line"><span class="comment"> * The elements from this context with the same key as in the other one are dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> operator fun <span class="title function_">plus</span><span class="params">(context: CoroutineContext)</span>: CoroutineContext =</span><br><span class="line">    <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="built_in">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">        context.fold(<span class="built_in">this</span>) &#123; acc, element -&gt;</span><br><span class="line">            <span class="type">val</span> <span class="variable">removed</span> <span class="operator">=</span> acc.minusKey(element.key)</span><br><span class="line">            <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">interceptor</span> <span class="operator">=</span> removed[ContinuationInterceptor]</span><br><span class="line">                <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">val</span> <span class="variable">left</span> <span class="operator">=</span> removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                    <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                        CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个<code>plus</code>函数是<code>CoroutineContext</code>的一个操作符函数，用于合并两个协程上下文（<code>CoroutineContext</code>），返回一个包含两者元素的新上下文。如果两个上下文中有相同键（<code>key</code>）的元素，那么原上下文（<code>this</code>）中的元素会被丢弃。这个函数的主要逻辑可以分解为几个关键步骤：</p><ol><li><p><strong>快速路径检查</strong>：如果要添加的上下文（<code>context</code>）是一个空的协程上下文（<code>EmptyCoroutineContext</code>），则直接返回当前上下文（<code>this</code>），因为没有新元素需要添加。</p></li><li><p><strong>遍历合并</strong>：使用<code>fold</code>方法遍历<code>context</code>中的每个元素。<code>fold</code>接收一个初始累加值（这里是<code>this</code>，即当前上下文）和一个操作函数。操作函数定义了如何将<code>context</code>中的元素合并到累加值中。</p></li><li><p><strong>去除相同键的元素</strong>：对于<code>context</code>中的每个元素，先从累加值（即目前合并的结果）中移除具有相同键的元素。这一步确保了如果有相同键的元素，那么<code>this</code>中的元素会被<code>context</code>中的元素替换。</p></li><li><p><strong>合并上下文</strong>：如果移除相同键元素后的上下文是空的（<code>EmptyCoroutineContext</code>），则只添加当前遍历到的元素。否则，检查是否存在<code>ContinuationInterceptor</code>元素（协程拦截器），因为拦截器应当始终位于上下文中的最后，以便快速获取。</p></li><li><p><strong>调整拦截器位置</strong>：如果存在<code>ContinuationInterceptor</code>，将其移动到合并后的上下文的最后。这涉及到在没有拦截器的剩余上下文中添加当前元素，然后再添加拦截器。</p></li><li><p><strong>返回新的合并上下文</strong>：最终返回包含了<code>this</code>和<code>context</code>元素（且<code>context</code>中的元素优先）的新上下文。如果存在<code>ContinuationInterceptor</code>，确保它位于最后。</p></li></ol><p>简而言之，这个函数通过合并两个协程上下文并调整元素顺序，确保了新上下文中不会有重复的键，且<code>ContinuationInterceptor</code>（如果存在）总是位于最后，以优化性能。</p><h1 id="如何理解其中的-CoroutineContext-与-key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。"><a href="#如何理解其中的-CoroutineContext-与-key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。" class="headerlink" title="如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。"></a>如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。</h1><p><code>CoroutineContext</code>在Kotlin协程中是一个关键概念，它是一组各种元素的集合，这些元素定义了协程的行为。每个元素都有一个<code>Key</code>，用于唯一标识该元素的类型，这样<code>CoroutineContext</code>就可以通过键值对的方式存储和检索协程的配置和状态信息。这里的“相同键（key）的元素”意味着两个元素属于同一类型，或者说执行相同的功能或角色。</p><h3 id="CoroutineContext和-key"><a href="#CoroutineContext和-key" class="headerlink" title="CoroutineContext和 key"></a><code>CoroutineContext</code>和 key</h3><ul><li><p>**<code>CoroutineContext</code><strong>：是一个集合，包含了控制协程行为的各种元素，例如调度器（<code>Dispatcher</code>）、协程名称、协程的异常处理器等。每个元素通过一个唯一的键（</strong><code>Key</code>**）来识别，键通常由元素类型本身提供。</p></li><li><p><strong>相同键的元素</strong>：如果两个<code>CoroutineContext</code>元素具有相同的键，它们被视为同一类型的配置或状态信息。在合并上下文时，不能有重复键的元素，否则会产生冲突。</p></li></ul><h3 id="为什么context中的元素优先"><a href="#为什么context中的元素优先" class="headerlink" title="为什么context中的元素优先"></a>为什么<code>context</code>中的元素优先</h3><p>在合并两个<code>CoroutineContext</code>时，如果存在相同键的元素，<code>context</code>参数中的元素会替换当前上下文（<code>this</code>）中的元素。这个设计选择是基于函数式编程中常见的不可变性原则，以及配置更新的需求：新提供的配置（即<code>context</code>参数中的）被认为是最新的，应优先于旧的配置。这样，开发者可以灵活更新协程的行为，而无需担心旧上下文的状态。</p><h3 id="为什么ContinuationInterceptor位于最后"><a href="#为什么ContinuationInterceptor位于最后" class="headerlink" title="为什么ContinuationInterceptor位于最后"></a>为什么<code>ContinuationInterceptor</code>位于最后</h3><p><code>ContinuationInterceptor</code>是<code>CoroutineContext</code>中的一个特殊元素，用于拦截协程的执行。它是协程调度器（如<code>Dispatchers.Main</code>）的基础，控制着协程的执行线程。将<code>ContinuationInterceptor</code>放在合并后的<code>CoroutineContext</code>的最后，是出于性能考虑：</p><ul><li><p><strong>快速访问</strong>：协程在执行时频繁查询<code>ContinuationInterceptor</code>以确定执行线程。将其置于上下文的末尾可以优化这一查询过程，因为在<code>CoroutineContext</code>的实现中，较后的元素可以更快地被访问到。</p></li><li><p><strong>避免冲突</strong>：确保<code>ContinuationInterceptor</code>总是最后一个被添加，意味着即使合并多个上下文，也能保证只有一个有效的调度器在最终的上下文中生效，这避免了多个调度器可能导致的潜在冲突。</p></li></ul><p>综上所述，<code>CoroutineContext</code>及其键的概念允许协程行为的灵活配置和更新，而在合并上下文时优先考虑新的元素以及保持<code>ContinuationInterceptor</code>在最后，是出于更新优先级和性能优化的考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.1 - Kotlin 协程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的惰性操作容器——Sequence</title>
      <link href="/2023/08/11/Kotlin/Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/"/>
      <url>/2023/08/11/Kotlin/Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="Sequence序列"><a href="#Sequence序列" class="headerlink" title="Sequence序列"></a>Sequence序列</h3><p>Sequence 是Kotlin标准库提供的一种容器类型。它和Iterable一样具备对集合进行多步骤操作能力，但是却是采用了一种完全不同于Iterable的实现方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val map = (0..3).filter &#123;</span><br><span class="line">    println(&quot;filter:$it&quot;)</span><br><span class="line">    it % 2 == 0</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    println(&quot;map:$it&quot;)</span><br><span class="line">    it + 1</span><br><span class="line">&#125;</span><br><span class="line">println(map)</span><br></pre></td></tr></table></figure><p>上面的代码用来演示Iterable进行连续操作的情况。它的输出如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter:0</span><br><span class="line">filter:1</span><br><span class="line">filter:2</span><br><span class="line">filter:3</span><br><span class="line">map:0</span><br><span class="line">map:2</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure><p>像<code>map</code>和<code>filter</code>这些链式集合函数它们都会立即执行并创建中间临时集用来保存数据。当原始数据不多时，这并不会有什么影响。但是，当原始数据量非常大的时候。这就会变的非常低效。而此时，就可以借助<code>Sequence</code>提高效率。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val sequence = (0..3).asSequence().filter &#123;</span><br><span class="line">    println(&quot;filter:$it&quot;)</span><br><span class="line">    it % 2 == 0</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    println(&quot;map:$it&quot;)</span><br><span class="line">    it + 1</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;准备开始执行&quot;)</span><br><span class="line">println(sequence.toList())</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">准备开始执行</span><br><span class="line">filter:0</span><br><span class="line">map:0</span><br><span class="line">filter:1</span><br><span class="line">filter:2</span><br><span class="line">map:2</span><br><span class="line">filter:3</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure><p>对比Iterable和Sequence：</p><p>Iterable是即时的、Sequence是惰性的：前者会要求尽早的计算结果，因此在多步骤处理链的每一环都会有中间产物也就是新的集合产生；<strong>后者会尽可能的延迟计算结果，Sequence处理的中间函数不进行任何计算。相反，他们返回一个新Sequence的，用新的操作装饰前一个，所有的这些计算都只是在类似toList的终端操作期间进行。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-f3db64c81524b0df40edf073b68f1ac9_1440w.webp" alt="img"></p><p>区分中间操作符和末端操作符的方式也很简单：<strong>如果操作符返回的是一个Sequence类型的数据，它就是中间操作符。</strong></p><p>在操作的执行方式上也有所不同：Iterable每次都是在整个集合执行完操作后再进行下一步操作——采用第一个操作并将其应用于整个集合，然后移动到下一个操作，官方将其称呼为急切式或者按步骤执行（Eager&#x2F;step-by-step）；<strong>而Sequence则是逐个对每个元素执行所有操作。是一种惰性顺序——取第一个元素并应用所有操作，然后取下一个元素，依此类推。</strong>官方将其称呼为惰性式或者按元素执行（Lazy&#x2F;element-by-element)</p><p>序列的惰性会带来一下几个优点：</p><ul><li>它们的操作按照元素的自然顺序进行；</li><li>只做最少的操作；</li><li>元素可以是无限多个；</li><li>不需要在每一步都创建集合</li></ul><p><strong>Sequence可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。但是，惰性性质也会带来一些运行开销。所以在使用时要权衡惰性开销和中间步骤开销，在Sequence和Iterable中选择更加合适的实现方式。</strong></p><h3 id="执行的顺序"><a href="#执行的顺序" class="headerlink" title="执行的顺序"></a>执行的顺序</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceOf(1,2,3)</span><br><span class="line">    .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125;</span><br><span class="line">    .map &#123; print(&quot;M$it, &quot;); it * 2 &#125;</span><br><span class="line">    .forEach &#123; print(&quot;E$it, &quot;) &#125; </span><br><span class="line">// Prints: F1, M1, E2, F2, F3, M3, E6,</span><br><span class="line"></span><br><span class="line">listOf(1,2,3)</span><br><span class="line">    .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125;</span><br><span class="line">    .map &#123; print(&quot;M$it, &quot;); it * 2 &#125;</span><br><span class="line">    .forEach &#123; print(&quot;E$it, &quot;) &#125;</span><br><span class="line">// Prints: F1, F2, F3, M1, M3, E2, E6,</span><br></pre></td></tr></table></figure><p>sequence的执行时按照元素进行的，依次对元素执行所有的操作，对一个元素而言，所有操作时依次全部执行的。而普通集合操作则是以操作步骤进行的，当所有的元素执行完当前操作后才会进入下一个操作。</p><p><img src="https://pic1.zhimg.com/80/v2-27021cdfe12cadb333ac2f9c5991f8ec_1440w.webp" alt="img"></p><h3 id="只做最少的操作"><a href="#只做最少的操作" class="headerlink" title="只做最少的操作"></a>只做最少的操作</h3><p>试想一下我们有一千万个数字，我们要经过几次变换取出20个，使用下面的代码对比一下序列和不同集合操作的性能：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val fFlow = FFlow()</span><br><span class="line">    fFlow.demoList()</span><br><span class="line">    fFlow.demoSequence()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demoSequence() &#123;</span><br><span class="line">    val currentTimeMillis = System.currentTimeMillis()</span><br><span class="line">    val list =</span><br><span class="line">    (0..10000000).asSequence().map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList()</span><br><span class="line">    println(&quot;demoSequence:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demoList() &#123;</span><br><span class="line">    val currentTimeMillis = System.currentTimeMillis()</span><br><span class="line">    val list =</span><br><span class="line">    (0..10000000).map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList()</span><br><span class="line">    println(&quot;demoList:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demoSequence:20ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]</span><br><span class="line">demoList:4106ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]</span><br></pre></td></tr></table></figure><p>这就是只执行最少操作的意思，序列按照元素顺序执行，当取够29个元素之后便会立即停止计算。而不同的集合则不同，没有中间操作的概念。它的每次操作都会对整个数组中的所有元素执行完才会进行下一个——也就是前两个map都要执行一千万次。</p><p><img src="https://pic2.zhimg.com/80/v2-76965bb77961ce0d47ccef581ac2c2e9_1440w.webp" alt="img"></p><h3 id="序列可以是无限的"><a href="#序列可以是无限的" class="headerlink" title="序列可以是无限的"></a>序列可以是无限的</h3><p>看如下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var list = emptyArray&lt;Int&gt;()</span><br><span class="line">var  i = 0</span><br><span class="line">while(true)&#123;</span><br><span class="line">    list[i] = i++</span><br><span class="line">&#125;</span><br><span class="line">list.take(10)</span><br></pre></td></tr></table></figure><p>很明显，这段代码是没法正常运行的，因为这里有一个死循环。我们也无法创建一个无限长度的集合。但是：因为序列式按步骤依照需求进行处理的，所哟我们可以创建无限序列：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val noEnd = sequence &#123;</span><br><span class="line">    var i = 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        yield(i)</span><br><span class="line">        i *= 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">noEnd.take(4).toList()</span><br><span class="line">//输出:[1, 2, 4, 8]</span><br></pre></td></tr></table></figure><p>但是一定要注意，我们虽然可以这么写，但是务必不能真的让while一直循环。我们不能直接使用toList。必须提供一个能结束循环的操作符，也就是不能取出所有元素（无限个）——要么使用类似take的操作来限制它们的数量，要么使用不需要所有元素的终端操作，例如first, find, any, all, indexOf等。</p><h3 id="序列不会在每个步骤创建集合"><a href="#序列不会在每个步骤创建集合" class="headerlink" title="序列不会在每个步骤创建集合"></a>序列不会在每个步骤创建集合</h3><p>普通的集合会在每次变换之后都会创建新的集合取存储所有变换后的元素。而每次创建集合和填入数据都会带来不小的性能开销。尤其是当我们处理大量或大量的集合时，性能问题会愈发凸显。而序列的按元素操作，则不会有这个问题。除非手动调用了终端操作符，否则不会生成新的集合。</p><h3 id="Sequence的基本使用"><a href="#Sequence的基本使用" class="headerlink" title="Sequence的基本使用"></a>Sequence的基本使用</h3><p>Sequence序列的使用和普通的Iterable极其相似，实际上其内部也还是借助Iterable实现的。在研究它的内部实现原理之前，想从Sequence的创建和基本的序列操作来演示Sequence的基本用法。</p><h3 id="序列的创建"><a href="#序列的创建" class="headerlink" title="序列的创建"></a>序列的创建</h3><p>创建Sequence的方式大概可以分为。分别是由元素创建、通过Iterable、借助函数以及由代码块创建。</p><p>由元素创建：通过调用顶级函数<code>sequenceOf</code>实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequenceOf(1, 2, 3, 4, 5, 6, 7)</span><br><span class="line">val strings = sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</span><br></pre></td></tr></table></figure><p>通过Iterable转化：借助Iterable的扩展函数<code>asSequence</code>实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ints = listOf(1, 2, 3, 4, 5, 6, 7).asSequence()</span><br><span class="line">val strings = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</span><br></pre></td></tr></table></figure><p>通过generateSequence实现：该方法有三个：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; </span><br><span class="line">generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;</span><br><span class="line">generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt;</span><br></pre></td></tr></table></figure><p>最终都是通过<code>GeneratorSequence</code>实现的，这里先不进行源码分析。只讨论使用方式：</p><ul><li>其中三个函数都有的形参nextFunction可以理解为元素生成器，序列里的元素都通过调用该函数生成，当它返回为null是，序列停止生成（所以，nextFunction必须要在某个情况下返回null，否则会因为序列元素是无限多个触发java.lang.OutOfMemoryError: Java heap space异常）。</li><li>而另外两个的seedFunction和seed形参都是为了确定数据初始值的。区别在于一个直接指明，一个通过调用函数获取。</li></ul><p>分别用这三个函数生成0~100的序列，代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val generateSequenceOne = generateSequence &#123;</span><br><span class="line">    if (i &lt; 100) &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val generateSequenceTwo = generateSequence(0) &#123;</span><br><span class="line">    if (it &lt; 100) &#123;</span><br><span class="line">        it+1//此处的it是上一个元素</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val generateSequenceThree = generateSequence(&#123; 0 &#125;) &#123;</span><br><span class="line">    if (it &lt; 100) &#123;</span><br><span class="line">        it+1//此处的it是上一个元素</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码块生成：借助sequence(block: suspend SequenceScope.() -&gt; Unit)函数。改函数接受一个挂起函数，该函数会接受一个<code>SequenceScope</code>实例，这个实例无需我们创建（后面源码分析会讲到）。SequenceScope提供了<code>yield</code>和<code>yieldAll</code>方法复杂返回序列元素给调用者，并暂停序列的执行，直到使用者请求下一个元素。</p><p>用该函数生成0~100的序列，代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequence &#123;</span><br><span class="line">    repeat(100) &#123;</span><br><span class="line">        yield(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列的操作"><a href="#序列的操作" class="headerlink" title="序列的操作"></a>序列的操作</h3><p>对序列的操作可以分为中间操作和末端操作两种。它们只要有一下另种区别：</p><ul><li>中间操作返回惰性生成的一个新的序列，而末端序列则为其他普通的数据类型；</li><li>中间操作不会立刻执行代码，仅当执行了末端操作序列才会开始执行。</li></ul><p>常见的中间操作包括：map、fliter、first、last、take等；它们会序列提供数据变化过滤等增强功能基本上和kotlin提供的集合操作符有着相同的功能。</p><p>常见的末端操作有：toList、toMutableList、sum、count等。它们在提供序列操作功能的同时，还会触发序列的运行。</p><h3 id="Sequence源码分析"><a href="#Sequence源码分析" class="headerlink" title="Sequence源码分析"></a>Sequence源码分析</h3><p>上文对序列做了简单的入门介绍。接下来深入源码去了解一下Sequence的实现方式。</p><h3 id="Sequence是什么？"><a href="#Sequence是什么？" class="headerlink" title="Sequence是什么？"></a>Sequence是什么？</h3><p>Kotlin对的定义Sequence很简单：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Sequence &lt;out T&gt; &#123;</span><br><span class="line">    public operator fun iterator(): Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个接口，定义了一个返回Iterator的方法。接口本身只定义了Sequence具有返回一个迭代器的能力。具体的功能实现还是靠它的实现类完成。</p><p>可以概括一些：<strong>序列就是一个具备提供了迭代器能力的类。</strong></p><h3 id="序列的创建方式分析"><a href="#序列的创建方式分析" class="headerlink" title="序列的创建方式分析"></a>序列的创建方式分析</h3><p>结合上文中提到的序列的四种创建方式，我们依次分析一下它的创建流程。</p><p>我们首先以比较常用的通过Iterable转化获取序列，它需要借助<code>asSequence</code>方法分析一下，使用<code>listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</code>生成一个序列。调用链如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123;</span><br><span class="line">    return Sequence &#123; this.iterator() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程很简单，一个扩展函数加一个内联函数。最终通过匿名内部类的方式创建一个Sequence并返回。代码很好理解，实际上它的实现逻辑等同于下面的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val sequence = MySequence(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).iterator())</span><br><span class="line"></span><br><span class="line">class MySequence&lt;T&gt;(private val iterator:Iterator&lt;T&gt;):Sequence&lt;T&gt;&#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; &#123;</span><br><span class="line">        return iterator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看一下通过调用顶级函数<code>sequenceOf</code>实现，以<code>sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</code>为例，它的调用逻辑如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; sequenceOf(vararg elements: T): Sequence&lt;T&gt; = if (elements.isEmpty()) emptySequence() else elements.asSequence()</span><br></pre></td></tr></table></figure><p>可以看到依旧是借助asSequence实现的。</p><p>接下来看一下代码块和generateSequence的实现方式，这两个方式会比较复杂一点，毕竟前面两个都是借助List进行转换，而List本身就能提供迭代器Iterator。后面两个明显需要提供新的迭代器。 首先看一下代码看的实现方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequence &#123;</span><br><span class="line">        repeat(100) &#123;</span><br><span class="line">            yield(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中sequence的调用逻辑如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; iterator(block) &#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T&gt; iterator(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123;</span><br><span class="line">    //创建迭代器</span><br><span class="line">    val iterator = SequenceBuilderIterator&lt;T&gt;()</span><br><span class="line">    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)</span><br><span class="line">    return iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现：该方法和asSequence一样最终也是通过匿名内部类的方式创建了一个Sequence。不过区别在于，该方法需要创建一个新的迭代器，也就是<code>SequenceBuilderIterator</code> 。同样以MySequence为例，它的创建流程等同于一下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun mian()&#123;</span><br><span class="line">    create&lt;Int&gt; &#123; myblock() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun  SequenceScope&lt;Int&gt;.myblock()&#123;</span><br><span class="line">    repeat(100) &#123;</span><br><span class="line">        yield(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;Int&gt; create(block: suspend SequenceScope&lt;Int&gt;.() -&gt; Unit):Sequence&lt;Int&gt;&#123;</span><br><span class="line">    val iterator = SequenceBuilderIterator&lt;Int&gt;()</span><br><span class="line">    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)</span><br><span class="line">    return MySequence(iterator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这是不可能实现的，因为SequenceBuilderIterator是被private修饰了，我们是无法直接访问的。这里强制写出来演示一下它的流程。</p><p>最后看一下通过generateSequence方法创建序列的源码，一共有三个：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T : Any&gt; generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; =</span><br><span class="line">    GeneratorSequence(seedFunction, nextFunction)</span><br><span class="line"></span><br><span class="line">public fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; =</span><br><span class="line">    if (seed == null)</span><br><span class="line">        EmptySequence</span><br><span class="line">    else</span><br><span class="line">        GeneratorSequence(&#123; seed &#125;, nextFunction)</span><br><span class="line"></span><br><span class="line">public fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; &#123;</span><br><span class="line">    return GeneratorSequence(nextFunction, &#123; nextFunction() &#125;).constrainOnce()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是创建了<code>GeneratorSequence</code>的一个实例并返回，而<code>GeneratorSequence</code>实现了<code>Sequence</code>接口并重写了<code>iterator()</code>方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class GeneratorSequence&lt;T : Any&gt;(private val getInitialValue: () -&gt; T?, private val getNextValue: (T) -&gt; T?) : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123;</span><br><span class="line">        var nextItem: T? = null</span><br><span class="line">        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue</span><br><span class="line"></span><br><span class="line">        private fun calcNext() &#123;</span><br><span class="line">            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)</span><br><span class="line">            nextState = if (nextItem == null) 0 else 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun next(): T &#123;</span><br><span class="line">            if (nextState &lt; 0)</span><br><span class="line">                calcNext()</span><br><span class="line"></span><br><span class="line">            if (nextState == 0)</span><br><span class="line">                throw NoSuchElementException()</span><br><span class="line">            val result = nextItem as T</span><br><span class="line">            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue</span><br><span class="line">            nextState = -1</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun hasNext(): Boolean &#123;</span><br><span class="line">            if (nextState &lt; 0)</span><br><span class="line">                calcNext()</span><br><span class="line">            return nextState == 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下Sequence的创建大致可以分为三类：</p><ul><li>使用List自带的迭代器通过匿名的方式创建Sequence实例，<code>sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</code>和<code>listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</code>就是这种方式；</li><li>创建新的<code>SequenceBuilderIterator</code>迭代器，并通过匿名的方式创建Sequence实例。例如使用代码块的创建方式。</li><li>创建<code>GeneratorSequence</code>，通过重写iterator()方法，使用匿名的方式创建Iterator。GeneratorSequence方法就是采用的这种方式。</li></ul><p>看完创建方式，也没什么奇特的，就是一个提供迭代器的普通类。还是看不出是如何惰性执行操作的。接下来就分析一下惰性操作的原理。</p><h3 id="序列的惰性原理"><a href="#序列的惰性原理" class="headerlink" title="序列的惰性原理"></a>序列的惰性原理</h3><p>以最常用的map操作符为例：普通的集合操作源码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;</span><br><span class="line">    //出啊年一个新的ArrayList，并调用mapTo方法</span><br><span class="line">    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123;</span><br><span class="line">    //遍历原始的集合，进行变换操作，然后将变换后的数据依次加入到新创建的集合</span><br><span class="line">    for (item in this)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    //返回新集合    </span><br><span class="line">    return destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：当List.map被调用后，便会立即创建新的集合，然后遍历老数据并进行变换操作。最后返回一个新的数据。这印证了上面提到的普通集合的操作时按照步骤且会立刻执行的理论。</p><p>接下来看一下序列的map方法，它的源码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123;</span><br><span class="line">    return TransformingSequence(this, transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal class TransformingSequence&lt;T, R&gt;</span><br><span class="line">constructor(private val sequence: Sequence&lt;T&gt;, private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123;</span><br><span class="line">          //注释一：TransformingSequence的iterator持有上一个序列的迭代器</span><br><span class="line">        val iterator = sequence.iterator()</span><br><span class="line">        override fun next(): R &#123;</span><br><span class="line">            //注释二：在开始执行迭代时，向上调用前一个序列的迭代器。</span><br><span class="line">            return transformer(iterator.next())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun hasNext(): Boolean &#123;</span><br><span class="line">            return iterator.hasNext()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123;</span><br><span class="line">        return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码并不复杂，它接收用户提供的变换函数和序列，然后创建了一个TransformingSequence并返回。TransformingSequence本身和上文中提到的序列没什么区别，唯一的区别在于它的迭代器：在通过next依次取数据的时候，并不是直接返回元素。而是先调用调用者提供的函数进行变换。返回变换后的数据——这也没什么新鲜的，和普通集合的map操作符和RxJava的Map都是同样的原理。</p><p>但是，这里却又有点不一样。<strong>操作符里没有任何开启迭代的代码，它只是对序列以及迭代进行了嵌套处理，并不会开启迭代.如果用户不手动调用（后者间接调用）迭代器的next函数，序列就不会被执行</strong>——这就是惰性执行的机制的原理所在。</p><p>而且，由于操作符返回的是一个Sequence类型的值，当你重复不断调用map时，例如下面的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(0..10).asSequence().map&#123;add(it)&#125;.map&#123;add(it)&#125;.map&#123;add(it)&#125;.toList()</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line"></span><br><span class="line">val sequence1 = (0..10).asSequence()</span><br><span class="line">val sequence2 = sequence1.map &#123; it+1 &#125;</span><br><span class="line">val sequence3 = sequence2.map &#123; it+1 &#125;</span><br><span class="line">sequence3.toList()</span><br></pre></td></tr></table></figure><p>最终，序列sequence3的结构持有如下：sequence3-&gt; sequence2 -&gt; sequence1。而它们都有各自的迭代器。迭代器里都重写了各自的变换逻辑:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun next(): R &#123;</span><br><span class="line">    return transformer(iterator.next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//由于这里都是执行的+1操作，所以变换逻辑transformer可以认为等同于如下操作:</span><br><span class="line"></span><br><span class="line">override fun next(): R &#123;</span><br><span class="line">    return iterator.next()+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当我们通过<code>sequence3.toList</code>执行代码时，它的流程如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123;</span><br><span class="line">    return this.toMutableList().optimizeReadOnlyList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T&gt; Sequence&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123;</span><br><span class="line">    //末端操作符，此处才会开始创建新的集合</span><br><span class="line">    return toCollection(ArrayList&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123;</span><br><span class="line">    //执行迭代器next操作</span><br><span class="line">    //当调用（末端操作符）走到这里时，便会和普通结合的操作符一样</span><br><span class="line">    //此时为新创建的集合赋值</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        destination.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">    return destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过几次扩展函数调用，最终在toCollection里开始执行迭代(Iterator的典型的操作)，也就是获取了sequence3的iterator实例，并不断通过next取出数据。而在上文中的TransformingSequence源码里可以看到，TransformingSequence会持有上一个迭代器的实例（代码注释一）。</p><p>并且在迭代开始后，在进行transformer操作（也就是执行+1操作）前，会调用上一个迭代器的next方法进行迭代（代码注释二）。这样不断的迭代，最终，最终会调用到sequence1的next方法。再结合上文中的序列创建里的分析——sequence1里所持有的迭代器就是就是原始数据里的迭代器。</p><p>那么当最终执行toList方法时，它会循环<code>sequence3.iterator</code>方法。而在每次循环内，都会首先执行sequence3所持有的sequence2.iterator的next方法。sequence2依次类推执行到sequence1的sequence1.iterator&#96;方法，最终执行到我们原始数组的迭代器next方法：</p><p>整个流程如下：</p><p><img src="https://pic2.zhimg.com/80/v2-d8485553b786d4cb8def81a27cffd361_1440w.webp" alt="img"></p><p>原理就是这么简单：中间操作符通过序列嵌套，实现对迭代器iterator的嵌套。这样在进行迭代的时候，会依次调用各个iterator迭代器直到调用到原始集合数据里的迭代器开始并返回元素。而当元素返回时，会依次执行各个迭代器持有变换操作方法实现对数据的变换。</p><p><img src="https://pic4.zhimg.com/80/v2-e34ba780f0b283f6fc8b6a9fb52f5243_1440w.webp" alt="img"></p><p>而其他操作符，也是遵循这个基本的规则。无非就是增加一些其他的操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>序列通过中间操作符对迭代器进行嵌套和复写，以此实现按元素操作执行变换；</li><li>中间操作符只负责根据需求创建并嵌套迭代器，并不负责开启迭代器。以此实现惰性操作且不产生临时集合；</li><li>末端操作符负责开启迭代，按照嵌套顺序执行迭代操作。依次获取操作后的数据，并且会创建新的集合用来存储最终数据；</li><li>序列不是万能的，因为要引入新的对象。在带来惰性和顺序执行的优势时，这些对象必然会带来性能开销。所以要依需求在集合和序列之间进行选择，使用合适的方式进行迭代。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.0 - Kotlin 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized 关键字为什么会引入锁的竞争</title>
      <link href="/2023/08/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/"/>
      <url>/2023/08/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>synchronized</code> 关键字用于实现线程同步，它可以保证在同一时间只有一个线程能够执行被 <code>synchronized</code> 修饰的代码块或方法。当一个线程获取了对象的锁，其他线程需要等待该线程释放锁才能继续执行。</p><p>当多个线程同时竞争同一个锁时，就会发生锁的竞争。这种竞争会导致多个线程按顺序排队等待锁的释放，从而引入性能问题。具体来说，锁的竞争可能导致以下情况：</p><ol><li>线程争用：多个线程同时竞争同一个锁，会导致线程进行上下文切换，从而增加了线程切换的开销。</li><li>阻塞等待：当一个线程获取了锁，其他线程需要等待，直到该线程释放锁。这会导致其他线程阻塞，降低了并发性能。</li><li>锁饥饿：如果某个线程频繁地获取锁，其他线程无法获得执行的机会，会导致其他线程长时间等待锁，造成锁饥饿的情况。</li></ol><p>因此，当多个线程同时竞争同一个锁时，就会引入锁的竞争问题，进而影响程序的性能。在高并发场景中，合理设计并发控制机制，避免不必要的锁竞争，可以提高程序的并发性能。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java.util.Stack 类为什么是线程安全的</title>
      <link href="/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/"/>
      <url>/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在Java中，<code>java.util.Stack</code> 类是线程安全的，这是因为它是通过在每个方法上添加<code>synchronized</code>关键字来实现同步的。<br><code>synchronized</code>关键字可以确保在同一时间只有一个线程可以访问被标记为<code>synchronized</code>的方法或代码块。<br>当一个线程执行一个被<code>synchronized</code>关键字修饰的方法时，它将获得一个锁，其他线程必须等待该锁释放才能访问相同的方法。<br>这样可以确保在任何给定的时刻只有一个线程可以修改<code>Stack</code>的状态，从而防止并发访问导致的数据不一致或竞态条件。<br>然而，需要注意的是，虽然<code>Stack</code>类本身是线程安全的，但在某些情况下，使用<code>synchronized</code>关键字可能会降低性能，特别是在高并发环境下。<br>因此，在Java中，推荐使用<code>java.util.concurrent</code>包提供的并发集合类，如<code>java.util.concurrent.ArrayDeque</code>或<code>java.util.concurrent.LinkedBlockingDeque</code>，它们提供了更高效和灵活的线程安全操作。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Stack 过时了吗</title>
      <link href="/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/"/>
      <url>/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在 Java 中，<code>Stack</code> 类并没有过时，仍然可以使用。然而，根据 Java 官方文档的建议，推荐使用 <code>Deque</code> 接口的实现类 <code>ArrayDeque</code> 来代替 <code>Stack</code>。</p><p><code>Stack</code> 类是基于向量（<code>Vector</code>）实现的，而 <code>Vector</code> 是线程安全的、同步的，因此在性能上可能会有一些开销。而 <code>ArrayDeque</code> 是基于数组实现的双端队列，性能更高，并且在大多数情况下能够提供与 <code>Stack</code> 类相同的功能。</p><p>此外，<code>Deque</code> 接口提供了更丰富的操作方法，例如在队首或队尾插入、删除元素等，使得其更灵活且更符合现代编程的需求。</p><p>因此，尽管 <code>Stack</code> 类仍然可用，但在新的代码中，推荐使用 <code>ArrayDeque</code> 或其他实现了 <code>Deque</code> 接口的类来代替 <code>Stack</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略</title>
      <link href="/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/"/>
      <url>/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayDeque-和-java-util-Stack-和-MutableList-的区别是什么"><a href="#ArrayDeque-和-java-util-Stack-和-MutableList-的区别是什么" class="headerlink" title="ArrayDeque 和 java.util.Stack 和 MutableList 的区别是什么"></a><code>ArrayDeque</code> 和 <code>java.util.Stack</code> 和 <code>MutableList</code> 的区别是什么</h3><p><code>ArrayDeque</code>、<code>java.util.Stack</code> 和 <code>MutableList</code>（如 <code>ArrayList</code>）是实现栈的不同方式，它们有一些区别：</p><ol><li>实现接口：<code>ArrayDeque</code> 实现了 <code>Deque</code> 接口，而 <code>java.util.Stack</code> 继承自 <code>Vector</code> 类，<code>MutableList</code> 则是 Kotlin 标准库中的可变列表接口。</li><li>内部数据结构：<code>ArrayDeque</code> 使用循环数组（circular array）作为内部数据结构，而 <code>java.util.Stack</code> 内部使用数组（Array），<code>MutableList</code> 则可以使用数组、链表或其他数据结构。</li><li>动态扩容：<code>ArrayDeque</code> 和 <code>MutableList</code> 都支持动态扩容，可以根据需要自动调整容量，而 <code>java.util.Stack</code> 不支持动态扩容，需要手动调整容量。</li><li>性能：<code>ArrayDeque</code> 在大多数操作上具有更好的性能，因为它使用了循环数组和更优化的实现。而 <code>java.util.Stack</code> 是一个遗留类，性能可能相对较差。<code>MutableList</code> 的性能取决于具体实现。</li></ol><p>综上所述，如果你想要使用性能较好且功能丰富的栈实现，推荐使用 <code>ArrayDeque</code>。如果你需要与现有的代码兼容或使用特定的接口，可以选择 <code>java.util.Stack</code> 或 <code>MutableList</code>。</p><h1 id="ArrayDeque-怎么用循环数组实现的"><a href="#ArrayDeque-怎么用循环数组实现的" class="headerlink" title="ArrayDeque 怎么用循环数组实现的"></a>ArrayDeque 怎么用循环数组实现的</h1><p><code>ArrayDeque</code> 使用循环数组（circular array）实现，它在内部维护了一个固定大小的数组来存储元素。下面是简单介绍 <code>ArrayDeque</code> 如何使用循环数组实现的一些关键点：</p><ol><li>内部数组：<code>ArrayDeque</code> 内部有一个对象数组来存储元素，通常使用 <code>elements</code> 或 <code>array</code> 字段表示。</li><li>头部和尾部指针：<code>ArrayDeque</code> 有两个指针，分别指向头部和尾部。通常使用 <code>head</code> 和 <code>tail</code> 字段表示。</li><li>循环数组特性：<code>ArrayDeque</code> 的关键之处在于利用循环数组的性质。当头部或尾部指针到达数组的边界时，它们会回绕到数组的另一侧，形成循环效果。</li><li>扩容和缩容：当元素数量达到数组容量时，<code>ArrayDeque</code> 会自动扩容。在扩容时，会创建一个更大的数组，并将原始数组中的元素按照循环顺序复制到新数组中。类似地，当元素数量较少时，<code>ArrayDeque</code> 也会自动缩容。</li><li>添加和移除元素：添加元素时，头部指针向前移动一个位置，并将元素放入头部位置。移除元素时，头部指针向后移动一个位置，并返回头部位置的元素。</li></ol><p>通过这种方式，<code>ArrayDeque</code> 可以在不断添加和移除元素的过程中高效地利用数组空间，并保持循环数组的特性。这使得 <code>ArrayDeque</code> 在栈和队列等数据结构的实现中具有较高的性能和灵活性。</p><h3 id="ArrayList-和-ArrayDeque-的区别"><a href="#ArrayList-和-ArrayDeque-的区别" class="headerlink" title="ArrayList 和 ArrayDeque 的区别"></a>ArrayList 和 ArrayDeque 的区别</h3><p>两种实现之间的主要区别在于调整大小的策略。</p><p>ArrayList 的调整大小策略是将其调整为 oldCapacity + (oldCapacity &gt;&gt; 1) 的新大小，增加了约 50%。默认容量为 10，在调整大小后的容量为 15、22、33、49、73、109、163、244、366…</p><p>ArrayDeque 总是调整为 2 的幂次方。在调整大小时，容量会加倍。从默认值 16 开始，调整大小后的容量为 32、64、128、256…</p><p>因此，ArrayDeque 达到了更高的容量，而调整大小的操作更少，这是因为数组的复制操作很耗费资源。例如，要在默认大小的 ArrayList 中存储 256，需要进行 9 次调整大小操作，而 ArrayDeque 只需要 4 次。数组的复制操作可能很快，但也可能需要 GC 来释放一些空间用于新的数据集，此外还需要进行内存复制操作（ArrayDeque 可能在这方面表现更好，因为它对齐到 2 的幂次方）。</p><p>这两种数据结构的最佳情况复杂度为 O(1)。ArrayList 的 push 和 pop 操作通过直接访问头部和尾部（ArrayDeque）来实现，而 add 和 removeLast 操作（ArrayList）则是通过直接访问大小来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque 的接口</title>
      <link href="/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/08/11/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>ArrayDeque</code> 实现了 <code>Deque</code> 接口，该接口继承自 <code>Queue</code> 接口。下面是 <code>Deque</code> 接口中定义的一些主要方法：</p><ol><li><p>添加元素操作：</p><ul><li><code>addFirst(element: E)</code>：将元素添加到双端队列的开头。</li><li><code>addLast(element: E)</code>：将元素添加到双端队列的末尾。</li><li><code>offerFirst(element: E)</code>：将元素添加到双端队列的开头，并返回是否成功。</li><li><code>offerLast(element: E)</code>：将元素添加到双端队列的末尾，并返回是否成功。</li></ul></li><li><p>获取元素操作：</p><ul><li><code>getFirst(): E</code>：获取双端队列的第一个元素，但不删除它。</li><li><code>getLast(): E</code>：获取双端队列的最后一个元素，但不删除它。</li><li><code>peekFirst(): E</code>：获取双端队列的第一个元素，如果队列为空则返回 null。</li><li><code>peekLast(): E</code>：获取双端队列的最后一个元素，如果队列为空则返回 null。</li></ul></li><li><p>移除元素操作：</p><ul><li><code>removeFirst(): E</code>：移除并返回双端队列的第一个元素。</li><li><code>removeLast(): E</code>：移除并返回双端队列的最后一个元素。</li><li><code>pollFirst(): E</code>：移除并返回双端队列的第一个元素，如果队列为空则返回 null。</li><li><code>pollLast(): E</code>：移除并返回双端队列的最后一个元素，如果队列为空则返回 null。</li></ul></li></ol><p>此外，<code>ArrayDeque</code> 还实现了 <code>Queue</code> 接口中定义的方法，如 <code>offer(element: E)</code>、<code>remove(): E</code>、<code>poll(): E</code> 等。</p><p>需要注意的是，<code>ArrayDeque</code> 是一个可变大小的数组双端队列，可以在队列的两端进行高效的插入和删除操作，同时也支持随机访问。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6. N 字形变换</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li><li><code>1 &lt;= numRows &lt;= 1000</code></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">重点不在字形，重点在变换是什么变换</span><br><span class="line">关键词：</span><br><span class="line">一维函数变二维函数</span><br><span class="line">往复变化函数</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>我们思考，为什么这个算法难写<br>分析 <code>N字形</code> 的离散函数，我们面临着一个唯一的 <code>x</code> 对应着 1- N 个 <code>y</code><br>在 <code>x</code> 变化的时候，我们首先要算该 <code>x</code> 对应了几个 <code>y</code><br>这根本不符合函数的定义<br><code>函数是指一个集合中的每个元素都有且仅有一个映射到另一个集合中的元素，这种关系被称为函数映射</code></p><p>推出我们需要把一个一维度线性离线函数 s &#x3D; f(n) 变成二维离散函数 s &#x3D; g(x, y)<br>注意，这里好玩的是 y 和 x 其实是数列<br>即 s &#x3D; g(x(n), y(n))<br>我们开始推导</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x(n) = x(n-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">函数 x(n) 很简单，我们怎么表达 y(n) 呢</span><br><span class="line">我们发现 y(n) 是一个往复的等差数列</span><br><span class="line">对于本题有</span><br><span class="line">y(n) = y(n - <span class="number">1</span>) + step(n)</span><br><span class="line">step 是一个往复函数</span><br><span class="line">用 flag 代表往复函数的方向</span><br><span class="line"> |-<span class="number">1</span>  当 y(n - <span class="number">1</span>) 到达最大值或者最小值时</span><br><span class="line">flag = | <span class="number">1</span>  其他</span><br><span class="line">step(n) = flag * step(n-<span class="number">1</span>)当 y(n - <span class="number">1</span>) 到达最大值或者最小值时</span><br><span class="line"> |-step(n-<span class="number">1</span>)其他</span><br><span class="line">step(n) = |step(n)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">convert</span><span class="params">(s: <span class="type">String</span>, numRows: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        推出 (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">val</span> rows: MutableList&lt;StringBuilder&gt; = ArrayList()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until numRows) rows.add(StringBuilder())</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> step = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s.toCharArray()) &#123;</span><br><span class="line">            rows[i].append(c)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) step = -step</span><br><span class="line">            i += step</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> res = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> rows) res.append(row)</span><br><span class="line">        <span class="keyword">return</span> res.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法题目 </category>
          
          <category> 0.1.1 - 中等 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. 最长回文子串</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">介绍 Manacher 算法</span><br><span class="line">理解回文串的对称性，减少与回文串相交的字符串的计算量</span><br><span class="line">关键词</span><br><span class="line">情况一：完全包含，直接赋值</span><br><span class="line">情况二：部分相交。直接从后一位接续计算</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>数据预处理： 首先回文子串有两种形式 奇数 与 偶数 也就有两种对应的指针操作方式</p><p>假定有字符数组 ababaabc 改成 # a # b # a # b # a # a # b # c # 将偶数数组变成奇数统一处理 索性改成 ^ # a # b # a # b # a # a # b # c # $，头尾清晰<br>这样就可以通过把每个字符作为回文子串的中心向两边扩展，找出最长回文子串 时间复杂度是 O(n^2)</p><p>现在需要我们观察回文子串的规律，简化计算</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">      ^ # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # c # $</span><br><span class="line"><span class="number">0</span>     ^                                      <span class="selector-tag">P</span><span class="selector-attr">[0]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">1</span>       ^                                    <span class="selector-tag">P</span><span class="selector-attr">[1]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>       --^--                                <span class="selector-tag">p</span><span class="selector-attr">[2]</span>  = <span class="number">1</span></span><br><span class="line"><span class="number">3</span>           ^                                <span class="selector-tag">P</span><span class="selector-attr">[3]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">5</span>               ^                            <span class="selector-tag">P</span><span class="selector-attr">[5]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span></span><br><span class="line"><span class="number">7</span>                   ^                        <span class="selector-tag">P</span><span class="selector-attr">[7]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">9</span>                       ^                    <span class="selector-tag">P</span><span class="selector-attr">[9]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">11</span>                  --------^--------        <span class="selector-tag">P</span><span class="selector-attr">[11]</span> = <span class="number">2</span></span><br><span class="line"><span class="number">12</span>                          --^--            <span class="selector-tag">P</span><span class="selector-attr">[12]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">13</span>                              ^            <span class="selector-tag">P</span><span class="selector-attr">[13]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">14</span>                              --^--        <span class="selector-tag">P</span><span class="selector-attr">[14]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">15</span>                                  ^        <span class="selector-tag">P</span><span class="selector-attr">[15]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">16</span>                                  --^--    <span class="selector-tag">P</span><span class="selector-attr">[16]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">17</span>                                      ^    <span class="selector-tag">P</span><span class="selector-attr">[17]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">18</span>                                        ^  <span class="selector-tag">P</span><span class="selector-attr">[18]</span> = <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>情况一：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">11</span>                  --------^--------        <span class="selector-tag">P</span><span class="selector-attr">[11]</span> = <span class="number">2</span></span><br><span class="line"><span class="number">12</span>                          --^--            <span class="selector-tag">P</span><span class="selector-attr">[12]</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>第 10 行，第 12 行 都是 第 11 行 的子串，完全包含在 第 11 行 之中，由于回文串的对称性 此时直接有 P[10] &#x3D; P[12]</p><p>情况二：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span></span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>第 4 行，第 8 行 都是 第 6 行 的子串，分别位于字符串的两端，当我们知道 第 4 行 的信息之后，我们知道 第 8 行 至少有 第 4 行 那么长，至于会不会更长，继续试着向两边扩展即可 此时需要干两件事 1. 将 P[8] &#x3D; P[4]; 2. 继续向外扩展</p><p>情况三： 8 ——^—— P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 第 8 行 部分与 第 11 行 重叠，第 14 行 是 第 11 行 的子串，非常简单，舍弃超出部分 8 –^– P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 当成这样处理即可 定义遍历指针 i ，指向回文的中心的指针 center 和 指向回文串右边界的指针 r 此时需要干两件事 1. 将 P[8] &#x3D; r - i ; 2. 继续向外扩展</p><p>好，我们现在已经理解了 Manacher 算法的精髓了 我们思考一下算法该怎么写</p><p>P[i] 计算过程</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">      ^ # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # c # $</span><br><span class="line"><span class="number">0</span>     ^                                      <span class="selector-tag">P</span><span class="selector-attr">[0]</span>  = <span class="number">0</span>  -- 起始，不必计算，更新 r</span><br><span class="line"><span class="number">1</span>       ^                                    <span class="selector-tag">P</span><span class="selector-attr">[1]</span>  = <span class="number">0</span>  -- 暴力计算，一次计算，更新 r</span><br><span class="line"><span class="number">2</span>       --^--                                <span class="selector-tag">p</span><span class="selector-attr">[2]</span>  = <span class="number">1</span>  -- 暴力计算，二次计算，更新 r</span><br><span class="line"><span class="number">3</span>           ^                                <span class="selector-tag">P</span><span class="selector-attr">[3]</span>  = <span class="number">0</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span>  -- 暴力计算，四次计算，更新 r</span><br><span class="line"><span class="number">5</span>               ^                            <span class="selector-tag">P</span><span class="selector-attr">[5]</span>  = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span>  -- 情况二，六次计算，更新 r</span><br><span class="line"><span class="number">7</span>                   ^                        <span class="selector-tag">P</span><span class="selector-attr">[7]</span>  = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">9</span>                       ^                    <span class="selector-tag">P</span><span class="selector-attr">[9]</span>  = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">11</span>                  --------^--------        <span class="selector-tag">P</span><span class="selector-attr">[11]</span> = <span class="number">2</span>  -- 情况二，五次计算，更新 r</span><br><span class="line"><span class="number">12</span>                          --^--            <span class="selector-tag">P</span><span class="selector-attr">[12]</span> = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">13</span>                              ^            <span class="selector-tag">P</span><span class="selector-attr">[13]</span> = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">14</span>                              --^--        <span class="selector-tag">P</span><span class="selector-attr">[14]</span> = <span class="number">1</span>  -- 情况三，一次计算</span><br><span class="line"><span class="number">15</span>                                  ^        <span class="selector-tag">P</span><span class="selector-attr">[15]</span> = <span class="number">0</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">16</span>                                  --^--    <span class="selector-tag">P</span><span class="selector-attr">[16]</span> = <span class="number">1</span>  -- 暴力计算，两次计算，更新 r</span><br><span class="line"><span class="number">17</span>                                      ^    <span class="selector-tag">P</span><span class="selector-attr">[17]</span> = <span class="number">0</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">18</span>                                        ^  <span class="selector-tag">P</span><span class="selector-attr">[18]</span> = <span class="number">0</span>  -- 终止</span><br></pre></td></tr></table></figure><p>我列出了每次计算面对的情况，计算的次数以及是否需要 r 我希望大家思考 当新计算出的 r 与旧的 r 相等时，是否应该更新 center ？ 当然不应该，我们肯定更倾向于选择更长的回文串</p><p>是这样吗？ 我们思考一种情况</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>       --^--                                <span class="selector-tag">p</span><span class="selector-attr">[2]</span>  = <span class="number">1</span></span><br><span class="line"><span class="number">3</span>           ^                                <span class="selector-tag">P</span><span class="selector-attr">[3]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">5</span>               ^                            <span class="selector-tag">P</span><span class="selector-attr">[5]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span></span><br><span class="line"><span class="number">7</span>                   ^                        <span class="selector-tag">P</span><span class="selector-attr">[7]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">9</span>                       ^                    <span class="selector-tag">P</span><span class="selector-attr">[9]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>第 6 行 较长有什么用呢，有用的只是 i 到 r 这一小截而已，不更新是因为都一样，没必要更新，所以只有当我们发现了更右边的 r 更新即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private fun formatString(s: String): String&#123;</span><br><span class="line">        val tString : StringBuffer = <span class="built_in">StringBuffer</span>(<span class="string">&quot;^#&quot;</span>)</span><br><span class="line">        for ( i in s.indices )&#123;</span><br><span class="line">            tString<span class="selector-class">.append</span>(s<span class="selector-attr">[i]</span>)</span><br><span class="line">            tString<span class="selector-class">.append</span>(&#x27;#&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        return tString<span class="selector-class">.append</span>(&#x27;$&#x27;)<span class="selector-class">.toString</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun extend(s: String, leftIndex: Int, rightIndex: Int): Int &#123;</span><br><span class="line">        <span class="selector-tag">var</span> r = <span class="number">0</span></span><br><span class="line">        <span class="selector-tag">var</span> <span class="attribute">left</span> = leftIndex</span><br><span class="line">        <span class="selector-tag">var</span> <span class="attribute">right</span> = rightIndex</span><br><span class="line">        while (<span class="attribute">left</span> &gt; <span class="number">0</span> &amp;&amp; <span class="attribute">right</span> &lt; s<span class="selector-class">.length</span> &amp;&amp; s<span class="selector-attr">[left]</span> == s<span class="selector-attr">[right]</span>)&#123;</span><br><span class="line">           r ++</span><br><span class="line">           <span class="attribute">left</span> --</span><br><span class="line">           <span class="attribute">right</span> ++</span><br><span class="line">        &#125;</span><br><span class="line">        return r</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun longestPalindrome(s: String): String &#123;</span><br><span class="line">        val tString = formatString(s)</span><br><span class="line">        <span class="selector-tag">var</span> maxR = <span class="number">0</span></span><br><span class="line">        <span class="selector-tag">var</span> maxCenter = <span class="number">0</span></span><br><span class="line">        <span class="selector-tag">var</span> center = -<span class="number">1</span></span><br><span class="line">        <span class="selector-tag">var</span> R = <span class="number">0</span></span><br><span class="line">        val <span class="selector-tag">p</span> = Array&lt;Int&gt;(tString<span class="selector-class">.length</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">    </span><br><span class="line">        for ( <span class="selector-tag">i</span> in tString<span class="selector-class">.indices</span> )&#123;</span><br><span class="line">            val iMirror = center - (<span class="selector-tag">i</span> - center)</span><br><span class="line">            <span class="selector-tag">var</span> rightIndex = <span class="selector-tag">i</span></span><br><span class="line">            <span class="selector-tag">var</span> leftIndex = <span class="selector-tag">i</span></span><br><span class="line">            val maxLength = R - <span class="selector-tag">i</span></span><br><span class="line">    </span><br><span class="line">            val hasMirrorIndex = <span class="selector-tag">i</span> &lt; R &amp;&amp; center - maxLength &gt; <span class="number">0</span></span><br><span class="line">            val case1CompletelyIncluded = hasMirrorIndex &amp;&amp; <span class="selector-tag">i</span> &gt; center &amp;&amp; <span class="selector-tag">p</span><span class="selector-attr">[iMirror]</span> &lt; R - <span class="selector-tag">i</span></span><br><span class="line">            val case2NotCompletelyInclude = hasMirrorIndex &amp;&amp; !case1CompletelyIncluded</span><br><span class="line">            </span><br><span class="line">            if(!hasMirrorIndex)&#123;</span><br><span class="line">                <span class="selector-tag">p</span><span class="selector-attr">[i]</span> = <span class="number">0</span></span><br><span class="line">                rightIndex = <span class="selector-tag">i</span> + <span class="number">1</span></span><br><span class="line">                leftIndex = <span class="selector-tag">i</span> - <span class="number">1</span></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(case1CompletelyIncluded) &#123;</span><br><span class="line">                    <span class="selector-tag">p</span><span class="selector-attr">[i]</span> = <span class="selector-tag">p</span><span class="selector-attr">[iMirror]</span></span><br><span class="line">                    continue</span><br><span class="line">                &#125; else if (case2NotCompletelyInclude) &#123;</span><br><span class="line">                    <span class="selector-tag">p</span><span class="selector-attr">[i]</span> = maxLength</span><br><span class="line">                    rightIndex = R + <span class="number">1</span></span><br><span class="line">                    leftIndex = <span class="selector-tag">i</span> - (rightIndex - <span class="selector-tag">i</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">p</span><span class="selector-attr">[i]</span> += extend(tString, leftIndex, rightIndex)</span><br><span class="line">            </span><br><span class="line">            // 更新最右边的 R 和 center</span><br><span class="line">            if(<span class="selector-tag">i</span> + <span class="selector-tag">p</span><span class="selector-attr">[i]</span> &gt; R)&#123;</span><br><span class="line">                R = <span class="selector-tag">i</span> + <span class="selector-tag">p</span><span class="selector-attr">[i]</span></span><br><span class="line">                center = <span class="selector-tag">i</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 判断是不是最长的回文串</span><br><span class="line">            if(<span class="selector-tag">p</span><span class="selector-attr">[i]</span> &gt; maxR)&#123;</span><br><span class="line">                maxR = <span class="selector-tag">p</span><span class="selector-attr">[i]</span></span><br><span class="line">                maxCenter = <span class="selector-tag">i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if(maxR == <span class="number">0</span>) return &quot;&quot;</span><br><span class="line">    </span><br><span class="line">        val start = maxCenter - maxR</span><br><span class="line">        val end = maxCenter + maxR</span><br><span class="line">        return tString<span class="selector-class">.substring</span>(start.<span class="selector-class">.end</span>)<span class="selector-class">.replace</span>(&quot;#&quot;, &quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法题目 </category>
          
          <category> 0.1.1 - 中等 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 寻找两个正序数组的中位数</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">讨论在两个有序数组中寻找中位数的问题</span><br><span class="line"></span><br><span class="line">观察单个有序数组，通过比较元素大小找到舍弃的元素，确定中位数。</span><br><span class="line"></span><br><span class="line">类推两个有序数组，准备两个区间来存放偏小值和偏大值。</span><br><span class="line">根据区间需要满足必要条件，使得偏小区间的元素都小于偏大区间。</span><br><span class="line">问题转化为在单个有序数组中查找满足条件的关键元素位置，可以使用二分查找。</span><br><span class="line"></span><br><span class="line">关键词:</span><br><span class="line">偏小区间</span><br><span class="line">偏大区间</span><br><span class="line">二分查找</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先思考我们是否可以避免全排序找到中位数</p><p>我们有一种想法就是通过比较元素的大小找到需要舍弃的元素</p><p>我们观察一个有序数组，我们准备两个区间 RSmall, RBig 分别存放这个数组的偏小值与偏大值（相对中位数而言）</p><p>分别用 left，right 指针从两头操作偏小值与偏大值，将他们依次放入对应的数组</p><p>直到 「偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1」，中位数显然易得</p><p>好，现在我们来看两个有序数组的复杂情况</p><p>我们同样准备两个区间 RSmall, RBig，同样我们需要将数组偏小值放进 RSmall，偏大值放进 RBig</p><p>与一个有序数组不同的是，现在我们必须综合考虑两个有序数组的情况</p><p>所以 RSmall 区间里可能既包含 num1 数组的偏小元素也包含 num2 数组的偏小元素，对于RBig也是一样</p><p>这就让我们的思考变得复杂了，这使得 RSmall，RBig 变得无序</p><p>现在将这个 RSmall 再细分为 RSmallN1 区间，以及 RSmallN2 区间，同样有 RBigN1，RBigN2 区间</p><p>想要得到中位数，那么偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1</p><p>也就有</p><p>「 必要条件一： 偶数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size 奇数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size +1 」</p><p>同时 RSmall 区间内任何一个元素都必须小于 RBig 区间</p><p>自然有 Small 区间的子区间的任何一个元素都小于 Big 区间的子区间的任何一个元素</p><p>所以得到</p><p>「 必要条件二： RSmallN1 的最大值 &lt; RBigN1 的最小值 ( 因为数组有序，这是不用判断的 ) RSmallN1 的最大值 &lt; RBigN2 的最小值 RSmallN2 的最大值 &lt; RBigN1 的最小值 RSmallN2 的最大值 &lt; RBigN2 的最小值 ( 因为数组有序，这是不用判断的 )」</p><p>简化一下</p><p>「 必要条件二： maxOf( RSmallN1 ) &lt; minOf ( RBigN2 ) maxOf( RSmallN2 ) &lt; minOf ( RBigN1 ) 」</p><p>显然必要条件一加上必要条件二就是充分必要条件</p><p>现在我们要得到这四个区间，或者说要在两个有序数组分别划分出这四个区间</p><p>我们要在这两个数组中分别找到关键的那个分隔元素</p><p>因为必要条件一的原因，我们找到了 num1 数组的分割元素，我们也就找到了 num2 数组的分割元素</p><p>这非常好理解，因为 Small 区间和 Big 区间的数量是固定的，RSmallN1 多了一个元素，RSmallN2 就要对应减少一个元素</p><p>所以我们只要找到 num1 数组的分隔元素即可</p><p>至此，问题成功转化成了</p><p>在 num1 数组中查找出一个关键元素位置，这个关键元素满足上述两条必要条件</p><p>这是一个典型的有判断条件的查找问题，我们就可以使用二分查找，测试每个元素是否符合上述两个条件</p><p>关于二分查找这里不再赘述。</p><p>以下是基于二分查找的 Kotlin 代码实现，用于找出两个有序数组的中位数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数用于在两个已排序整数数组中找到它们的中位数，返回类型为 Double。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 nums1 和 nums2 的长度。</span></span><br><span class="line">    <span class="keyword">val</span> n1 = nums1.size</span><br><span class="line">    <span class="keyword">val</span> n2 = nums2.size</span><br><span class="line">    <span class="comment">// 如果 nums1 的长度大于 nums2，则交换它们，确保 nums1 的长度小于等于 nums2。</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 设置左右指针的初始值。</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span> <span class="comment">// 如果把 num1 和 num2 合并元素重新排序，最左边</span></span><br><span class="line">    <span class="keyword">var</span> right = n1 <span class="comment">// 如果把 num1 和 num2 合并元素重新排序，相当于 num2 最左边</span></span><br><span class="line">    <span class="comment">// 当左指针小于等于右指针时，执行二分查找。</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 因为 n1 &lt; n2</span></span><br><span class="line">        <span class="comment">// 计算 nums1 中间的索引 i 和 nums2 中间的索引 j。</span></span><br><span class="line">        <span class="keyword">val</span> num1HalfIndex = (left + right) / <span class="number">2</span> </span><br><span class="line">        <span class="keyword">val</span> num2HalfIndex = ((n1 + n2 + <span class="number">1</span>) / <span class="number">2</span>) - num1HalfIndex  </span><br><span class="line">        <span class="comment">// 计算 nums1 和 nums2 的左侧和右侧的最大值和最小值。</span></span><br><span class="line">        <span class="keyword">val</span> maxOfNum1SmallRange = <span class="keyword">if</span> (num1HalfIndex == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[num1HalfIndex - <span class="number">1</span>] <span class="comment">// nums1 小区间的最大值</span></span><br><span class="line">        <span class="keyword">val</span> minOfNum1BigRange = <span class="keyword">if</span> (num1HalfIndex == n1) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[num1HalfIndex] <span class="comment">// nums1 大区间的最小值</span></span><br><span class="line">        <span class="keyword">val</span> maxOfNum2SmallRange = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>] <span class="comment">// nums2 小区间的最大值</span></span><br><span class="line">        <span class="keyword">val</span> minOfNum2BigRange = <span class="keyword">if</span> (j == n2) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j] <span class="comment">// nums2 大区间的最小值</span></span><br><span class="line">        <span class="comment">// 如果满足条件，则返回中位数。</span></span><br><span class="line">        <span class="keyword">if</span> (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; <span class="comment">// num1小 &lt; num2大 &amp;&amp; num2小 &lt; num1大, 也就是说“小区间都小于大区间”</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">if</span> ((n1 + n2) % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果 nums1 和 nums2 的长度之和为偶数</span></span><br><span class="line">                <span class="comment">// 则返回左右两侧最大值和最小值的平均值。</span></span><br><span class="line">                (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / <span class="number">2.0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1 和 nums2 的长度之和为奇数，则返回左侧最大值。</span></span><br><span class="line">                maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; <span class="comment">// num1大 &lt; num2小</span></span><br><span class="line">            <span class="comment">// 如果 nums1 的左侧最大值大于 nums2 的右侧最小值，则需要将 num1HalfIndex 向左移动。</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   left   num1HalfIndex   right</span></span><br><span class="line"><span class="comment">                    |           |           |</span></span><br><span class="line"><span class="comment">                    1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">          1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                          |</span></span><br><span class="line"><span class="comment">                     num2HalfIndex</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            right = num1HalfIndex - <span class="number">1</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    num1HalfIndex </span></span><br><span class="line"><span class="comment">                   left   |   right</span></span><br><span class="line"><span class="comment">                    |     |     |</span></span><br><span class="line"><span class="comment">                    1 1 1 1 1 1 1 1 1 1 1 1 </span></span><br><span class="line"><span class="comment">          1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                                |</span></span><br><span class="line"><span class="comment">                           num2HalfIndex </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 nums2 的左侧最大值大于 nums1 的右侧最小值，则需要将 num1HalfIndex 向右移动。</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         left   num1HalfIndex   right</span></span><br><span class="line"><span class="comment">          |           |           |</span></span><br><span class="line"><span class="comment">          1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                  1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                                  |</span></span><br><span class="line"><span class="comment">                            num2HalfIndex</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            left = num1HalfIndex + <span class="number">1</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            留给大家画</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到中位数，则返回 0.0。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n1 = nums1.size</span><br><span class="line">    <span class="keyword">val</span> n2 = nums2.size</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = n1</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 因为 n1 &lt; n2</span></span><br><span class="line">        <span class="keyword">val</span> num1HalfIndex = (left + right) / <span class="number">2</span> </span><br><span class="line">        <span class="keyword">val</span> num2HalfIndex = ((n1 + n2 + <span class="number">1</span>) / <span class="number">2</span>) - num1HalfIndex  </span><br><span class="line">        <span class="keyword">val</span> maxOfNum1SmallRange = <span class="keyword">if</span> (num1HalfIndex == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[num1HalfIndex - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> minOfNum1BigRange = <span class="keyword">if</span> (num1HalfIndex == n1) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[num1HalfIndex]</span><br><span class="line">        <span class="keyword">val</span> maxOfNum2SmallRange = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> minOfNum2BigRange = <span class="keyword">if</span> (j == n2) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j]</span><br><span class="line">        <span class="keyword">if</span> (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">if</span> ((n1 + n2) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / <span class="number">2.0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123;</span><br><span class="line">            right = num1HalfIndex - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = num1HalfIndex + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留给大家一个问题，问 N 个有序数组的中位数怎么求？</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法题目 </category>
          
          <category> 0.1.2 - 困难 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">巧妙的使用 HashMap&lt;Char, Int&gt; 记录每个字符的最新的位置</span><br><span class="line">巧妙的确定了每个元素对应的滑动窗口的左边界</span><br><span class="line">关键词：</span><br><span class="line">HashMap &lt;Char, Int&gt;用以查找位置</span><br><span class="line">窗口长度不固定，遍历指针作为左边界</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>本题的巧妙在于使用 HashMap 和 遍历指针构建了一个滑动窗口</p><p>在寻找滑动窗口的时候，我们总是固定住一端位置去寻找另一端的位置，通常需要我们找到两个端点之间的关系</p><p>来分析滑动窗口的性质：左边届位置，右边界的位置，滑动窗口的长度<br>三者有以下这些关系：<code>滑动窗口的长度 = 滑动窗口右边届 - 滑动窗口左边界</code><br>无论算法如何变化，我们知二求一</p><p>我们分析，遍历指针和左右边界的关系有三<br>情况一：遍历指针是滑动窗口的左边界<br>情况二：遍历指针是滑动窗口的右边界<br>情况三：遍历指针在滑动窗口的中间</p><p>结合滑动窗口的性质<br>情况一：知道窗口的长度，以遍历指针为左边界<br>情况二：窗口长度不固定，新增的元素决定窗口的长度，也就是左边界的位置<br>情况三：对于滑动窗口算法，通常情况下遍历指针要么位于窗口的左边界，要么位于右边界，用于控制窗口的扩展和收缩。在常规的滑动窗口算法中，遍历指针并不位于窗口的中间位置。</p><p>显然这种是情况二</p><p>当滑动窗口的位置和长度变化受制于新增的元素时，我们将遍历指针设置为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">0</span> <span class="comment">// 最长不含重复字符子串的长度</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span> <span class="comment">// 窗口左边界</span></span><br><span class="line">        <span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;() <span class="comment">// 哈希表记录字符最后出现的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right <span class="keyword">in</span> s.indices)&#123;</span><br><span class="line">            <span class="keyword">val</span> char = s[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(char) &amp;&amp; map[char]!! &gt;= left)&#123;</span><br><span class="line">                left = (map[char]?: <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map[char] = right</span><br><span class="line">            maxLen = maxOf(maxLen, right - left + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法题目 </category>
          
          <category> 0.1.1 - 中等 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2. 两数相加</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">遍历两个链表，元素相加生成新列表。</span><br><span class="line">关键词：</span><br><span class="line">哨兵节点 val dummy = ListNode(0)</span><br><span class="line">关键返回值 dummy?.next</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="comment">// 定义两个指针 p1 和 p2，分别指向两个链表的头节点</span></span><br><span class="line">        <span class="keyword">var</span> p1 = l1</span><br><span class="line">        <span class="keyword">var</span> p2 = l2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个哨兵节点 dummy，作为结果链表的头节点</span></span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 定义一个节点 cur, 作为结果链表的尾节点</span></span><br><span class="line">        <span class="keyword">var</span> cur = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> x = p1?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> y = p2?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> sum = x + y + carry</span><br><span class="line">            carry = sum / <span class="number">10</span></span><br><span class="line">            sum = sum % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            cur?.next = ListNode(sum)</span><br><span class="line"></span><br><span class="line">            p1 = p1?.next</span><br><span class="line">            p2 = p2?.next</span><br><span class="line">            cur = cur?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cur?.next = ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy?.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法题目 </category>
          
          <category> 0.1.0 - 简单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1. 两数之和</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10^4</code></li><li><code>-109 &lt;= nums[i] &lt;= 10^9</code></li><li><code>-109 &lt;= target &lt;= 10^9</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键在于对 hashmap 查找时间复杂度 O(1) 的应用</span><br><span class="line">关键词：</span><br><span class="line">HashMap&lt;Key, Value&gt;</span><br><span class="line">hashmap.containsKey(Value)</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> hashmap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> nums.indices)&#123;</span><br><span class="line">            <span class="keyword">val</span> complement = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(complement))&#123;</span><br><span class="line">                <span class="keyword">return</span> intArrayOf(hashmap[complement]!!, i)</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i        </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> intArrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法题目 </category>
          
          <category> 0.1.0 - 简单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23. 构建前缀树（字典树）</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/23%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/23%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> children = HashMap&lt;<span class="built_in">Char</span>, TrieNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> isWord = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(char)) &#123;</span><br><span class="line">                node.children[char] = TrieNode()</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[char]!!</span><br><span class="line">        &#125;</span><br><span class="line">        node.isWord = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(word: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(char)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[char]!!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isWord</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startsWith</span><span class="params">(prefix: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(char)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[char]!!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22. 动态规划-自顶向下法</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/22%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B3%95/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/22%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dp</span><span class="params">(n: <span class="type">Int</span>, memo: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否已经计算过该值</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        memo[n] = n</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归计算并保存结果</span></span><br><span class="line">    memo[n] = dp(n - <span class="number">1</span>, memo) + dp(n - <span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21. 回溯</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/21%20%E5%9B%9E%E6%BA%AF/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/21%20%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否达到结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (满足结束条件) &#123;</span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">        处理结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可能的选择</span></span><br><span class="line">    <span class="keyword">for</span> (选择 <span class="keyword">in</span> 可选列表) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        做选择</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(...)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20. 二分查找-贪心问题</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            nums[mid] == target -&gt; <span class="keyword">return</span> mid</span><br><span class="line">            nums[mid] &lt; target -&gt; left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. 二分查找-重复元素，最右边的插入点</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/19%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/19%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchInsert</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> result = nums.size <span class="comment">// 默认插入到最右边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 找到目标元素，更新结果为当前索引</span></span><br><span class="line">                result = mid</span><br><span class="line">            &#125;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18. 二分查找-重复元素，最左边的插入点</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/18%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/18%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchInsert</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到了目标元素，返回索引</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 目标元素在右半部分，更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 目标元素在左半部分，更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标元素不存在，返回插入位置</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17. 二分查找</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/17%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/17%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16. 找到堆的前 k 个元素</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/16%20%E6%89%BE%E5%88%B0%E5%A0%86%E7%9A%84%E5%89%8D%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/16%20%E6%89%BE%E5%88%B0%E5%A0%86%E7%9A%84%E5%89%8D%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findKthLargest</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建最小堆</span></span><br><span class="line">    <span class="keyword">val</span> minHeap = PriorityQueue&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组中的元素依次加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        minHeap.offer(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最小堆的大小超过 k，移除堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size &gt; k) &#123;</span><br><span class="line">            minHeap.poll()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆顶元素，即第 k 大的元素</span></span><br><span class="line">    <span class="keyword">return</span> minHeap.peek()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15. 图-BFS</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/15%20%E5%9B%BE-BFS/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/15%20%E5%9B%BE-BFS/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adjacencyList: MutableMap&lt;<span class="built_in">Int</span>, MutableList&lt;<span class="built_in">Int</span>&gt;&gt; = HashMap()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addEdge</span><span class="params">(src: <span class="type">Int</span>, dest: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        adjacencyList.computeIfAbsent(src) &#123; mutableListOf() &#125;.add(dest)</span><br><span class="line">        adjacencyList.computeIfAbsent(dest) &#123; mutableListOf() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(startVertex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> visited = BooleanArray(adjacencyList.size)</span><br><span class="line">        <span class="keyword">val</span> queue: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">        visited[startVertex] = <span class="literal">true</span></span><br><span class="line">        queue.offer(startVertex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> currentVertex = queue.poll()</span><br><span class="line">            print(<span class="string">&quot;<span class="variable">$currentVertex</span> &quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> neighbors = adjacencyList[currentVertex]</span><br><span class="line">            <span class="keyword">if</span> (neighbors != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (neighbor <span class="keyword">in</span> neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                        visited[neighbor] = <span class="literal">true</span></span><br><span class="line">                        queue.offer(neighbor)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> graph = Graph()</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    graph.addEdge(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;BFS traversal starting from vertex 2:&quot;</span>)</span><br><span class="line">    graph.bfs(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. 图-DFS (迭代)</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/14%20%E5%9B%BE-DFS-(%E8%BF%AD%E4%BB%A3)/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/14%20%E5%9B%BE-DFS-(%E8%BF%AD%E4%BB%A3)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adjacencyList: MutableMap&lt;<span class="built_in">Int</span>, MutableList&lt;<span class="built_in">Int</span>&gt;&gt; = mutableMapOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addEdge</span><span class="params">(u: <span class="type">Int</span>, v: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        adjacencyList.computeIfAbsent(u) &#123; mutableListOf() &#125;.add(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(start: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> stack = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        stack.add(start)</span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> vertex = stack.removeAt(stack.size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(vertex)) &#123;</span><br><span class="line">                visited.add(vertex)</span><br><span class="line">                println(<span class="string">&quot;Visited vertex: <span class="variable">$vertex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                adjacencyList[vertex]?.reversed()?.forEach &#123; neighbor -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                        stack.add(neighbor)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> graph = Graph()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加图的边</span></span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点0开始进行DFS</span></span><br><span class="line">    graph.dfs(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. 图-DFS (递归)</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/13%20%E5%9B%BE-DFS%20(%E9%80%92%E5%BD%92)/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/13%20%E5%9B%BE-DFS%20(%E9%80%92%E5%BD%92)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adjList: MutableMap&lt;<span class="built_in">Int</span>, MutableList&lt;<span class="built_in">Int</span>&gt;&gt; = mutableMapOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addEdge</span><span class="params">(u: <span class="type">Int</span>, v: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        adjList.getOrPut(u) &#123; mutableListOf() &#125;.add(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(vertex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        dfsHelper(vertex, visited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsHelper</span><span class="params">(vertex: <span class="type">Int</span>, visited: <span class="type">MutableSet</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        visited.add(vertex)</span><br><span class="line">        println(vertex) <span class="comment">// 在这里可以对当前节点进行相关操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> neighbors = adjList[vertex]</span><br><span class="line">        <span class="keyword">if</span> (neighbors != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (neighbor <span class="keyword">in</span> neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                    dfsHelper(neighbor, visited)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> graph = Graph()</span><br><span class="line">    <span class="comment">// 添加图的边</span></span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    graph.addEdge(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 0 开始进行深度优先搜索</span></span><br><span class="line">    graph.dfs(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09. 单调递增栈</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/09%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/09%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotonicStack</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> result = IntArray(nums.size) &#123; -<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; stack.last() &lt; nums[i]) &#123;</span><br><span class="line">            stack.removeAt(stack.size - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以根据题目需求进行处理</span></span><br><span class="line">        <span class="comment">// 例如：找到栈中元素的下一个更大元素</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            result[i] = stack.last()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack.add(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08. 找到符合确切条件的子数组数</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/08%20%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E7%A1%AE%E5%88%87%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/08%20%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E7%A1%AE%E5%88%87%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numSubarraysWithSum</span><span class="params">(nums: <span class="type">IntArray</span>, goal: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (right <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        total += nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; total &gt; goal) &#123;</span><br><span class="line">            total -= nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total == goal) &#123;</span><br><span class="line">            count++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计连续的0</span></span><br><span class="line">            <span class="keyword">var</span> temp = left</span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= right &amp;&amp; nums[temp] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++</span><br><span class="line">                temp++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07. 反转链表</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/07%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/07%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> next: ListNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reverseList</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">var</span> prev: ListNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> current = head</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> nextNode = current.next</span><br><span class="line">    current.next = prev</span><br><span class="line">    prev = current</span><br><span class="line">    current = nextNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06. 链表-快慢指针</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/06%20%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/06%20%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在模板中，我们使用两个指针，一个指针每次向后移动一个节点，另一个指针每次向后移动两个节点。如果链表中存在循环，快指针最终会追上慢指针，这样我们就可以判断出链表有循环。如果链表没有循环，快指针会先到达链表的末尾，此时我们就可以判断链表没有循环。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasCycle</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slow = head</span><br><span class="line">    <span class="keyword">var</span> fast = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast?.next != <span class="literal">null</span> &amp;&amp; fast.next?.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow?.next</span><br><span class="line">        fast = fast.next?.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05. 高效的字符串构建</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/05%20%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/05%20%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>以下是一个高效的字符串构建算法模板：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildString</span><span class="params">(chars: <span class="type">List</span>&lt;<span class="type">Char</span>&gt;)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ch <span class="keyword">in</span> chars) &#123;</span><br><span class="line">        sb.append(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个模板中，我们使用 StringBuilder 来构建字符串。StringBuilder 是可变的字符串类，可以高效地进行字符串的拼接操作。</p><p>我们通过遍历字符列表 chars，逐个将字符添加到 StringBuilder 中。最后，通过调用 toString() 方法，将 StringBuilder 转换为最终的字符串结果并返回。</p><p>使用 StringBuilder 的好处是它避免了在每次拼接字符串时创建新的字符串对象，从而提高了性能和效率。特别是在需要频繁拼接大量字符串的情况下，使用 StringBuilder 可以避免不必要的性能损耗。</p><p>使用这个模板，你可以根据具体需求构建字符串。可以根据问题的要求在遍历过程中进行一些字符处理、条件判断等操作。</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04. 构建前缀和</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/04%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/04%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>以下是一个前缀和算法的常见模板：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">prefixSum</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> prefixSum = IntArray(nums.size + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.nums.size) &#123;</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prefixSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个模板中，我们使用一个额外的数组 prefixSum 来存储原始数组 nums 的前缀和。通过遍历原始数组，我们可以计算每个位置的前缀和并存储在 prefixSum 中。</p><p>使用前缀和数组 prefixSum，我们可以高效地回答多个查询，例如计算某个区间的和。假设我们需要计算区间 [left, right] 的和，我们可以使用如下方式获取结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = prefixSum[right + <span class="number">1</span>] - prefixSum[left</span><br></pre></td></tr></table></figure><p>这个计算结果即为原始数组中从位置 left 到位置 right 的元素之和。<br>请注意，在模板中，前缀和数组 prefixSum 的长度比原始数组 nums 的长度多了一个元素。这是为了方便计算区间和时的边界情况。</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03. 滑动窗口</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/03%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/03%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">slidingWindow</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算第一个窗口的和</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxSum = sum</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> k until n) &#123;</span><br><span class="line">        <span class="comment">// 新窗口的和等于之前窗口的和加上新进入窗口的元素，减去滑出窗口的元素</span></span><br><span class="line">        sum += nums[i] - nums[i - k]</span><br><span class="line">        <span class="comment">// 更新最大和</span></span><br><span class="line">        maxSum = maxOf(maxSum, sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02. 双指针-有两个输入, 两个都需要遍历完</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/02%20%E5%8F%8C%E6%8C%87%E9%92%88-%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%E5%AE%8C/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/02%20%E5%8F%8C%E6%8C%87%E9%92%88-%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%E5%AE%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoPointers</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pointer1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> pointer2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt; nums1.size &amp;&amp; pointer2 &lt; nums2.size) &#123;</span><br><span class="line">        <span class="comment">// 处理指针1和指针2对应位置的元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        pointer1++</span><br><span class="line">        pointer2++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余未遍历完的元素</span></span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt; nums1.size) &#123;</span><br><span class="line">        <span class="comment">// 处理指针1对应位置的元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pointer1++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointer2 &lt; nums2.size) &#123;</span><br><span class="line">        <span class="comment">// 处理指针2对应位置的元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pointer2++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01. 双指针-只有一个输入, 从两端开始遍历</title>
      <link href="/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/01%20%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%BB%8E%E4%B8%A4%E7%AB%AF%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86/"/>
      <url>/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/01%20%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%BB%8E%E4%B8%A4%E7%AB%AF%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doublePointer</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = arr.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 根据 left 和 right 相关的条件进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (CONDITION) &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 返回需要的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RESTful API</title>
      <link href="/2023/08/10/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/RESTful%20API/"/>
      <url>/2023/08/10/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/RESTful%20API/</url>
      
        <content type="html"><![CDATA[<p>当我们谈到RESTful API，”RESTful”是表示”Representational State Transfer”的缩写。它是一种设计和构建网络应用程序的架构风格，用于创建可伸缩、可维护和可扩展的Web服务。</p><p>以下是RESTful API的一些关键概念：</p><ol><li><p>资源（Resource）：在RESTful API中，所有的事物都被视为资源。资源可以是具体的实体（例如用户、文章、订单等），也可以是抽象的概念（例如用户登录、搜索等）。</p></li><li><p>统一的接口（Uniform Interface）：RESTful API使用统一的接口进行资源的操作。这包括使用标准的HTTP方法（GET、POST、PUT、DELETE等）对资源进行操作，并使用URL来标识和定位资源。</p></li><li><p>状态无关（Stateless）：RESTful API是无状态的，每个请求都应该包含足够的信息来理解和处理请求，服务器不应该保存客户端的状态。客户端可以在每个请求中提供必要的信息来完成请求的处理。</p></li><li><p>资源的表示（Representation）：资源的表示指的是以某种格式（如JSON、XML等）将资源的状态传递给客户端。客户端可以通过获取资源的表示来了解和操作资源的状态。</p></li><li><p>超媒体驱动（HATEOAS）：RESTful API可以通过在资源的表示中提供超媒体链接，使客户端能够动态地发现和导航到相关资源。这样客户端可以根据链接进行进一步的操作，而无需事先了解所有可能的操作。</p></li></ol><p>通过遵循RESTful API的原则，可以使API设计更加简洁、可读性高，并提供灵活性和可扩展性。RESTful API也更加符合Web的原生特性，易于理解和使用。</p><p>在使用Retrofit或其他网络请求库时，通常会将RESTful API作为后端服务的接口，通过发送HTTP请求来与后端进行通信，获取、创建、更新或删除资源的数据。了解RESTful API的概念可以帮助你更好地理解和使用这些API。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
