<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何理解 Vulkan MAX_CONCURRENT_FRAMES</title>
      <link href="/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/01%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20Vulkan%20MAX_CONCURRENT_FRAMES/"/>
      <url>/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/01%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20Vulkan%20MAX_CONCURRENT_FRAMES/</url>
      
        <content type="html"><![CDATA[<p><code>MAX_CONCURRENT_FRAMES</code> 参数是Vulkan多帧并行处理的核心设计，理解它需要从<strong>硬件工作原理</strong>和<strong>性能调优</strong>两个维度来分析：</p><h3 id="底层硬件机制"><a href="#底层硬件机制" class="headerlink" title="底层硬件机制"></a>底层硬件机制</h3><p>GPU流水线特性：现代GPU采用深度流水线设计，类似CPU的指令级并行。</p><p>当设置为2时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU帧<span class="number">1</span>记录 → GPU执行帧<span class="number">1</span> → CPU帧<span class="number">2</span>记录 → GPU执行帧<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>内存带宽影响</strong>：每增加一帧需要额外存储：</p><ul><li>命令缓冲区副本</li><li>Uniform缓冲区(本例中每帧144字节mat4×3)</li><li>同步对象(约32字节&#x2F;帧)</li></ul><h3 id="性能权衡公式"><a href="#性能权衡公式" class="headerlink" title="性能权衡公式"></a>性能权衡公式</h3><p>理论上吞吐量提升遵循：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理论最大帧率 = <span class="number">1</span> / <span class="built_in">max</span>(CPU帧处理时间, GPU帧渲染时间)</span><br></pre></td></tr></table></figure><p>当<code>MAX_CONCURRENT_FRAMES</code>&#x3D;N时，可掩盖的延迟为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可隐藏延迟 = (N<span class="number">-1</span>) × <span class="built_in">min</span>(CPU_time, GPU_time)</span><br></pre></td></tr></table></figure><h4 id="理论最大帧率公式"><a href="#理论最大帧率公式" class="headerlink" title="理论最大帧率公式"></a>理论最大帧率公式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理论最大帧率 = \frac&#123;1&#125;&#123;\max(T_&#123;CPU&#125;, T_&#123;GPU&#125;)&#125;</span><br></pre></td></tr></table></figure><h5 id="核心含义："><a href="#核心含义：" class="headerlink" title="核心含义："></a>核心含义：</h5><ul><li><strong>系统瓶颈决定论</strong>：渲染管线的吞吐量由CPU和GPU中较慢的一方决定，符合木桶原理</li><li><strong>时间维度</strong>：<code>T_CPU</code>包含命令记录+资源更新，<code>T_GPU</code>包含所有渲染阶段耗时</li></ul><h5 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h5><p>假设某场景：</p><ul><li>CPU每帧处理时间：3ms</li><li>GPU每帧渲染时间：5ms<br> 则最大理论帧率 &#x3D; 1&#x2F;5ms &#x3D; ​<strong>​200 FPS​</strong>​</li></ul><h4 id="可隐藏延迟公式"><a href="#可隐藏延迟公式" class="headerlink" title="可隐藏延迟公式"></a>可隐藏延迟公式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可隐藏延迟 = (N-1) \times \min(T_&#123;CPU&#125;, T_&#123;GPU&#125;)</span><br></pre></td></tr></table></figure><h5 id="关键洞察："><a href="#关键洞察：" class="headerlink" title="关键洞察："></a>关键洞察：</h5><ul><li><strong>并行窗口</strong>：当有N帧资源时，系统可以构建深度为N的流水线</li><li><strong>补偿机制</strong>：每增加一帧资源，就能多掩盖一个较慢者的处理周期</li></ul><h5 id="动态演示（N-x3D-3时）："><a href="#动态演示（N-x3D-3时）：" class="headerlink" title="动态演示（N&#x3D;3时）："></a>动态演示（N&#x3D;3时）：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间轴   CPU活动            GPU活动</span><br><span class="line">t0     记录帧1命令         空闲</span><br><span class="line">t1     记录帧2命令         执行帧1 </span><br><span class="line">t2     记录帧3命令         执行帧2</span><br><span class="line">t3     等待GPU             执行帧3</span><br><span class="line">        ↑ 这里CPU必须等待，因为N=3的窗口已满</span><br></pre></td></tr></table></figure><p>此时可隐藏的延迟 &#x3D; (3-1)*min(3ms,5ms) &#x3D; <strong>6ms</strong><br> 意味着系统能容忍6ms的突发延迟而不掉帧</p><h4 id="工程实践意义"><a href="#工程实践意义" class="headerlink" title="工程实践意义"></a>工程实践意义</h4><h5 id="参数选择策略："><a href="#参数选择策略：" class="headerlink" title="参数选择策略："></a>参数选择策略：</h5><table><thead><tr><th>瓶颈方</th><th>优化建议</th><th>数学原理</th></tr></thead><tbody><tr><td>CPU受限</td><td>增加MAX_CONCURRENT_FRAMES</td><td>增大N使T_GPU×N &gt; T_CPU</td></tr><tr><td>GPU受限</td><td>降低画质&#x2F;分辨率</td><td>减小分母max(T_CPU,T_GPU)</td></tr><tr><td>均衡状态</td><td>保持N&#x3D;2~3</td><td>达到1&#x2F;max(T,T)的理论极限</td></tr></tbody></table><h5 id="性能诊断方法："><a href="#性能诊断方法：" class="headerlink" title="性能诊断方法："></a>性能诊断方法：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto calc_optimal_N = [](float cpu_time, float gpu_time) &#123;</span><br><span class="line">    float bottleneck = std::max(cpu_time, gpu_time);</span><br><span class="line">    float hidden_latency = (target_latency - vsync_interval);</span><br><span class="line">    return std::ceil(hidden_latency / std::min(cpu_time,gpu_time)) + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="现代GPU架构的影响"><a href="#现代GPU架构的影响" class="headerlink" title="现代GPU架构的影响"></a>现代GPU架构的影响</h4><p>在RDNA3&#x2F;Turing等架构中，由于：</p><ol><li>异步计算引擎的引入</li><li>硬件指令级并行(ILP)增强</li><li>显存压缩技术</li></ol><p>实际观测到公式需要修正为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有效帧率 = \frac&#123;1&#125;&#123;\max(T_&#123;CPU&#125;, \alpha \cdot T_&#123;GPU&#125;)&#125;</span><br></pre></td></tr></table></figure><p>其中α是GPU并行化系数（通常0.7~0.9）</p><h4 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h4><p>在VR系统中，通常需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N = \left\lceil \frac&#123;motion-to-photon&#125;&#123;\min(T_&#123;CPU&#125;,T_&#123;GPU&#125;)&#125; \right\rceil + 1</span><br></pre></td></tr></table></figure><p>例如Oculus Rift要求的20ms延迟：</p><ul><li>如果min(T_CPU,T_GPU)&#x3D;5ms → N&#x3D;20&#x2F;5+1&#x3D;5</li></ul><p>这种场景下就需要更复杂的<strong>帧交错</strong>(Frame Interleaving)技术。</p><h3 id="C-具体实现分析"><a href="#C-具体实现分析" class="headerlink" title="C++具体实现分析"></a>C++具体实现分析</h3><p>在代码中体现为三重资源组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每组资源包含：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FrameResources</span> &#123;</span><br><span class="line">    VkCommandBuffer commandBuffer;    <span class="comment">// 命令缓冲区</span></span><br><span class="line">    VkSemaphore presentCompleteSem;   <span class="comment">// 图像可用信号量</span></span><br><span class="line">    VkSemaphore renderCompleteSem;    <span class="comment">// 渲染完成信号量 </span></span><br><span class="line">    VkFence queueSubmitFence;        <span class="comment">// 队列提交栅栏</span></span><br><span class="line">    UniformBuffer uniformBuffer;      <span class="comment">// 每帧UBO</span></span><br><span class="line">&#125;;</span><br><span class="line">std::array&lt;FrameResources, MAX_CONCURRENT_FRAMES&gt; frames;</span><br></pre></td></tr></table></figure><h3 id="参数选择建议"><a href="#参数选择建议" class="headerlink" title="参数选择建议"></a>参数选择建议</h3><p>根据硬件特性调整：</p><table><thead><tr><th align="center">硬件配置</th><th align="center">推荐值</th><th align="center">理论收益</th></tr></thead><tbody><tr><td align="center">集成显卡(移动设备)</td><td align="center">2</td><td align="center">避免内存带宽饱和</td></tr><tr><td align="center">独立显卡(桌面级)</td><td align="center">3</td><td align="center">利用高显存带宽</td></tr><tr><td align="center">多GPU交火系统</td><td align="center">4</td><td align="center">掩盖跨GPU通信延迟</td></tr></tbody></table><h3 id="延迟分析"><a href="#延迟分析" class="headerlink" title="延迟分析"></a>延迟分析</h3><p>增加该值会引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总延迟 = 呈现延迟 + (N-1)×帧间隔</span><br></pre></td></tr></table></figure><p>例如60FPS下：</p><ul><li>N&#x3D;2 → 最大延迟16.7ms + 16.7ms &#x3D; 33.4ms</li><li>N&#x3D;3 → 最大延迟增加到50.1ms</li></ul><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>可通过Vulkan调试扩展验证实际利用率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkPipelineState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkPipelineStageFlags stage;</span><br><span class="line">    <span class="built_in">vkGetFenceStatus</span>(device, frames[currentFrame].queueSubmitFence, &amp;stage);</span><br><span class="line">    <span class="comment">// 如果stage长期处于VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</span></span><br><span class="line">    <span class="comment">// 说明GPU资源饱和，可考虑增大MAX_CONCURRENT_FRAMES</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>配合<code>VK_KHR_timeline_semaphore</code>扩展可实现动态帧数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> dynamicFrameCount = <span class="built_in">calculate_optimal_frame_count</span>();</span><br><span class="line"><span class="built_in">resizeFrameResources</span>(dynamicFrameCount);  <span class="comment">// 运行时调整资源组大小</span></span><br></pre></td></tr></table></figure><blockquote><p>最佳实践：从2开始逐步增加，使用<code>VK_LAYER_KHRONOS_performance</code>层监测GPU空闲率，当达到95%以上GPU利用率时停止增加。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 8 - 渲染引擎 </category>
          
          <category> 8.3 - Vulkan </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 Vulkan</title>
      <link href="/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/03%20/"/>
      <url>/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/03%20/</url>
      
        <content type="html"><![CDATA[<p>这段代码定义了一个名为 <code>uniformBuffers</code> 的数组，它包含 <code>MAX_CONCURRENT_FRAMES</code> 个 <code>UniformBuffer</code> 对象。这种设计通常用于图形渲染中的多缓冲技术（如双缓冲或三缓冲），目的是实现帧重叠（frame overlapping）并避免资源冲突。</p><h3 id="关键点解释："><a href="#关键点解释：" class="headerlink" title="关键点解释："></a>关键点解释：</h3><ol><li><p><strong>帧重叠（Frame Overlapping）</strong>：</p><ul><li>现代图形 API（如 Vulkan&#x2F;DirectX 12）允许 CPU 准备下一帧的数据，同时 GPU 仍在渲染当前帧。</li><li>这需要为每一帧使用独立的资源，防止 CPU 覆盖 GPU 正在使用的数据。</li></ul></li><li><p>**<code>MAX_CONCURRENT_FRAMES</code>**：</p><ul><li>表示系统支持的最大并行处理帧数（通常是 2 或 3）。</li><li>例如：Vulkan 中常设为 <code>VK_MAX_FRAMES_IN_FLIGHT</code>。</li></ul></li><li><p>**<code>UniformBuffer</code>**：</p><ul><li>存储每帧需要的统一&#x2F;常量数据（如 MVP 矩阵、光照参数等）。</li><li>每个活跃帧都有自己独立的 UBO，防止写入冲突。</li></ul></li><li><p><strong>工作流程示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 帧N使用它的UBO</span><br><span class="line">drawFrameN(uniformBuffers[currentFrame]);</span><br><span class="line"></span><br><span class="line">// 同时，CPU可以更新帧N+1的UBO</span><br><span class="line">updateUniformBuffer(uniformBuffers[(currentFrame + 1) % MAX_CONCURRENT_FRAMES]);</span><br></pre></td></tr></table></figure></li></ol><h3 id="为什么需要这样设计？"><a href="#为什么需要这样设计？" class="headerlink" title="为什么需要这样设计？"></a>为什么需要这样设计？</h3><ul><li><strong>安全性</strong>：避免 GPU 读取 UBO 时被 CPU 写入破坏数据。</li><li><strong>性能</strong>：允许 CPU 和 GPU 并行工作，提高吞吐量。</li><li><strong>同步</strong>：配合栅栏（Fence）&#x2F;信号量（Semaphore）实现正确的帧调度。</li></ul><p>这是现代图形编程中实现高效资源管理的典型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 8 - 渲染引擎 </category>
          
          <category> 8.3 - Vulkan </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UBO 与帧重叠</title>
      <link href="/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/02%20UBO%20%E4%B8%8E%E5%B8%A7%E9%87%8D%E5%8F%A0/"/>
      <url>/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/02%20UBO%20%E4%B8%8E%E5%B8%A7%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<p>这段代码定义了一个名为 <code>uniformBuffers</code> 的数组，它包含 <code>MAX_CONCURRENT_FRAMES</code> 个 <code>UniformBuffer</code> 对象。这种设计通常用于图形渲染中的多缓冲技术（如双缓冲或三缓冲），目的是实现帧重叠（frame overlapping）并避免资源冲突。</p><h3 id="关键点解释："><a href="#关键点解释：" class="headerlink" title="关键点解释："></a>关键点解释：</h3><ol><li><p><strong>帧重叠（Frame Overlapping）</strong>：</p><ul><li>现代图形 API（如 Vulkan&#x2F;DirectX 12）允许 CPU 准备下一帧的数据，同时 GPU 仍在渲染当前帧。</li><li>这需要为每一帧使用独立的资源，防止 CPU 覆盖 GPU 正在使用的数据。</li></ul></li><li><p>**<code>MAX_CONCURRENT_FRAMES</code>**：</p><ul><li>表示系统支持的最大并行处理帧数（通常是 2 或 3）。</li><li>例如：Vulkan 中常设为 <code>VK_MAX_FRAMES_IN_FLIGHT</code>。</li></ul></li><li><p>**<code>UniformBuffer</code>**：</p><ul><li>存储每帧需要的统一&#x2F;常量数据（如 MVP 矩阵、光照参数等）。</li><li>每个活跃帧都有自己独立的 UBO，防止写入冲突。</li></ul></li><li><p><strong>工作流程示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 帧N使用它的UBO</span><br><span class="line">drawFrameN(uniformBuffers[currentFrame]);</span><br><span class="line"></span><br><span class="line">// 同时，CPU可以更新帧N+1的UBO</span><br><span class="line">updateUniformBuffer(uniformBuffers[(currentFrame + 1) % MAX_CONCURRENT_FRAMES]);</span><br></pre></td></tr></table></figure></li></ol><h3 id="为什么需要这样设计？"><a href="#为什么需要这样设计？" class="headerlink" title="为什么需要这样设计？"></a>为什么需要这样设计？</h3><ul><li><strong>安全性</strong>：避免 GPU 读取 UBO 时被 CPU 写入破坏数据。</li><li><strong>性能</strong>：允许 CPU 和 GPU 并行工作，提高吞吐量。</li><li><strong>同步</strong>：配合栅栏（Fence）&#x2F;信号量（Semaphore）实现正确的帧调度。</li></ul><p>这是现代图形编程中实现高效资源管理的典型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 8 - 渲染引擎 </category>
          
          <category> 8.3 - Vulkan </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 边框阴影绘制方案</title>
      <link href="/2025/04/14/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/2%20%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6/Android-%E8%BE%B9%E6%A1%86%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6%E6%96%B9%E6%A1%88/"/>
      <url>/2025/04/14/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/2%20%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6/Android-%E8%BE%B9%E6%A1%86%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在说解决方案之前，我们需要先明确两个问题</p><ol><li>到底什么是阴影</li><li>为什么在 Android 端上绘制阴影效果这么麻烦</li></ol><blockquote><p>每当我向 Android 同学提出第一问时，通常他们会回答我：阴影是个10-25%透明度的线性减淡的黑色图层</p><p>但是当你尝试在移动端去绘制这样一个黑色图层去代表阴影，其视觉效果肉眼可见的差强人意</p><p>于是绝大多数 Android 同学会提议你去找设计出个带阴影的图，或者使用诸如 ShadowLayout 这样复杂的控件<br><a href="https://github.com/lihangleo2/ShadowLayout">https://github.com/lihangleo2/ShadowLayout</a></p><p>ShadowLayout 使用了 1600 行代码只为实现边框阴影</p><p>再看看 github 上其他绘制阴影的方案，不是采用 RenderScript 这种即将被谷歌废弃的图像处理库，就是使用 Android 12 以上才有的还要依赖硬件加速的 RenderEffect，更有甚者者干脆用 Canvas 硬画，不仅效果不好，性能更是很差，稍有复杂的情况，甚至可能导致卡顿发热</p></blockquote><p>我们不经要发问：Android 10多年了，难道就没有一个不需要和设计掰扯，能兼容所有机型，对开发简单友好的阴影解决方案吗？</p><h1 id="到底什么是阴影"><a href="#到底什么是阴影" class="headerlink" title="到底什么是阴影"></a>到底什么是阴影</h1><p>先来看下阴影的组成部分</p><p>我们可以将阴影大致分成两个部分，<strong>全影&#x2F;umbra</strong> 和 <strong>半影&#x2F;penumbra</strong> 。</p><p>半影区域就是阴影的过渡区， 也就是软阴影，有半影的阴影过渡时，视觉效果会好很多。</p><p><a href="https://imgse.com/i/pEWsX28"><img src="https://s21.ax1x.com/2025/04/14/pEWsX28.md.png" alt="pEWsX28.md.png"></a></p><p>通俗点说：全影就是大家常说的 10 - 25% 透明度的黑色图层，通常我们需要绘制的边框阴影是半影。</p><h1 id="为什么在-Android-端上绘制阴影效果这么麻烦"><a href="#为什么在-Android-端上绘制阴影效果这么麻烦" class="headerlink" title="为什么在 Android 端上绘制阴影效果这么麻烦"></a>为什么在 Android 端上绘制阴影效果这么麻烦</h1><p>半影的绘制实际上是一个多次采样模糊的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">PCF</span><span class="params">(float2 uv, <span class="type">float</span> currentDepth)</span> &#123;</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    float2 texelSize = <span class="number">1.0</span> / _ShadowMap_TexelSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; y++) &#123;</span><br><span class="line">            <span class="type">float</span> depth = tex2D(_ShadowMap, uv + float2(x, y) * texelSize).r;</span><br><span class="line">            shadow += (currentDepth &gt; depth) ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shadow / <span class="number">9.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，对 3* 3 的区域进行了模糊采样，也就是说每个像素点的颜色依赖其周围相邻的一圈像素点的颜色的计算结果，实现逐步衰减</p><h1 id="切图和代码实现究竟哪个更好？"><a href="#切图和代码实现究竟哪个更好？" class="headerlink" title="切图和代码实现究竟哪个更好？"></a>切图和代码实现究竟哪个更好？</h1><p>首先明确一点：切图和代码实现的本质区别是什么？</p><p>是预渲染和实时渲染的区别</p><p>如果我们当前卡片所在的背景是可枚举且数量较少的，我们应该倾向使用预渲染</p><p>举个例子：</p><ol><li>如果一个页面只有日夜间两种阴影我们倾向于切图</li><li>如果需要七彩渐变非中心光源产生的（上下左右阴影不一致的）阴影，我们倾向于代码实现</li></ol><h1 id="使用-9-图来规避切图的弊端"><a href="#使用-9-图来规避切图的弊端" class="headerlink" title="使用 .9 图来规避切图的弊端"></a>使用 .9 图来规避切图的弊端</h1><p>切图虽然方便，却有以下几种弊端</p><ol><li>设计会想打你，尤其当你需要反复调试效果的时候</li><li>切图会增加包体积</li></ol><p>解决方案</p><ol><li>自己学会使用 figma 调试阴影切图</li></ol><p><a href="https://imgse.com/i/pEWy1G6"><img src="https://s21.ax1x.com/2025/04/14/pEWy1G6.md.png" alt="pEWy1G6.md.png"></a></p><ol start="2"><li>使用 .9 图</li></ol><p><a href="https://imgse.com/i/pEWsHUI"><img src="https://s21.ax1x.com/2025/04/14/pEWsHUI.png" alt="pEWsHUI.png"></a></p><p>当我们想要绘制一个带阴影的圆角矩形的时候，我们会发现除了矩形的四个角外，整个矩形绝大部份都是重复可拉伸的</p><p>如果我切出一个这样的圆角矩形最小图，并设置其非圆角的区域为拉伸区域</p><p>那我们就可以用一个只有几 kb 大小的 .9 图实现固定圆角的带边框阴影的矩形</p><p>考虑到实际情况，我们可以切出 0 - 12度的圆角图共13张图，圆角越小的图片越小，易得总共大约 (1kb + 5kb ) &#x2F; 2 * 13  &#x3D; 39kb</p><p>再算上深色模式，未打包压缩前总共只需要 80kb</p><p>而 1600 行的 ShadowLayout.java 未压缩前有 55kb，引入 Androidx 的 CardView 就更大了，还需要考虑机型的兼容性和硬件加速开关</p><p>而使用 .9 图，开发同学只需要选择对应圆角的 .9 图设置为背景即可</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>轻松使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;400dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:backgroud</span>=<span class="string">&quot;@drawable/rounded_corner_12dp_shadow&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>我们可以进一步，将圆角和矩形分离，使用原子化的图片素材 + 微量代码，组合各种圆角与阴影效果</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以下是 <strong>预渲染（.9图）</strong> 和 <strong>代码实现（如ShadowLayout &#x2F; CardView）</strong> 的优劣势对比表格，结合性能、开发效率、灵活性等维度分析：</p><hr><table><thead><tr><th><strong>对比维度</strong></th><th><strong>预渲染（.9图）</strong></th><th><strong>代码实现（动态绘制）</strong></th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>✅ 极低开销（仅纹理采样）</td><td>⚠️ 较高开销（实时计算阴影、图层叠加）</td></tr><tr><td><strong>内存占用</strong></td><td>✅ 小</td><td>⚠️ 动态（取决于具体代码）</td></tr><tr><td><strong>开发效率</strong></td><td>✅ 直接设置背景，无需编码</td><td>⚠️ 需编写&#x2F;维护复杂逻辑（如阴影算法）</td></tr><tr><td><strong>灵活性</strong></td><td>❌ 仅支持预定义的圆角&#x2F;阴影样式</td><td>✅ 动态调整参数（颜色、圆角、模糊度等）</td></tr><tr><td><strong>适配性</strong></td><td>✅ 无兼容性问题（Android&#x2F;iOS通用）</td><td>⚠️ 需处理机型兼容（如硬件加速、API差异）</td></tr><tr><td><strong>扩展性</strong></td><td>❌ 修改样式需重新切图</td><td>✅ 可通过代码快速迭代新效果</td></tr><tr><td><strong>文件体积</strong></td><td>✅ 极小（如80KB未压缩）</td><td>⚠️ 较大（代码+依赖库，如CardView）</td></tr><tr><td><strong>动态效果支持</strong></td><td>❌ 无法实现动画或实时变化</td><td>✅ 支持动态阴影（如跟随光源移动）</td></tr><tr><td><strong>多分辨率适配</strong></td><td>✅ 自动拉伸（.9图特性）</td><td>⚠️ 需额外处理多分辨率下的绘制精度</td></tr><tr><td><strong>维护成本</strong></td><td>✅ 低（替换图片即可）</td><td>⚠️ 高（需测试不同机型&#x2F;系统版本）</td></tr></tbody></table><hr><h3 id="适用场景总结"><a href="#适用场景总结" class="headerlink" title="适用场景总结"></a><strong>适用场景总结</strong></h3><ol><li><p><strong>优先使用.9图</strong>：<br>• 样式固定（如标准化设计语言中的卡片阴影）。<br>• 性能敏感场景（如列表项、高频刷新界面）。<br>• 需要快速开发且无动态效果需求。</p></li><li><p><strong>优先代码实现</strong>：<br>• 需要动态效果（如阴影动画、交互反馈）。<br>• 样式高度自定义（如设计师要求的特殊渐变阴影）。</p></li></ol><h3 id="补充建议"><a href="#补充建议" class="headerlink" title="补充建议"></a><strong>补充建议</strong></h3><p>• <strong>混合方案</strong>：对静态部分使用.9图，动态部分叠加代码绘制（如悬浮按钮的阴影）。<br>• <strong>工具化</strong>：将.9图生成和代码阴影封装成工具，供团队按需选择</p><p>通过明确场景需求，可以高效选择最优方案。</p>]]></content>
      
      
      <categories>
          
          <category> 7 - 复杂代码模版 </category>
          
          <category> 7.3 - 复杂 UI 效果 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实时渲染（一）绘制一个三角形</title>
      <link href="/2025/02/15/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/02%20OpenGL%20ES/01%20%E7%BB%98%E5%88%B6%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2025/02/15/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/02%20OpenGL%20ES/01%20%E7%BB%98%E5%88%B6%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d224a62d412bc33756f163ae06a1bb8d881145651b330b1ac3820f04995d2e0">076ab7262a2d7b7b9ca4206bd02587eba9a50141cc7a87b2ae6cba00de9ad37387d3b1f943028b8f995fac8e2d28dbe2f5a63f5cad7e9785ebd02a4bd293d1e648225999d67c04de7984768a388aa07156de057b502b7a9921f8aca5372072e1742d1848f7305d449680d7b90a1c3196238abf435c7ca14a89fa7115f1854fd23cae459d5dca63b601e501ee0fa616a3b4adb7a650de45a13b9e7b38ea6f7ef7aec0b8f5848d2dd20ed85320f8cd22cb7924c5954be4e6ce87bf44e66a99bf61b636ba8ac9f399c48b29684432f839f6a03dbe9f969299e37c958d2f03ab10f096ee8eccc053f2f594be2c1657dda01c985ec3e8134833d06c39ffed91f0a8458090b4eeb1d778f9829a9a41a52fbf55de2d6db7fd76d1748daa5ea3fe53985bef4848b12d924dbfbc9ceb895abd73ea93c62182c2c70865bb039593412a13b4deebb809b107c6b85d089fb49b051df761d3bfe35b5a3faf2ca95dbe8ff6137c114fb9351bb01706e78cd50fd722f264323006cf0b1d3d9a8bcb2c9809b3c2f52be6e08b254a0abbe351fa8c186fc77666ca706f7657ab1b7e7b8346fac5dd93454d7627f86027eaf845f3619f6ca860e6f5247b39915500445e585f723e0575dd135cf80f8d859a68105643a0ddb73b3392f982649349ca0dd66270604101a39899289823c6ed48689a57d41cf3efea5d26ded814c9a8c881019841b200deb73d207702967d55d2d6cd093d929aa124102485e9c10612249eb65a9528404db7c159c89fdbeaff04c410030b5fe9cea2298242063956cdf8668189a18ac4b9c348fe636eba61d05195adcea8f3251992c0847251922933ef8281de32efd4e9370c020057bbd05d48060adc9513217d0aa279e2e9224e2279724011a72db38b5ce9c53d3f42bc4f46261facfc7d0433fcdf06ebf5e3a3bfa2652e818cbd493e62f163109d5787b2c23fbcd1168084d5a509e7ff5aa9ce19c54af6dc34552b7d1ab5053c7ea92f6b9fa59dbb8aeabb59c1426886061757f606ec7bc2c7857aaf15f1eb4d99480a02cb4946abf695db38b4544485154c7698503a52d0475a9d4cfdecc5b8d08054352b85c0cb9302fb0b5381c69096a29350882953d6b0689f9faec96a5886911316be31beb69e14eec58a903ff3f45b3e3be71e617d5b8d7eac50bd2e00e3b80d0c074b3d99b8993f96bb943314f282f83e9e7c2f0dbeb5d6b45ec564f0363a511c288927dfa8d2a45e13ffdda5bccb65d021a4a46dac6c0a60e2c6cd50d8dbdfdceb519051457d2e90d452d1d6a62625d05b2f95f40d9f5e2c0503cc3531d7cd73cf93d45a47ccc5df5acb603c6ec0724da9958ee446ab26cde7798368bc8898a8f47272bf78cae933cfbb2eb1023ad54d54f88ed1cc66992d4b38b485202090bebab0344464e348f7148ac287f5b8735c20452ad3f9de035bafd55ff21f7f1c49b3c95b992dd43fc8753c4ce966045a3d4cbe2476fabf296433b36175eda2ed1ac55330f6669af015629c2a75bdf3ca259bff44d134c53c6bcd52d2e00978130a47a2def6058c9eb7f4cb4da3f2288e4cfd89138e2913e9a46d431db11c8b0750d58ed5f000af64eb0f005a542123e3a1cc25da67976d69083584671ec149f205c60488dd6553b2de2662c4fd916d7d8e6846a5d20cebf3cca43b1a9bd272f8911fb1ed12678e9a114ea3b41715e60887c5e39514bec495d1a5729210de0ed91482588f1a704ad6a2b26eed0679102ddb1344a4cc5de5b0be66f0175910047ffb9834c64545dfd382be4f20c3149cd90f3a16c814463a3342bb02733abb63aff6bc0c34e4e5af685d57bee5e0131c552ea6f9b8dae6d90e494e836ae95fdb04c18f5e86aee9cffa18529f9f0a7cb9bf62fd55006dda7b11f5f805fe48f717111e66a5dd709e188387262c707001398372de9b6844270891279f90560c0f345b169e1722d2f0dedb249865a469941f70280e77c758c417651a9a50af17d64f650ed54c4969a5af63cc868d963849da44c0aac2f847cb204bf5a5d17f6759418fa2ac295e2377dccb642ee6c51eba4d9cf0867cf12d565254cacc7f4a4a9c8c8528ea99325beae731f0df4997cab8b036ad91abeac4f362f2c9a166424b77ab6ee256478dc85f32c9f64c4356a492d462d193ff303112f0793d58f101af9072e23100810a9b3808aa565f902bda54bbf0d1e09bf8466dcc029072dcb76896fbff70fa78f4e1dca80850f620dc5f9c07e3069aae4acd5294c269b9fe1d6f0572f8f2024214744cda939fa48d146ad3ed27139b21c63ac9ebf969a2052a2ae5be6c60fff0ae4d77157729604774ecc69589028d46f399ccbd475ff349b3ffe5c37dcfe72d2af5980025cc54ce11921b3e161be91067df912bfb1482cc946704079a4f0e7492a90e56d4c6448c7a0a8f25640ceae5db76521006d97bedc1583d8ac58b3e10e331a39811ad7c0a1d4b89dc8276aefdb7f10e19418680bea4256b0576c7add867334947b6f7b3e92be809ee678426ef39a4bb507bca93dbd9b35b95ace7b5de55b88fba07830f2b2894bcaa7c4fdf6ac2ce85199fdffe3e2116df1154697d75974a31d4949d8744023ddb862e40c59ad76bbebc7953ff4af2a7216ee2cd6e20cc4a995191d8a8bb17bfb0724c23d31a2d0877f66a88a6474f40ac3ad3428cf73b627200ccb26580d4d1328d91d7b8a0f184f21290942546dd7c180c114ccb8d10c27d2a5238851c0e95e2d3df18683487c7284fcb10784a0a85f5b41b447f9010c9b95f6b3782375703bd3e37f20ba2b1fc9c288ad998cb26c93f3cf6828d3d714d6a4ff6afa97b6faa8a98b8969d026e19c1565f204be29afc5e941898e794640fbd3cca24eaa0fd22abfd1dd6a9f986f2a253f61c40d2703d023097730c3c935dba7c2e50a99e7608a9894bd60abc3b1260f48116cb93e1bc00c69ae754c8e52f0413048bd450b0eb373232b49eb2be5cb5c1969933ba6d33f1b599cd9f2d6422ade12d25a2810dae1c5fc22ef35fbb1443ab89539eb0918c0c59aa3f105f4804affa47c3bf5408ea8e83d6241463b34d8fb6f25bfd3291e2bea520e6ec0283d9bd47ae7e7efd33ac33988f8777216f923b8584996440c87e88e5d78196f951813b6de05dae79d228b5b1de87bf865877545a5bc2925b78a091274ec63fb5480e7dd0427fbe87f4cdf17eb94d947a7c7ff33436b81bc813b633863a477f8a8af6c429328899c9c74b405ae4d247c3bba473469297179bdcf3fec08d23948ff167b5b7476d9f4d6e040acb14fe2e8ba300d99ef51490aeb60f6cddc923cc8df6ea9832e9c816d3bbb4724d054dd26ae3ffb4e5a85310aafbd5d0496f6cfa619ca3bb3a6305e804a49c288dc86d0221c84071972d1712ff9e1630ccdda809096c28ee1ca1ead5f1e58504ed79505c48f6db966ea5c8fe48701eb571f683418c9f1a928c050281557521260f3dd44f91d8418dd41c241925cd78b637dcfb6a5e974a3eecf98f51e0184020231ef5d5c7e1243bd5026e35f218f249b87d82b9af8a506ab31f2c0a44dc0c91887fe9c95e9a97b6defb8e74b9a4c8a1d3721c2a01b1d1b40b551f7ce23bf388fba08f92d445cf36ae1221d4197856239f7439dcc795319499136891f799330f295223449709da85e77934917a9a6817bd195b4fdbe8c78b2180f904f05adfd175bab3dd6ecc939b0bcc9a1db451f8aa122a9d37d760d3c84828fde2432bb876c778cb1fb06f9848f8dc3b62bf49ac27ad7ef7b414646f0d4ea3e0066c4af9fef924a6f137690b1621a36b6eec7386f55e378f77c87b8a6a342d3b3a9f271cd7e9d232350b28af9e7f1ab61405ddf330b7ccbc61d1cb26333794716d89658c47434c5688caf3821708968414188e927b6fd1b4d64f33847bdae40ef94c4a3cbdbeb5821da45cd1c1c0d3d661fd366ebfd50bf19bfeb6c645b30423bd5c71883f3bc2cd40af5ccaa8590abe81b9cce8815f54a510d17dbdd084e4519ab02dce81e4ab8de97fc07303319130e0d3cdd2a14497c037f85a04a697c7c73bbacbcf03eb2f76785f456f8fc58d02c6ed0091b8fff0b9f000331787a6fda02822df8e63b157c4d5bc45748bc0cd7430ef68d1ac800ebd8c82ea710de50bf20acf8022291fc36984f60a6fcb72f551b5b8251cb4a1b1b3e1294bb80b5a84b4d91f2f91c365cc4fbde6991b2c67c906ef493e5108156588c1c08b3e4941ec2f878a0abc7a992b40ed57c4327b726e528dc8879234c8a9cddeb305b8e528e56a835495f8563b0b390a3444d26d15035dceaf9b3f14bb7c9524520980259e582d1d7b1f08274b623bf2f5687deaa6b26c882e98fff8cd0071490765318a0c075ebb5b4acbf72d95b6c9f40f610cb2e4e71b2067694424ac169c4a9fc28efce492aba50c6b5e670a58b3ca96e62c8054bb6bbb4452f98dc3289d300169b9f92d6fce7cc38c24306a9c7c6f2229253b9becc3f08c688c40d4a82cad029e00d45242f890f8b5243c3d45bcc45bc1cceb54a2f59a468e11613786c1078aebffd82737771fe0820f9e1aad866c2c05cf0ed96984e9f5828b3d4ec1060cf5c3afda520dd682e65696d9306590ac8aaf885425794e6382375322074e5de4aa01e209a5540c9d8fb92ffc33a597be55f95e5b255c6434da43b6f267a54c6a81d9162be65942e63373a3771729a1b311d9c1670e368006f8e4609898c9c42b149c282af0e2bb87b470fffe84f73b7496a745caf33043fa8141b33db8e19bc711f06ab1f970ba22d5274e084a0ffe8a022c50091a023e84f8849a5c22d2de86f7143f3e35d66cf1467a1366d7425330cedddd1102bdae42bf9c9a16f7702788c4d87ff088a5815432d36ae6a964462c3e3f94b20e086304c819ce523d0e0a2d9afc1317fd672c889b9ec3491e333149010301ce41acd357f9a22d7a2a68b6fa3fdcada5a32aba06b64f2b0173d64047cc42b71a77f318daae50391e772c25d85bdd85065f34d38d44b2b7ed959579d88fb8d68fa81968c5e722497fa7892a11319805bee1a669fdfc8b3b7cac006ab78450e84c4671901b4d9c452c0cc987ab5420528cddde2d43bc899ac2ec5ce3df401632ab711917576bb33c06b09b8a05de6cdcec1d05d5b38fb77f65bf31bfcccccaaf05d4317b795755ae3c93c0c9b27ac7b90c26dea5c53096d6128100628a73563e02087370a90bea16aaf9f9f88942be040b79b40ee6772d6d54558ccdaea00ca88bebe681d1d3b9400fd2735c7250d69dffb787e6195e4bede92d52a40c761e15428b59e67f9f25598cc2e54d148e7090fd3b1d071adfc4b6f1d9d3a4e5fafbbd8b22b54c218c6c5682e52ef8ace730febf023e6b485e757ba3049048d0b26647a6dfe6dd7b958a4932cb3b8fb952ef9fccdf88ecdeab05df9a8ed2c7e9517d2b507edfc45cae2c3acdcbf35b7a42a7320966b59a8b695b4c03516ec6ffec4453b4b384d98985e7a2bf1668cd842bb40654273f4b03302c71142b07c26c1fc51f33d930f082a1941829f5aab3a3b72bf1b67eef0337aa399b1f5619a6fa16d055649ea15c581ae0446b90437cc13e082ab6bd55f18daaa0005afac73416eb5864ce79db02a4ff343f06d686b666c4fbdd209a423e9a6e618f18db7a95506154c82cbbffa3b1a3546ce3594e76420daa540e17a43a1b5d43c54e9367b869c210c6c0a7ce64d215dc9d434e187d72d2c11d053b6682979bb3fcf12b5b9fa9ff4cff829d00a1848acaee4c375c34eeed57eef67cb4c9139aad85f28d96923136bd8f4c5471077237c0088b98e990ea69e57e604f774c8803b1e4505f14dc94aecd101ae3b751e4fa2d71b91a1f04e298200acc76bcf4016cd065fe8a19683481d23fee28a3f690e2eb6b7325699ef9fc0da3d23ab6a782ab7ede21823e980e08c2a6b5616ace6218bb22789327575330c670f8af7ec028bb03aafb8de6c311b1efb2c55d140b2b6d2e8f529a99e3b2a71adbc4a43e60bb9d32c4130108fee3ba7b38a56adb53a20a756dd1953c3fcc57310d8466817edf1e4d285638f94d2f0d737fc36e7ebf98ef2e83a1629f9bad5db089f64c3abf971362d803c6b77fa7a868e5189b6fb085f70ac05ee1fb422828938f5db9be6d74f3a69158cd4ceffb2e0e0a3132230edd16c62a49667c37397ff09a29ca1a441d15d16b2d7f025b0c374408e5c082e714de5c915a9417b927ce847d21ee17ceb33203af049da673a0ffb1d509ca2c714ce28af9474c13adba6a7f2e8c0e4bcab2f2df07869ea49f20f9d13730fbdeeac7bd3a7fa82c225dce4b1542de8dbfc7c850c2d8afdd5cdecc3ea678a6bac917f7e0db9759f4c29976e0507d9de26cd28376f237b61e538fe5a23198716e1a2061bb474d11a9a4f3b7157ebc24a7b350910a97107a87a80e3962a0455ab99f515a6c84797f2953fa50c5e18b2f9c3b62897607d672f51e6a8c83f5db8e4aa9ba20349209b30fad9205542ede2068ab09964074fdc4d86c0fdc600a7282fd36ffad544c6fdf17f3b01ed4b162335d7437b03eab010ae8c9330633e778980b561b8768dffed5ed702c0afaa4c1d46201d591ce414c33cd6c484ba5b9a449ed593ab54406063008dd665e7111c6e8b936a76e865470f1bcd176285f5be0b4080841010aecaf1ff629a5996ed71ec59dca3f249a62f560146d30a3c179ac009843fe35b2530ae53bf19f666fa05e76cf8c01a29f001f34b8df7f8b8958f524feebd437ad0d3acb8d56e81b40a1aa83c818fcc2d2d95882d1bc7af67db6b9e0b564e0db5fba83fe5e76a6fc64d6652e45465f3f9da94832a0eadc750507f99945c3f62af64948b949933dcd5c5ddcca966cf61334479833af13f30eb470623329bb2d5e6a22ee5234c82e661a8be86677ce8bad258f76c185b692a10c40eab482293f4904c517ffb6284618304e35ada4a76c50aa4964f74af8dae30baf0f0f4f031f55dfda27795405193e155d3a9d734ab68d2dde9921dcc37196649a25ba4a11d0a1b682f514d36ddb76359dc7b1824bd6eb5b41f14e02e8af2f0b37a5eb2a2dda12c00306c8df2f1aeee1a2ffda99ec17f7389374924d512dbffae145e50c93f476256b4d42a0c24cb467b60e7f219f72e84e57820eef72d10ddb9eb0812477bf90dd865355da3bb530b8854d172e92571b2c8e80017715566dfc97ec175b6374c82fe70f4229c4a92d1c5cebe06361387934940f831ec70bda6b0353166aef1749b84f78036162f29f9a869f31c4bf2cccc47638ae81bb0ac6216ff5101557942ca7f4357db728e5946e9386a309f00051d825e31e5d70cc3fd0457c6fc82c822e2396614516c5a155debf55f460ae91a2fe50bc0296881112920b9cf76d39cdb982c1e7b5b2d5110ace2a5c73f8eb3148128afbad746710728624c3a3b75cf30c99fa87b64f2f1b66a2281092318eb8ef9cf909344e8985cf93293070565efb86188d995d8f2ec45c19536d220abda94d2dc3f01f85c4c061a3ea7fa55898163596e99812f4909b5384b9c770d1ec5747e93e005cd74453415685c121ffe6e0174cd1a1e1ffa3b75507b951740aff448322cb8699bdf1ca048175588867028ce8dd909b0ff9aeb41b117518c9e6237ac07b6ea9b98c2113534905aed752b6a37e5e0e1fde35e139fb9ca712733a8cd77bb845509509795de56218ce36ca29d6c6d325d7029bd0360ed9e26a6a203c079ffb5ddc9357408c75b79f335697e308ab8eb4c58dd82da5a0e308424f754e3c820bb7341dd4ed4d5a2d370cc73583a0f42c026952a86623ff1002b7a272417c6940ab813e8525f9b970f3b4eb49448b8d5f6e6c8a5f78f6d0e20fdca9ae52ef1361964a5f7ca5305f5a54262b0946d7e2c12765272832ec2e901c7067825e295e2381288a89befa83d793c34b4560c2cc1b826a5eb265d54716b347d7c72520200f379c4d91e8f5cf3530ff8d5c1228938102b326178fef9326691d8277c36e4d32de872cabf37f2f6b0562646a601bffedf06d8a9a3955bdc79c0b66e8dd7e2f1e62c0bc58a1fcdfe2219eddb316208e985535b31f3172daad808bc58ad9ec7e88dfbd47ec955769d27b93392f1b6777d1db6a563bd3ec7712d7012413227b7dcd645727ef0394c3868c5cec6aae6d6cf31d04b20a9c2b365c2fb00a9dfd36d9548e2ee51011691a9adc2af00ca952fe50066a1e2acf0ae448b05d72e98a02c23c33b5bf692d10b99cda9dd4d56b04ccdc4c5591dbaae06ac1abeed57d418159f9c0964859050659e3bd19ebc99407e24d53617a8001cf455c06b7d7350b8a94598bcf70086a3880bcdcce22bbd195a60459e01d00e42c57fc3f904d74b887ff81a361100290931634920faf28dac892d2721908e79f8b7c8649cd449a9f3d0e0693912a4c7cbc93e3eb3b699a0c0aa8c003794601ad0cb2e387f62677d67b33080b8c4c0f68e56ed5dca4145ac11b7ce55d5a0c0b1794dfc2c5711027c20b5401bce6af9846b2a3a1a21ef909ff5421cc2c4b60474c8c97181e0af019c9bb4f7df5b2ee2b6051bb37e2e875497c3f36c38e14c1dc4ed6d6cbb0714b310b5c6109f0486e4ed4e31d29a710cce9c6b3605fb2b4cdfc6c22b45450e4f3b0a4c5989498a4330daef772dce775da13553243240737687ef5b470675ed272aee58bd243e60af2eaef07dfcea455c0aeab0bdb48dcad1830b76fe6684850bf9f5db945cd6de95d2f1fd92da3575385b3971a7282ee66a4c1a7acb311c96331956164c67632ac71b824ea7ad73b2dcd5ae060d1f7638cdff8d210a679f374a4df4bbc1d93cddc037b2a363c4d7fa0b7b652b245402ef47764165a5a6144d4a2c2b20809ef711b61f87c10566f3334b7021bee96d54c1e6fde28180cab6934868e7645f47e01e914a8420b9f1470984bb726c8bed100401e3cb6702531209680186e2df0e4b9a0aebd7d0cdb78d072a595fc6850936cbd4eafe0cea9ab135bb2968987a925399bfd3b318212c3be68f1a17b2ce18461ff8b900c0d8e35d601582096907a2bb7fb33aee9ab2a412d477f0ce8734d58df6d901ec5e0c9ad14e1f47091e713160b313a3ba168c28143a2700238f95467ada182e2a2afec75e20d0a2dd6b178272e50afb9efccced0ce407e338d7202a6187017cfce0f1dca98ef85d106f27346a148a856a9cc7717ff2fd540a6ee0ca9dde524bc14ce215082856735748a3fd61261e50c68e75a24a2f8acd9616fb7e6bed25e2db1fa452c8e11e3ce57f9ee7a9938af186d5260fa9e2d4a909af4d276a41cd0b817d1861e5524d330dbf4207bf7d727e32c19e4ef3c3f98d9634045d2b0c102374a46e67d93dfd257db8a820cece35ad0bfa1da3ccd770b48b440238dc2df925661832c94117653dd19c2ce73946cc9394cb13e9fe25db5b705ee5c944de05140e173033f40b551192af268166c08d76b8ff3571e5474e42c7cfe4d9f3413f84a5dd3be022f2c693e83059f56cef2cb463b2f8b11e69b9a83e5079dd557d1d9093773a4df48a47a0193c0ad3a1b5490c41ae76d61594a10f088978b082955aa22f1b219ce542cf6f6f9af8ef9906491d5d65c0f2de2a3fc108c2247eab8ad96f2ac5e9d8cdd3580f090e6f3feec56dbc92192900d03f5eb59a922fa4a76c9aef79b948b70a82f6984751376a45ee6b18f1f29c19141997e6dd50faf2581665ba242a181f4d34e46142fd3cb5ea3a11915ab1595105fca88cc63e092f278517fdb6d1683762023f567f7a538388beea70e482ac0c569965ea82e1655c6390b0bf7e3901c67125db1f0fb04b8c306758b327dd0e6abe07024a17187f7b6d2e0507e7b01072516d93e3ec1cfce06e8e4525c1c24fe5f65e384645efc3a5605e06d4c580deaa9c94b44a6a055a064640396af0a87cfed431bae9bbf19ee444e755e26a44bf13ae3d549ed1e650a1d4111e223e31551166f2002d71902724f3eae38ee3fdfc85766c613abd80b8cb7c535a490b1ada3346b81e8f89de5eb5130af8cebd3f147adcdc7b7cbf1842d058fbb59dc231db1c0f1ef356954f080147dc302eb7f5e8c82506f180e3d58b0fd1ea640cd4007c50aaaf7c99e73232f9d7bf467d9c3f59180e93ce7180ebd3bf12444eb556802ea4d5410191b00fe4060b8e281736c592e08f1fdf4af5a6ebb23fb4cb401c08fed00b24933c532598de4bd5f100a020c376fd2a633b2367913155c0c2f9c4bfa4072e6ac046f40b619288c5ac82cd2432e60e12f425d0c03ec173c8391ef5b718f7e9076d8ad203759fa908b96eef7ac1bf47cbfd1a0af8ee5eda26a57884cb5bdaa3081d31e12e3978844d327e0247231cbe335bc21d32871f2a90eef0de2617f551e5523b3cc7afb64bdf7c3da246ec1d4ee3a76795cdbc2e0bf846b2580277fcf4fc69bd29f619ae67d9c3395aeb3a3e857e0de070086d89698808e59e91ad8a3862d134521ff6c19cc539dac61e9f984faa62d5f1a75fb2835b98264b2cf88f4e302deb42867bb3311ca4eda0436082aff25ddc02fb4dd7cbad46f4d8a7ab0ad5f0e8c70e4b983767327fd8bc80d6acab255c1049b9c86eb6e796f680d79b29360f3dc822d37547634e8a36b06e4b93d64e81965123b71e55ab001be262505c810e0324af2c7c4b975a29673cbc129bde0155254dfc5d4937fbe74f21652f5faa7674db6aab44cd8799d494528f5c08efafb444a2533cceeb39b5564bf4d07eb35c5d6c90abab2efcaab7dde8df5fd0da8a6c04043db1335086607f69d5fd604215823dd4e2492660e625a44f683a8fd4a63088a26607c0cc49e0907e7b61f48755ae60fc95616e24335f4974e2de23d2170005ac93394fca4f21aad573ebd37cd1c2f90fbdaff4e8594fff9fef7c2c4a7f062b1b18eaea6895b7e725d03fb893ce2724f0e660ed476966b8bd50228ba191bc4cb81f7d8d5fbacd7c4cdb438cddd13e459eebbfbe38cacc792e7d55a701c663a24c99390dbedac545cbed0f3013b8fc16ca94daab9c7660c908e665c3830df6665df06e09dc8dd18f55702b6a8706c6e6af950ad1cdaa4b6b96d55e275ac504cbded5d83fba3eba957d42a5ecdc2bee415c03731a9ba32f5578ee117b9bbee082c3b045e4f762c3e20c4f4e9758be669085a5c80bd62ee8819fc7f8fda9cdc6f87126582d22c4e9b54a41aa100e2e16d76a2ced96bd9022e1b6e15e14e3a22ecb9e94cbcc09422db247803171790787e777e263e92b286d5b3bd2f4e17430d0e5b19cad267e59acb5a4808a56a2c4e05e1c964455dcc81b95c6444574cd546ad02d35ae1423404197cbb38358b9a9255eb7fb98e714ee6b8c53e08303e2caf68943c6f27e23b30b3bf3e50688457730fdacf495e9efe6644e90311e9d898209c35d8349260be3931bf58e5c74f15c7fd358a1ee64d33309f4976d262bed6f6a49f5073ab367e9c029d3cb058516a136ad85d11a09797a086b4090d0016db9f5e4f5ca0a5cedf0408da1f0c6e3ba38948b95388a8004bd320fe6a17f0a0a29a5d24ca5b096f5e9f5b7314ec334b10001eb6c116e85c8ffbbf437daab5565f59721f94c7446f9e5eb5c71c92d8f73871bce7a16c72e1044f8b26ddec13f70c99b4816def89d389863483dbb233d109d446140f3bf1bbd99796dc34c4ac1503a97ebb86b4359f3b5c44c4e463dcc9858451396b944cc0f8a04c9fe8ac1a735b7d6edd1bf9b814554c7bef2cd653118743802c0c723e0d4d57bd88075aab37ff1247e99b1c4c067938d4335932da7e9c223bf3cd9de2692c115c60bf46eb33396f4b04d164a5dd473b85bb74f6952b33f5d8f2fc6fc2cab7775a4ea7158bc7ead6a00a77c3e4fd8465c5ed5976f7b95a3ffee2962104c45f88aaedc53519d9069710b8ee275211c0fc62f69d7d3a012672b952d83c0dac14cc4d00a9d0f8fe2a08512a58d51a283d8647fbe40766842805b710e25e8fb6779bb4a1b2aaf1b91dedecfc1686a4b329fe78e2ff1858097e42e0d01bff216c0b9e426fc2fe0275ca8702972dcc63946097bb09603acbcf9674a609305312f8d4c90a307acd26580212f48b7c3eb6fcd13123ba718c0e57eaad93a8bab0fe36a786202fa9c2f383a59ec23118dd18d3598f88255b2544db439e066f97393e99e338b01fa28cbe520c8b9f485ef50172d2dbbea21dfe7f3543aa0ae112628539e245f2a2db2fec6002588a44d2fe6f845b72fbfc37fbf679fcd6b96d6ebfc2f0fe731d6a2eb5c7a0bda9a342a538678d81bb2f1b33377faca84840bf46bfc362c500a7c04c833d4290b94cbe453d3961f6879079730d54a59b981dfcf6e1b66177d1b924be78c3522ca27063d8a55b51c71c4c112a8a308f321cd5003dd0decc29e3d733d6961687e8ea8d3f1a7198f26a44126a5fd70c01d69a56f28c3b8e5b218d68569cd6b27fc05d020dbfa2bd76cd8cf8c9e01a5177dcb251ef72cf835120e9e6f47e51e66f97f2e399ee6c7642d324f814c848c6cf00a5cce6b5a7aa899a3c24edb5c53635ca1d6c059a6d43001474ff028a7dd402dd11037dca13f912f1a3e8733892ad14576df68514fde0c3d81f7d1f3bc55725b0136b2f497157c1cfcacd33ef81219f7df33d34e708c86895cc860fb3f353b7cba73acd5c6dca444339ec9d7bb910da32e47ca1609f1697ea0560dd244895794ede975529ebb3ce04a7096668f55d135aad926e0c993bd4c7335e9e6d965cc107b44dc0c3d58534b33ae31d491ab0ecc1e4ed2118e4339f41d5ec279975c451f30cbafc08fccd3ad12f866790c3517fc866de9a21d50477016435bc692afa7138c13286abc271a0e8a86ba40bc40b9101cbe3921386c2d461b9e1043de289a5b813d88264463897726c35d4c078e43943ea6398586e4b0d86b7f3e7245b8ba0c2cb8a65f395e394769dc979ccf7c0deaf6867e8d4dcf45dee3bd63f6524be716d3b86b6efb41412d052b716bf12ab060e49b9fa1f90cb6996806d937715203c0edb88323f20fa960609ea41d66f11b74989bcacb08a4bc86590a5ebc55b06561902a24b0fa2721f450b0b4f43a0f5f491bef8a9f5f724373e3ef257f39fcfa2d25f4acf2ae205996f57d77d242b1578b98152337736c82cd7fc111147dfe54982dfff1ff653114ccd94e210186418c496c50202a65d4fc4ff3743ad02c368dab66c1461b4438a3eb07bbd26fc649a16ddc03aaa33cfcb10a5b9c610e902a18da854c7a976755099c6c8363921bf5d4b8b51cf42b6653aab2d4b5a9b56e959e97bd270f77a0edb41826654bd3ce72f1a6ad7092c240945cf09a94d33ed994d928a70ce350590b955e64c1b72a5dc6fd871577277a7ff3875710a1aa9a1e27168041b4af9496e95906ace2669b6d6ffd1ebc142ecc545e926757cd6418e4f758133f1c8ec733676dceeb33461d6c1c5c41e626e760c432a05965a8315f4ea7be95c96361d68bbc5b0ad0089c5010daa6adbfa855ab2a10858de3b063acce30ec05bc90856989ff568d3001110f6347c10ce13e74bedd67ffc1c0737940b5c5a3df25862d254dff63442c552219becf5735d83fb0db67f728096ffafc665d1c29bd2f9256b5f78ca35210bc681f0d10d33d4c4685c6fb380db5270a94cb469ec476376f6ebc1ebcd7eb6bf357322d2eb8ecb86309b68829b75bbb79ff4b6173be592415e851207d68caae78301689840ccb3fd334b6ae620e8567beaa667b1654a8fa0e7dd89322fb4baf89faaded9e6bca2b130e5849492baf5e88a46d67912c0607a995a5aa3c44121b2a3b1793b504fee6e8ad60e56fca6987dde402415dd8a18214b5b0cc46453dc0fafa9a9a7d7f17a047f8e64bda68cbc5687daf5c5451da3d7ea93f1bf20ae7cabcd663dce81e35baee78ae28a84a3cee4e7842f4f791737832cd7d4e19e2d63fd1f4d2307555b600648607deb53b312a747009ebc387f21dcf5bb1c46690e679bc39c5424dd74095dc94a06dd9714438b9d3aa457c8eced15acabadc002ad7d199294d6a10602ad54bd4819de6497e67995e703d43c7086c4041f2cf0fb35c4ed3ee4f96ec0b074955bc3f77b766618702a0bb4306585e9910ab16e01cacb2b3718cab941e7bf55e2cbb770dd462623ce14fdb40f54d6bf9df6bc781878d455471439843cbc4b3a1f61fdf93c73f079dcf1db9a1dc2becc90905143d4538604605090f1bb2616514a0a5bbc1bbcc92109dc1e3f01dc8ff774e535b5d20c722e8a7def818da2bc4fe746fab16869dbbd128ed7f1c777a6a84d80dda9ce08b78ba89a9fac6251a0d1f1402c6018c919c5f950b62895b42ccc3350bc0e93e78be549e07cc0595e676a1484f838ce1e3e7b05561937b13ce2e92bc214b5bfb9d3ca422138ec55bcc61a3e5b0af49f07278ef2212dbe7d5722a665ace1b1aa7cdb902eb6d6964c56dc4edbc6411152a64af78dc8d23c436b0332bcde3ad0c117a9f5366940d52db5d9e0aa800424a6cc2abff27103138ec3e2228d406587cd67c4dbded0bc43b3a2a35c638afac12d471ea531024c12db1b4f37a9f1566562d92c4b7c447b81688bc431688796d7ed0968a13323b45e58efbb39bea23431385774543a3ce4e5d0caae63c841f3b2130b9c10a0ab35efc1240a1ea9d78bf734b185d5bbf896095dceec9b5c9b0a8d7165ec4ea33f21f97722cda61fde6262b2f46b76bf930833493fa0b3de374cd879206eb5bba159a620800221fb4994d3480ed1c162c7c2664472a9052e26509e23067c017ca38338980a820be3afeaae4a31776edc2d850d7c9ecd87b57e0ecd6af520ddadd314808226ec43bdd6ead2c9176891adcd54bd82819e8fc31f618a975161c64ee59da658be08f2f4e5136b2d621556869a3dcdba109821c9eaa3608c620394c85f7ff59af936d49230691260eff41d1f08b58a4a005b54f9a7d8f37dead2faf977671a45fcf1824513ceacd281bb4f93e49741191506314c66914c2470cc8ad97d4e6f00c867d6a9f6387c762a4e634c2585e6b74570a9adf6f2a3f057874a4854dc145185f36f669e7316085c791aa3936e515da8e68a3bad84e4ac28b9bee219ba3c0df956513a066848e2e7df30e8129d079583edf6db4a5619b14191de39c926a3ed31f773a88dc90dc520e04b669968bb8eac3d0409b79d8b88bf9a62dc824ae2ce53ae908aad2be59cc59b9831a5f2d36e466521bc0e43894b121bef5ffb1cfc8b8e103f74be664bbfe95fcd997c9b4bce2a1e0f91e5a415793efe04e15c00efe6d8268bde4f151790e601623688ba9424428af55bf8e90963b54a9b40a7698d27026fd26aabce158296e39fda36d995d25a8886224fa72600435386c203140ee6ee27a7e3af691df6fc98f5d1565638a7dc6f5839fce961ba15f0d8e6c9d8e440ba8227cef10f41a28ed5b3262ca9fb4e3dd6cda5e6157c3927836cfc7e27d5e4d7a7c5b9015e21ac9a9bc8353d5328b9a745b955b8406c411860757fe296201feed347a480270becf85f7ddc52fd1843094787d5566a531b44ada2a84e15ac70b8b349af9ac91df566511212f56e25192205a1336eabb5e1a7a4fa3cc25d61f8b62ef8d100a0f19dbfa65679c409aaae62628c65bbd9365cf6aa69e1a77b27de259d267556907f23ea6ccd62ee194b6f3c490b349576fad7bd96ad870f25965bb3a2c14ee4090653a76b31d5a7733422477e3d5930eae6b3a6fd6e9258dd64397a4c700e59e21666f6ac788ad593c3a4d9729e2d326e58d222934cd37911c571ade5b77ee632c56b4368a40ca97969b91779f546f50deda79538431fbd115c28b3d48bee1227f98b05cef870c97b9cd7d3514037c6d9d5496330f2ae80e792c0ac6ae62d1c284a13835bedfad693a06917816c7af8f0e55b836bce649d7a6339ca193f59eaa5b85d0abdb12dd4b6e75826f17f57ef122e3d1b3ce153cb39f3eb03acccd3f257b22bfbc735dcde730f6c7c1e30af71dff2d0bc387ec623d3476cfd1bbf908474329d108d306a346c950620fa8c850a66e5541b7777e56bbf314176b291048a715a5c74a622421e28feb40db90cdd5d11112cfef0a026fa253f16fc432c6d1e714a56d551afeb9d2a873acb39a818766ef4e67c519051aa98330e15ed0c337f1ad078f2fbdfee54ac7773ba95f63f861d5da0a64bda3d1176825ecda3b1688f34fbb3fad45b0f53eb682da706dfa5420d8d9de9bb93c945443bf215d724fb9003fde5e25ae335a5d9b8d24d60133f5881c862b86b69af3011592eb20c06dd252c701eff428e425384b71cac2e447917108adb44b44fd08363c38f65840d1786346c873219190eba33a3a6ecb4450a4e6e6fcb0b05a92f22986ed6f59071571973b6de80fc427b138b280212673d1deb2d6339d33aac50be3479123bb8ca88abd1aa0e1e2192dafa645dde4e973441aa1b913c5b3858dfd8dad3ddde8b00f091b9ab69ead2f72eaadeec1758ff4fd14f6159329bf016d71967f527a99bf753595fab932660762b36ef0e675c786635225ec7dc1a0624b6ad850e2540539787de474cb606bfddb53df2d00ba4b46a60fc6db1f6b2319eba74081f84abb9f5924ef34b027a33da71cf66e2c59f35cabf8111823e4a9126339912e94bf6686082e0bb38a46a41f8cebe116b0f924666eb77e07b8c6fb9ea67b9aeeb5f4ba35ee98e8954fe6e03311aa7775b4e5dae5248ee1d579d822cc3998e312d34eef080ade43fed1dade416ab60ff2ad6f35fabde99482ba7ae3834fae3d239e46b9c7e6f432354074907825de5a5870f764450cc88b17e705a321bd1e496687f2a2c2a33d91ee2937a4aaa0533f7a40e7202aec0ab4670c5cb54f08d010ab2a07911bed6b87bd10cdfaf5cab3ea684dd51785e0f02880bb40dfa04adb9aeca7a151dd53af83db1a69207583dc7e3bdba53f71dbccf7dec578519e323e56794c1a90fde18e506726558a48e7de0ccdf1e50ac24538cedd91dbc9acde4f21b98657d1515463f7f80090c89971fd84efd8aadcf144474b35c8bed641b76cc519339b1b474cf00b7e5f5db57702ffdf781ca5b7dc43fb379edb9a8720da87257df3fc6afbd24dd5371b8204e79b096e38319f8d2ecfbb00c5bc1fd44dcdc93f466e816729dd5d79aa9cf106d827d9f3854925c18299a108532019c17b74ee47d0f058ba77956fe5fbfee31d36a50fb861c19f2cbd3c32d0bf39943d37c10ed731ee6f2de150a69cd081149d250004ded29d137ee4f86d9e675560168cec5f8eef036a810d4195178fab762bbc36486b6793f9dee47e78a93232c25ceaa215ecc79ffa8f3accdc06c12a01ca3ad17e4a4536bb0adf846555e929821c2910d0a28b535ed3cd8ef82d86d504f6d41c088c5f8427b5ab2e47387908a0a9e725f66af90b32bbd31b7511aba71ffeec8b563700ddf38f5df4c944dac3535d301a36a7c12d69dea8f1e4055ed79a9856af7ebb7dc12a29b300bc56109ab247bfe9ac6166ef5611e4caf309d1ac5e1c08932275680f4ac5af252d0804bca6c8d40e934b2ee12b2b87db351bf4eda42e5c914bec21a39ce8d4e7b868f7b153b77bf4bf31465e33007a360e35bd48693cb72c257a59ebbbad7ce0008123694b09786fa7dbf3a932dc826c2a82660da868cc896ba70c03fa8964637a564bdae02215c44ac6ed368bd194422ee21bde9d73236df56c656754006938442a4e03bc1d3b228dc81e9071bed0c7b382be825b6fb1e9143bdcfdb074357a30f2da3cf5ae63fa209cb2dd16372fba891c5b45b160aa37a492e2de60c98ca96fe432476477fd96bce6b06bb77067d5cb9d8a667442f8c312048db3dd70b859c6f4dba3bdc2460201e8c7c48e06c1856466976a5dbad8c8d69fe829a45d0206a6ab9a31320f4165ab1a51b8721210ba61b21e3cf31aba1f66ce493b549d6463df97bcfc7add0eef2bc3830c49d63f7ca533ae926fe4d2c6ccad46771087c26ea6a4c830810fe27e44b54a4dcc5850e3ea621c1637eaefc51717a49855aae3f58c221e352a049b68d3758d9578b9171e5c3a3aa68641b91833065c29fab9a3cd97798d3201bba3204f05e92c7521b2e7c66cd5cf3a63bc2510a8903ff7f7a93f4ebba5955653bf273d2d44afcb3a2fee6b6938940a808b5924dfb557e24570ab09a9b423fe8abe407c0a67cd9dafcac913901e29f8e19dadbaee050b4149c5459b9053cd8deb12c836a017962852c5da7246e989064043b66afa17531d0d6a9b1a7974b66d881206d7317af9e52d2d45974fa78db3f81567cb4cea28e6d89ac3bb6a3ebab1ee57dc880c2689f9257fc37865a9d5fed076d4f246c32c1dedd0cebbbb679fd7a4f17d0f4272d8effc43a4f107a019e3fa67ce816c840994f2b4947ad1c4fd86ed7cd6132d9d7a6645f16441e0d07cd1466fc485405b41234e7406bb4059cc5e82f7d61463fa1fdee0f64079dba5fd9af8becffe1d319ccd521e38551fe6817a002fe7ccad00eaa37b62e514165e668569e8c982fed8def9943caa4ac710a05d1acba848eb2cff015d2f5a5990aa263297158072bda430e590479a0b8509a46e6d095239efb1c363cada71928922ae6ad2e6da4447f1304a78cdcf2987fd4436dac0683941a00ea32caf4d7a93352b96ce5a50bc8674d0b657b4235c3b5f1f1714e293ce369c00bf35dc3ce58e4b7c3ec7a43cda909625d8abe51b895afabe1960de594891c4591b82fb81a16e8f2d91b587d59b27e9bde149f74f2d8dcc942fb221130f9fbf5366d186ba0be6beb63f539aa21bb596b0dddc6f9844d931e031452f19033a371a2b0971d9d832fca7e3fbdc667783f4bddc87c63e3d7a12bd814cb8e569feff42bf63a8fbffe172602f57f53b1f3e21aa16c3c0f282f7d35981086b361e8d0ed2bc77db5e05d861b2e52849045dff608bd0c07ef3fc4c5d040aa3406ab4e8166a5061267c0af7c3065281faa191edc7dfa8699163dfd6349514723f957386e95fac54bfbb6f1b146dba496df16c87695b2930aafe060b47ea748124fa10f18bf8cd6ff692c2000f2453a6724cec036e60ba39f9a3238879fe62a80e0a87df56d0870e501b241fba4df82dfb79a5c1f64fa421c291592f5a6e0964c8a9bfda5f452dfcf9e59225193fbe3807175650b4d1f16b5928a8a7f2aeacb0eddc1648ce85c070eb59bda6c821bb18ad9e52e8b71a9d4c99d205757a476e99b9be8c0c5089b29bf1672c9f70b19e9d6444b55ac3d42d19d5014e84960d73bceb81630f8dd81d5820c00699bd7db254ec2d04ff99d08dbd7b881ee192f0ae6dcd617371c21f95e0d38609d8d45637c808733d01befa695f8a776de0bdd2ec3c4d7d0dba91d827d9aaa0c8d8c531dd5a7e1abeb618eed51047af0b5aab3144a4a704a2618970a584913adcb8a4edb23b7d3fb05fdbbf81ebcf86fc88e64dcd98b7fe710ce3c368af8a9d8c2f73e333bb1e41b0725ea08f9f8e426b8b71b9c77a5491b332498d3a5f33753b9994efda1e165be54f0685a143d5353c26347458857cae6d3d561ca8ce92546f14fce7b42bf8dee56e51d6e6e08ba70f8cdbe54df0b0264c588aad5bdcf3081de7b8e386984c78be70277aaeb432a5445889e4b3644aa53838f45bdefba8d90c9139f4aa7f65af0b241bf58c075b247dc7d4a69216bf6fdb5fc822d324f78d820c5b533a81616f31cd6491d9cf0e6e10a5fe0eb6aca43c62e806e9a03912f41063ad7c69e3f036f6e7b804268b2d25549bea43dcfccbef39732904485d89f762f43d8ea5c44433555f5b0d9edfd354bc93637b0d78a7aec427868f96c38868dd692265555544caf1d31ee661dc8e0c701579493421cf6484478df4233abcaa63d3c0eeb089c8e557011cdbf6d18345e2b7e0abb83711fe8e0b1478cf8ab9a8e2eabe50cfa95971346fe19630f45e610aeff13deab7a3877e502114d350e6fb3ed2cf9d5a6434b9274f8f6064c834aae659d946ca4455d2a997fdf74b00efad9f1ad0162070b00e1e1afc4278e8541001a8889c9fc60f4bf92ecae1a13f1ae0cb63b60754688c8e6b04cd5f72024e25cc4204327aa95d5e77a6535544f479c6e27962afe685ca3a68037579d09c70697e71bf7e9349933bb41035ea5f348de618b094fd06b3a79cbdcb1e94392f2f7487a6c705def0721ef311b4070a91ec08ebf4f41fa915e75f775d76cc19444bc0459debd9ad984e90feb6ae554d4072ffe13d989d562dd4215867e7b74303c7c4d040ff2043f65f3827cc0cf9cc1b4f5637875bb6474525bed3ddac1edb37624e70e4c1601a7fc599cf4586f4bf640b779cafdff8ddf232f09f3e5f3072b3b1a8aa67bd4301cda3658dcfb5329532d25062182fcdaee99b39cd1db5620441bf9a90de4412205839f2df5245df30d74cd4689c09ce2bf07cf625abbb8ef3f3d71246172acc429df2272ccd007b065cbe5f6f3b3ad9425dde5c1c88cebca1445c939bb0f6f4d41990db1ce2e06d651b7dd94c89ab2301d839372fa60e5e1d53ebc85863150fbb0b846208cce72ae465ab8ecc2516275f988d5a95ae544142fec7ee7041ba0ca2a08f2879125ab0821451c8db4e55e414e0b031e5ec229225ec41aa5d2d59a8a128a9261631e94a285dcc7006c800dc1a10fa2d7ecada6a3af8b7238cd8cea586ea468ee4c7ae59dabdf79a0a2ae86e01d1aad8f8d55edf1ed985c4b2ce9454e7c2638aa64208a7701b10d0ee93f899259c1518c6ca6a4e5eeb34f916d564a7d96ea5de34d803e2c73cd7ec349d6b0e98e48591ab0b2cbfb2ce339197888d7ee14a2995027924aa370aeb40a0520e86a0f75457c9b58e5c858592c76b9d1637d5c770d3c42e11c52065190ce13e1a74e3ea0fdd132134d378b5f4a28e20e70360f721c413c91e55996baf07e12938cc6df025fe0d81103bfd13ae56ef61c2103f9cbd4eef5fd0951fd676e0ec28bf153eab1558d3cb74b84294be987a390a58429405d1488b58193ab419354cbe4212e705537df732809ba645c020c877edec90a15386da2ea0bf14a4406190c2e6152080486d1b505d000b79e7efe895197587455510a2ac2cfbbaab5b2579b6e0bacbe38bd51c8044d8476ae1bb9217a1bba895f9811384f9d9b51e2da2d9a2891afc3612b6bbee7fd6bc96e07776f4381f63fdf1f91fa42b9b7281095685ec1061e6b9c6bbe136112db938fab75cbabeaf675ffc8cb20afc9495a6ef657128803f5b45a02d5f24f0c9b8ab18ea8ff8bb2dce7959bb1d2b82f549be2a7ff2fc1b9ff74592367701b3b2d691ac39ec66cc0f4b11afcb7a8ebaa0d3b58d759d22f8ca054350dcf50e12d192039693eaaa42429bece6c4dff2916826e6aa410c3db433f7f5c6ec54cd7543957d03e54b3ff44ffe3b3be00bfaaa68b3a6931a66086203eadcc7701529614b78405ef67b95b7fc4049635978f84d198ca8acf93138d119b46a90581afe2a78ca62aeaa289620b0e839a4bee9680183041a053f25f5531b85d4f694445cdc89eb9d93ac272047d77da2855ab870e52ff4118173c4cb17647e8d9f76a0dc47ef51133e0917ef2772e67d75fba48508a495c59f0c7196175dd39bcf29fdd41a3fd53656aa33d8169843092967759840800e9fe694f8768e4060547a290ee1e8b8d0390a4c00fe10f314331503a12ab3e739e7246a6e48b47d29d555b16e3c1cc4c3941f19d338e400709068308545ed8018e3362f761427801efd52b508ea42ef45fe4a436da4847babd93dc2c91f5e8eb847be06ed7b3e7d7af7ab569d67cd336cf270fc3ede76161130cfbe03aaf7b95eb33e1554d00381d725abf12e6bab8e2539bef232aed0ac9e02941426dacb7de1e7110c327e308e07575b98b52d424405a4a1e5b3259a6c6cd332a49dceb21230f97e4105765fb9d943c4bbdaab7445af903615fbd4eb8d9e87000ff0ed1d9def72d347fc5021409c8781a27a240500358dd5e8c2853a228f8467ca4142783c256262cba4068a41d2b51875a97e2bb8436ba2326cc482089ece6ed02fef8370fdd67c32f4938ff100f4dcbe46b833d9982b9a34b39edcc1722ad793b8bc7c91bf2a84cdb44cb8a0a86b3fe0cdb0f2e97b50ddba6ac2272944ecd6b7500a5969bb58f49d6fca80100260d670066bb4639cd2dd05d92b9617188247674de1f83234b01b006ac7967aac2f22368e21f8721ee296850f7dbde48c751a0097b61eec487351200113269e752adb67a845b1fdce4b86a1b921298196dfc70f9a2de04332b930d2d3dd462bb4c7ca7688b7c7da7541e35a86d8e89b80952c452bc315ba8a7950b799fe5ae52ea21b817562dd4ef8369ff17ff2d7894a32e402cc1b4a54c08524d136acdcb918b2a7f2a8d3c9a7cd167a32cd38cf4ae00717afe2f9653c355e26a4567f504967eac38493e9a503a55f5b971d03886ec12a556a72996d6ecc9434ca2966b713d1ea02c85c7a2c9eacff733f058b8a74e42d9328ecb523ac10df816f6302ca6cc5d0b8f0abf019873965ae196cfa0c44b30593aa7a0b1d547046db09f62e7a3bc19606f73ae3eae25728b2b45c804354db84670c07df700c2dcba12e46512495a29f0d5e6ade16931c3d3d943cabcf42ae9f2ad35bab5efe0a7d816d7822f527b791a219590c7baac3d2fcaad15a8cb402282ef715acaed4c1ca82fc8b9fd2e69c3778bbc7ff4e57d4cc197e1d3d7a07806ceba319e1323f905b99a91a72efca6dca93d18eba27e54e586eddcd0f419a113c6478cd81ba25458f0e203bbb3a679054584fb18457dc0ec99c59bd7a55078d7f23454519243d4fd618f0b2f851c806ec1847580fa2015b98459a3c5cd4da095f23068e262063876444932e145e42659e61e7897482998a60202873b11d141e319a9d06faf379ba0aa602204f767a4708393b3bbd3c2de66c2d17e2250feca9c6b8ac6a04906bd0dc4067beab5c81059e6214d2c95d269d7ab2d56ce22c91be1e5df07fed220ddc144d031603da7fee670c214673fab99a9df1fa29cbb51537dd1c4ea33baeb568522d7bb70d0fbea65c2d252bd500fed5e9b4f6e0dd1c3f345daefe40f631f6109f4eda6fc638bfa8b41b313b39840d5a4f18dd19a4e5c1a09b98c92be1e626393ab9a0a919206c3017c07413e889a7d9403f3a768d31f626847765744d502701628a10f6950fe2154b3dccce73abd3251a531d1ff2c877313449957ee3abcec5cb5326924786a786e223a9025494b77b62ca252e04cff3fcce5945b8ab90ce5390331de18b1c5a3c8eff6650f464d73eb66ce2d900520070410cbdf5e05f3043bb9aa995007307e39cf36c66568acd458eaec6b097c1f4debe06688f2f84d84566ac7013c0c993de06958aa48aa2ee6d2a024271ab3732a20e704d68e7d4306fff473b2c90222f97671c41cf20b7b507ffd5e88615e4cdbc1d5aee952c818d612a632038f2808d397abc87a36d27f6ca46fdbcdc9ca13e385b2d4e2f5771b452f9fbb6b73884a9fd7759e3275f6b3761f8410f337347d5147ac2619d3cff94951bb71958996316b2d8ea73bc82c1c3ae73e6cd17ca138a419aa5c91c21979799e7bc143a8b92fadc928161e0fe0bf4802757674adb4358f131fc87a8cec68deb096df7558f3e72ab914613c30ae85c04c1be7fa3d084db5eea1c00d2a72e2fc7abf9ee3d9b4614b1ea722210c4d20a245e2d7b0093abc5246b1b74e48042478a8a4a8e187243c4bbd52fd19380d97bdee6490f00c49d6e159ba69520fde8bf0fd84dfd4f50d28608d23303e7bd1d0f8d9ff4b8c156766a03962ea852814a6968230b38957ba21a5ff3908be75360cc7b02d1f85856aa06f1a094624183ffbbb10167fffb31f22a1e4bd776745cfb3f726b085ecdbd815487d9c466e774c8b333b393c2feadda449ad0c27103ab15b1eddbc342045e0769ec6d3e35c0af2badc80a245dddb96ac9baf62b5683140eca2cb157d33ec79e2013ecd442d37d9054748564482877351a95415920db7751137a220eb09fd0a85685354ceac8384b4ec91f613f7c55e77fbbf8069020482ccb1b81974e9131343ddc342a531ecc031b247ed4ea5c9879b8ad5ce6c4b1b95897d4c14f88449d289f68e3818aa56c5129cad4576e9f06c2f46923fa81ca5a702631a10f741933fa723ac117e8c58051c03642189ab28a2c86b0d92e51f813d72a1a090c64622844a42211e647f324707fc5dd282403cbd2b66dcdacacfb154cb6461ed408449a50e3c98b34aa32342110004cdfe83c5362d803785e166f423a46bf958d058d699a91116bdedeb083697527b41b115c4e6ef69b5079b310f32854dfe1daaf4aa901bba21fc4cf8cc501b9ca3c903e4473d625edc732963c0feeee7080e5ce0dded280db4ebba9ed17e5d796bd96033e92dec5c3f4a7a133968a53b8b2327101b86fcb37af2b9438f57983a07f192cd514bf4575f2c2b1341c90c6824f39cca98976822f9bfe25ba5ff5b2670392ee1561f39780c9933f39013cee1f35cac88b4503eab1573c6e9ebccbd5030d382002b08142239e472047c601ae7b10c126f9009af6822fa7b89fc615bffa8b9a86c3ce352bb83306073ec62c4cfaea35198c383be9071bb796e4f46b4bdbc6535f6290d73c8b29802c8ab410ccdb42e4f0dd67e6b90bd7ee2dba091711f7c54904e45ec3d56e6bc252ba293c3a3e38892d99762c6cee8b19e20d3dc6ebae78dcbadd72f706acf6fb8d1440c928e91b06c1008862c9d9c13f7d393c9b4545f225c7caadf1cb8edd3885aa94a8653faccead1a82fb4aa4fb222363e5c6bd27b72bc3b81e7c91616fbd940e8e74b0c61fee78d82e12357f2a6d93aec9e9bc9116cdbc36125e5894760d11e775f7aa6ffef5429d4053dc4e88d894d5519b2f0d20fceaa87cf2114d0f50b110bb8336c1487ada39ea4782c29dc1d0f6332ec2180957727428b5e37c5bf956731d023123372e891a22dfa51c3b2d8940013c43ebcaf461a15d0bd9ca16a4202aca0d66ef8f7be176dd766dec99d2b44f0c44d3c13a6b4120e5898dedcf899e8c36a69dd23988b545e73a2ff6148fbaf454bffc0a944b39fb0566c7c7a652c012d09856ed258559f3a4a343c1cf54722930d918be42d2567e46e2a89aa91a6068a56da4f17fb86c8c3dbb9c3a6533a5f8f836b5bfd34f7367b54318e1aed57ac353527d3d75f127a11f648bb8376732c9607e94b9887fd380d60bb569a59aabb8c2c3f1ab39ca7847b78a3386945d8800afcdb8dcbb29c3bb7986d818878fedf4f4c6d780c324160c893d42d393997b8e33e41547e4a581a4cd816111be6fda9afe29f49b0308176f5ee927f97d8427249b38137a114768868be5b0800ec837df6b9d6cb4453a72f893a66b0a9a5b5b263b2ebb757d3143982949e5b89dc8d2aef420e7b0423ff39ba546a8d6ee03ab3c7372eb4db0a5924cc655086691302f648b5739da498d49c3f3025e4e15bf8eadbd339d8a496066d3b59bf1f70641f423323638df6499ebd2b2a4bbd90c4c006530d0ee345a8486ad6cae219171b9a733e0146df0ff4bb3b2850960946df74dea7c17b87b215aedcd8a06ee651acb80cd67d3a429cb561b9dce27934ac9e3a09018f36824303412532fb2008367bb69dab90939a1b3231682ad22822d92a26468c792637ef8b5eb0336e13d18eaa085ed1094992f87d8e24e9bfcff1475ec468b96a9d9ea2c4e163c8017d5fb392ee629c22dff57d1a5d4e82b33fd6f81684d26c40d58a750fd2d7ff1e31988346b31c22c2846037cb988e8166f3f6a08ea2de9bb7d3307d7cea4dc0a7d50a837d47759e665f80711ea720ddff47d0c0cb474cc0a03bfe2857c24ac9424cc5d9ebc2031109ed90beb9b3019bc7f80b18c351f94b38c48c611ee5a1840e902feff7f8f1f453113566d9992e40451d44ca79e669ec8519644e5165cdbb1f232a02ecab8be8a57306d0568c4f533d7d9a3d60bc2689f4efaf397bb0184982f5583a8deea58d7731e640d16cc58b71ee57d9813ca2c82c8c27d57f65ee4924836d0d52f4984945301d0e91705cf6a78f09adcf6651cf9d3e2d887be0cbaa0b412357dda22cbb696af88dfd646e5942eb90c644562078cc37d05c9ceaf23a31511cd166da5711f5c5ac0294aa78c7355fd97775ac3d2ea08c5d47a2a657df65ae2be87dc55de4b536ed2438c5baf824899631e08eb68d4b7c80c1428bcc97426a995388092e45ec81f1d26b53ce8fa122ba7b99517d37006d13114d4393289c775736fc5fac54f98b047bcc9baf5ebf12ef4c31bed1a1b43461a9fb47649c84469343f9332444f3ed6146641da7e826fb1a77141ac27f984af3a749e27418b686f993dac38449838ea3d7dd6fba0d0b3460f98649739b03d7304cdb7eae76e5a3011e251163ff31dfabfa1a035fdde690c535cfb5b935f20f97318ddcedce42c1b67a48c467efb0424c40e3135eda7459a3ca93bfc99bdb3957a6d557a740948efadae373448d4471d1632555b1d661d044d0e0233de80c6378fdfe71d13c7e984fb84a5d2a00e7e6b55835577682e555934a3f74be9090afc0c83efb3507d8e3c09de3b1e4cd3fed5b04375cbaf2c3b9732211eac9dae6741d8473e8c36c38b1afa60cfe34cdbe21dcac146f1326ae18fd3ba46f1bd5be5a6413e330d6ec4627e8727a6c5606f36ec7f3d3e0883292e264592ccb193f1d35937f34ed6981549d54848c4443e0d661c9714f1f691b0c298a98654e5072249985c7cf013ff02b85a19b67e8358daaffce78fccb7fe8566deecc313390d4acc206725ae9ce00a7ec92598545d13529d486cd0ae1c11d28f2b9da9b9eaaee41136382a950d0ed38a6cf7f70f4d88f8167c96ea2338091de06eaa65450c50899bf2011a4a39888928212e639aa26baf3f7f42502faa32bd31bc072aa8da644c0636b9011795a79ce9631481d61cac6b56c41450d80c944729e6e84c911253f4a2d44cfd4cb4cf1f9b83ec538340da22b8069a0b582034440146cb7dacd31eb04bb6ca0d81bcbb73f0eb09a7173480ea7324cc8b659a0e5612d33a7f2820d7a047fe375b0bdadb911b24ab1cd5089af653ed8c0cd578d82078949542644f779ce3c95a2e5b7c26625e3391b3c34678b3e634d95ab25c67064f26e86d070ffcf3590b812dc7e60df46b3a48cc6a9023fe78eae3e6af9585ffff97396f8a50486a8a4afb6c02e580af429a3bf3e539dcd4a2b784d66e658e9c55760e0d5a3771ab1f03ac0c15c7721de0fb4fc142aa3cb95aa62986bd3290fe8759fe9acb78b38879d7740a5df886989b6095d8570c02d2bedb794fe6710800d50d2e226f0e06d967754a0c3fc9288e08d92a4618a838f38d10aa6cedce8b3f791b6770f11b8a0d4919668477bced8bdba43db1864e4e0d30fb43dddb29d0d387bb129b40969ee6b92535477b4970526c9faeaa063ffa6fc0fa316ba2e6aac7b57ab44eb7a8c0acae5d15d0ecd999169ebb2d09350ba2a6b8d442a32c095b018f705037c54aff835dd5779dc2fc69631f9076d84599a589bdf4c38150d5145b9f9bcfa7a69be5173f75ac6b95199487b2c1060a9d5cd05bd19e9f0b43b93fb05c7cc188f66164d5fbdaf3ac9593f254f24ccc93eef62de79a79d151382b90171dde47776f9e8e3bf68240947c58e76cf9e97cf5216eec1b3798cc39ab58bc1815f2affbeeec224a85b716df81c2bcad838c7c4445c692482b6bee63583358694bcfa520545d3ed568ee3d169161f98447eaac2ed41fa4a48afcfc3ae8f46fb9a36eaf87352d17b5a4902d61f1f8a7747389b5b6a34babc5198f0ce59634583354b36deb016adc15134559eb8b50b7434f5248cb08f2246359a73ca7fd4c84b1475361250f5c98064f7fb8ba39238c3994c45e58e5fc368018032eb3554f22307c102a71db0a3ece31061a4c345384db7304cc1c2e832d7a527bab4b44a3d160ac0253ce55678a405babfc447ff509a3493dee62b6b2e3f031ea92958bd0358cddfd72ab9af835e185f6f2a18c67777a1497d094f6bd47bb5ffbfc2fb8111b77e1a03e7897eadd39547c8ad5360c4ea79db8e915d8a24e809eec19a6c8ad4c46a8ff12b40d0e437cb73a9e452342fa704a435b5cf78fdc21266a4d753af356238e9fe586d7fb5351d67d3188e58de5cd774954ab7494483e770c485cb847d1997c84f5fe3bac823bac9900addeb807a9f8120bea8cd7e3aeec2ae0d07e1a5cf6f7dc68eedaeb91a8c3b27b18f9ab4c5b21958658a59d4296d345262fd6dac0d59b8f582140a949b5f4bc4148eaafd8658e05046e8b79a55781fe099c6fe8d4f07722fc5852ab287d9d712ae874466a379c6e9a633772d3014d4b6b9a1e40d370a088e24047d05c6bfcd1aa1f773d1a516aa2cca11716ee88d54ffb824220c4f632a8ec44ec56dc2442655d9b172c89ccc958bb088b52230072a42b8625970d409e674955a790695e24cf23bb3f5b6dfcbb9fe171e1fcf204999d87ecd782297fc49166662bf223a773f5c4bec25c6a0336811219697d5ac6ec9e0aaca2557edef093923f9d28583456683e68f7219f0cd42b79f5849811a1245df2eb03a9f3d1b21a3fe6c3f525ba2f081956c9a1262767b4c0f1accfda0257ba2b3c21f86cfc76c3063d976af74b71c7845c6d43e248bced01d940a1b4003811b11da7c082443ed309a88092afbe5ff930af69e175ac84bd972c9dc20580f00e373b170ca4e0cf7117ae9d6273a284d7909b29afee9334fdc881bfbb87de194a21677d68b3261e677752df275076f1e754ffaac9cc169fcd5cc18c503abf7e70b3e494ff574a292c676938c47d829391ad5873f3af065ebc3026aa2fb2fbd59461c248a3e38294b40c24e2f9c985b7be020e1d9cbb8f639226414403ba3fa2c8d63d53e3f950223937a6464bb4dec0e64137ba4f1a7036562467c3842d6cceb0387b406dcf2059732371f57c433981bf3362d924d174d229f9f1d39d4c5316e1c7cc2470ff324cf35e94cbf64595f489cb7c64336a0ea5c84c92143b08edf0cdd426c3a08d09ffac3770a83bed9c2ef3b5ddb6200883e2579377b1495da96c5beaa465cd39486fda4e6b1a6554688fcd5608ea80b9e29f667f08edb6cb7a86a2088c8483f7ee885044d5cba9c81d7d137179f95952516479f761f1a2a488603b37e3a5354bb314ba3bfe6b93dae3f136a29460092f449a35acf2f6ce323be20080d22fbc9dcfc2f53518daa1d2c4ab59157716dc949af64ec9be451308363158e625e7e700e25d634e16357837a5d3a49270707e1656e6c85b9a2a086617d806a12254afc71884fbe2ddc492199ba7516f6146c60ddb42ef84924155c7293ed23da06e09327550dc407802e3639803cfb797006b30c2e274cafa477e07cdad2befbd75d9e6e126912b4d8883003c293913185a0e7506cf16e27ea08e8f5dcef0d8e965f4f648c7bacadeaf6381bf84d1aed0f4d8a4768192ff93ed25c9ba54234c3bb7f1b98393b711844131104e322783df9dbb59a25343eff5c5b278e77de11f563dc7ba8e171f126d7098c14cd906eeb2d1cf4728cdf74b20b9961e4c580031cacb5b090c5dacb955391d15128f78ea72198e79b7589d01d77de5a61f241d84542431569a682ccf2aeea9a6772bbb2608a8ff98f585821d44a6764e9a60188c5aa60176737415fee696636dc52c90daf2ae52793d4c11e181bf58a1e23f6c521a93ef1f74e6a1e737f5edd855d2159a6ef20dc82bf739c82d49ae690f86b01e5f94124607009441bac162a93784c4f907f0b9d8fec26c8b87a6866241ae33d55d8f2ab75aff601a8f7996c4f9a42828d5b34d5ee8f5a238b53f5087af0a0b7225ab0a9c2a1357cdea30705b64f4fa538d628c250b54094237c24e486804357707e08d7b17b7ff7ee1f383d8e6da04661c2b10c2ee4bde0d4a699429e99325683510dbc0deb063413e98e96a85df8b8cef2da1a3e3ac2eb21978e97eea41e5d8febfb4811a59787d7258d70a3bec0fec1808104bdbf3f7ac9309a89997a39aa79b4613a30a799bc8418e10adeab5a5849df412cddceb6eb161267014ccbc33bd7c2f5d864c79b3654a836168f534af3b62875a3588ade5dda46a534ccfb7120f5d59949271c9f8000411b2eae9d05bdf1f370174f5fd530c32aeb63375ba414f7287f43eb4cb555dd5df344e9ad9b7c0744b5b93a57d84232053d1dfa2cdcdd673f2f00bee8df5bceabf12de0a7cf09174b418d3eb38d84059e9815aec2b9f34f29aaf364b7cf61517bcaadb16f323a391bde2190cf1f4ab5c498a44e7f5d977a60667b37b28dd1f5edbf6f6f6e84c7deccf68a7022e84ec9f27612184927d65c735d1fa94b88e8d103b725907dd5e9123ce38dd9933ae037fd449ece8d8a45e887a7392a9ca4e5c31c81f8bf3b05890a56a5156e0932494ea59dc0220034c3e7a202634550cc51f7b60ef92fa0a34b10362433dc18ef0453d4e6ceaaeb50ffddb45146762fb6684dd9c6bdd473ddd5fef326d9ac7631990e4036b1ca1898354b9725b45d93fbd5337f5dcd752b5a268e2e45fa9871b168c04e8336c3f6b50a39c2f4529a8931140f80373fce9dd69a13c5583d3f5007e1cbfd223c2931d0ad4f7a49b25193436e1e3af9ca7e950120f7ae3adbba5f074a37306ca9a904777a42f6879fdee4afe8536ebe14ee95c3b4acfb40d54a4ad886c7e998cc35a30503064b3030667ff071de5f22a2a6c7d15fba06378a6e6ea13af7d0e4f83f53183dff0fb3e9bf9951769304013fb7d0acc19ac9fc92db3a499e049890f4b5ac1528beb7723ad36536a5a11e26e3460ae658ca342d980cb07ec8a1659b9c4281ee51d481a79b238deda6bf03b3bcce7d6b3ae4c5718dce01e8e6c206405678cc2745119ce6660f1152036c16bb3b90e2505f9c4a3ed84b47c3ca9f3a04c1461ff03680c5f126537e761bbe99c71344d4f53db991dfb8a11cc2fc1bcf460569f6cf5e7b16dd8874ba9724033a14d73a3d350ca85f494568373724f93f97406d5a5ff7a02d132eb4f8a260cffd0fdd1aa1da71c17838d2245e51deb80c0936989ad41a473a8e7e6ff71ec45e3e36daa020466c1c3ae42869fab49ce7d357bd18fe4c1b21eb0e803d2a4398b800cf39b4f2191020361685bff1c995a7cd8a46090f4143738be8fbe38a69c669af626b32581f8df4101e01a1fa345645d02292e19b38ab53b8c0f07a89c90e98f948e06b55f392b48928dd16db85766cf0b096aee5584247059f5ac7326266cbe85b24cca80711545f5f19d5e46cd585faf64b278ee9bc549f6b4d4a070e7045ef8a25f6891545dcd42fea20135afe66baca1ac94d34f4894f5c0e6f42fa2d00e0ea5f83e650f8fe792d753281fd3939bd23440d70b7e227836205e0bf86057d42c2a62df0e165e3c1363f53b48b4e6071fb73a69d47482883d4b2520632dfcbd5d948d28cbee2d2475550773ad1e7633fa65adf80b33c33f4e45187600e9f721cb49d3a2d0f06c03ae2a941edc893f3f727ed0b4044d611588515cf2b99ccfcf819eadbd099bf05d731469be27ea0615cd7f91f87e6f1661dc6904ed8244c4aefddb8fe34013b703ed3b29906d7e78ef45417c2910b2c89b5cb1613f4603d909da4a9829670fb7e895f783fe0461f2a43cc788926e40546af8a690863d4d49f058faddda7f39ea17782677fac3580a48da04a6d5e67f4a04dd582475f49c2461718184aeca1a32c42884e0301e5fbf63c5522efd673c3346569db5840ebcb827995901c90e5d33efecf01d73acecf895946eb2113b5726e9f792f2cac072aac10d00b8e1fc8ed8f56e473ac61fe1a057e9efa629d467fc6bb44c435ca67a5389aefe44756c322efac0804c0644cd3193bbf3974cf6c5fb327be514e579ea0b702d538934df3616218ade5343866439df3165c0e9baefd9006138c94987e25792aeab354933a297ba818b49430128cdf294dae93bb0506aa90c81f0dfa27b1f8218205e4df55163ceb78af6c718931a043262aaee37a26adedb6459215d3c18aa83fa84c08dca134ef6b7d09e44381bdf826eecccc6fe5dd590ee69989e85df4097ec9829141b00ace8040dc67fc7aa6ca73b6dab95db53faefd2565ec27ea1d0d557e41078f3250810ebcf2ef07ed5d20f9c39353ee15912d2b7c86c36f9b7a8ca073f0a5ed09b3f0a5f2180068751f8b0e1d5ed90310f94f4ebea709db200680b4dd8973c02f1f61f423b8aee7b6197d7f68bba197582ae2dd0f1a7cbbe89f33215e3c947eae1826bf0fe2e0e7dd2e021ac40778afe0c16f6129873ecac53ada8533e009ba5bf76336906dc983cf729f63705048c0572b6b1838e4dcc9920ab622cc2614ef4b3f46fed30f0c240cb112e68da12417d90ffb17819e5c72a7703a3bec62069b64324eb3ebcf65dc80cf814b8701c3143dcd018dea8a96a0ce40fc84117f40d7bd88b27a8ac9dc4180ab1f81f4284ebc8393569c60eef3ab573ddef36bff93e0073c29f1b7d9e2d1f19099bcdb7c54f700d26adf01dab8959e587c268154634f16902c0c18d9972751dab4693eff73cecbe4371c677543a73db7347c76310114a03a381698d081afa6be8ca7ec47d993b9bae43d393e4ff16ce52a15413a2044d82d36347f79bcaf556dfb0e95a765b020309c9e46981607fbc4c5e6aedf5a2e986d986671d07e57eb6f5ce9ba92b39e21f79778a674ada233c20122e5c55ed742bfcbe370c716b29a0aaffde0505415c7aef34737fc2d4129f6cd40de7ff48aaef086663f6d7c2998ef8d7de3a277618bf3640ced70779117a10fce42733caa8c981e522b700efeb8d2d331bee62d562eb1902a0176a4f1c10cd37ee431fa699a50fd743bbcf73f3d13a57f150be2ab07f65f4b891ec887dca6998dca0b230e5088e8a208ea92efecc291d954d4b226a53f15bb32b9011010e3c6f897bb5a3999eed6578ed5ef240fc27282d3df1d88c396e0516dcc6e305514aa5690426e26d4a24a8fd62047d887a71f551b47ce9525073dc877dd3a696e9420ed53cba6fe607bc4187573921899a21d9ea98cc2230f5d010c2b1e7585c95f53728a6fa782658364f8e307d45d96e78ba0a523ad6b8f7031b6d93bf2a01363ffabe7a95090ae109cbfc4e9ff9d39a3e54414b2defa37656f445cd61d9adf9c9e0da7cd076208a445f3cd58549822e38512850cc757df6b0cf61b32777adf338cb630ddb1bfd4ac101cf7ab20839859ec9e076dcd2a847929aa8f8053b424546f807aa6729ace70ae3f1714604c7ba2cc43f7936dba20bbbf4173f07732d47a4e7c3925c8d329b780391698dc93ad95c0cae883577a4ec00bebd5e2dacd69298f1fe51d939818b1fa5f33fedd5991d376894843be87b5f0aa219f94795b110ff5c7cf75a5b94681002fad04ad3ab8720cefb759641f0a0a050eeacfde2fe0bc86558c218c04e9e0356a00f51bdaeb29fd765df11d4f3dc8c2111f1efe8ff0333c7874994504f0ac0a00967f065742f6d4d21ae69e4fe8d1262a1dd6e4f48cdb65285b071957738b49196fa0a6868f1f062a250c85764d97f74b48fd07df77b752ff115676ae17cac85c329ea112d4977152b1a5223f2fb5390b2c9f31ffecb10be7ff2f2db9725de8488f2ef4e213ea2453a9a7fff29cfdbdb11f2e6a0acf79cb28250023a101c0d32bf998cebaebba396dc836595cab48e30a7c46dc07b0947e4e374989944e66bfb87c10d85b5d4c9b5ad2b0def11e9c6b8100c9727c552dbb406226d8f489cd8644c6a64ca04631fe8f2a73f2df36f97294c1bf3d87c51fb829d50505ad546b5500657b8abe68212c6e43ec4f7334ff0d74d063ff39f90b99fc8853229c11515f23f51e7141bb05f6d30015a4a27fc9c57e13a2b3b5a16c06042027ea454e83a29827d5e813d1e4c41e6792f4e98a4be1ea957b8e008462bcd80efd6e264f5d034b5f1485e6fccb091ae265af5f4aff1fdf983ea810ae45f916a46e3ac0951e16197e204b626a643ea9142dcc089febe50a843d61ce20e6b5b17dd1b451ad0e7323b6ebc1d977e5436886a6611ed96e53bd1a1071286bfa92df25588b619df792fa7285c14cdcba1ca8bbddbf80aef4070843c75a9a6a47896228f785f012268c9ff47dac94dc6690b0b5ec25a74421ab0d9836003b93fa610fcbc38b7c20328acba9af46726c7c5e739d7388891742994c5e3d4f8d2b8c393028a6548f2fef375e06a54490132666b5fac768b5d634247b0c3d0889f32047ddcebf1b8995016677f2b767a92b13f8ddd1056bd2416e9994dd4b2029a528bb6e0ef7fdb335c41a33844b18863200477691e980f9b51c5a6856be0581119168ad7386e1da5f7a5cb6665ae34084df1fcb5c5986f1c301b2b4be11303f0e87fc351bbd6eff2163b8da4237da6ce1046bfe1b23d9e21a0ed67c49dfe44989995803988e8ada6ae466ed2480f4ef9a69101ecc17da4c136cf9140bb00d21b5a84685ecf2b52d1d316ca1ef33d17b89caee9ab265424ca392f4fd1e5b96690c46a93dd1cc53e5eb7bbcb04467f0526b95c41db65206d14c5c7f831033b9b520ee10c72876ee867f5f86e6d43dc9c4f78934515368d3b353031b45eb730f3c75c6c44339fa2a53af2adf88dc766b4296be250458382b3baaa6ed85004e8899d5ec81fa8db1b8365f2d44c2fd94615905448b0f73a7605245f758f19c02de0ae0f6279cbaaa0012c16245449a653a873957d7e86571967abaab4eab6676bba0a2556e4b0a922b6cbbab0069ff953ccdeb268ba843d51d6b164bb042259b13123e10904e916823fa800b852444ed8f762cabb1b4528820f372fda0a945ed95b009f97d616b10dca27d0b286b40e6ba82ff92ec3e9de06bd0bdd9763a0a08609c93e522876f5ff0636d30fa1026097c9ef206c6d26493166b6ac92220c08c23c10c2fe17610c00d2df2481bb1b5a00d177ec7a3c93b0d2d84d7250e6741755cc370b0d3d66131dfa3c367d1c97df7171c94ca2dd6a9ef78831690a1338f5dd5e6d8c5773021f9c134eb33c3357380c097b18d9db33c405f399b3261aed83d9ba9c26016b759e49772b6770aede34b72199b2ded8e21d5d7830af6fc4c18d99658598424317a3eb148b2c98583f80c4ace54a2144ac8df767f1e1ee531f65cd71ddbdba389fe009d087eacc557c1cf69ce1068797827ebef1c25933a33b0e94b093f3cf0d6222c7f9f5e06addc2120a0a92f4e79748401f0f96000013d408fc633e41f6f161ecce1fad827f5e5f453063531f21114b1ac86b8596104fd35352e3cf6db09d995a83fb36d424baf138ec9de4d3eb088907055abf4dcc6b48744650f2b121b53ea095f16e171eabc6018fb25c429461cb624c5afc36cb6e021c58e474ff13394a33ad65f80615d53cd8079adefbb0fb62b8b4c7a7775fe940f31f4252e1210cf698643262ddbc8e96764a4cc154670c3e3b439f61167a3c96b80caeb87cb32abe4b617bb5c4d036e966112714809d8ef310bd77c5e35825caa6275e6cf355f4f37f0f699080648ad5de31737f1607263017e83bc051d185fdf94b181c0b9c8e1310f1908181c9651e66a8d1ce88f16f4b78576e1a1c45544d3589150cc56f6a42b015e812bc0dcfd8e555153219f071486c901f29ed9fa93f2c694b33cf42a96ce980dc912e66d3440b37fbbb790b96760b80fa7ee72e13c6c2a6f5dec612927a2decc9162f7e77f8a21d04893f9a14a408d87da33e889778c6f22cd5f8f1827e211eeb9fcf721cc2e25702ffa65f5b3f44647f907db4ff4e09e8bbc9a1ae6cf4bfd5a3fac4bccba05c93993b0937ba420017b996ee0a8da2495326e454f5d04af2cf33b916c21708b636b3f4fb8d9e73105b72d7a8a2c4fde8e47542bc77bd6af213be09fcc43441a07804e0af0f46bdca480224bdac3f220d74c93b80a31bf1e79a9c1569f0212306ca156cc9f4c2a6dc8c9ffd227f37e0b24d40f3be348aa848f87ce3aa380156b7fdbf76a76dbda9e85be91dd0e0212c7c1a8bc7e7a087e477744723c6b4eee1b798f1980890f83ce458114983fe9f79efde497a55458aaffc1a5142ea70a48c04e415b5bd62c4a1709d14b0a031f74f17f8d5ec752875fc8edfed68919c811c9f6db24bcb247113f892b62da8782ab70434ea9be61a1ec24cac6c04ac6ef9d1096fd9af684356c4085c66a7f1eae47d6827c5df0bca13fcb55f43febdb7f568f1c6c1fbed67fcfdc56f2dc23a2bcbcb11b4a0f97cde43677033bbae06d10e711bd15706f46d6f93d81f3032fa9910b3a1f4d72b2c0036d049827f6a6b33969264603b4b9a841c7899406f4b1022476be743d5365169851e3a1a87b55970b6934c19bc21f571a5066dce593e93868b2e1fc9c2708186a85e6b0ba2ecd9c9e06a6735081be7084f9a2175a44e748be3ea1a9a1c7c245f669dbf2ba9acfd3e5345a98ff15fb1e316abfa5f8f737bd165cfecc1a1b117a76e938f0c60a25c943dc2123625276cd8788f66f006e389f2ea17c5f771ae86edf79973daac8a6ecc4abc505cd4f34ac2ee140264fab3646649f115b1529e497371b371a4d93acd92f3faca86955941562704b8488e2cb9ac031806a8be91f78ff5985d1aa54d732ef58e086a54400aa8e9a260291a446ba9dd95a28a55cc7d2db875259771cccc0e55b131c7903560e32b95b51e3abf157632ed3bb79116a9d51569f3c95dd36f0c18b841bb44ea181b9ae2cd4e307655e55a5301476edb0dd8c76c7b6b7f79be94669d6c8c149ddad962b6bba09effc07f5cf983b98a61953efe3484dd8cc887cf664d3e12540519dbf216338f9d4555205a6c117db0b65e7be176b61df7986d4237bb3e6886eff7d4b220dcb1e4c8112c54beed7d82b62bb625cced2540da0912665de1431c28fb20fb7ed1da6ec5461d4e894349dba3e54f90d1baab3a6db3c6643e1fd9270fc9be1414ae327628699240060f35688274736f87206f91902662701a5374912027bf93ea6045ae6df88752b7f612ed6e2b88fea6d34dbba53977467311d3bbe9bfa3a8500fd5e992f2638648f86acaaafbcc0fd7e31b67136cb92dcd160035b0b5eca4a5353268eb057c08a219d23ebc69690ed09d26ac9c9ce58f933658ee5c5c72ba48ece083c73ce76f3ab23c795b848bb63b50904dbe5a3aed99c50946d9d995d8a2b559fc7fc3f2f0ba1c89aadc6a19d3b8d491ba52ce1bfcd5aebed3c70572b0871fd1e09666ba571304f2fda0372c90716792057cd3aca8258e553e87847175efb8db605884fbafffef4e74e44967cd57fc4991e6a942361166f2bb5aa6f892920b2a7ea1417683c72c7ff7f4e79adce604329f5a20a794d9b42025fe7e0bbff88eac4627e5fe418799fedd5b49eafad6b27218e040de93fec635f51ff4cfeb1539caa10a9607978b2f51542e7f38ac4adb3928632a2642a3c56776bd5befa8dd82e2f2ef6296be2c1c053ddbfe73d59ab6bdce1d64565a01ac0066a9386610f6b09500586504d0db2d4c2c6c2604fdc687bfeeb4cf40acc933eab6fca91b170151e1176a53ee72f09440ab6badb2ab629ad89b498bbd5f520dab65517170a1d24fb767fa0353ffa7d556070e767f6a544ca3980238baa901040b6b95123efffdf76d083af9075368fabd306c43f76f0536fa65687c69d5fff58fe022349301ea4f8005a9a4144667ad3dcd2979f6a53521d2f9000533270d08e28d5cd31822c43cf13607f75cb5434edaa7cfbcf7c605bf132931462b6b6f96a35f4f8d3947983cf4720803f1ba64359ce572d3788fd1845e19c6b96125481e00cd380e963bec1f48085bdf2acd3b01495231011040f67e05f80eafe0f5e14da3dddd507fe330a030e4fff839f6bb7409b8f262779732471706773cf429d336288f9832aef9c1d577eb33fe8a4b2d5b938e9523ef56263a97263293745093b435cf161696b417999eb266d3b4a6241c4202582c6148409687da74059db58cece4f20ada862513ecea9ede89e2bb12077f4250b3c67bcce637b03266eb8f4c0e1eb9569140022d2852a75b53d36f62efc5b7dfcf9eb0d5e133ae390abe8595df3a472fdb08bd7595d29cea0fec898dba6e390368f5ec0feb16277851c19096580124db5c6abde012fce0031854c0e08158ed7af4ecd2e7ba2386394c67f7a6af002717c8a8ffb7f2bd58fc7c6d0a2370cd7fba341eed96c7bc10b8721ed23564d8e5af73a8528810ca458ab7cce89be5c26b553604270293c68fdf81530090ce11fa3312897410eb8d6409c0d46852d2c2be6ca1d9d3a7d632397fea763de003e9c81c792184c104b78099aba742813bc42fb51baa89fb2c06b969f9b42a17bad04e49021ca645785138b1b40ffda48f6e3caa859a0d50e31e8ce0cb3a7c8da6434252ca766daf76b2290d819dabff1e1bb374ec89fbe95f182496cf7b5615fdbb21e0c53d920e43ec838908a8fbfb264b1e3bac73b140ab1ec70cb7872e902eedd59ddc5c4241761d09f536f2682df82f1098b20f0277fb92853e4f1ee87241b349b62cd41ce2e42691f9be077c9d81e4dca9f7fdd1f487cebcab991014e8d0e859ce0ef74a7c0c498c64cf800931d93207ce7dbb2595b99cc6ed7e2425d7c0746e6154db8f1e0f789320b5101c0871b6fed46ac5edf35134dd369e0d16ddf0bd18925f30157863ab71e12d44654cafb6b2691e928256480e34146538c3fc5c905b0c6bf704f221e718c60b63ab3a3f120f50552282d8ed6d7e3752a624b00e9ba41050c861a4f653f2e7cc740abdf4ebe0de249c5e0bed423574a207594cbfb8f519c79a4bd4820a1616890bca9cf236346adc437b013762910bfb19780adb6ebb11248c6cbfd72fbf53936c7f962ec88a250f2eccd466f96e912d2870ca920a3bb5ae69eb905a6c06906c370981c52363e39226d6e80e96f5c5c5aef6f0dd1515769efd5dd394cb3cc58cb89c8fb34fef2425a2b181f4bf8b508a1060726092d53fb49963b640283824700514cb8bfa645118d7662cf71ee10a6b0cfdd4fdc3083aea47788a854e48c1d082c595df13a5061dd15050a0502e475f03880e93cf09804842eaab036dc6f86aff76a751310b472e404562aa42299c2ee3e559ee0c9ba8a69fd75b3d3aeff7ca647c47e306ccbabcac8af19cbab9fcb0ec455e91909d81513a75b9560dc505e62157059fa11f76fd423b886c27b4911df59b6615e079c3a0cf8318e785209d8150ba795d4298d6576c0cc5911ec759982e2c596c5a6ecae4012ed3cb58482c84c25356b4599703ef1fa00f53ad9281948a1993657aa97538365d11fed51e7030c5b94fc806efa774885a8dbd062a2669befda9fb2f9f13aa4230f0cfbe4b0f860103497548149dda33afe5b26c60d123d6054f8fc277c56cbeb447b210dfe74b2dded6cb12a840382e8c80170b8b58793d6f2e37df798f4673fce96a14e4703f55ddb30a4f9587a3c952e5f7eabdd306470e54d17566c7e04535873ffdb329d6c7d2f4d26079d4f356fe77c36a2a603a20b2f686637205eee69a79c9f64a0d1453aa33983fffce745659ff63d91fb963deb3857256c9cb14cbda6a1ba7c1d26377a0c6232de1497f989212a361468326719a608ad0f4520793722e8bd7623b94867a957e8340bf17c2c2ceda04ad8d998206351afbed88c404bfbed2fdc839f5e3388f444376df8374b0da1bdaa9cbffc8721980a5ab551d5f44b3a8cb06a2072a97c5e48ee60cb6c71593f6d1451ceb381968648de67afeae76b2620e7c4f9304ebd855e91eb4931f1d13e457a90586ce232eaa288f9d053dd26158c4488a57e915eb35b0b692ed89bdf1265854e4a612db075c2d49b023e6f5a3426a7543c5fda54a90553a3d94f124ba50247af789511e8c302cc808598a8d9b8b7f0a6e75e70b695cfaea80fa7fddf12e496ab9cd74fea5205d1f59c99533af41c52f8508341762efdf231bf773a13d618612ba9e037f82d52ce9334052ad10880e263f1ce2256414a6716424614fdbda8870b21d9cf3c4655ca2f24ad5dd8e95b606305b02b90fd49107bf8bbe86a345686b1d8162b292821b561a895a4abb2083333fb069b162f24fc194a28f52c61c9e76d0b82119bd6faac0685bf8e3ef5a0b01c9e5007a040368fc50bab8b7a5203a1f695ee24ce69b2a4c5775101ef8dda0ea177c0ed19d1839c8283f6c94def29c794f0389586da71ff813905580e296f29eed166d7566e0b08bb1945c13fc862f901bab70c6ce75e38f7708e467f527a01b79d38fcb280592b2db5dd95eeaf06b2bf2e53275b69322b41c4cd2ef7a2a154117b480ff20957cee0717a4db136a0e9dfaf65b78d7cf86b645afa24c67ab851af36b426e106ad185afe05ed7934b2064af8c33d0671356a75fa2df81584bc82a2e105c90216a771613333d75cc6fee9d5fcd071396b8f2837300e79248336f4fe07c9153281cde6de5f51d4c70f124516012293016d714dd10fdea8136af00deab31907d11aa72baa416a5e7939053145625a96406afd465f4fd09ad1474b6ccec9b784b40162cbb15477cff657d150e5c635fcb9d9a06ce196dca33621d308159d53ff5811bfac30ca8004afaf0db8e91ec40bdd8b689da05fce0c2386eb44afc2dd76863117ba0701b6de7cdf7ea663054f4c4f28bbe43ab5030bb5b13df9fe989e3af28f05c98771b6fbec2de6ee857967aba58340a73a6b3dacf39260e81c7726911d35a8dc8e9cfc4c0fe364236dbe6975db16b6a999837771346e0beb4e31e6f90c26f2665e568b3d3dd797b3f6e5fd06add8093d0d2bfc79423d888e09b7498fee032b246c7a7a3a84b46bec30029fbdf7af7bc15e6868dd20b5b9d3216f8dcb8c3a4b5c50e9d58d34af5571a46e067753179a645eeca0b8ae5bc1e44c688ad020ad18d71ed2cafd53e927bf9f25b226f82120807a55e498e0fa65dfbf5e47eb8691bb17d366770a0184a1848b37484554b8fb481b97522f551f8954391b35fb998101434fc4552f6ca0272fc33bd8e1d14a8d77712e62bf55d9ceabc9f0209df0deec85a4e7f32ed06c830ce980ab60fe6f525e5b3a4826fe16d7b32cf622c9a993e16fa3515b15715b6da0b26f8b3438642d3fc7210eddf8a6bf03e7c3f66fdec32250db758b1fe9f570f46b71c630a41cd9cf417f2874870480f773aef1a12912a678430e62eb4e21593c9f16c7f58b484503e67a2398d2086078cd87d8cffc85942884098bdabcc121e7b5215fb7a22074283b7d19fd1870efa7ccc9a8881bc86f606a89a1e82a0c772794f6063f227dc6de89bd6ff690f64e19c1d90bb66fbb365fae299b2ed039266d65a46fa8e31cda2aabc854cdb83ec38e03a0cdff35e9bb4d32ea52150770b8028b1b39711531b7913fbd035fc668535830f8b5f928e3cbdf903866b45bf3446b971b9e0c302b165667c4114cfc79234e2af7cddd1870667e0e9ea3ca82ed58112600a25c178bfe0595dad6d1efc2da7858879490910a827cbe1793184377807b90fdee6adb03fdc6b9bbc53d1633f75e564fae89b697952a8f2be4a01bc9486edc6d4d0e1b2f0b10133990ca9206f82bcc997a0e489f79b81d8d837ac840e64d49ac020c85ecdd576a5d427d035170f2a05ae0c994fab14ea41884e666641edee07559e1edd5573517a73e23ee463deeb4613340072d9fa2372f60293e615bb5bc83d1cb67b4eaae627939e2d0a00eeea8d5995e4a35dd4c95168315cb8e14cfcaf6d77ea3e31710753c9136943191b7df14df5a16620811435354819e56570465f4b85b256b88bb33e3c5ff016124ef38e9ae1badb48b24ec5653f80c24a89444a5adf94e93fc182cea737da7e26bfad6551af58b04c98f156093e6841e3e17038db5dcb165711a1fb3ffa35ba0aa5364e92bc661c6069dd7edfe2860d4401dbeed32aafdd6bfbca29a8a1174eb63cde347224cd7b1f1ba0ee0c3f17987ecb13a85e82486585392a64cbfbf8e2fdd3f09287f315e4062906467353b2963b37508409077ad6d5e64d9cf1200d137c23a47fcde67118746bde1eb470996b3393c17533c871bb998c0f273c2b5d927536cf4d96c76988114dd32d58fa90930f9fb1415d4099193122bd13ee55622420c545c5998a73ddb05a961c958124abcd7be0160540fbb41990170d30fe0d391ed55fb43730acaf2a9e07b5385c3f65f9e5797d535d3bf5d9b41d9d62de404cb19dc78b0559f07d807f7215ce6a3c573ab923083912ca12ce46ff9cebeeff77b723890cead1c4167e0da9a836b2860e302e0b34a6837bc7fb3f79d1114fc4e597e3c9aac6bea384c78589edd103c5a2f7a63a46a5169a205ea6537b92f14f3fa72d2bcee55f133ec3fb68be3db137d41afa208707920199a5dc33ec6a227d7f79e73c4b343e04703b7e0f03381676dcdd00fabdeb2f080aa9a4d8fad0ee70ac8fc90a855b3a2599d7f4a03d2f026bf26792812031c8c582e8541eafbd31e3251b6721d46cdfd842557be96652b864438f9d98238c3188bd3b367e9183d753de290524adef78ad4765307e32b91defb4bf4e9d0d6982ace70a6749650ad8a4eeb409a7479ec9f3cd276b389d5fbbe648ad8f33e2e17e436c63fb855ed448b41cbae2038079f2653e5ea13a081fff1785817db7a796640ca993e52437c8a8d2dbc81fed3c76e435a27fff7bd111fa98a3e25cbd3c99858a087a494e4e61e766b61c992d2c1bacef01729a2314cabae321598854c53c9de91d249db266ddc58b46be06b39fd09ad387baa36495c203f5068975fa4de825768bc0642f11c7ef015eb26abb9c4508b929c138d0c8802e68a6558f9d10c7d51a5999584d8e70c13127253318980bcd37abbd5f64fae91e7fa515d391e459111c23269f9d85ac467c6fdd391e4ce600e33cac2cfb35e9dbe9d3a5791bec9aa33db1ec581847828b0bf92abb4bbfb101e8bdb7569056165ac2aba59889d25b1ecf1883d4565ef533cde2bf3ec1b2844d8c9f297d4e3801713ac0acd53fa7bf779724700353cd0715b222501138539ef256fd6e5a561810806518b0f087b99af220de4377612bbb058a8af379f45c373ca6e33667748ad4c94ef20e08a5aad84addd6e11b6de44a05352fb9e32d4aa448f379c21477536b0b0db4d8f450ec957c32fa716470009fc84c0dcce3c12836c1642bf12602e350855491c46d07a2d52df4346f9bd243a98df24cb0f21d2cc552f42fb1fa8effeba86e466aeba9162794dcc564277545e3708477737a98381fbac15a05c6899facbca95cd6638d06877e913782611af969878d0539f7d30c7728531cbfc2d0184f3829bfd1e92ad3c2f0e3fa09e738b99deaef5c3ef9511043f01c816ac2d303af0f15b790e1824e9bdfe8198b846e98e86abca46849c1981644ec9e171081c5d5d41ba297447ee2a6e703ee741bc49b90caee3808ed3d020b2c5f48a86ac8a3c44085554149867b6e3b64d83cecefe5373d3604cb3c9b9bf17bfa9ffccea2c83525f83e3e5cb14c7f62fa401b4363d539156a0a40797c8be78e26cc2564791a526c5a6fc52124f6b1421928dd244ba4ab5095e6e034c497a33b9f50612587bb0c27d23f71ead071632a0751dd7bd342a30be39be56c1350ddf1b8f5169e3f30756ffc38b06a756e3a330a8882fad5657389b806029920567d8c3a6bb1bd9aa550574ab9e75b6cccf61a60e44e9cbf00841b0fbf10be02629602cf47116d11ae63f557b3734bf64e58798ca5ad4bc4c3f96fcaae975a6a08fc5f37b3bd386a25c692e344f150aa7d60eaaa063b61083eefd65113219f4817247d8438460be3f1efce959898ff0761bb8d244f316018af87be146c5513fa965668d99a68f09f51fd6699b58d8ac07cd80ee108f5b43058805642fadea4eca77c25ae89a16faac86b5302fe88afed435493fac5f31b0aa88238270a6728c552981f415353b91afb72acaffcbf7f0f61993eba0712d6bcb2ba0c73a2994bc09fe396668fbe82b816017ee5ffaec1b3fadc4424c0322116efd5a472d5da07a25f7775abdc4c8d9b6c1872375f6f4f7999be0a9777f0ab73f76d7ff559048afbd7e764c29d127ec0df685aa9d68fb291a01223a3329cefcd683e681377ea6ffc9e07d5124a5bb929444e3e3bf8baf8f81fe92206e63d183e34d3b81313b4b939c903b00556cd050dbda24e9e2d5e71d761b731b8d27b762cf4827799d02323316a2a672f82645841c9f36f151947967abd48b5eee8b7df1e8599899a36fd00ab5a8b8c80b743fd43d078c5975508698292ea13ec80e9990aa1cd91ce4e245ba08e17daeac01172e120fdf4e3601e30cb6386a6f354f309e51026c59e10523f66f3f8a41dab35db3ac0dfdcb53b4552a1610624d7b468483eba8a959031ffc8b1828b8d5d1042901fa2cc9b4a3778b4cf639b89803c3ff36414c01038142710168748f6733ea819c22ebb47ae089e02359c0350728d80ef1fe915bea215156b623c1bed561c023fc7c79a22dff65f98b91b8c0a8215e3050352a8e8ede3d2aaf8bb84fd4d5788cb050977af6eda02715c361bf91b96c1786b6dcaf5810e03a02b0cbfa7e26f1df7adee0a81c4016e46a8e6cc80ae955e294f5abba98ac1df0cfa660effb78814591e854eb84799dbe8ef4c053ec0327ad3278f50e5c0ba148c31ed62e5a9a6705165ca7b244a9ffa36c84acc0f8a78885a121bd00b1a14abbb261e7f6a12ff44d27be4ea6df3a718861ca080dc24b453f77adad788b62c20a05c92557edef387c7146a3980322a9a4a964b6089656682014cb9de52c4b554cad8ac7f0fc9330b65d39af4537cb841532ad3b202fc0029b9945cde0266d09a43c274dbefe51b320e7b30b7c619f3564481473edcee899de52bc452cc8ff9b0ef5b9f45321e04a8e66d93fc2aae005b1cc8e97629a5b79cf0ce0886e2539fca17f8305c5cff5ce9435c640b99a4e759ff43670a34c5262464dc2ac89200857c8af35e839e8de3335a136d0247a24dc40491472673c38c6091c720a58fe58d54aa7c1786e8ed69a1e926230ac59559c4b011d9e7c76d599af2c7013ef10ebad52f7bfa53c66d9e31bc651dc89accc802b09d903747af929fcd5e209a527863606dc938ada6a7fdeeea0dd0d0d153bd02211a6f1433c32cdc6ea24c3233b59b4b8db57824e9b743068b75ac220ec90fb21bc6a88475c3437c39383a4ddd1b4b38ef1d4cd31402dfba2185022a2f660dc3403f3f2168dcdbf0b7624d4883fcc50f1c61fa177f8a9101cc3cadae5833c262dc25a931bc7d166a1867703ba82274b2b2495e2fd4010633afaff7e7791b1c1d00d46952db2f63e6f34c0a569833326ebb11074203b04944133767fa7202ae65ab56c0c21b5136c402869a74728019dc33ae3bfd546e97b61f5ec9f180091b1092369a9646ed34476f19edcf3169f799ab14eede3829c3a0fe061db93107818f230f1e7e38da36d0bb0a1fab9f491591c56285a78573f58636e012e43742a1a30efcea59077698e638543f9a4819982606e87768547517614b5d2eb41405458f257f59a0d1f69eb78f5a959546742ad41ce9e259760874c019f66ad9f9ce7d18eebbdd1b9c6d02843840546666eadc5862e67b4da762f11fcbf81a55fd64706942f7af2ecc64dbd2c6aa24ae4337c6969c02b9c48fc72fa1049a3aaea07b169dd2299f144667aff118dbf4c0c7a9bb1619e6ad78416f124d58fb367d1b99ae3226dac931eda6473bf1ae0496ce541cf6d0849709d106b94e8efa2b79a50fd2afc7bdf61bbe4a90bed67505e25e686a48e37dcfbe4b0b79c4046ab165892dec7770295be0d030e4074548a02b06f6d279a51d81a20341553b9deb8cd683ed00c678c5e56414022d0b2289880045231fb44c7d41f242995c3855138db349fd813987772b03a863c186b2ca648dc911211060a6756f4ab27d1d1511bc742008150e2214c3a69baaa79288fe2b37ae5079b07227122b24b338ffb11e11c1ed4d33d6bc9dace3eaf89822e222dd5e8e123420770e8527baa0040cbc3b8d615aa9f3dc76cb4de1a692f668b472da232bb43a86e00a00d0c3ff5109bbd67f8441015bc56f63d98102d6e251a4068c64e4018672371cbce148a7339d787b98adb60c7b3ef34763a1ea1a404babe71fe2b9157ab46ec48ce83215bd4ff7e90a4fd2e22b57d55cbfc1c873dd07df6928f3ccb8e07842c402e1eef219a0c27fb35bb9444932884be4085abfe836899f6190db1b4c32aa9331d8839f0f4633a4699de192ec891eaf5c84867f6a491604faa33f84e685790f8a2139bc0f13a4102b6ebaa583528f71c2d810968ffe5af7a526601071397a0913388699401e31658bbb4b9e7b33113eae612ec0de69a73368b3b2ef65129ad759e98b5a28fe9fde2d591288d054d5e3af43cdfb75dbe788f3b6884f8a9230decf52f05bb5b5a918ca8a446bab69e87a3e093e1c1964d188626ff954a65fbd8f77073ca6e42a6ef9351976d71810d5eee8998fc6e172e485c08da30d1d3f64b1c8a7c05455721e33537372de481973d7338671e826163d3752a206a48a4556ab4853eca03dd344066311329a9492f16dfc091f6cf893dd635208f0c4df56af0b3bd0f9d97fe75c2d3ad2e7031f5be0524cd08e3b77588b8057db48b8e83976518629d8fd45d18f1a1b5e888d18e85da14b43cd51ee543a35b0c06af5ff99fbc883516863d3f82c86f13c00899eb5f8ffc29948d40484a2c3988bfbb6d25b8334594c5c70e6b89e6219f575257019e7c4031630ee03288b3cecb91041900341d72fc9560aa96023b5d9306a2c9780bdd3648b7b8a32430322e1b464c88502bec464322f20c1a9a9a533dbb4f9afcd93f8e6ba080c02eb52a85862b6112ee54880bb61fc838fd41591343585abec5f52cf71cd77b1b2f47ddcd24709b2e9b5961d7373b5309fd9447b4a59a37af49ddaeac77bb85582dd7cea61ad8c4b792640e7cf342e96e07ff31c2adad93fcdfc28550a2e23477345374c6fe25ab013bb797ce0586e04245b2a82b7fa542e9379ae5d4654123963170c3efdf50e7aa17b458d6214d991c09cc9748792963d5ba3a0ce9ba450a44195e3b7c3f39f8bfcbc757bd57d832112a7d8bf1852ba4263e34440eddb09deeee594805979e4c1cb9863c8811775dcd74dc6f1ba2e75b422768fec7f9f7586b834bab0a3140348c99e2a0ba93b1cb593b931c1cc429a813dc892bed4286f54966a89ea55734f1f42456bf32824614fc3338398840f53e7115ddec5f9c59f94c16040e48849ef18374a4d32e39184ce518f3073313db812218f1ff3334b882bbc9753978fb85be36cda54816d1868520eddc3613fc7402a10c47730ca3c6cd3ff60a672058fd978f03df1e79b10cf783b5f26dd522abd3ce47925a24cd18b3b06f5b71ad5102f20571b62946819ba8ce85e0e9062ebd2d078445a35f428650aae5c78daeed51f7cea7b83d8b4e7cb9caeea6281126a7887ebdb54d57d22ce9d63f05929bf941eb81b9021433fa66af50f8f80978b72d031ac078739bca5d90ff5d635ef53d915f24f51f2459df958f35a07b89965b7eeefa0b80b79a814f5240a6dd8785bf20a2d0d4092740011e15ff46cc52e57745b25c69386668412e5eb57ccfad128453629e5dff6b91db139c582993e79ce6a39717b69866c52a33515b8c4cfa36217e0d62ee86ce40827e95d525074923932071be21b5cb7019759decbee89c23389ec44d2e722500cd9ad78e241e2f653630ed84981f6bdc31f0438d533526ead7098f3458f61b2375c78ef65ef21b273c62f10be177036caee980e19af20ee21740627757c88dec800fec7e4344b075fbe6cf3743217d4aa3e50750f30af8b26a33b7c732222c97bd7a137211b7e13ae54e9b0b0a4dac4391ecd4f2a053b8c7b5e8f27d24853129276460fd7f2903a5dd8ecf705a7a2d221a5d467fb62590371942d3421072c4c8eff22f742eb8f3fc2dd39b961fcfbf4c14c888ef8be4badf8f19be60915e9fabdca55c0c14cb5bc3058391100825de4986dce5d547fb15af0b67cd3ac03949e83eb007c6512494fc142e7ea05fc0fb6d3e476e8f1380720b52c8bd3255d85cbf3064f67d429db3034f917f7abc6b308bb52fdad81bf149b46a84f38dc93451c98cb1f32f7f39f66697062424f8136e37cc007b6f002a4f430e72538dcfbf20b6fa169ab5f9d8a6cf01528798f5c984cae0c6cc296deea94964c695d8e6cf0364c690e14f2afa418978613d14e98dc9330516195205a7a515933bc45a2a07d70c7f07ed51900d5c9568fe4b918e44c3bc59a55b9787238d7324baf524ac178a04bacafa230dbc02f0d9bb80d41bcfe9c508a4f54d465dd51bff5850b30af6aa123c80cf22b6db9c8da1ef4b5e8044c948d4c7163ceb61b6d63fd707532b825dfcdb1172772c164c7411d09fc431c857ff3a78a9c58c5f6f9e5c347716d9cb9a41623d486572419d149435bfa28a1050dd30e14fcdc393ecefd794ade11562433fe0b91a35cf1c32bc0e5e68305875d67b4ab460cbca9199d757831c8de3b7a3dccdc4dd900f23f87562d600b49fbecf3c05b2ec9d27d93062a726db4fad47a27180c0c2e1a41329200c00c59a14eb6a41ec6a0875ff4712603dd9b8706f6ae7edf17f78c268d03905511e4dae77135018be72c0a976cbac2d6f4618d2a2b5208544aa0cd63dfa773e91194748b67174ddeb4b7ca8b83b1b46995c524ee8d85398aa0c6300f1d582e2f9ddd259c15faf47ed7f3c584cc409a52bccd3dc643586beb02dd6242fd77c5ac6cb1479e2775aba6417572b9984fe0a0b5bdd5438bc62cd29c16f831331d787775a35326431828a0f436c4653e99e07eba2fedfef0e94b6d9e1301d1140638eed828cb12a7bb33a5e9ce0bdc572d063e6e74b6d586530bcf6c6be3d92f8c2a7c7d77ae2985ab622484e78d8c0ff16807b0c2610e5df7f4fc2317572a6cb548fe3d5f9269a42141f03220ac3ddcdcfa5818d31ec9d55cc3607785c4606cdefc7d15741ac32e3b1c3222213ed4c2424b483ffb616e7672c84e7fb753209987f2a1587276c1d9ac3b143f7c5023dfa06c17f88cba459f5a23aa536745c705ddca606e89ea3159f19e9a19d33804990cc04f33f660d6ba740db608108346401b587f5ebcf708ece4bc9c92df3b81cd4692cbf37136cd2e59a4fe64369deed10c2bbfc480c74bec555933cb0101ecaa4ee5d2e7a89181d0dcf05faafa16776fb20b55cb784a1bfef0d4b6053df4141108ab8efc131001e7f2ee22c9ad683b3e557ebf05065a4f79f866ca23560ac918b6fc845a644bbecc49250813a7bd06a559880056979f13d2db9dd1191f39bdc5da84b4bad99fffeb886477ed8957b404377a8e77f6b60401f5772e2ab4749a0573cae87d74386edff7dc108589c54aa57652dd8dcb9dc6f1ed7741e34b890c394e536027fc55c67ced58ff27f8a409006caf1e960d9e552e6ba1e834076dbec740157fe36d9c9bb36a39401308c85903d061f6beab824b3801f5df2dfe13953acd20d458d8a790e2f5881fa12da2c82be944314968aa10095bb5e5c79de74745ea366160fbbb3f168f34577110bd73a6fe0c4a072940b63efacecc344ad42df56c7a030fd16ef598d0c22d6a4257c3e3c27934385edaab73b7205ae2e4ffb2b8e583b21005a1a3f88d1702ba108318c54a0478d7c5d532449a544f7382a62553f8d224ebef1946d8c811e32a94f5946e839385361e7921307b93b281387f7760422f82f83bbcbdd2ffa17492ffad49bdf12d2f4910892f0f062a04e7dce202eb2f1004c2d248c8314126a150cba7c6ca63cde7af11c6c079fb91c6ec1fc1a6d2f847c9ffa55238f1027c4e03e465a72f7e76a9820c14ca16a906f20883fefdb5fe154ef6bcb0bdbce927410536d2cff6478b318eee8587261721cd4005b6fbe77865e168762b3c252b9c0ead468837e7694b83e7cd8db85a72c7165b04f16eaeaafea07e3faaf66989057b42daba60a6e6ca45ee1d7d9975ae4d6a10aba4342e03a184b4c95d8afd1d640bf7b688277a408fef1b13a6000fde1470539911e5b8bf7b1d845c42636a524b1ff35f81d0cae702b24df6ce31222c8bd407c7d5a38ec65e6550f3beb854eebe2af3bfbcb7545821ed68b6cbf104c963e37fb7e152398903b31201b2bfbac7cd10026d44f8cd03be7c0cc5e29c89baa45d1af5883c40be4174eca78f290d2e1b88017fafad6c87abf52ddd995fe1c72c5ce718b22454b1dc4d5aeeab31bc0904bb8383944ddabd1cdba109b43bc3c687e7c1a75ffc2622af18e0066f2f18ab8258d64747daf153e34e807d39a7bcd322a0380fb39fbab03c2da80da87ba549d988955403e1a814eed3489fb38e3d1f5e8eb5f5ecbdb01247c09b4197bd3ef5e1f73c43064f82d9f1ea4bba310fec08d6ac79c0a747970964cd1912dcf5ac9f0f3de7d6d02027f64c190b4aa7a0fd606cb96f2b6c9ef3cfc334cb55d40065d1d4aa43366c8de2cb260f07ef50a15d1fca3901ec9b1693b33864bdf75b7244d3eb6c02a22a775cef4332f750895ed50c4173684806dd9ffc39b1909443d457097c29e57cee909dc82000a7ca44940e322c8e29af351de3585d21dde3eb4463b6ebb6e9ebf88e75bd0ffedcc65fa3fcb8cbaf96b12a7ad7e5a9ad143f9c80cc76d8991d39c376add3dcabcfc116cd8070a5ec64ec46e5d02671f46211a8fbd9d68460d940f54947875cf94021b3cc8da2417dbd2f1159c4bba35dbf25a9b00265ef78af93d8a3923476ec0d265e9e7227bba10539d53c7c4c368dcec6812a4629994e6f9a5986d5bb666b552d3831231afd41dc339c78582e846798cca12b75ce6960b688bb0558b759aabdae3086743e7d3a244b8c9c53eabe41bbf091f170f2fcc9214648c7e94eda42dd5feca826d12a1c2e3c3f28fdcb30930a510fdb7632a870ee09ddf571783c600482ab7acd3e775ce165cb3271fdb5883726c13419d46002044b49efa6419b9ec9fd94595cd4720974e0c8213d96626961d846b6011f435fc84eeb5bae0c5a160855a19dee17ab1fbbccbcd4e253e7cf32cd4db4af915932cc7de6a0d809804f65f9aed13882448f70df57b7fcfa439fb492ce54efe1710790d375c97cb30db52481f2d1ba703fa77fb950f9a62fea99e2c0a4c10acb7830fcecaf2103de931282f849d53ed99d616dc46e549ccb37f6b672537bf15269f7b7c88253763c53bef1058a4533267cc72606b3af83bc9e9033c089b043bb30e2db99356af303461c09b0e4b36d63a79efcb3e8c9f137dc2d114b6a8dedb0a9df77ccb75ba163c757065f235ab7c4ac5df851d93a7cf7f2fb33ed89d9b3bf6ed6dd9ac6396c503035deaf031c072b9fe3931d2f46a3d6d30e8156cd47e51276179c760e7fb9e848d89170b6eea4e8ac51111fc04f4830a595da11d8bf4794fc09e869314ff62523e8df2eef4161fe807f5d60cae4f30e86e4c81f02945b7989a3bcaa9cf221f724f235b3602af581040407e74a7af1fca6fc258dfde85582bcc98b2d31a323aee875a1449b26cb11943406e60187d827d5527b7aee9df921410e920e3c3797b5eb1dca475dc1400dc4a0f26b4a10ec3b079318f1d9c923b666703c4ab3faecbb364014b9de712ba9dbaedb1099e9e2562dc276171e659ed2cc8f719d5a6824cc4a7fb56fb2a964fcebd6882c09108be10e59d73e0846a6b4f1491aeae3871afdf17a84a46243f5081b38add0709042b634ec613b3788f2630ed3ff3bf137053afe1b05411cbadc00f2459cb583c38bf93a38ce5f6777ec7ba5541ee20953bdd2e7c7a0af06eb389ed50e0d9d8f8520954da2538f89523fdbc70dafd61073f234070fd6413d6e0bf77a51f5443834b36c76e29616a36474a9ec2a53f5a07f80ae60de6239315007c35b3518568049ac416820013d688d25078cd81560117e323d992a52819fdb473f5fe4772688e8ee9287b480f7e163a73e8143d5218d151c0fb7a73ddb3a069834bfd016ae7484c40909d023432cd72c07c8d6de0444569baa20efb99b4eb4a3823509394bd94083d474ce87f6e8b1d0417f103e8b61b6a223e175e573c7e458ab9bc5b290dbaed281ce6dc20df6d0b1b36badd1a8ab85f06fa877c2390cc5c1abedaee537016e33cb9cff5f4812ef672ecdc0dd901e271baa7bd2fa4c80752ad5b0a5c2eb25be40226e1b41fc3c6525df31ce60b484b4c09f45ed66d3cf35c005226d593f694ec2e860e9274c4485da6145993fbf250b4948fa73cee24bf7ceba508c7728faed115b9af16da7dcc392acffa95a1c729bb831c533947de6287584674478e3d06a5d0a370601b3456d0ee6e2450e16ade2114be716b5fc0764e6a8797cee7a2b94593a6c55aea9ac506b5d5bb87c4a57f3b70d12c4f0d83de4c2109007abb3ca1c44f19a33450d7d5e05f6bb0e701f6e5c742adb0add11b9fc7f1a5342aa939778fc27fae58871e2bb07bb85a805440b48213ff199a4f27249423aa1191256e3add9f1001ac12f975565cef68becf982967c422c72c7ca8b637b99fa0d04fa511ac1c704326823a5a3d8289f714a53f03ede542c496502ad3f7e53fe83150711a23e8beec42d8f060ccca967d79eba4daf94d1c3cb12f75c4041fe5497ca26187218cf9e12b3e8b7aae203c5118a09ad6a50b0999a18e9c3c34ca9cceb57f08c0681c6f6e899591617a84a1e2e80575289ac34c471a634319fa1216ce80ba9a6881ca46b87aa6e0d0b2b7bc70a4ef1d8a693275ccb571df0e1af2b013a910159228af31e8bc31514c43c7e1d7e7fad771cb79912baa13cac3fadd7cc6a862e8fae5f2ba9e25d1bb460aaf466b4ab06ffc8c28ef27a070bfa4f9a81d6e95345532e4e6634cf5822cd1c63c9b0456b549aa00a585e4db0c4ac30d0cb4ef89684fa5003b92ebb43e154fab03584781d6ac1044c5e86b5674c71d0f6c43f67a875af1ead10f85961c97676889893b1cb2b30f4fa87d7f5f096a1c4296ae9c7200b77fed0c78e01dc461d3ce9162ed3461dba146f84a415c28a9c39277a881e34f6a617e66f33e110fe6d2f481786240faa23edbb4af6aa76dcb6c10ff807276077093fc890148326616bf67414849585bdedad0bcac523e0cc5e72ad37996db04163491e3bf9599e49c61f1e32c58bb88d271b021c5ec28ae25caaaf908ebb039d83bdbdcfa92c0170679f5c11b2773770ceeac34c04b5636cb82b9ce9fef368580f6112619d2c0daf82ef7acb2b7d8c4285887dae1167f54df0c7276d052fe569c634fd51f8813290463e6e48218252a5f279358b647444b99857bf6983b3b9ee9107470cdab023eba2f4a84dee768135eaf053c341f432f77ca836aca939c0732acebb09cb8994a48bf9bca47610cca02e247f55dc2095eb84f781abc6944dfe3fff77ad8a62628e5683622b4846247fe42b0e428da7c9e1f6fb68c2bff44237d4646ff9b61bb6d4ec99277f82add48df144ddb4b191dcb984d1c2b34eed4de2f19bf4998975327c0dcdeea20986619e118fe6af9eb09687629ac1d51e5b94f39dfaff189211548827e6b9c622666291e0d9d5e0677c97475a346e8d3f281a523de9e7d68d970bcbd89543e1bee8b08b3017c39519927f504cf930261a37534195f2d8ec412b0643d22d250a495d8d10cc360c8340202948384b8cec75fe1d6ec74b390f5b07407c89907de800c6f9c55ee51863790a964b59d777952428a18ff451e5d48b56e54371dfaebd112eca48004f2ba15fdcd02cd0737ca19fc2885cbc6bd9a92c0d7cc8c0266557223e461ff86075015268abbe7d2ba968afa27850e540c937a7b01bfcf9335d5195011c300a701cb516963e7286c51263bc7b23e5218d46532f1451b3d25e9e29e410ba8b11ef85516a83f8b104a289cf4de0b7271b078925dd5e1d73d69ec1275dc3db33356ec1d7ff16e7412b63582050b7e7a41355dc4a4f5ed01961e3a666ccabd0004e8893782eaf1b4fd7f399c0d70aa2eed49963b8a4c092e86690b49997b0ff893b3b11667bea665e8251b7ea03b2b6c56fe8135749ab3acfd601c30ee013eb9ced6702677594b3d90c56e3809d898fcbdacde7130f572aee7009685cdba6c3d215ee6f259b012af0ca6a434e6ca0706974abb128b1f576c4f2ac89d2534bff28370d46d3d8714a45fd1cf5aed6f953b1294e365d1b12ee3b52dd57574f6e1e2c4fa74cee4463b05b59f5b6c923d76e789974a37e9ff705a7b98e7e006ec981b25f75df60b56afbd844fa7ce740427292a3a56ead3e803f04f9f81ae37776548f3c0d12257792e5e8d20ff2f77b7ae27f7f39d0bbc7655a1c99160641376949158c911178c0a08132ec069b9b14055ef525fe3fb408bf931f98bacb3b9cb129a1e714d22c1d476e197882455b5b84f10aeae88b52ec7d469c9d85abf81aaaec832b31524f03196cef858d72db3e6195bc03177eee2a280ba2c4b2d2f33a159fc908c3282ec2d19738e696886f6f85ae0f5a3ecb2691b90acdd3b53e4f056703f3e61c0ebf71695f210c714889c3c68e351bed79ac44680a7a932aa78c0b262106b38af06cc8591329eac40e3eb675a3719a514f0b0f5a65ced9979da2f2f4b2c9e7d6276eefe4bf29895805f40c2fe3e5a7870741897192528ca91f02e273d2f8df9261ceba572c5bbf0d1676c66958402d735874cdfbdc74c2b0661bde7da02663b30dede7485db54824107851c15ec795d19505f9edc656baa341d340ef2ef7510b498595d22e75adb2cb8710f83cc792e8870b2ce1198b7b9b4f99472906af16269e73748fe785c4b095bfc0cb7631228c50b92012bbf0cc50f6704172e991ae745287bfc2e4f95b4cee62e5d95b88ec3b75dcb29c10a93bd45e2034cb9e4c05622b22ab6d3d00570e6d51c3b8e34bb201455c18ef5ccd82257bf7a5ee773e91c427db3e98b5a636f39d57480b0b763e3e6f35df94064144ecc818e447fb20497a639906cfe0d29ae8b894d7ca323cffa1b6dd32cae893bbeeb068d3ba85bc61cd5eab4a42873dba2c56485012cd085480621f2e1a200c4795d5ff304514becbbc2503b7d7a3bfd38a5caf19682cf170ab66ac3b72f183f73b7c13c7a9db9c6e6c1e5eb3c1e171bcb0e360914b921de68000fdd2877be8da88bc9320c075ebd0d461e24d6d7799e575624ff02a361b2fcb41b47084344b7f02f6327e6850ddb32ff0d8220f25fbd71af0c8428d4f604bcf7a6167f126a305c3ff3f409c98e327df5a8e3017523391cd7d189ba5e53f95105a794d2d195da0f09f4a6d33dbd9f4837a446cb4d7a80bffb744254502acb1a561d0ee22197f3644a4ae1ac6e745a45cad648d1fbb02ed2bb3849b2de6a242c51d089e7b5d1f16f2dff1e90af68710b24dc07f0fcfae47306a5824995980dd86006a3b1fd9fb4ab3f5f62056f646e841c237030eba816fb000b3c918250a71216a4e66d057d0ae57af9e714e54c9f4b6d7a276a7fcb4fd074d20ab86879a2ead1cc2de9e9afb5e049e254f5f0d905b1321c1a21023dcd794d1fd267e5c2976cdef02257c35953aea5dc7543923ec8efe23f7e52901280ca1ccd37b9e68cd8cdbf6678109748226d63e83a4417fb064198d4c93467a8d651b2e1768d8eae03d01cac1a2ebc6e0d809d269655a6859068237892e8208b219f0bf4d0a0eee326cf705c7763b810b452ede4045490c6e0d8684c5824c3ea034584f75007539807ea6b56a41597a8faa857b11af98976e4bbb4bd29a3ece331fe09bb4e6dc048a56d64203a6441039282f0851c74b4e6b3b8634e8f03fa63de60592795d6d4f51a547ca8fd0dc656c15fb732c067d00a2790f45c780ae1ae252dae9cc210135035f93cd6f144262bd9cac19c19988744cba56158d900a8b30a9b4ffab0a2f978fbd6188f183dedfeb98d5568227f0f6e702da943bd7645a122a9e33c2bc1bb518e1ec714ab590e8b7f6c06cfff61900b1cd8a4019c3f826c53031a8097fb9e7205f3dd18e945181eda97f10219ef25051424bb9ee3e21b9ff8dc2c41901f90e30e5c3fdf3441f89243d8be11e89c3a07d7266976f2fe650f2997b67fd6d525694ee702bc44260ecc4d5f6675ed888c6702ab4969c0743f3afd424f5c5f8c5cfbe2e7d4a1656bc5ce37bb70e86fdeb16624bf56106e245342857cc0c890b16a4472a528b0e7c6b2dac54dadaa78fa663986357829aa39bc193fbfd4e3d2ba693e11d9b4eb0921a01d7675a17409a430795d7065ab341c35181708ac662b249471bc5725a01e3b18a2b76fa5c5b0af8f607f9491d01adffbe4575fd8ddba1ff1d53886f40d4053d296d6808cf530004714d504f6aa2951f5be103fa35f1150acbf4907cbb7df43cee27d387891c284b64f39693ab4d1dd1e6b91aeb44cbf258242ec2bb3d3f2fd3f60903897ccb7e5b2f5b29d797885fb4b563c70ea4a902005356a6b23569cd3a81a3c8f6b891956eede1fb330f8bcbf84d1ebd0e4a8e92c56b040949f82185304371264c622ddaf3f550e255494208aa58f2c57fa1c3b50e02553bcf21650a422176188eba5a3ef2081de69b8453eedda38de0878e7d925b20ec1a78ddd4fa779f0829eebcf061c1d16cb0a06723644bad207e6876dc1e30d8d9d66dc32a6a665f825d5911530b092be108b1795a6e6b202fae481aaaeabef746ea71852ba0ee65fb55f4bbb1d0c78408ab750c1f724295cad188c8d4d496b033c0038f53897fc0e8baa65be4e0ca9327d66b5833b6f0eb122496b338a067122929b899fc9213b1d75a7779cfa1586cb8722de10cbd4421861fd2d221ecbf9c9636c473960aed51cff0ab2f0e1c4521e0b72326740f221f4a80973af5879f3ba626d959360df09c5a0e244690b0203146fb57b83bdf08be002f14d3cd7682f5d7cb72c2e7420300ff4904c642c647af6a3f58d5bb6b7729d3d9d23ce5bb0f45698bd2d9c1d41779d03fd66db1396fa4f7cbd85c288a76d7c706a009a72fbb8fd9c3729e0057c824c1a2824d2d6d3eeff6e0b0456330c84218dee2b2d3cfaecf80fe4e3d2663efb1b9cc59b5d663ce2af091929b167ec028c1874e2c53e3d466a8ad87deb8f97cee857b1975da6013ca946ba045e8f3dd68a801804111ee9535cef6be5539f67375b33f9aeb296dc6ac26418ebc4108462a52c28f9ff3568cf69c59f8e715ddde3c789ba25e227c007e8b5f3cbb83c8ddbf83e99691115e3625bbe88f614ee1e77a12157d494b5c0566c8081b6556f77a163a8a604f7b7adf8ac75f2553a94f3abbff6466479c1f774cd4cd33bc6a521e27ea0ba7d02b60855dcf9d9d812c3eaea3cd9f25668f85e97a28c05cc06546102fdf66009a748ced0e444af6e21040dac86eb02d0ea8206351a049293357a5df4312461cb9499d05c36d4ab7101859ca37df38aa94b555d11bbbba8bc42173f3ccee5951b8c491e70c054e51383a869fceb7b54cc4191cb5422a1d59950ae082e14c6e5396a31ea52c9f0ee9e04948a946236659dd5b475aa93a954af5d9e0e2566251ea1abdc818a09242697d6f4b167c2f89d792fca25ee51018a1adeb68377c133a54f7778d5ffc3365323f715dd361800cfa1fa8985a03426f614459963be76dcc6c280606cdd170c5f991699864e7f176945eb2614ebf99174310ac9a172ccfd06ac30a02a14e2c4c03844bd80debc3f9cb827cbe9f6570df95958709b77a86e8400d8f355edac2edc8fb5a68eb30a91f162ef5d69a3a34e7dabeb042ce076e790cfaf5b65262244ac0725e49397160b54a1001df5f269aff94e248e0ef41f08379a60210597b96d9438f1489b2dc4779e1490b658231464af10a819ff0dda27967f4bf60730bee9644346dda963da0567bcdda6b3ac9cabd011ca4164fd7f3227d613ad8d0e381a94fbea384f08def59d1e7c1569a7de0a272e731bf36b8a9c14067eabf25c246a850d66872d8237b6c865ee3bed6f4732a0860dc6724c59d8946b38487e7185688af67d2e2d25705d4d588cf4f9461b9e3760dabcda17a17999ffb3ada6c3971bdcdf3cd644e21dfe49c9ce31d4cd5b8b82a8137d8453dcf544e4f8b5e3d5c90d598f9659a12e6245514edf079583e1fa661fb463d9697a6b20347ea4bd086c640944c5c5a5974881a8ab07ed3d7d3347814c040cf72be3e0f18eebbceded83427575a66fd8ef352ca9ee6aea68c26f77cae569bfbf39fa14c35fc005db346c08d818d1c26caf78ec09538c898d661801af3e89413b362c1ae17363b919280090500078c89b3449b22ccae10dbe25fa67ec3b8ac962fb9299198929c53bb0fd12bf7ffcc89a9fe0cc90c67c30a1ec35aea59d9454dcb31c05f365603ec4b0553869c2e0bfc5bbbe72a119d04bf3d5f644435e71ac9607010e3634c03dc4a1d7758f742e27f88c8529a053bbdd63115fa8e25c0551649a457a92b53aed445d2ad922504aa4e25c50cb8e05a7196242c9779c0a5d8aea89cce166e526ac43839909bf77cc201476d950dd5d910e97b1d5b543661f1ed09f8277800c975eab699066a344feeac245120ae55b7ca06ccea4628d8c0337af35c758f1212628e8097b17ed9f42c697593078e3c7dffdd0d3a9276618d0fa36d80f539baae92bf9625ca472f2db04f3b0789a3cd6edbd616ea1ff56651ce35f2e94a791837f2818cda7f10fc939c58a6e197e3877698a2ff71bb47fa85dbafec3a59f8b089271ad69839d499c3286d497a34255751fad55136beebac97f5589e469e6d29c26e815d5f4683a4c1c76e830ae97015c0f4dee3bdd2af75829e89bd44ba152274fed8d50d06ecdcd8a06de1027dc7dd1e185148b81b4999a20d5052dc4c407bc1173b81fc899be25f46f6f2f0407a784dd6501a50310bd202076000d42e6b0ef7c7513cffe880c09041eb97f900e1e88a6315dc37c0228343f4ca2ab446b69d24132727aecefcede0dd2f4819ae1a2a692a6dd20a2aa6e0dbc0a994b4a53ddd37a27aaa7f00a2af5b429d6cbbf4e7c6118d958c14bef92e550e9108060f8caa08919dfb4f51fd46455191daa275a36f22aa29895ca31d6b5a4a500e4f0c5fbd4f6a95ae88e263462b107e3d0f7c566b926d81147ea611f61476baf410102d49863d5cac25293540a07b651354fa8e22b73f14cb1e3b62982e84a3fd7e2b066f41b2cf7cd41a0860d9aab8bac6f0ab1c31b0cebaedaefcf90d3fd9424b828f9c4627dce9ecc38eaa8afa5871a97c3e1dabe3786bdd6466b11240ef7930004b1ee84040f484b3744b9f1c66f9335e060d79566d998e0bdfa35a99b423347ff5c0f0456589d1b343145c34c7ef0058cf0143fdc01251cffa78d7e91074c3e8d97dd8aa74906946ab453d4419622db43ab0521fd0a596adc097c75cb90db2592580f03b40df38b1376859cb8eb02d8d7a4b305179f3c3c299c82aee8f575d80542635ee2dcbae2dadf40b12da22f8a0c0e625ffa6a89df270beb630e43a2fa19fc2f0f6d58d72afc90915768689695192541471521e794fa8716949b062d5f25df312903cf8667e63508d0595a2e64751ba9b55ddd0222646bc29eea64dbd11aa80243c7b43096a7b4305f9e7b177153453882b5bfa5b0daf6c39e20adc45aa71f55ed6bf29ac30d8e2f741e76da8d4473ba460c3a4747d385c66c1fba0ca3d9a6f3f46fe33ba3b496557990752025bca80bd53b8e1e453bd4125f9afdffe7772d359315e9fc852d55dfb9ecbf9ff5258c3e638959a488736359f536ee328c4170172274329d3c98c65daa0379ba1228e989fdbd15e215a1942bccad351a769549c9de6ab92dcfead9edfc59139ea0bd682981b9136ae97f8921e2b0f1cffeab191fdb6a1d5696b976bef743088137ed8cfc2a75ae45e2852d315d1d6b7505c64146ad835f887b4728330cbc5b1e3c6b3ac6af2237bc468ecd4324046cb67756baa82c6133a71c847fc0b6fc191fab33247f83c982439a118313e2634bba2ef5f8f26a10c23c2a0a7103448a70c16d38cf9485db135c3186bd3cd0bf6b9820d63dc43351526c689d7c679426fd37aaf61b40bca6bbdf95b4b6b952c50d8239ba5e8b817496c1d36f24608f5a03462fdb6dac94dca3dbfdb4addbda164de9d58bea14be4a421feb80978bf6f3b6924a593a5ad8b2713e2c0bc132a0a3f617843b2af7e8bf5c0eabbf071e6f727f3b66723fd6566bde988fb422e240eda823cdf6e00356a9fb8b0b36ed50e0bf32550365760caaa71c647263513d773cf66dc96c620ce0199940d5165be7537f736c16b9f4ffe3c64b3886f4023d856332c389117112bdfb7a42c938892fe3755172e6a587710cbc5ea83b9482f0de4eef00aae1285de9622988a0f8a2c39b5ef38e8d33b632c7fde6738c2c3bf789a9f3705c01511f592ce47b73cb7733da6df05a1464b329bca6161386cb3e896806d7106687b862816b3655140f50dbcb26c9eaede5b50e47455afab51aa8fb5acf5be5a640dfc9848f3254cb9bb186462143d881295416e886c4b1deeb11b188e97580aee540c6ec90af03395ab08c1896b3dc71fadcd5292c27b7b86a49290a7f217e13cbbc2263c2ee46cc4c9dbd4d17d4a2b0d3fd88cf24d41750a6e4c952b5d83af2874289b70bd06b7cb5529fd99a935d79ddb27cb3fe9d0b1e5e67ac6bc74705132c2bd7ba6a7c9da08b0d1063618b8e6cb3a9d44fdd2acb42dc7c93afde80aaca783b25949c2f7638d561171dcbc15a0078248a24aaf17df5ada6b857096e966dfd342f7a0658a65fa299525d5ec243fe2437a232d35ec263c4a384a4ff63f034912da0c4dcc192cd3365239fcca87af1869a63f6c3048689feb13d02e0864e0920b7376e1d48f6ca89c7673f62b464705e920b7dbe13ecafcbdb7dc17f171c6ba4ee5812971e814de7876521a3eeb9da469a59a6b70d15a9d62557a57107d39e0d9c4ae4d7a6be4d45b0f43ab1296e23c746f368c3456e14856265d0938126b456d4eb2f7f0b9b08134ca424df8c27e33ebd01826055f9aff4adc4382e07d93f321e0fc5c5b31b1468aa2c0ca4af4e3e5666e179ca673e791968093d4dbd1b8d0019a1535bc6425cf2e455cdcedb2cdffd4a8d954e75ed6f33aeba6a8c24cd2edc880061cb3984d3934ef1056350c7d62f6df2a5a0b296292c28d660f647d58e4b199c513147ff5c2160d89025c2bbdf8e691e346b45e41b380466ceeb861638947b356888bf111455a37f0dffcd1a9f04b7c6a85979708de28203bba14725e5092b0c45d2b63714d2620cdbcb35ab215a9f78a4477b0343d27f32c539bf55c0be6f4a7280f7ceb4265d719e40f416f6dbb223d086d08117c067dd3687b36d5b566818be2ad4f435973ab20b042f8b7f13bf797e377ae70258ea43eabb6288e50192b7516e76bd13a1d429b78eb6e912f3549a2942cfaba211eeb3b0226edefb494f26462ba69f87f863a01ae3ad2cf8d15c199000a57799c107bf8efb25eee1a24c21277be5d6123474c234394240415cc122c3cd17f5cb8488e42cb8ad407bf6c593e98674256e24128abda6f02f608c5d7eecfc32a17fe4f542add5b7a85608b6e7fb1212a9e999544217d0c3720b6dca4c22db7bd908f19b4e26374bb90612ad0a666e398207bdc61ff22b68d72044242c20c3026cf130f73f7928163fb77979766e2ec17bfe083a8d8d70b435503ea9a4539fec5f1c49fbe1bb1b19062b6b018bffa69549614968cacf482a430946b447b72d9cade58d4aa4df7323ebf397c92f35a3f22c78e0ab0d922796a5361dd5c7df2e0429c5de2063d7c8e4f5ba7a864f8965acba0724fbe61dcf5f2c8bfb0289e18a28eaca50de4c460de7046d5adb74610978c897288d091184efd62c405541386aeb9f8bc7df4c345cda5a84fb3df8b6509e3d4575b5cd15dabbac5adcea1856f3871e4b136c3d17419a55e1155cb4a962f45dc8213d4390f6fd0f9868d20f547161b593638014c6f98b8737c8aa9f0f18adfddc528eadc6926aa819bf3f8894ca49a40b2a0ee249b148baa9ed8f6b880882f4704fc2c0c1e7b1f1fea7e9f40d452a10ebcaa406782f1d5e16f53da93040c719538cff2be7d7953ec58c686196c6523ec521a041458ae521b44fef639f4e425594e3b1cb7e0c5dc5b1bc3cdc64413cd39c64ba4027ce0a3096412f9f148452236bab6ec2d489853d45aceb3cc88a5350b6d2f6fdfa87f7f0e52ac84e3e760c8dd8034276bada0bf6c4ea8512ed190ee5036e561b7ef86795ca4e8620d850f91a495be8592d3609692cfa3617ea916556490cce3790eb5fcf7ea2d5c3c83395d63a70526bebbec193715ae4329183365cec3b38c9580760ede1646d1f81b5640fee6042c017425c0fff65aeee82e30428f4623317caf05499fd8f8ef96daefc3e179fe824747c8dcd0c81cbb2bdbfe889c6b0f7bfd8fbaba33b3b9b9242538c84ddc563cb0d77c16e2c7b6ef8a9d7e74bb7ced0bf6dfb7a2a65bd9d7b35ce8c78c84f17270761f7c6fbe656e56c49e67263e457cecce1b5f5f9400027b85148baaba8bedc9adc4ec1a070415d1c4d68abcf869ad693bf4e1b2275187028072453a8f6143874d1a66fab6ed06f25cccd13ca0ce292b46dfd36328526b0e5ddf0f6423480338676b9adfd8ef551d66c4a4cab9162638b0107310cc371dbbac396787315e46f5e5bfefcb644d6850c5c18eb782b3ef23a4e4061f734ce8f5fa3d6da2ea3e4f3786b7373a9134a02d4be5ed31b42510faa7238e71787125bdacd913860e386e5aa05307ae50006ab07be4445fc20ac906caa6eb81d166bb208282197489d87bd44f31a2dd98240a4aeb181c63d3f95dae65dcd7bcf7eed6958d2668d03e6e2c55afe8c128989bc0bebd607736ffcae4b1785cc179fd8555694d3633cc5cbace6af644fedb6474c21c3b38a656090123df3566d48a057d16ce2058c1a354c7349053711ddf6309eabd53fb818f97479429589b44893ec5c6e1133c9c5198dbd6cb7af8823f211a315542228a533e43322d478d35929d9e7d6b0c40072afe5cb6acae9b29e54ee3771808e5e1845382108cc5fa4f484e1a08abb65f719feb299afdb511df78a0cf061ab17892828c6df82858714c89a95051f1ff976da229d3195dd59a050434dfc6c0cd5fb68a3a02385c344756e25113143048e62e6c52c31294fbf54f6b56933ab0d5dcc198444238d08dcb615e9c046d09137af3509b940022bdf478329c31149ed998b36f622db7447be303282939f4da4aa105e2d4879c19c3ccb5d7f750a8f1f33f92202468915d6f272272244d08ff5393530dd24d2c76374de7e0bf2da4eae57cc40004d1dc71d7d56b213de317ad4054d7322e097d55279d76a67f9696d2fadaa8aabe55328c2b69c239fbdf0d00ea8c76befcb1f3a8f0d589bacaa887348e3d9eea9d96d6db28b9401d9704975ec93e7d251c7d4b38f42e74cf66f43d8b47294097ca5e83b8d7019017602fff012a42fad5a7011204c2fac3037a7e99f946121c95c2e65474d8252dd7e993f868d4b3a2bfb107544db743e54bec32d9e762eb277a250aeb103c3cf533329d735373cd5ddc58d88b89ba2e148e8b9496da0448e61d6c3bc4b09d08d11e5ab2ec9ad1112fd54b3ad8243073c92fae72e3552769eaec3ed37bd7fc7ea6c2315eb5610ead4a3a2b85bc086e45327e11dcde628a3c3fb96bc7cffadee38b2a7730889cb1a8006fd1abaa4c0dde1f2f2cca7906ba21dc5edb053ccd0ef20385f5b1a46eb2d1ac59afabe7907e7abe4e963cea43f9ba9fffdc04af32519796a62b70d4d16b14940628aeb86c5c1be95ab042d0f4c58b5c1a3c3ee00a8f05bb00573f6517eb6032df6ce82ea06e656ecde614a2cc72697f30ce5e55feb4b0ef94361f2c2a997a6e16a5ba4db6f863ff2bb7ac6e30d35474a133e286a752b9a78dae6b76a353dfa38e389f83d731abda6982ef5fe4600b8cb102e12020ee35760ef4f3287c275d443af40ab27066cc47ba982a529efc180e3762740b98798ee66c53a697557b110fe6f0183b6e91e9f03c1d56820189718ca84cd67d787a6fc9640290d6868ef10cf2f3cc1e745fb51cde8c9aec6b6d826dec788849c0ab4218d6d5ea2e884a1c5261dd51288f9539740dfad832ae7e1825e716490f0d09b384f2a93eca4384cbd90b6f31c40b082796c25ef5bfa3cb29807d538ef81b819b30a2b350110cf053e73b4722a8f108a1e3d6b76bd13c2cc374d8c32e5ea757e53e7e1564db6c60b16fcee38e6c720c07f20a28d4b81d72e9fcfcce0cadc1c721554848d7e4d5d42058c550f2876473f80aee96ffa2425c791ed533ac1346a987107e9515fd4a8e0d415754d3c3dc4cec89c46a1fc8efef2d45a1b21c99f712f4003a1a4fe8ff60c1846d483caaf0abcb0ea6e6dca615a8182899384f5f21b6d4b73566d3f2331be46840683e8b3e32ed31236932fddf3f4b89fafc6f15f836c9733b5bc4bc77f6bab04d9e3d52186c28d5dac0ca0971eadd58a77f76e55968b509d4e0ee93115d804d5ce3e8f0380f133e8f433ce51d63a3d832026c7fa2cfa79d3b7d5d94e01851fbf3d89e3a623bac2568d3c29b0d4c193bc1a4cfdb92f865ef5ad888b83e107b1a695f33d43d066e777510fa3610e9af2fb3c0f4daf2e293ea720db1276ad2e7260f2d6f794683501506901e5c9f1365530cfd7d06c76add56245babc6f954dbc6c904ee92ac4bbf9f3821d0014aeae9d61f2a634f1bb72b9c6ef69a03fc2b79cccd9d1b19df92d78c1485a90d0035e9b74fbefee954789a0de34c9fe1ac8d0fd27da5e44549dba9397692a79a4f62d6b404ee029b4a1e6d4eae2a71a25da1de385b1b54c84826045c388d637411312d2c4c9e0d7918e3f4ba4e2502c4f9b6702a63ab620c79c4cdb9db2cd946528328018591ab28a334ca428b1033da89ac7197f57d5bf4a69925e9a09dd3b8c585e6a2a481b06959f2f0a88eb9f99082b0e0603b0248d77b3e88d59a523067d9ef423ed1afd688d2f36726968039f49bcbc23e6e20229d348858559977aa1831cebd8f0df770639bfb8bfd70c10d4da7201974f89dd4a1f4e23d38226c08fd39a25429a54e27c736fddf49b77a10d99f283f6c00491a10c2940290f9421083ff1b6effa4c5f6c8d9276739a1254cc49ff06a487e24c6ed2f9595c96e125b99ef957b21bb7b0ba26577e108e7497c4e5fec2436d3da5a9aa35c58afc04a8e25b17a30b758e31df8550a75773837c37de1a8a15c22111cd6509d8ed25cf93f31699200afff0852806fdf2a9fb7e7f8c29b4d3a1e53ab2e274b40ea800d2f3010ae222678a4d4abe2f1683244d6d2aa80bf76d3fcdef924add5ac130ff036677f5ac8033e574680b19f50ff813226eb7d3c71bd41f366910499c569c2fa2bbfdf3bc33285688b1cbc450a0bc3ebc9be07d41c58e723765b02f831592d1477ef852595c68f100f486daa099e3938a3d8b19d735773458a76b20ff0cd0c80b700091b2afe2f0259f8276629e90598db83f1ea89696919f8843a4b7312bb84c541e4c8e6c7d21073cc54bf5a01fbbe2fd52147870d3304447765afb2b0f6efe26c0b739746b1719933ddac962ffee32c35df8c7ad3d10be2a744d95cb4bc08e048974dd6f60a5f1a1fab672ffb7b05db165a4ed50ffd736e0ac19e2224c382c42d53c2ccdf4de6e0337cbb3228f7c123045bfaaf19a9953af24bb476c92756e4a95ac453eba8b0fbe249f6b1a7011d116785d5047e4d5d7866899b60a1c82ec93038a555861285ea867aecac309cf73993add3bd21bf63f90b3b77427fbd6f6129d44e88fc7011cf7b912b9ffb33393597dacf46d2b40c026b9242e0c53cd17b50e715652d89699b6fc02ae0b8d467aaa74dbb5231cacd67e2056721c70c65130262913062e8902fa413b2585f8ae2f2dee7293f3957729e274d50b69b1f3fbafd9d739f0f914ddc78b8a2fcf09b64369613915fd964d976b5c6f2b952ca9a05f16dd5b58a0bc17b942aceae30c0db576c310b6b071560cb370f38b10901459a399bcf0aadcb33e1f6b8812497dbb6ab9ffff7dd7d0a83a8f415d193d911208b78be39f4da1b571a393cad38af214a491a41112864e1930a58278b552c2210bbe234e77f83042f19197645eb1e31e64f2bdf4c2de794b7d42bbda0c7e333c400160ad5e3cd8513d371f9b851a630fe0c76c9fd4ae666173ecf04e81bef93e6777064c2e63e5932188f4f26c662829d8659ddb80478cbe69c0f6175a8d420e16f97fcb4c51ee1bcf86624972e86a49a45282bc6838ac31ba861f37792f69043af459f0e99657bf80fe6aade388ea36647eb20b8cb1dafd7ac0aff3df6f6ab09c062079e9428e205ac919590531e4ea871b642594e1e9380ddb16ab8a2f3025956d9f1d47f7cd0aeefe50882d0782c077f102e80e77c3e60f620b47afaa6588e6838d4658e59b08b0e4a6546b5bceb57df0af53d8f3345e1c7de4c6b3ddfe07230b2ff48a2e35dc12ef0d5afee81a6fcee63ae387c314ea77154c176bc748d0b12091ebf8de9bc052a7db71847eed13fe14f61df15e0edba475f79fefcd2fe4dbb2f08c3078fdc4eeb412f7a43c19774dfc0dee3870322efcc2f4be5430e160bc5b6d7b3292dab62f09932b485cc92ada15a0b4b26db1a740ee8821c87c4fe87616ff8c7a8564b135a4c7cc2d8a9b065c22de004a690ca7aa4eaaa1506ae0d4de31213499f5dc8a5ff5fa412ef39104167a96e8b3e3f6e4944ad8fba5279f8849468d150a54d396079a9c7684a74fa624492b8d5534d3c26704c615c6b724c5cec9ce66cc91bba7306b8f72274d39924c9935dd105a3f7bed8e9389870466dce9a152ea5aa66e92afea9484045dc76c09596713a4dfe987a760421cb73504c2a402a89f7c829a0ca51bcfc775cf7dec550973b37b7f92bde0de0b36f454d5964188070776ca32ab21423e29a721a56941188e593584b52ed292709a871a7136af105fa9b422bfed74362e465ad5b6a03eed0101dd24cd4c312d69189dc0a371e9adc3e10d2ddbf0ed429d799d7b54841b5c9e7980fbfb993478c72e63347c7d0a87d2d853106f7ed1f32fa44d14fe101584702d025f9be187b0feeb04b8b72154790bd11acec482160d2d8ab7dffe29bea5699dfa8b166a5fa6aa41b7412a55f2d222a9b3f662eb70d8c1ec7c9e48728c0e89f61b4b0651ac46cc488256e6994a4dc301862975bf44591cca83a998cee3afeb1b59f391da78dcc24e2c318665fc183eebc3d6984b4d7074a7a14a1c14ed404f359cd558ccf44223ac5067c9a59736f6947bc2ef55b25946cf4aa7c952b848a4919974d92aad34f9c32851930b7079c815339976981b540b507a9ef6d400546d229427029aec234542612fbacfd051e55b54de7c571503dfcdf453c263b446e2a6e92897300b6882dcacd5e6af5d2038f350bbbaf3b81e24c7cef06b2ac821d5ae1eed87ac327f45b6b1ab89b42b62023a697e563f02f40283162a025e01251b5d04130b38fa0e77f590b7a8fcdc8b747da3133ebd620b070e1b504f2a39e74d1b9f119ce5d3c6a3a3f6469e1b5ea4c76f9ec7d1d5dd3e4d77df4327cc35a53ad9d14e0bb70e1e1affed618b17c0c08fefd6b67fa7f4ebfb7fa0424f0179f998c902cd153be0e81344a28ff20f615b40b578462bf09c22234d52cffacf411c940d8f457b5e62d5531dd3bd15fca6f3e2d9e6418e97c7ee4d7d30ce48df526d31bf23921173a82289d312e67ed555dbe036805fd9d778e290f364a3e340591b21c307f4f280ef917ae315c51efd04020567bd7deadb27bae26c3cf0ad046d771856d711a97d923feae1376d9d28c9c9ef5644de81305815ab2c55cf29745578f23ab84bac42a6a449478e0ab5ccece36b55df926cd9dbca1635e055cc75ff52a5005e613650b0d8b3f22fc1edd4ff3a7e8e8afe64bd78bfe6ab7f6dbb86c4747e683ef70c0062121fab829c47002513cc390f691260bd351d9149df27cbc218a0a7a6a33bf9a81f68c2d97101bbdf1d44d5fbd8ed1c279f834be41b723d66ce924be9e9ad3f29cc3ef5128efe01d5b422e303f6a21113f6f7db4918afc44c8a4552d256a856958c3ab614473da09770073decfae486e5f3ad798de3257074a7c91d5f1c496371dfb812d40693f58de712256bedaae43db792dde84be53a4f776cd692585eb7cf310707b88f04157a9fdbb48cf540dfff69ff796af939335b6e490117f56525c92cf4439427982ec2b75289c6bae4832bb42f16a5d22b1f207b66641c0499ac21e30804029de927eb00b880eb00a038e1303da4bc4e607b39a4ea283f6ac2df0e2a0749aca2b82d2ba6ad04e0be807c97c7952989e4b1071eca86b5443313096659d00351512a1c99c02c76f158a7b22bba286cadb190863e067a1d7daec4171739cd7f95fadc125df13accfd7f5602d039d59babb9b577874c2bb05e7ed2d1c3594583cc3c44f5990ae340840847c542f547fe27af2da3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">点击这里输入密码解锁</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 8 - 渲染引擎 </category>
          
          <category> 8.2 - OpenGL ES </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 Android 播放器（一）</title>
      <link href="/2025/01/23/9%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/media3exoplayer%E4%B8%93%E9%A1%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/01/23/9%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/media3exoplayer%E4%B8%93%E9%A1%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Mp4Extractor-解析-mp4-数据"><a href="#Mp4Extractor-解析-mp4-数据" class="headerlink" title="Mp4Extractor 解析 mp4 数据"></a>Mp4Extractor 解析 mp4 数据</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.media3.extractor.ExtractorInput;</span><br><span class="line"><span class="keyword">import</span> androidx.media3.extractor.Mp4Extractor;</span><br><span class="line"><span class="keyword">import</span> androidx.media3.extractor.TrackOutput;</span><br><span class="line"><span class="keyword">import</span> androidx.media3.common.util.Util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaExtractorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析 MP4 文件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果读取文件时发生错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void extractMp4(InputStream inputStream) throws IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 ExtractorInput 实现，用于从输入流中读取数据</span></span><br><span class="line">        ExtractorInput extractorInput = new ExtractorInput() &#123;</span><br><span class="line">            <span class="keyword">private</span> InputStream input = inputStream;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> long getLength() throws IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> input.available(); <span class="comment">// 获取文件长度</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> long getPosition() throws IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回当前读取的位置，假设从头开始读取</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void advancePeekPosition(int length) throws IOException &#123;</span><br><span class="line">                input.skip(length); <span class="comment">// 跳过指定长度的字节</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void resetPeekPosition() throws IOException &#123;</span><br><span class="line">                <span class="comment">// 重置读取位置，这里未实现</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> int read(byte[] target, int offset, int length) throws IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> input.read(target, offset, length); <span class="comment">// 从输入流中读取数据到目标字节数组</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void close() throws IOException &#123;</span><br><span class="line">                input.close(); <span class="comment">// 关闭输入流</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 MP4 提取器</span></span><br><span class="line">        Mp4Extractor mp4Extractor = new Mp4Extractor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供输出轨道的处理器，简单打印数据</span></span><br><span class="line">        TrackOutput trackOutput = new TrackOutput() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void format(Format format) &#123;</span><br><span class="line">                <span class="comment">// 处理格式信息</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Format: &quot;</span> + format);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void sampleData(ExtractorInput input, int length) throws IOException &#123;</span><br><span class="line">                <span class="comment">// 处理样本数据</span></span><br><span class="line">                byte[] buffer = new byte[length];</span><br><span class="line">                input.readFully(buffer, <span class="number">0</span>, length); <span class="comment">// 读取样本数据</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Sample Data: &quot;</span> + new String(buffer));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void sampleMetadata(long timeUs, int flags, int size, int offset, CryptoData cryptoData) &#123;</span><br><span class="line">                <span class="comment">// 处理样本元数据</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Sample Metadata: timeUs=&quot;</span> + timeUs + <span class="string">&quot;, flags=&quot;</span> + flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用提取器初始化 ExtractorOutput</span></span><br><span class="line">        mp4Extractor.<span class="keyword">init</span>(new ExtractorOutput() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void seekMap(SeekMap seekMap) &#123;</span><br><span class="line">                <span class="comment">// 处理 SeekMap</span></span><br><span class="line">                long duration = seekMap.getDurationUs();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Media Duration: &quot;</span> + duration);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void track(int id, TrackOutput trackOutput) &#123;</span><br><span class="line">                <span class="comment">// 添加轨道</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Track: &quot;</span> + id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析文件数据</span></span><br><span class="line">        mp4Extractor.read(extractorInput, new PositionHolder(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mp4Extractor-需要的-API-名称以及对应的功能"><a href="#Mp4Extractor-需要的-API-名称以及对应的功能" class="headerlink" title="Mp4Extractor 需要的 API 名称以及对应的功能"></a>Mp4Extractor 需要的 API 名称以及对应的功能</h3><hr><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><ol><li><strong><code>Mp4Extractor()</code></strong><ul><li><strong>功能：</strong> 默认构造函数，初始化 <code>Mp4Extractor</code> 对象。</li></ul></li><li><strong><code>Mp4Extractor(Factory factory)</code></strong><ul><li><strong>功能：</strong> 通过工厂方法创建 <code>Mp4Extractor</code> 实例，用于支持动态依赖注入。</li></ul></li><li><strong><code>Mp4Extractor(int flags)</code></strong><ul><li><strong>功能：</strong> 通过标志（flags）初始化解析器，例如控制是否解析特定类型的 Atom。</li></ul></li></ol><hr><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h3><ol><li><code>newFactory(Factory factory): ExtractorsFactory</code><ul><li><strong>功能：</strong> 提供用于创建 <code>Mp4Extractor</code> 实例的工厂方法。</li></ul></li></ol><hr><h3 id="格式验证"><a href="#格式验证" class="headerlink" title="格式验证"></a><strong>格式验证</strong></h3><ol><li><strong><code>sniff(ExtractorInput input): boolean</code></strong><ul><li><strong>功能：</strong> 检测输入流是否是支持的 MP4 文件格式。</li></ul></li><li><strong><code>getSniffFailureDetails(): ImmutableList&lt;SniffFailure&gt;</code></strong><ul><li><strong>功能：</strong> 如果 <code>sniff</code> 方法失败，返回失败的详细信息。</li></ul></li></ol><hr><h3 id="初始化与资源管理"><a href="#初始化与资源管理" class="headerlink" title="初始化与资源管理"></a><strong>初始化与资源管理</strong></h3><ol><li><strong><code>init(ExtractorOutput output): void</code></strong><ul><li><strong>功能：</strong> 初始化解析器，设置音视频数据的输出接口。</li></ul></li><li><strong><code>release(): void</code></strong><ul><li><strong>功能：</strong> 释放资源，清理解析器的内部状态。</li></ul></li></ol><hr><h3 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a><strong>文件解析</strong></h3><ol><li><strong><code>read(ExtractorInput input, PositionHolder seekPosition): int</code></strong><ul><li><strong>功能：</strong> 读取输入流，逐步解析 MP4 文件的音视频数据或元数据。</li></ul></li><li><strong><code>seek(long position, long timeUs): void</code></strong><ul><li><strong>功能：</strong> 跳转到指定的文件位置和时间戳。</li></ul></li><li><strong><code>getDurationUs(): long</code></strong><ul><li><strong>功能：</strong> 返回 MP4 文件的总时长（单位：微秒）。</li></ul></li></ol><hr><h3 id="跳转与定位"><a href="#跳转与定位" class="headerlink" title="跳转与定位"></a><strong>跳转与定位</strong></h3><ol><li><strong><code>getSeekPoints(long timeUs): SeekPoints</code></strong><ul><li><strong>功能：</strong> 根据时间戳获取跳转点，帮助实现精确跳转。</li></ul></li><li><strong><code>isSeekable(): boolean</code></strong><ul><li><strong>功能：</strong> 判断当前 MP4 文件是否支持跳转功能。</li></ul></li></ol><hr><h3 id="Atom-解析"><a href="#Atom-解析" class="headerlink" title="Atom 解析"></a><strong>Atom 解析</strong></h3><ol><li><strong><code>shouldParseLeafAtom(int atomType): boolean</code></strong><ul><li><strong>功能：</strong> 判断是否需要解析叶子 Atom（无子元素的 Atom）。</li></ul></li><li><strong><code>shouldParseContainerAtom(int atomType): boolean</code></strong><ul><li><strong>功能：</strong> 判断是否需要解析容器 Atom（包含子元素的 Atom）。</li></ul></li><li><strong><code>readAtomHeader(ExtractorInput input): boolean</code></strong><ul><li><strong>功能：</strong> 读取当前 Atom 的头部信息（类型和大小）。</li></ul></li><li><strong><code>readAtomPayload(ExtractorInput input, PositionHolder positionHolder): boolean</code></strong><ul><li><strong>功能：</strong> 读取 Atom 的有效负载部分。</li></ul></li><li><strong><code>processMoovAtom(ContainerAtom moov): void</code></strong><ul><li><strong>功能：</strong> 处理 MP4 文件中的 <code>moov</code> Atom，它包含元数据和轨道信息。</li></ul></li><li><strong><code>processUnparsedAtom(long atomSize): void</code></strong><ul><li><strong>功能：</strong> 跳过未解析的 Atom，通常用于忽略无关数据。</li></ul></li><li><strong><code>brandToFileType(int brand): int</code></strong><ul><li><strong>功能：</strong> 将 <code>ftyp</code> Atom 中的 Major Brand 转换为文件类型标识。</li></ul></li><li><strong><code>processAtomEnded(long atomSize): void</code></strong><ul><li><strong>功能：</strong> 在解析完整个 Atom 后执行收尾处理。</li></ul></li></ol><hr><h3 id="音视频样本处理"><a href="#音视频样本处理" class="headerlink" title="音视频样本处理"></a><strong>音视频样本处理</strong></h3><ol><li><strong><code>readSample(ExtractorInput input, PositionHolder positionHolder): int</code></strong><ul><li><strong>功能：</strong> 读取音视频样本数据（如一帧音频或视频）。</li></ul></li><li><strong><code>getTrackIndexOfNextReadSample(long timeUs): int</code></strong><ul><li><strong>功能：</strong> 获取下一帧需要读取的轨道索引。</li></ul></li><li><strong><code>updateSampleIndex(Mp4Track track, long timeUs): void</code></strong><ul><li><strong>功能：</strong> 更新轨道的样本索引，用于定位到特定的时间点。</li></ul></li><li><strong><code>calculateAccumulatedSampleSizes(Mp4Track[] tracks): long[][]</code></strong><ul><li><strong>功能：</strong> 计算所有轨道中样本的累积大小，用于样本偏移计算。</li></ul></li><li><strong><code>getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs): long</code></strong><ul><li><strong>功能：</strong> 获取同步样本索引（关键帧），用于跳转或快速预览。</li></ul></li><li><strong><code>maybeAdjustSeekOffset(TrackSampleTable sampleTable, long timeUs, long seekPosition): long</code></strong><ul><li><strong>功能：</strong> 根据当前轨道信息调整跳转偏移。</li></ul></li><li><strong><code>processEndOfStreamReadingAtomHeader(): void</code></strong><ul><li><strong>功能：</strong> 在文件流结束时，处理 Atom 头部的读取操作。</li></ul></li></ol><hr><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a><strong>辅助方法</strong></h3><ol><li><code>maybeSkipRemainingMetaAtomHeaderBytes(ExtractorInput input): void</code><ul><li><strong>功能：</strong> 跳过当前 Atom 的剩余头部字节，通常用于优化解析流程。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 9 - 音视频 </category>
          
          <category> 9.1 - 播放器实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 Android 播放器（一）</title>
      <link href="/2025/01/23/9%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%80%E4%B8%AA-Android-%E6%92%AD%E6%94%BE%E5%99%A8/"/>
      <url>/2025/01/23/9%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%80%E4%B8%AA-Android-%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Mp4Extractor-解析-mp4-数据"><a href="#Mp4Extractor-解析-mp4-数据" class="headerlink" title="Mp4Extractor 解析 mp4 数据"></a>Mp4Extractor 解析 mp4 数据</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.media3.extractor.ExtractorInput;</span><br><span class="line"><span class="keyword">import</span> androidx.media3.extractor.Mp4Extractor;</span><br><span class="line"><span class="keyword">import</span> androidx.media3.extractor.TrackOutput;</span><br><span class="line"><span class="keyword">import</span> androidx.media3.common.util.Util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaExtractorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析 MP4 文件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果读取文件时发生错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void extractMp4(InputStream inputStream) throws IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 ExtractorInput 实现，用于从输入流中读取数据</span></span><br><span class="line">        ExtractorInput extractorInput = new ExtractorInput() &#123;</span><br><span class="line">            <span class="keyword">private</span> InputStream input = inputStream;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> long getLength() throws IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> input.available(); <span class="comment">// 获取文件长度</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> long getPosition() throws IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回当前读取的位置，假设从头开始读取</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void advancePeekPosition(int length) throws IOException &#123;</span><br><span class="line">                input.skip(length); <span class="comment">// 跳过指定长度的字节</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void resetPeekPosition() throws IOException &#123;</span><br><span class="line">                <span class="comment">// 重置读取位置，这里未实现</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> int read(byte[] target, int offset, int length) throws IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> input.read(target, offset, length); <span class="comment">// 从输入流中读取数据到目标字节数组</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void close() throws IOException &#123;</span><br><span class="line">                input.close(); <span class="comment">// 关闭输入流</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 MP4 提取器</span></span><br><span class="line">        Mp4Extractor mp4Extractor = new Mp4Extractor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供输出轨道的处理器，简单打印数据</span></span><br><span class="line">        TrackOutput trackOutput = new TrackOutput() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void format(Format format) &#123;</span><br><span class="line">                <span class="comment">// 处理格式信息</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Format: &quot;</span> + format);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void sampleData(ExtractorInput input, int length) throws IOException &#123;</span><br><span class="line">                <span class="comment">// 处理样本数据</span></span><br><span class="line">                byte[] buffer = new byte[length];</span><br><span class="line">                input.readFully(buffer, <span class="number">0</span>, length); <span class="comment">// 读取样本数据</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Sample Data: &quot;</span> + new String(buffer));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void sampleMetadata(long timeUs, int flags, int size, int offset, CryptoData cryptoData) &#123;</span><br><span class="line">                <span class="comment">// 处理样本元数据</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Sample Metadata: timeUs=&quot;</span> + timeUs + <span class="string">&quot;, flags=&quot;</span> + flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用提取器初始化 ExtractorOutput</span></span><br><span class="line">        mp4Extractor.<span class="keyword">init</span>(new ExtractorOutput() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void seekMap(SeekMap seekMap) &#123;</span><br><span class="line">                <span class="comment">// 处理 SeekMap</span></span><br><span class="line">                long duration = seekMap.getDurationUs();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Media Duration: &quot;</span> + duration);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void track(int id, TrackOutput trackOutput) &#123;</span><br><span class="line">                <span class="comment">// 添加轨道</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;Track: &quot;</span> + id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析文件数据</span></span><br><span class="line">        mp4Extractor.read(extractorInput, new PositionHolder(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mp4Extractor-需要的-API-名称以及对应的功能"><a href="#Mp4Extractor-需要的-API-名称以及对应的功能" class="headerlink" title="Mp4Extractor 需要的 API 名称以及对应的功能"></a>Mp4Extractor 需要的 API 名称以及对应的功能</h3><hr><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><ol><li><strong><code>Mp4Extractor()</code></strong><ul><li><strong>功能：</strong> 默认构造函数，初始化 <code>Mp4Extractor</code> 对象。</li></ul></li><li><strong><code>Mp4Extractor(Factory factory)</code></strong><ul><li><strong>功能：</strong> 通过工厂方法创建 <code>Mp4Extractor</code> 实例，用于支持动态依赖注入。</li></ul></li><li><strong><code>Mp4Extractor(int flags)</code></strong><ul><li><strong>功能：</strong> 通过标志（flags）初始化解析器，例如控制是否解析特定类型的 Atom。</li></ul></li></ol><hr><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h3><ol><li><code>newFactory(Factory factory): ExtractorsFactory</code><ul><li><strong>功能：</strong> 提供用于创建 <code>Mp4Extractor</code> 实例的工厂方法。</li></ul></li></ol><hr><h3 id="格式验证"><a href="#格式验证" class="headerlink" title="格式验证"></a><strong>格式验证</strong></h3><ol><li><strong><code>sniff(ExtractorInput input): boolean</code></strong><ul><li><strong>功能：</strong> 检测输入流是否是支持的 MP4 文件格式。</li></ul></li><li><strong><code>getSniffFailureDetails(): ImmutableList&lt;SniffFailure&gt;</code></strong><ul><li><strong>功能：</strong> 如果 <code>sniff</code> 方法失败，返回失败的详细信息。</li></ul></li></ol><hr><h3 id="初始化与资源管理"><a href="#初始化与资源管理" class="headerlink" title="初始化与资源管理"></a><strong>初始化与资源管理</strong></h3><ol><li><strong><code>init(ExtractorOutput output): void</code></strong><ul><li><strong>功能：</strong> 初始化解析器，设置音视频数据的输出接口。</li></ul></li><li><strong><code>release(): void</code></strong><ul><li><strong>功能：</strong> 释放资源，清理解析器的内部状态。</li></ul></li></ol><hr><h3 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a><strong>文件解析</strong></h3><ol><li><strong><code>read(ExtractorInput input, PositionHolder seekPosition): int</code></strong><ul><li><strong>功能：</strong> 读取输入流，逐步解析 MP4 文件的音视频数据或元数据。</li></ul></li><li><strong><code>seek(long position, long timeUs): void</code></strong><ul><li><strong>功能：</strong> 跳转到指定的文件位置和时间戳。</li></ul></li><li><strong><code>getDurationUs(): long</code></strong><ul><li><strong>功能：</strong> 返回 MP4 文件的总时长（单位：微秒）。</li></ul></li></ol><hr><h3 id="跳转与定位"><a href="#跳转与定位" class="headerlink" title="跳转与定位"></a><strong>跳转与定位</strong></h3><ol><li><strong><code>getSeekPoints(long timeUs): SeekPoints</code></strong><ul><li><strong>功能：</strong> 根据时间戳获取跳转点，帮助实现精确跳转。</li></ul></li><li><strong><code>isSeekable(): boolean</code></strong><ul><li><strong>功能：</strong> 判断当前 MP4 文件是否支持跳转功能。</li></ul></li></ol><hr><h3 id="Atom-解析"><a href="#Atom-解析" class="headerlink" title="Atom 解析"></a><strong>Atom 解析</strong></h3><ol><li><strong><code>shouldParseLeafAtom(int atomType): boolean</code></strong><ul><li><strong>功能：</strong> 判断是否需要解析叶子 Atom（无子元素的 Atom）。</li></ul></li><li><strong><code>shouldParseContainerAtom(int atomType): boolean</code></strong><ul><li><strong>功能：</strong> 判断是否需要解析容器 Atom（包含子元素的 Atom）。</li></ul></li><li><strong><code>readAtomHeader(ExtractorInput input): boolean</code></strong><ul><li><strong>功能：</strong> 读取当前 Atom 的头部信息（类型和大小）。</li></ul></li><li><strong><code>readAtomPayload(ExtractorInput input, PositionHolder positionHolder): boolean</code></strong><ul><li><strong>功能：</strong> 读取 Atom 的有效负载部分。</li></ul></li><li><strong><code>processMoovAtom(ContainerAtom moov): void</code></strong><ul><li><strong>功能：</strong> 处理 MP4 文件中的 <code>moov</code> Atom，它包含元数据和轨道信息。</li></ul></li><li><strong><code>processUnparsedAtom(long atomSize): void</code></strong><ul><li><strong>功能：</strong> 跳过未解析的 Atom，通常用于忽略无关数据。</li></ul></li><li><strong><code>brandToFileType(int brand): int</code></strong><ul><li><strong>功能：</strong> 将 <code>ftyp</code> Atom 中的 Major Brand 转换为文件类型标识。</li></ul></li><li><strong><code>processAtomEnded(long atomSize): void</code></strong><ul><li><strong>功能：</strong> 在解析完整个 Atom 后执行收尾处理。</li></ul></li></ol><hr><h3 id="音视频样本处理"><a href="#音视频样本处理" class="headerlink" title="音视频样本处理"></a><strong>音视频样本处理</strong></h3><ol><li><strong><code>readSample(ExtractorInput input, PositionHolder positionHolder): int</code></strong><ul><li><strong>功能：</strong> 读取音视频样本数据（如一帧音频或视频）。</li></ul></li><li><strong><code>getTrackIndexOfNextReadSample(long timeUs): int</code></strong><ul><li><strong>功能：</strong> 获取下一帧需要读取的轨道索引。</li></ul></li><li><strong><code>updateSampleIndex(Mp4Track track, long timeUs): void</code></strong><ul><li><strong>功能：</strong> 更新轨道的样本索引，用于定位到特定的时间点。</li></ul></li><li><strong><code>calculateAccumulatedSampleSizes(Mp4Track[] tracks): long[][]</code></strong><ul><li><strong>功能：</strong> 计算所有轨道中样本的累积大小，用于样本偏移计算。</li></ul></li><li><strong><code>getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs): long</code></strong><ul><li><strong>功能：</strong> 获取同步样本索引（关键帧），用于跳转或快速预览。</li></ul></li><li><strong><code>maybeAdjustSeekOffset(TrackSampleTable sampleTable, long timeUs, long seekPosition): long</code></strong><ul><li><strong>功能：</strong> 根据当前轨道信息调整跳转偏移。</li></ul></li><li><strong><code>processEndOfStreamReadingAtomHeader(): void</code></strong><ul><li><strong>功能：</strong> 在文件流结束时，处理 Atom 头部的读取操作。</li></ul></li></ol><hr><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a><strong>辅助方法</strong></h3><ol><li><code>maybeSkipRemainingMetaAtomHeaderBytes(ExtractorInput input): void</code><ul><li><strong>功能：</strong> 跳过当前 Atom 的剩余头部字节，通常用于优化解析流程。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 9 - 音视频 </category>
          
          <category> 9.1 - 播放器实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake 中的静态连接和动态链接</title>
      <link href="/2024/11/02/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/CMake-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/11/02/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/CMake-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>作者: 朕小猫与GPT4</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span>(DualVectorFoil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先设置 Assimp 配置项，禁用测试、样例和文档生成</span></span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_TESTS <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_SAMPLES <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_DOCS <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Assimp 目录和包含目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Assimp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Assimp/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义库文件 DualVectorFoilLib</span></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        DualVectorFoilLib      <span class="comment"># 库名称</span></span><br><span class="line">        SHARED                 <span class="comment"># 库类型</span></span><br><span class="line">        <span class="comment"># 你的源文件列表，示例：src/main/cpp/你的文件.cpp</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接必要的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        DualVectorFoilLib</span><br><span class="line">        assimp                 <span class="comment"># Assimp 库</span></span><br><span class="line">        android                <span class="comment"># Android 系统库</span></span><br><span class="line">        EGL                    <span class="comment"># OpenGL 库</span></span><br><span class="line">        GLESv2                 <span class="comment"># OpenGL ES 2.0</span></span><br><span class="line">        m                      <span class="comment"># 数学库</span></span><br><span class="line">        z                      <span class="comment"># 压缩库</span></span><br><span class="line">        atomic                 <span class="comment"># 原子操作库</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Q: 这样写完之后，apk 安装包中有两个so文件 libDualVectorFoilLib 和 libassimp，都占用 14m，但其实，libDualVectorFoilLib 中包含的就是libassimp，不应该再占用这么大体积</p><p>A: 为了减少 APK 中的体积，你可以将 <code>libassimp</code> 静态链接到 <code>DualVectorFoilLib</code> 中，这样只会生成一个包含 <code>assimp</code> 的 <code>libDualVectorFoilLib.so</code> 文件，而不会包含独立的 <code>libassimp.so</code> 文件。这种方式可以避免重复打包和减小 APK 的体积。具体修改如下：</p><h3 id="修改-CMakeLists-txt-配置，将-assimp-静态链接"><a href="#修改-CMakeLists-txt-配置，将-assimp-静态链接" class="headerlink" title="修改 CMakeLists.txt 配置，将 assimp 静态链接"></a>修改 CMakeLists.txt 配置，将 <code>assimp</code> 静态链接</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span>(DualVectorFoil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先设置 Assimp 配置项，禁用测试、样例和文档生成</span></span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_TESTS <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_SAMPLES <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_DOCS <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">OFF</span>)  <span class="comment"># 禁用 Assimp 的动态库生成，改为静态库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Assimp 目录和包含目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Assimp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Assimp/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义库文件 DualVectorFoilLib</span></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        DualVectorFoilLib      <span class="comment"># 库名称</span></span><br><span class="line">        SHARED                 <span class="comment"># 库类型</span></span><br><span class="line">        <span class="comment"># 你的源文件列表，示例：src/main/cpp/你的文件.cpp</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接必要的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        DualVectorFoilLib</span><br><span class="line">        assimp                 <span class="comment"># 静态链接 Assimp 库</span></span><br><span class="line">        android                <span class="comment"># Android 系统库</span></span><br><span class="line">        EGL                    <span class="comment"># OpenGL 库</span></span><br><span class="line">        GLESv2                 <span class="comment"># OpenGL ES 2.0</span></span><br><span class="line">        m                      <span class="comment"># 数学库</span></span><br><span class="line">        z                      <span class="comment"># 压缩库</span></span><br><span class="line">        atomic                 <span class="comment"># 原子操作库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><p>**禁用 <code>BUILD_SHARED_LIBS</code>**：将 <code>BUILD_SHARED_LIBS</code> 设置为 <code>OFF</code>，使 Assimp 以静态库（<code>.a</code> 文件）形式生成，这样 Assimp 将不会生成独立的 <code>.so</code> 文件，而是将代码直接打包到 <code>libDualVectorFoilLib.so</code> 中。</p></li><li><p>**静态链接 <code>assimp</code>**：在 <code>target_link_libraries</code> 中链接 <code>assimp</code>，这会将 Assimp 的代码直接合并进 <code>libDualVectorFoilLib.so</code>，避免生成和打包独立的 <code>libassimp.so</code>。</p></li><li><p><strong>结果</strong>：这样可以减小 APK 体积，因为不再包含重复的库文件。</p></li></ol><p>之后重新构建项目，确保 APK 中只包含 <code>libDualVectorFoilLib.so</code> 文件，不再包含 <code>libassimp.so</code> 文件。</p><p>Q: 为什么改成静态连接之后小了好多</p><p>A: 改成静态链接之后 APK 大小减少，主要原因在于静态链接和动态链接的工作原理不同，以及 Android 应用打包时如何处理库文件：</p><ol><li><p><strong>避免重复加载的冗余文件</strong>：动态链接时，<code>libassimp.so</code> 作为独立的动态库被单独打包，并在运行时加载。而静态链接则将 <code>libassimp</code> 的代码直接整合到 <code>libDualVectorFoilLib.so</code> 中，避免了多余的 <code>.so</code> 文件。因此，只生成一个完整的 <code>.so</code> 文件，而不是两个重复的文件，节省了空间。</p></li><li><p><strong>优化与裁剪</strong>：静态链接时，链接器会自动去除 Assimp 库中未使用的代码，只保留 <code>DualVectorFoilLib</code> 需要的部分。这意味着生成的 <code>libDualVectorFoilLib.so</code> 体积更小，因为一些多余的功能不会被包含进去。而动态链接时，通常整个库都被打包，即使项目不使用 Assimp 的所有功能，APK 也会包含整个库的内容。</p></li><li><p><strong>减少符号表与动态加载信息</strong>：动态库需要额外的符号表和动态加载信息，以便在运行时进行地址解析和符号加载。静态链接的 <code>.so</code> 文件则不需要这些额外的信息，因此最终生成的文件会更小。</p></li><li><p><strong>加载性能提升</strong>：除了体积减小，静态链接也会带来性能上的提升，因为它省去了动态加载库时的解析步骤，在某些场景下可以略微缩短应用启动时间。</p></li></ol><p>通过静态链接，代码体积优化和去重工作会更加有效，因此可以显著减小 APK 大小。</p><p>Q: 如果我只想引入 assimp 不想引入 libDualVectorFoilLib.so 怎么处理</p><p>A: 如果只想引入 <code>assimp</code> 库，不需要 <code>libDualVectorFoilLib.so</code>，可以直接在 CMake 中只构建 <code>assimp</code>，而不创建其他自定义的 <code>.so</code> 库文件。这样可以实现只生成 <code>libassimp.so</code>，并确保它在你的 APK 中被正确引用。以下是可以实现的步骤：</p><ol><li><p><strong>直接构建 Assimp 并禁用其他库的生成</strong>：<br>只需要 <code>assimp</code>，无需自定义的库文件，可以移除自定义库的定义，只保留对 <code>assimp</code> 的配置与编译。</p></li><li><p><strong>修改 CMakeLists.txt</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span>(DualVectorFoil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Assimp：禁用测试、样例和文档生成</span></span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_TESTS <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_SAMPLES <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(ASSIMP_BUILD_DOCS <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Assimp 目录并包含头文件</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Assimp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Assimp/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assimp 将自动生成 libassimp.so，无需自定义其他库</span></span><br></pre></td></tr></table></figure></li><li><p>**在 <code>build.gradle</code> 中指定加载 <code>libassimp.so</code>**：<br>在你的 Android 项目中确保在 Java 或 Kotlin 代码中正确加载 <code>libassimp.so</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.loadLibrary(<span class="string">&quot;assimp&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>**检查并确保只有 <code>libassimp.so</code>**：<br>构建 APK 后，检查生成的 APK 文件，确认只有 <code>libassimp.so</code> 被打包，而没有 <code>libDualVectorFoilLib.so</code>。</p></li></ol><p>这样配置后，APK 中只会包含 <code>libassimp.so</code>，并且该库可以直接使用，不再生成不必要的库文件。</p><p>Q: So 文件的 Raw File Size 和 Download Size 分别是什么?</p><p>A: 在 APK 文件的打包和发布过程中，文件会经历压缩处理，这使得 APK 下载包的体积通常小于安装后在设备上实际占用的空间。在 Android Studio 中，APK Analyzer 工具展示了两个关键指标来帮助我们理解这些差异：</p><ol><li><p><strong>Raw File Size</strong>（原始文件大小）：这是文件在 APK 解压后，在设备上占用的实际存储空间大小。在您提供的截图中，<code>libassimpd.so</code> 的原始文件大小为 <strong>14.4 MB</strong>，表示安装到设备后它会占用 14.4 MB 的空间。</p></li><li><p><strong>Download Size</strong>（下载大小）：这是 APK 包含的文件在压缩后的大小。由于 APK 打包时会对文件进行压缩，<code>libassimpd.so</code> 的压缩后下载大小仅为 <strong>3.4 MB</strong>。这个值表示用户在下载 APK 包时实际需要传输的数据量。</p></li></ol><p>总结来说：</p><ul><li><strong>Raw File Size</strong> 是文件在设备上解压后的实际存储空间需求。</li><li><strong>Download Size</strong> 是文件在 APK 压缩包中的大小，直接影响 APK 的下载体积。</li></ul><p>因此，虽然下载 APK 时 <code>libassimpd.so</code> 只占 <strong>3.4 MB</strong>，但安装后在设备上会占用 <strong>14.4 MB</strong> 的存储空间。</p><p>Q: So 文件是怎么实现从14M压缩到3.4M的</p><p>A: <code>so</code> 文件（共享库文件）的大小可以大幅度缩小，主要是因为 Android APK 打包过程中应用了<strong>压缩算法</strong>。以下是一些关键原因和过程：</p><h3 id="1-ZIP-压缩"><a href="#1-ZIP-压缩" class="headerlink" title="1. ZIP 压缩"></a>1. ZIP 压缩</h3><p>APK 文件本质上是一个 ZIP 文件，打包时会对资源文件和库文件应用 ZIP 压缩。共享库文件（<code>so</code> 文件）通常包含大量<strong>重复数据</strong>和<strong>空白区域</strong>，这些内容在 ZIP 压缩时能够被有效地缩减。因此，像 <code>libassimpd.so</code> 这种大型的二进制文件，通过 ZIP 压缩可以大幅度减小体积。</p><h3 id="2-二进制格式的高压缩率"><a href="#2-二进制格式的高压缩率" class="headerlink" title="2. 二进制格式的高压缩率"></a>2. 二进制格式的高压缩率</h3><p><code>so</code> 文件是二进制格式，包含大量的<strong>结构化数据</strong>和<strong>代码段</strong>。这些二进制数据在结构上非常紧密，包含许多重复的模式和数据块，非常适合被压缩算法处理。常用的压缩算法（例如 DEFLATE）能够识别这些模式，减少冗余，从而将文件压缩到较小的尺寸。</p><h3 id="3-去除无用数据"><a href="#3-去除无用数据" class="headerlink" title="3. 去除无用数据"></a>3. 去除无用数据</h3><p>一些调试信息和符号信息在生成 <code>so</code> 文件时可能会被包含在内，但是在发布 APK 时通常会将这些<strong>调试符号信息</strong>剥离。这会进一步减少 <code>so</code> 文件的体积，尤其在压缩之后，对这些无用数据的移除效果显著。</p><h3 id="4-压缩前未使用的代码和数据区域"><a href="#4-压缩前未使用的代码和数据区域" class="headerlink" title="4. 压缩前未使用的代码和数据区域"></a>4. 压缩前未使用的代码和数据区域</h3><p><code>so</code> 文件可能包含一些预留的<strong>数据段</strong>或<strong>对齐填充</strong>，这些部分在压缩后也会被进一步缩小。比如对齐填充区域在压缩时几乎不会占用空间，从而进一步减小了整体体积。</p><h3 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h3><p>在您的示例中，<code>libassimpd.so</code> 原始文件大小为 <strong>14.4 MB</strong>，而在 APK 中压缩后的下载大小是 <strong>3.4 MB</strong>。这种大幅缩小主要得益于 ZIP 压缩的高效性，以及 <code>so</code> 文件的二进制结构带来的高压缩比。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>APK 中的 <code>so</code> 文件能够实现从 14 MB 压缩到 3.4 MB，主要是由于以下原因：</p><ul><li>ZIP 压缩算法的高效性</li><li>二进制文件的结构适合压缩</li><li>发布时剥离调试符号信息</li><li>未使用的数据和对齐填充在压缩后基本不占空间</li></ul><p>这些因素共同作用，使得 <code>so</code> 文件在安装包中的大小远小于其解压后的原始大小。</p>]]></content>
      
      
      <categories>
          
          <category> 6 - Android 打包编译 </category>
          
          <category> 6.1 - 文件分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的自动拆装箱</title>
      <link href="/2024/04/14/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
      <url>/2024/04/14/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<p>在 Kotlin 中，对于基本数据类型的包装类，比如 <code>Integer</code>、<code>Boolean</code> 等，Kotlin 设计了一套特殊的类，被称为原生类型的包装类或者叫做原生类型的对象，例如 <code>Int</code>、<code>Boolean</code> 等。这些类的行为表现得如同 Java 的基本类型，同时它们具备了对象的一些特性。在编译阶段，Kotlin 会尽量使用 JVM 的原生类型来提高性能，但在需要时（例如作为泛型参数时），这些原生类型会自动装箱。</p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>Kotlin 处理原生类型和装箱类型的自动转换，以保证性能同时提供丰富的类库支持。这个过程包括两个部分：自动装箱（boxing）和自动拆箱（unboxing）。</p><ul><li><strong>装箱（Boxing）</strong>：当一个原生类型的值需要作为对象处理时，它会自动被装入对应的包装类。例如，当你将一个 <code>int</code> 值放入一个泛型集合如 <code>List&lt;Int&gt;</code> 时，这个值会自动被装箱成 <code>Integer</code>。</li><li><strong>拆箱（Unboxing）</strong>：当从对象中需要一个原生类型的值时，这个包装对象会自动被拆箱。例如，从 <code>List&lt;Int&gt;</code> 中取出一个元素时，它会自动从 <code>Integer</code> 转换为 <code>int</code>。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">val</span> x: <span class="built_in">Int</span> = list[<span class="number">0</span>]                   <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，整数列表中的数字自动被装箱成 <code>Integer</code> 类型的对象以存入 <code>List&lt;Int&gt;</code>。当从列表中检索一个整数时，它自动拆箱回 <code>Int</code> 类型。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>虽然 Kotlin 试图隐藏装箱和拆箱的复杂性，但在某些情况下，装箱对象的身份不会保留。例如，两个独立装箱的整数可能不会在内存中具有相同的引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">println(boxedA === anotherBoxedA)  <span class="comment">// 可能输出 false</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>boxedA</code> 和 <code>anotherBoxedA</code> 是相同原始值的两个独立的装箱实例。使用 <code>===</code> 比较它们的引用时可能得到 <code>false</code>，因为它们可能指向不同的对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 在编写代码时提供了类似于基本数据类型的简洁性和效率，同时也保留了对象的灵活性。通过自动装箱和拆箱，Kotlin 旨在提供无缝的集合操作和泛型支持，同时减少需要程序员关注的底层细节。</p>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.0 - Kotlin 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel 源代码分析 (一)</title>
      <link href="/2024/04/01/3%20Android/Jetpacket/VideoModel/0%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%80)/"/>
      <url>/2024/04/01/3%20Android/Jetpacket/VideoModel/0%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<ul><li><p>viewmodel</p><ul><li><p>CreationExtras<br>ViewModel创建过程中传递额外参数的容器。</p></li><li><p>InitializerViewModelFactory              </p><p> ViewModelProvider.Factory接口实现类，使用ViewModelInitializer来创建ViewModel实例。</p></li><li><p>InitializerViewModelFactoryBuilder   </p><p>用于构建InitializerViewModelFactory的工具，通常以DSL形式提供。</p></li><li><p>MutableCreationExtras                     </p><p>可变版本的CreationExtras，允许添加或修改额外参数。</p></li><li><p>ViewModelFactoryDsl                       </p><p>一个DSL（领域特定语言），用于更声明式地定义如何创建ViewModel。</p></li><li><p>ViewModelInitializer                         </p><p>用于初始化ViewModel的类，通常与ViewModelFactoryDsl一起使用。</p></li><li><p>InitializerViewModelFactory            </p><p>提供了使用InitializerViewModelFactory的Kotlin扩展。</p></li></ul></li><li><p>AndroidViewModel                                  </p><p>AndroidViewModel是ViewModel的一个子类，它接受应用程序的Application作为上下文，这对于需要访问Application资源的ViewModel特别有用。</p></li><li><p>HasDefaultViewModelProviderFactory</p><p>一个接口，标识一个类拥有默认的ViewModelProvider.Factory，用于创建ViewModel。</p></li><li><p>ViewModel</p></li><li><p>ViewModelLazy                                       </p><p>一个提供懒加载ViewModel实例的工具类。</p></li><li><p>ViewModelProvider                                 </p><p>用于获取ViewModel实例，确保配置更改时ViewModel可以持续使用。</p></li><li><p>ViewModelStore                                      </p><p>用于保存ViewModel实例的类，以便它们可以跨配置更改持续存在。</p></li><li><p>ViewModelStoreOwner                          </p><p>一个接口，标识一个类可以拥有ViewModelStore。</p></li><li><p>ViewTreeViewModelStoreOwner            </p><p>用于从视图树中查找ViewModelStoreOwner的工具类。</p></li><li><p>ViewTreeViewModelKt                           </p><p>提供了操作和查询视图树中ViewModel的Kotlin扩展</p></li></ul><h1 id="CreationExtras-与-MutableCreationExtra"><a href="#CreationExtras-与-MutableCreationExtra" class="headerlink" title="CreationExtras 与 MutableCreationExtra"></a>CreationExtras 与 MutableCreationExtra</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle.viewmodel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CreationExtras</span> internal <span class="title function_">constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    internal val map: MutableMap&lt;Key&lt;*&gt;, Any?&gt; = mutableMapOf()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> operator fun &lt;T&gt; get(key: Key&lt;T&gt;): T?</span><br><span class="line">  </span><br><span class="line">    object Empty : CreationExtras() &#123;</span><br><span class="line">        override fun &lt;T&gt; get(key: Key&lt;T&gt;): T? = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [CreationExtras]的可变实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialExtras 将被填充到结果MutableCreationExtras中的额外信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutableCreationExtras</span>(initialExtras: CreationExtras = Empty) : CreationExtras() &#123;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        map.putAll(initialExtras.map)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的[key]与[t]关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> operator fun &lt;T&gt; set(key: Key&lt;T&gt;, t: T) &#123;</span><br><span class="line">        map[key] = t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> override fun &lt;T&gt; get(key: Key&lt;T&gt;): T? &#123;</span><br><span class="line">        <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> map[key] as T?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="fun-viewModelFactory-和-InitializerViewModelFactoryBuilder"><a href="#fun-viewModelFactory-和-InitializerViewModelFactoryBuilder" class="headerlink" title="fun viewModelFactory 和 InitializerViewModelFactoryBuilder"></a>fun viewModelFactory 和 InitializerViewModelFactoryBuilder</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle.viewmodel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KClass</span><br><span class="line"></span><br><span class="line"><span class="meta">@DslMarker</span></span><br><span class="line"><span class="keyword">public</span> annotation <span class="keyword">class</span> <span class="title class_">ViewModelFactoryDsl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> inline fun <span class="title function_">viewModelFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    builder: InitializerViewModelFactoryBuilder.()</span> -&gt; Unit</span><br><span class="line">): ViewModelProvider.Factory = InitializerViewModelFactoryBuilder().apply(builder).build()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于构建新的[ViewModelProvider.Factory]的DSL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ViewModelFactoryDsl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializerViewModelFactoryBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">initializers</span> <span class="operator">=</span> mutableListOf&lt;ViewModelInitializer&lt;*&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为给定的ViewModel类添加初始化器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 与初始化器关联的类。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initializer 用于创建ViewModel类实例的lambda表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fun &lt;T : ViewModel&gt; addInitializer(clazz: KClass&lt;T&gt;, initializer: CreationExtras.() -&gt; T) &#123;</span><br><span class="line">        initializers.add(ViewModelInitializer(clazz.java, initializer))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">build</span><span class="params">()</span>: ViewModelProvider.Factory =</span><br><span class="line">        InitializerViewModelFactory(*initializers.toTypedArray())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fun &lt;reified VM : ViewModel&gt; InitializerViewModelFactoryBuilder.initializer(</span><br><span class="line">    noinline initializer: CreationExtras.() -&gt; VM</span><br><span class="line">) &#123;</span><br><span class="line">    addInitializer(VM::class, initializer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewModelInitializer</span>&lt;T : ViewModel&gt;(</span><br><span class="line">    internal val clazz: Class&lt;T&gt;,</span><br><span class="line">    internal val initializer: CreationExtras.() -&gt; T,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">internal <span class="keyword">class</span> <span class="title class_">InitializerViewModelFactory</span>(</span><br><span class="line">    <span class="keyword">private</span> vararg val initializers: ViewModelInitializer&lt;*&gt;</span><br><span class="line">) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T &#123;</span><br><span class="line">        <span class="keyword">var</span> viewModel: T? = <span class="literal">null</span></span><br><span class="line">        <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">        initializers.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.clazz == modelClass) &#123;</span><br><span class="line">                viewModel = it.initializer.invoke(extras) as? T</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> viewModel ?: <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">&quot;No initializer set for given class $&#123;modelClass.name&#125;&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AndroidViewModel"><a href="#AndroidViewModel" class="headerlink" title="AndroidViewModel"></a>AndroidViewModel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressLint(&quot;StaticFieldLeak&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AndroidViewModel</span><span class="params">(<span class="meta">@NonNull</span> Application application)</span> &#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Application</span>&gt; T <span class="title function_">getApplication</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AndroidViewModel</code> 是一个扩展了标准 ViewModel 功能的类，通过提供对 <code>Application</code> 上下文的访问，它允许 ViewModel 执行需要这种上下文的操作。使用 <code>AndroidViewModel</code> 可以帮助你编写更清晰、更健壮的应用程序代码，尤其是在处理配置更改和应用程序范围的资源访问时</p><h1 id="HasDefaultViewModelProviderFactory"><a href="#HasDefaultViewModelProviderFactory" class="headerlink" title="HasDefaultViewModelProviderFactory"></a>HasDefaultViewModelProviderFactory</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.CreationExtras;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HasDefaultViewModelProviderFactory</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">default</span> CreationExtras <span class="title function_">getDefaultViewModelCreationExtras</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CreationExtras.Empty.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.MainThread;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="comment">// Can&#x27;t use ConcurrentHashMap, because it can lose values on old apis (see b/37042460)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Closeable&gt; mCloseables = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">mCleared</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewModel</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewModel</span><span class="params">(<span class="meta">@NonNull</span> Closeable... closeables)</span> &#123;</span><br><span class="line">        mCloseables.addAll(Arrays.asList(closeables));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCloseable</span><span class="params">(<span class="meta">@NonNull</span> Closeable closeable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCloseables != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mCloseables) &#123;</span><br><span class="line">                mCloseables.add(closeable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        mCleared = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mCloseables != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mCloseables) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Closeable closeable : mCloseables) &#123;</span><br><span class="line">                    closeWithRuntimeException(closeable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">setTagIfAbsent</span><span class="params">(String key, T newValue)</span> &#123;</span><br><span class="line">        T previous;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            previous = (T) mBagOfTags.get(key);</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">null</span>) &#123;</span><br><span class="line">                mBagOfTags.put(key, newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> previous == <span class="literal">null</span> ? newValue : previous;</span><br><span class="line">        <span class="keyword">if</span> (mCleared) &#123;</span><br><span class="line">            closeWithRuntimeException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getTag</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) mBagOfTags.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeWithRuntimeException</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Closeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Closeable) obj).close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例子说明哪些特殊数据是需要-ViewModel-特别管理的"><a href="#举例子说明哪些特殊数据是需要-ViewModel-特别管理的" class="headerlink" title="举例子说明哪些特殊数据是需要 ViewModel 特别管理的"></a>举例子说明哪些特殊数据是需要 ViewModel 特别管理的</h2><p>在 <code>ViewModel</code> 的使用场景中，有几种特殊数据需要通过 <code>ViewModel</code> 来特别管理，主要是因为这些数据的生命周期需要与 <code>ViewModel</code> 保持一致，或者这些数据在 <code>ViewModel</code> 被销毁时需要进行特殊处理。以下是一些示例：</p><ol><li><p><strong>网络请求的取消标识（Cancellation Tokens）</strong>：当使用 <code>ViewModel</code> 进行网络请求时，可以在 <code>mBagOfTags</code> 中保存请求的取消标识（如 <code>Call</code> 对象或其他取消机制）。如果用户离开了关联的界面（例如，Activity 或 Fragment 被销毁），则可以在 <code>ViewModel</code> 的 <code>onCleared()</code> 方法中取消所有挂起的网络请求，以避免不必要的网络流量消耗或潜在的内存泄漏。</p></li><li><p><strong>数据库监听器（Database Listeners）</strong>：如果 <code>ViewModel</code> 监听数据库变化（例如，使用 SQLite 数据库或 Room 持久库），可以将监听器对象存储在 <code>mBagOfTags</code> 中。当 <code>ViewModel</code> 被清理时，这些监听器可以被适当地移除，防止因为监听器持续激活而导致的内存泄漏。</p></li><li><p><strong>文件资源（File Resources）</strong>：应用可能会打开文件进行读写操作，这些文件的句柄或相关的流对象（如 <code>FileInputStream</code>、<code>FileOutputStream</code>）可以放在 <code>mBagOfTags</code> 中。在 <code>ViewModel</code> 生命周期结束时，确保这些资源被正确关闭，避免文件资源泄漏。</p></li><li><p><strong>自定义资源的清理（Custom Resource Cleanup）</strong>：如果有一些自定义的资源或对象需要在 <code>ViewModel</code> 生命周期结束时进行清理（比如自定义的缓存机制、临时文件的删除等），也可以利用 <code>mBagOfTags</code> 来管理这些资源。通过实现 <code>Closeable</code> 接口，可以确保这些资源在 <code>ViewModel</code> 的 <code>clear()</code> 方法被调用时得到正确的处理。</p></li><li><p><strong>订阅服务（Subscriptions）</strong>：当 <code>ViewModel</code> 订阅了某些事件通知或数据流（例如，使用 RxJava 的 <code>Observable</code> 或 LiveData 订阅），可以将这些订阅的取消引用（比如 <code>Disposable</code>）存储在 <code>mBagOfTags</code> 中。这样，可以在不需要这些订阅时或 <code>ViewModel</code> 销毁时，统一取消订阅，防止内存泄漏。</p></li></ol><p>通过以上示例，可以看出 <code>ViewModel</code> 中的 <code>mBagOfTags</code> 提供了一种便捷的方式来管理与 <code>ViewModel</code> 生命周期紧密相关的特殊数据和资源，帮助开发者维护应用的健壮性和性能。</p><h1 id="ViewModelLazy"><a href="#ViewModelLazy" class="headerlink" title="ViewModelLazy"></a>ViewModelLazy</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.CreationExtras</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelLazy</span>&lt;VM : ViewModel&gt; <span class="meta">@JvmOverloads</span> constructor(</span><br><span class="line">    <span class="keyword">private</span> val viewModelClass: KClass&lt;VM&gt;,</span><br><span class="line">    <span class="keyword">private</span> val storeProducer: () -&gt; ViewModelStore,</span><br><span class="line">    <span class="keyword">private</span> val factoryProducer: () -&gt; ViewModelProvider.Factory,</span><br><span class="line">    <span class="keyword">private</span> val extrasProducer: () -&gt; CreationExtras = &#123; CreationExtras.Empty &#125;</span><br><span class="line">) : Lazy&lt;VM&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cached: VM? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    override val value: VM</span><br><span class="line">        <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">viewModel</span> <span class="operator">=</span> cached</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (viewModel == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">factory</span> <span class="operator">=</span> factoryProducer()</span><br><span class="line">                <span class="type">val</span> <span class="variable">store</span> <span class="operator">=</span> storeProducer()</span><br><span class="line">                ViewModelProvider(</span><br><span class="line">                    store,</span><br><span class="line">                    factory,</span><br><span class="line">                    extrasProducer()</span><br><span class="line">                ).get(viewModelClass.java).also &#123;</span><br><span class="line">                    cached = it</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                viewModel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">isInitialized</span><span class="params">()</span>: Boolean = cached != <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a>ViewModelProvider</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file</span>:JvmName(<span class="string">&quot;ViewModelProviderGetKt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> androidx.lifecycle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.MainThread</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.RestrictTo</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.DEFAULT_KEY</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.defaultFactory</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.CreationExtras.Key</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider.NewInstanceFactory.Companion.VIEW_MODEL_KEY</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.CreationExtras</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.InitializerViewModelFactory</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.MutableCreationExtras</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.ViewModelInitializer</span><br><span class="line"><span class="keyword">import</span> java.lang.IllegalArgumentException</span><br><span class="line"><span class="keyword">import</span> java.lang.RuntimeException</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException</span><br><span class="line"><span class="keyword">import</span> kotlin.UnsupportedOperationException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> open <span class="keyword">class</span> <span class="title class_">ViewModelProvider</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line">constructor(</span><br><span class="line">    <span class="keyword">private</span> val store: ViewModelStore,</span><br><span class="line">    <span class="keyword">private</span> val factory: Factory,</span><br><span class="line">    <span class="keyword">private</span> val defaultCreationExtras: CreationExtras = CreationExtras.Empty,</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">            <span class="keyword">throw</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">&quot;Factory.create(String) is unsupported.  This Factory requires &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;`CreationExtras` to be passed into `create` method.&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T =</span><br><span class="line">            create(modelClass)</span><br><span class="line"></span><br><span class="line">        companion object &#123;</span><br><span class="line">            <span class="meta">@JvmStatic</span></span><br><span class="line">            fun <span class="title function_">from</span><span class="params">(vararg initializers: ViewModelInitializer&lt;*&gt;)</span>: Factory =</span><br><span class="line">                InitializerViewModelFactory(*initializers)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="keyword">public</span> open <span class="keyword">class</span> <span class="title class_">OnRequeryFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> open fun <span class="title function_">onRequery</span><span class="params">(viewModel: ViewModel)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">constructor</span><span class="params">(</span></span><br><span class="line"><span class="params">        owner: ViewModelStoreOwner</span></span><br><span class="line"><span class="params">    )</span> : <span class="built_in">this</span>(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">constructor</span><span class="params">(owner: ViewModelStoreOwner, factory: Factory)</span> : <span class="built_in">this</span>(</span><br><span class="line">        owner.viewModelStore,</span><br><span class="line">        factory,</span><br><span class="line">        defaultCreationExtras(owner)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> open operator fun &lt;T : ViewModel&gt; get(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.canonicalName</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> get(<span class="string">&quot;$DEFAULT_KEY:$canonicalName&quot;</span>, modelClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> open operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">viewModel</span> <span class="operator">=</span> store[key]</span><br><span class="line">        <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">            (factory as? OnRequeryFactory)?.onRequery(viewModel)</span><br><span class="line">            <span class="keyword">return</span> viewModel as T</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@Suppress(&quot;ControlFlowWithEmptyBody&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">val</span> <span class="variable">extras</span> <span class="operator">=</span> MutableCreationExtras(defaultCreationExtras)</span><br><span class="line">        extras[VIEW_MODEL_KEY] = key</span><br><span class="line">        <span class="comment">// AGP has some desugaring issues associated with compileOnly dependencies so we need to</span></span><br><span class="line">        <span class="comment">// fall back to the other create method to keep from crashing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            factory.create(modelClass, extras)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: AbstractMethodError) &#123;</span><br><span class="line">            factory.create(modelClass)</span><br><span class="line">        &#125;.also &#123; store.put(key, it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actually there is getInstance()</span></span><br><span class="line">    <span class="meta">@Suppress(&quot;SingletonConstructor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> open <span class="keyword">class</span> <span class="title class_">NewInstanceFactory</span> : Factory &#123;</span><br><span class="line">        <span class="meta">@Suppress(&quot;DocumentExceptions&quot;)</span></span><br><span class="line">        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">                modelClass.newInstance()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InstantiationException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> companion object &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">var</span> sInstance: NewInstanceFactory? = <span class="literal">null</span></span><br><span class="line">          </span><br><span class="line">            <span class="meta">@JvmStatic</span></span><br><span class="line">            <span class="keyword">public</span> val instance: NewInstanceFactory</span><br><span class="line">                <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">                get() &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        sInstance = NewInstanceFactory()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> sInstance!!</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> object ViewModelKeyImpl : Key&lt;String&gt;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@JvmField</span></span><br><span class="line">            val VIEW_MODEL_KEY: Key&lt;String&gt; = ViewModelKeyImpl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> open <span class="keyword">class</span> <span class="title class_">AndroidViewModelFactory</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">constructor</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">private</span> val application: Application?,</span></span><br><span class="line"><span class="params">        <span class="meta">@Suppress(&quot;UNUSED_PARAMETER&quot;)</span> unused: Int,</span></span><br><span class="line"><span class="params">    )</span> : NewInstanceFactory() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(&quot;SingletonConstructor&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">constructor</span><span class="params">()</span> : <span class="built_in">this</span>(<span class="literal">null</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(&quot;SingletonConstructor&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">constructor</span><span class="params">(application: Application)</span> : <span class="built_in">this</span>(application, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(&quot;DocumentExceptions&quot;)</span></span><br><span class="line">        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (application != <span class="literal">null</span>) &#123;</span><br><span class="line">                create(modelClass)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">application</span> <span class="operator">=</span> extras[APPLICATION_KEY]</span><br><span class="line">                <span class="keyword">if</span> (application != <span class="literal">null</span>) &#123;</span><br><span class="line">                    create(modelClass, application)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// For AndroidViewModels, CreationExtras must have an application set</span></span><br><span class="line">                    <span class="keyword">if</span> (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;CreationExtras must have an application by `APPLICATION_KEY`&quot;</span></span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">super</span>.create(modelClass)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(&quot;DocumentExceptions&quot;)</span></span><br><span class="line">        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (application == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> UnsupportedOperationException(</span><br><span class="line">                    <span class="string">&quot;AndroidViewModelFactory constructed &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;with empty constructor works only with &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;create(modelClass: Class&lt;T&gt;, extras: CreationExtras).&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                create(modelClass, application)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(&quot;DocumentExceptions&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, app: Application): T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    modelClass.getConstructor(Application::class.java).newInstance(app)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: NoSuchMethodException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: InstantiationException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: InvocationTargetException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">super</span>.create(modelClass)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> companion object &#123;</span><br><span class="line">            internal fun <span class="title function_">defaultFactory</span><span class="params">(owner: ViewModelStoreOwner)</span>: Factory =</span><br><span class="line">                <span class="keyword">if</span> (owner is HasDefaultViewModelProviderFactory)</span><br><span class="line">                    owner.defaultViewModelProviderFactory <span class="keyword">else</span> instance</span><br><span class="line"></span><br><span class="line">            internal const <span class="type">val</span> <span class="variable">DEFAULT_KEY</span> <span class="operator">=</span> <span class="string">&quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">var</span> sInstance: AndroidViewModelFactory? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@JvmStatic</span></span><br><span class="line">            <span class="keyword">public</span> fun <span class="title function_">getInstance</span><span class="params">(application: Application)</span>: AndroidViewModelFactory &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sInstance = AndroidViewModelFactory(application)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sInstance!!</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> object ApplicationKeyImpl : Key&lt;Application&gt;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@JvmField</span></span><br><span class="line">            val APPLICATION_KEY: Key&lt;Application&gt; = ApplicationKeyImpl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal fun <span class="title function_">defaultCreationExtras</span><span class="params">(owner: ViewModelStoreOwner)</span>: CreationExtras &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (owner is HasDefaultViewModelProviderFactory) &#123;</span><br><span class="line">        owner.defaultViewModelCreationExtras</span><br><span class="line">    &#125; <span class="keyword">else</span> CreationExtras.Empty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> inline fun &lt;reified VM : ViewModel&gt; ViewModelProvider.get(): VM = get(VM::class.java)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="简单解析一下-ViewModelProvider"><a href="#简单解析一下-ViewModelProvider" class="headerlink" title="简单解析一下 ViewModelProvider"></a>简单解析一下 ViewModelProvider</h2><p>在这段代码中，定义了一个<code>ViewModelProvider</code>类，其作用是提供<code>ViewModel</code>实例。<br>在MVVM架构中，<code>ViewModel</code>是负责准备和管理UI相关数据的组件，它使数据和命令可以轻松地绑定到UI控件，同时保持UI控件和应用逻辑的分离。<br><code>ViewModelProvider</code>负责创建和管理这些<code>ViewModel</code>对象。<br>以下是该代码段中定义的主要函数及其作用的分析：</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><strong><code>ViewModelProvider</code>构造函数</strong>: 接收一个<code>ViewModelStore</code>和一个<code>Factory</code>作为参数，以及一个可选的<code>CreationExtras</code>。这些构造函数允许你在创建<code>ViewModelProvider</code>实例时指定<code>ViewModel</code>的存储和创建方式。</li></ul><h3 id="内部接口和类"><a href="#内部接口和类" class="headerlink" title="内部接口和类"></a>内部接口和类</h3><ul><li><strong><code>Factory</code>接口</strong>: 定义了创建<code>ViewModel</code>实例的方法。这个接口允许自定义<code>ViewModel</code>的创建过程，包括通过<code>CreationExtras</code>传递额外的创建参数。</li><li><strong><code>OnRequeryFactory</code>类</strong>: 这是一个可选的回调，当<code>ViewModel</code>被重新查询时调用。</li><li><strong><code>NewInstanceFactory</code>类</strong>: 一个默认的<code>Factory</code>实现，它使用反射来创建<code>ViewModel</code>的新实例。</li><li><strong><code>AndroidViewModelFactory</code>类</strong>: 专门为<code>AndroidViewModel</code>定制的<code>Factory</code>实现，它需要<code>Application</code>实例来创建<code>ViewModel</code>。</li></ul><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><strong><code>get</code>方法</strong>: 重载的方法，用于获取指定类的<code>ViewModel</code>实例。如果<code>ViewModel</code>已经存在于<code>ViewModelStore</code>中，则返回这个实例；如果不存在，则通过<code>Factory</code>创建新的实例并存储起来。这些方法确保<code>ViewModel</code>的生命周期被正确管理，即使在配置更改（如屏幕旋转）后也能保持状态。</li><li><strong><code>defaultCreationExtras</code>函数</strong>: 为<code>ViewModel</code>创建提供默认的<code>CreationExtras</code>。这是用于传递额外参数给<code>ViewModel</code>构造函数的一种机制。</li></ul><h3 id="其他重要组件"><a href="#其他重要组件" class="headerlink" title="其他重要组件"></a>其他重要组件</h3><ul><li><strong><code>ViewModelStore</code></strong>: 一个容器，用于存储和管理<code>ViewModel</code>实例。这确保了<code>ViewModel</code>能够跨配置更改存活。</li><li><strong><code>ViewModelStoreOwner</code></strong>: 一个接口，表示拥有<code>ViewModelStore</code>的对象，通常是UI控制器，如Activity或Fragment。</li><li><strong><code>CreationExtras</code></strong>: 一个容器，用于在创建<code>ViewModel</code>时传递额外的参数。它支持通过键值对形式传递任意数据。</li></ul><p>整体而言，这段代码提供了一个灵活的机制来创建和管理<code>ViewModel</code>实例，支持自定义创建过程，并确保<code>ViewModel</code>能够有效地与UI组件的生命周期同步。</p><p>这段代码体现了Android架构组件中<code>ViewModel</code>的灵活创建和管理机制，包括支持自定义工厂、传递额外参数以及通过工厂模式解耦<code>ViewModel</code>的创建过程。这套机制不仅提高了<code>ViewModel</code>使用的灵活性，还增强了组件之间的解耦，使得应用架构更加清晰和易于维护。</p><h1 id="参数-defaultCreationExtras-的作用"><a href="#参数-defaultCreationExtras-的作用" class="headerlink" title="参数 defaultCreationExtras 的作用"></a>参数 defaultCreationExtras 的作用</h1><p><code>defaultCreationExtras</code>函数在<code>ViewModelProvider</code>的上下文中扮演着重要的角色。它提供了一种机制，用于在创建<code>ViewModel</code>实例时传递额外的参数，这些参数被封装在<code>CreationExtras</code>对象中。这允许<code>ViewModel</code>的构造过程中接收来自<code>ViewModelProvider</code>以外的信息，进而使得<code>ViewModel</code>的创建更加灵活和动态。</p><h2 id="CreationExtras的作用"><a href="#CreationExtras的作用" class="headerlink" title="CreationExtras的作用"></a><code>CreationExtras</code>的作用</h2><p><code>CreationExtras</code>是一种键值对集合，它允许开发者在创建<code>ViewModel</code>时传递任意类型的数据。这些数据可以是应用上下文（如<code>Application</code>实例）、配置参数，或者任何对于<code>ViewModel</code>初始化过程中可能需要的信息。</p><h2 id="defaultCreationExtras-使用场景"><a href="#defaultCreationExtras-使用场景" class="headerlink" title="defaultCreationExtras 使用场景"></a>defaultCreationExtras 使用场景</h2><p><code>defaultCreationExtras</code>的使用场景通常涉及到需要向<code>ViewModel</code>传递额外信息的情况。例如，如果某个<code>ViewModel</code>需要访问全局的应用状态，或者依赖于特定的服务实例，这些依赖项可以通过<code>CreationExtras</code>在创建时传递给<code>ViewModel</code>，而<code>defaultCreationExtras</code>函数就是为了方便地提供这类默认参数的。</p><p>总之，<code>defaultCreationExtras</code>函数和<code>CreationExtras</code>机制为<code>ViewModel</code>的创建提供了额外的灵活性和动态配置能力，使得<code>ViewModel</code>能够更好地适应不同的应用场景和需求。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.4 - Jetpacket </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel 源代码分析 (二)</title>
      <link href="/2024/04/01/3%20Android/Jetpacket/VideoModel/1%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%BA%8C)/"/>
      <url>/2024/04/01/3%20Android/Jetpacket/VideoModel/1%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<ul><li><p>viewmodel</p><ul><li><p>CreationExtras<br>ViewModel创建过程中传递额外参数的容器。</p></li><li><p>InitializerViewModelFactory              </p><p> ViewModelProvider.Factory接口实现类，使用ViewModelInitializer来创建ViewModel实例。</p></li><li><p>InitializerViewModelFactoryBuilder   </p><p>用于构建InitializerViewModelFactory的工具，通常以DSL形式提供。</p></li><li><p>MutableCreationExtras                     </p><p>可变版本的CreationExtras，允许添加或修改额外参数。</p></li><li><p>ViewModelFactoryDsl                       </p><p>一个DSL（领域特定语言），用于更声明式地定义如何创建ViewModel。</p></li><li><p>ViewModelInitializer                         </p><p>用于初始化ViewModel的类，通常与ViewModelFactoryDsl一起使用。</p></li><li><p>InitializerViewModelFactory            </p><p>提供了使用InitializerViewModelFactory的Kotlin扩展。</p></li></ul></li><li><p>AndroidViewModel                                  </p><p>AndroidViewModel是ViewModel的一个子类，它接受应用程序的Application作为上下文，这对于需要访问Application资源的ViewModel特别有用。</p></li><li><p>HasDefaultViewModelProviderFactory</p><p>一个接口，标识一个类拥有默认的ViewModelProvider.Factory，用于创建ViewModel。</p></li><li><p>ViewModel</p></li><li><p>ViewModelLazy                                       </p><p>一个提供懒加载ViewModel实例的工具类。</p></li><li><p>ViewModelProvider                                 </p><p>用于获取ViewModel实例，确保配置更改时ViewModel可以持续使用。</p></li><li><p>ViewModelStore                                      </p><p>用于保存ViewModel实例的类，以便它们可以跨配置更改持续存在。</p></li><li><p>ViewModelStoreOwner                          </p><p>一个接口，标识一个类可以拥有ViewModelStore。</p></li><li><p>ViewTreeViewModelStoreOwner            </p><p>用于从视图树中查找ViewModelStoreOwner的工具类。</p></li><li><p>ViewTreeViewModelKt                           </p><p>提供了操作和查询视图树中ViewModel的Kotlin扩展</p></li></ul><h1 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有不想保存的数据可以在存储前调用 ViewModelStore  clear 函数</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="Activity或Fragment销毁时"><a href="#Activity或Fragment销毁时" class="headerlink" title="Activity或Fragment销毁时"></a>Activity或Fragment销毁时</h3><p>在Activity或Fragment的<code>onDestroy</code>方法中调用<code>ViewModelStore</code>的<code>clear</code>方法，可以确保所有关联的<code>ViewModel</code>能够及时清理资源。这是因为，在某些情况下（如用户明确退出Activity或Fragment），保留ViewModel不再有意义，应该清除所有资源以避免内存泄漏。</p><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    <span class="keyword">if</span> (isFinishing()) &#123;</span><br><span class="line">        viewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>isFinishing()</code>用于检查Activity是否正在结束（用户退出或因其他原因被销毁），如果是，则清理ViewModelStore中的所有ViewModel。</p><h3 id="在使用ViewModel时实现资源管理"><a href="#在使用ViewModel时实现资源管理" class="headerlink" title="在使用ViewModel时实现资源管理"></a>在使用ViewModel时实现资源管理</h3><p>如果你的应用程序具有复杂的业务逻辑，可能会创建多个ViewModel用于不同的数据处理和业务逻辑。在这种情况下，当确定某些ViewModel不再需要时，可以通过调用<code>clear</code>方法释放这些ViewModel占用的资源。</p><h3 id="3-单元测试"><a href="#3-单元测试" class="headerlink" title="3. 单元测试"></a>3. 单元测试</h3><p>在进行单元测试时，特别是在测试涉及ViewModel生命周期的逻辑时，<code>clear</code>方法可以在测试完成后被调用来清理测试环境，保证每个测试运行的隔离性。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>虽然<code>clear</code>方法的使用可以帮助管理资源，但需要谨慎使用，以避免在不适当的时机释放资源导致的应用崩溃或不稳定。通常，Android框架会自动处理ViewModel的生命周期，只有在特定情况下，如Activity或Fragment被销毁时，才需要手动调用<code>clear</code>方法。</p><h1 id="ViewModelStoreOwner"><a href="#ViewModelStoreOwner" class="headerlink" title="ViewModelStoreOwner"></a>ViewModelStoreOwner</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看一下到底谁是 ViewModelStoreOwner</p><h2 id="ViewModelStoreOwner-ComponentActivity"><a href="#ViewModelStoreOwner-ComponentActivity" class="headerlink" title="ViewModelStoreOwner - ComponentActivity"></a>ViewModelStoreOwner - ComponentActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">            + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureViewModelStore();</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewModelStoreOwner-Fragment"><a href="#ViewModelStoreOwner-Fragment" class="headerlink" title="ViewModelStoreOwner - Fragment"></a>ViewModelStoreOwner - Fragment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFragmentManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t access ViewModels from detached fragment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getMinimumMaxLifecycleState() == Lifecycle.State.INITIALIZED.ordinal()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Calling getViewModelStore() before a Fragment &quot;</span></span><br><span class="line">            + <span class="string">&quot;reaches onCreate() when using setMaxLifecycle(INITIALIZED) is not &quot;</span></span><br><span class="line">            + <span class="string">&quot;supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mFragmentManager.getViewModelStore(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ViewTreeViewModelStoreOwner"><a href="#ViewTreeViewModelStoreOwner" class="headerlink" title="ViewTreeViewModelStoreOwner"></a>ViewTreeViewModelStoreOwner</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewParent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewTreeViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ViewTreeViewModelStoreOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// No instances</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@Nullable</span> ViewModelStoreOwner viewModelStoreOwner)</span> &#123;</span><br><span class="line">        view.setTag(R.id.view_tree_view_model_store_owner, viewModelStoreOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ViewModelStoreOwner <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> &#123;</span><br><span class="line">        <span class="type">ViewModelStoreOwner</span> <span class="variable">found</span> <span class="operator">=</span> (ViewModelStoreOwner) view.getTag(</span><br><span class="line">                R.id.view_tree_view_model_store_owner);</span><br><span class="line">        <span class="keyword">if</span> (found != <span class="literal">null</span>) <span class="keyword">return</span> found;</span><br><span class="line">        <span class="type">ViewParent</span> <span class="variable">parent</span> <span class="operator">=</span> view.getParent();</span><br><span class="line">        <span class="keyword">while</span> (found == <span class="literal">null</span> &amp;&amp; parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">parentView</span> <span class="operator">=</span> (View) parent;</span><br><span class="line">            found = (ViewModelStoreOwner) parentView.getTag(R.id.view_tree_view_model_store_owner);</span><br><span class="line">            parent = parentView.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ViewTreeViewModelStoreOwner-与-ViewModelStoreOwner-有什么区别"><a href="#ViewTreeViewModelStoreOwner-与-ViewModelStoreOwner-有什么区别" class="headerlink" title="ViewTreeViewModelStoreOwner 与 ViewModelStoreOwner 有什么区别"></a>ViewTreeViewModelStoreOwner 与 ViewModelStoreOwner 有什么区别</h1><h2 id="ViewModelStoreOwner-1"><a href="#ViewModelStoreOwner-1" class="headerlink" title="ViewModelStoreOwner"></a>ViewModelStoreOwner</h2><ul><li><strong>定义</strong>：<code>ViewModelStoreOwner</code>是一个接口，定义了可以拥有并管理<code>ViewModelStore</code>的类。<code>ViewModelStore</code>是一个容器，用于存储和管理<code>ViewModel</code>实例，确保它们能够跨配置更改（如屏幕旋转）生存下来。</li><li><strong>用途</strong>：这个接口通常由Activity和Fragment实现，使它们能够持有<code>ViewModel</code>实例。通过这种方式，Activity或Fragment可以在内部管理其<code>ViewModels</code>的生命周期，确保在发生配置更改时，<code>ViewModels</code>不会被销毁并重新创建。</li><li><strong>实现方式</strong>：在使用<code>ViewModel</code>时，开发者通常不需要直接实现<code>ViewModelStoreOwner</code>接口。例如，<code>AppCompatActivity</code>和<code>Fragment</code>已经实现了这个接口，提供了对<code>ViewModelStore</code>的访问。</li></ul><h2 id="ViewTreeViewModelStoreOwner-1"><a href="#ViewTreeViewModelStoreOwner-1" class="headerlink" title="ViewTreeViewModelStoreOwner"></a>ViewTreeViewModelStoreOwner</h2><ul><li><strong>定义</strong>：<code>ViewTreeViewModelStoreOwner</code>是与Android视图树（View Tree）相关的工具类。它提供了静态方法来从视图树中查找<code>ViewModelStoreOwner</code>。这是通过在视图的<code>Tag</code>中设置和获取<code>ViewModelStoreOwner</code>实现的。</li><li><strong>用途</strong>：<code>ViewTreeViewModelStoreOwner</code>的主要用途是在视图层级中找到最近的<code>ViewModelStoreOwner</code>。这对于自定义视图或视图组件特别有用，这些组件需要访问<code>ViewModel</code>但不直接与Activity或Fragment关联。</li><li><strong>使用场景</strong>：当你有一个嵌套在深层视图层次结构中的自定义视图，并且这个视图需要访问<code>ViewModel</code>时，可以使用<code>ViewTreeViewModelStoreOwner.get(view)</code>来找到最近的<code>ViewModelStoreOwner</code>实例。这使得即使在复杂的视图结构中，自定义视图也能正确地管理和访问<code>ViewModel</code>实例。</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><strong>作用范围</strong>：<code>ViewModelStoreOwner</code>直接关联于可以持有<code>ViewModelStore</code>的实体（如Activity或Fragment），而<code>ViewTreeViewModelStoreOwner</code>是一个工具类，用于在视图树中查找这些实体。</li><li><strong>使用上下文</strong>：<code>ViewModelStoreOwner</code>通常用于直接管理<code>ViewModels</code>的生命周期，特别是在Activity和Fragment中。<code>ViewTreeViewModelStoreOwner</code>则用于在视图层级中寻找<code>ViewModelStoreOwner</code>，便于自定义视图或组件访问<code>ViewModels</code>。</li><li><strong>实现与调用</strong>：Activity和Fragment通常自动实现<code>ViewModelStoreOwner</code>接口。相反，<code>ViewTreeViewModelStoreOwner</code>提供了一种机制，允许在视图树中任意位置将视图与最近的<code>ViewModelStoreOwner</code>关联起来，而无需直接实现或管理<code>ViewModelStoreOwner</code>接口。</li></ul><p>简而言之，<code>ViewModelStoreOwner</code>关注于拥有和管理<code>ViewModelStore</code>的能力，而<code>ViewTreeViewModelStoreOwner</code>提供了一种查找视图树中最近的<code>ViewModelStoreOwner</code>的方法，使得在复杂的视图结构中的组件也能访问和使用<code>ViewModels</code>。</p><h1 id="ViewModelStoreOwner-的-set-方法"><a href="#ViewModelStoreOwner-的-set-方法" class="headerlink" title="ViewModelStoreOwner 的 set 方法"></a>ViewModelStoreOwner 的 set 方法</h1><p>ViewModelStoreOwner 的 set 方法是什么时候被调用的，被添加到哪个 View 的 Tag 中？</p><h2 id="androidx-activity-ComponentActivity-中的调用时机"><a href="#androidx-activity-ComponentActivity-中的调用时机" class="headerlink" title="androidx.activity.ComponentActivity 中的调用时机"></a>androidx.activity.ComponentActivity 中的调用时机</h2><p>androidx.activity.ComponentActivity#setContentView(android.view.View)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">    initViewTreeOwners();</span><br><span class="line">    <span class="built_in">super</span>.setContentView(layoutResID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;)</span> View view)</span> &#123;</span><br><span class="line">    initViewTreeOwners();</span><br><span class="line">    <span class="built_in">super</span>.setContentView(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;)</span> View view,</span></span><br><span class="line"><span class="params">        <span class="meta">@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;)</span></span></span><br><span class="line"><span class="params">                ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    initViewTreeOwners();</span><br><span class="line">    <span class="built_in">super</span>.setContentView(view, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>androidx.activity.ComponentActivity#addContentView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addContentView</span><span class="params">(<span class="meta">@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;)</span> View view,</span></span><br><span class="line"><span class="params">        <span class="meta">@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;)</span></span></span><br><span class="line"><span class="params">                ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    initViewTreeOwners();</span><br><span class="line">    <span class="built_in">super</span>.addContentView(view, params);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在-initViewTreeOwners-中调用-ViewModelStoreOwner-的-set"><a href="#在-initViewTreeOwners-中调用-ViewModelStoreOwner-的-set" class="headerlink" title="在 initViewTreeOwners 中调用 ViewModelStoreOwner 的 set"></a>在 initViewTreeOwners 中调用 ViewModelStoreOwner 的 set</h2><p>androidx.activity.ComponentActivity#initViewTreeOwners</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initViewTreeOwners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class="line">    <span class="comment">// and attach listeners will see them already present</span></span><br><span class="line">    ViewTreeLifecycleOwner.set(getWindow().getDecorView(), <span class="built_in">this</span>);</span><br><span class="line">    ViewTreeViewModelStoreOwner.set(getWindow().getDecorView(), <span class="built_in">this</span>);</span><br><span class="line">    ViewTreeSavedStateRegistryOwner.set(getWindow().getDecorView(), <span class="built_in">this</span>);</span><br><span class="line">    ViewTreeOnBackPressedDispatcherOwner.set(getWindow().getDecorView(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里顺便提一下 ViewTreeLifecycleOwner，ViewTreeSavedStateRegistryOwner，ViewTreeOnBackPressedDispatcherOwner</p><p>在Android Jetpack架构组件中，<code>ViewTreeLifecycleOwner</code>、<code>ViewTreeSavedStateRegistryOwner</code>和<code>ViewTreeOnBackPressedDispatcherOwner</code>是用于在视图树中传递和存储与生命周期、状态保存和返回按钮事件处理相关的对象的工具类。它们允许开发者在任何视图层级中访问与这些功能相关的对象，增强了组件化和模块化开发的灵活性。</p><h3 id="ViewTreeLifecycleOwner"><a href="#ViewTreeLifecycleOwner" class="headerlink" title="ViewTreeLifecycleOwner"></a>ViewTreeLifecycleOwner</h3><p><code>ViewTreeLifecycleOwner</code>与<code>LifecycleOwner</code>接口相关，后者是一个类可以实现的接口，表示这个类有一个生命周期，比如Activity或Fragment。<code>ViewTreeLifecycleOwner</code>提供了静态方法来在视图树中设置和获取<code>LifecycleOwner</code>。这使得在视图树中的任何位置，都可以访问到与之相关联的<code>LifecycleOwner</code>，进而可以根据生命周期事件来管理资源，比如开始&#x2F;停止数据加载、绑定&#x2F;解绑资源等。</p><h3 id="ViewTreeSavedStateRegistryOwner"><a href="#ViewTreeSavedStateRegistryOwner" class="headerlink" title="ViewTreeSavedStateRegistryOwner"></a>ViewTreeSavedStateRegistryOwner</h3><p><code>ViewTreeSavedStateRegistryOwner</code>与<code>SavedStateRegistryOwner</code>接口相关，后者管理和存储状态，以便在进程被杀后恢复状态。通过<code>ViewTreeSavedStateRegistryOwner</code>，开发者可以为视图树中的任何视图设置和获取与状态保存相关的<code>SavedStateRegistryOwner</code>。这使得即使是自定义视图也能够利用Android的状态保存机制，无需依赖于Activity或Fragment来保存和恢复状态。</p><h3 id="ViewTreeOnBackPressedDispatcherOwner"><a href="#ViewTreeOnBackPressedDispatcherOwner" class="headerlink" title="ViewTreeOnBackPressedDispatcherOwner"></a>ViewTreeOnBackPressedDispatcherOwner</h3><p><code>ViewTreeOnBackPressedDispatcherOwner</code>与<code>OnBackPressedDispatcherOwner</code>接口相关，后者提供了一个组件化的方式来处理返回按钮事件。<code>ViewTreeOnBackPressedDispatcherOwner</code>允许开发者为视图树中的任何视图设置和获取<code>OnBackPressedDispatcherOwner</code>。这意味着在任何视图中，都可以独立处理返回按钮的点击事件，而不是仅限于在Activity中处理。这对于构建复杂的用户界面和处理嵌套的用户交互特别有用。</p><h3 id="使用场景和好处"><a href="#使用场景和好处" class="headerlink" title="使用场景和好处"></a>使用场景和好处</h3><ul><li><strong>组件化开发</strong>：这些工具类支持更加组件化的开发方式，视图或组件可以独立于Activity或Fragment使用这些架构组件。</li><li><strong>灵活性和可重用性</strong>：使得自定义视图和组件更加灵活，易于重用，因为它们可以在不依赖特定Activity或Fragment的情况下，管理自己的生命周期、状态保存和返回按钮处理。</li><li><strong>简化代码</strong>：简化了在自定义视图或深层嵌套的视图结构中访问这些功能的方式，避免了复杂的回调结构或过度依赖于上下文。</li></ul><p>综上所述，<code>ViewTreeLifecycleOwner</code>、<code>ViewTreeSavedStateRegistryOwner</code>和<code>ViewTreeOnBackPressedDispatcherOwner</code>为Android开发者提供了强大的工具，以更加灵活和模块化的方式处理生命周期管理、状态保存和返回按钮事件处理。</p><h1 id="ViewTreeViewModelKt"><a href="#ViewTreeViewModelKt" class="headerlink" title="ViewTreeViewModelKt"></a>ViewTreeViewModelKt</h1><p>Google 也准备了一个 Kotlin 使用的扩展函数配合 ViewModelStoreOwner</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.lifecycle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> View.<span class="title">findViewTreeViewModelStoreOwner</span><span class="params">()</span></span>: ViewModelStoreOwner? =</span><br><span class="line">    ViewTreeViewModelStoreOwner.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.4 - Jetpacket </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel 源代码分析 (三)</title>
      <link href="/2024/04/01/3%20Android/Jetpacket/VideoModel/2%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%89)%20/"/>
      <url>/2024/04/01/3%20Android/Jetpacket/VideoModel/2%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%89)%20/</url>
      
        <content type="html"><![CDATA[<ul><li><p>viewmodel</p><ul><li><p>CreationExtras<br>ViewModel创建过程中传递额外参数的容器。</p></li><li><p>InitializerViewModelFactory              </p><p> ViewModelProvider.Factory接口实现类，使用ViewModelInitializer来创建ViewModel实例。</p></li><li><p>InitializerViewModelFactoryBuilder   </p><p>用于构建InitializerViewModelFactory的工具，通常以DSL形式提供。</p></li><li><p>MutableCreationExtras                     </p><p>可变版本的CreationExtras，允许添加或修改额外参数。</p></li><li><p>ViewModelFactoryDsl                       </p><p>一个DSL（领域特定语言），用于更声明式地定义如何创建ViewModel。</p></li><li><p>ViewModelInitializer                         </p><p>用于初始化ViewModel的类，通常与ViewModelFactoryDsl一起使用。</p></li><li><p>InitializerViewModelFactory            </p><p>提供了使用InitializerViewModelFactory的Kotlin扩展。</p></li></ul></li><li><p>AndroidViewModel                                  </p><p>AndroidViewModel是ViewModel的一个子类，它接受应用程序的Application作为上下文，这对于需要访问Application资源的ViewModel特别有用。</p></li><li><p>HasDefaultViewModelProviderFactory</p><p>一个接口，标识一个类拥有默认的ViewModelProvider.Factory，用于创建ViewModel。</p></li><li><p>ViewModel</p></li><li><p>ViewModelLazy                                       </p><p>一个提供懒加载ViewModel实例的工具类。</p></li><li><p>ViewModelProvider                                 </p><p>用于获取ViewModel实例，确保配置更改时ViewModel可以持续使用。</p></li><li><p>ViewModelStore                                      </p><p>用于保存ViewModel实例的类，以便它们可以跨配置更改持续存在。</p></li><li><p>ViewModelStoreOwner                          </p><p>一个接口，标识一个类可以拥有ViewModelStore。</p></li><li><p>ViewTreeViewModelStoreOwner            </p><p>用于从视图树中查找ViewModelStoreOwner的工具类。</p></li><li><p>ViewTreeViewModelKt                           </p><p>提供了操作和查询视图树中ViewModel的Kotlin扩展</p></li></ul><h1 id="页面旋转的时候-ViewModelStore-到底被谁持有了"><a href="#页面旋转的时候-ViewModelStore-到底被谁持有了" class="headerlink" title="页面旋转的时候 ViewModelStore 到底被谁持有了"></a>页面旋转的时候 ViewModelStore 到底被谁持有了</h1><h2 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h2><h2 id="Activity-的销毁"><a href="#Activity-的销毁" class="headerlink" title="Activity 的销毁"></a>Activity 的销毁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Core implementation of activity destroy call. */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performDestroyActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finishing,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> configChanges, <span class="type">boolean</span> getNonConfigInstance, String reason)</span> &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; activityClass = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Performing finish of &quot;</span> + r);</span><br><span class="line">    activityClass = r.activity.getClass();</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        r.activity.mFinished = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    performPauseActivityIfNeeded(r, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">        callActivityOnStop(r, <span class="literal">false</span> <span class="comment">/* saveState */</span>, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unable to retain activity &quot;</span></span><br><span class="line">                        + r.intent.getComponent().toShortString() + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="literal">false</span>;</span><br><span class="line">        mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SuperNotCalledException</span>(<span class="string">&quot;Activity &quot;</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">&quot; did not call through to super.onDestroy()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.window != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.window.closeAllPanels();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unable to destroy activity &quot;</span></span><br><span class="line">                    + safeToComponentShortString(r.intent) + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_DESTROY);</span><br><span class="line">    mLastReportedWindowingMode.remove(r.activity.getActivityToken());</span><br><span class="line">    schedulePurgeIdler();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSplashScreenGlobal != <span class="literal">null</span>) &#123;</span><br><span class="line">            mSplashScreenGlobal.tokenDestroyed(r.token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updatePendingActivityConfiguration() reads from mActivities to update</span></span><br><span class="line">    <span class="comment">// ActivityClientRecord which runs in a different thread. Protect modifications to</span></span><br><span class="line">    <span class="comment">// mActivities to avoid race.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        mActivities.remove(r.token);</span><br><span class="line">    &#125;</span><br><span class="line">    StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unable to retain activity &quot;</span></span><br><span class="line">                           + r.intent.getComponent().toShortString() + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="android-app-Activity"><a href="#android-app-Activity" class="headerlink" title="android.app.Activity"></a>android.app.Activity</h2><h3 id="retainNonConfigurationInstances"><a href="#retainNonConfigurationInstances" class="headerlink" title="retainNonConfigurationInstances"></a>retainNonConfigurationInstances</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NonConfigurationInstances <span class="title function_">retainNonConfigurationInstances</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">activity</span> <span class="operator">=</span> onRetainNonConfigurationInstance();</span><br><span class="line">    HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances();</span><br><span class="line">    <span class="type">FragmentManagerNonConfig</span> <span class="variable">fragments</span> <span class="operator">=</span> mFragments.retainNestedNonConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;re already stopped but we&#x27;ve been asked to retain.</span></span><br><span class="line">    <span class="comment">// Our fragments are taken care of but we need to mark the loaders for retention.</span></span><br><span class="line">    <span class="comment">// In order to do this correctly we need to restart the loaders first before</span></span><br><span class="line">    <span class="comment">// handing them off to the next activity.</span></span><br><span class="line">    mFragments.doLoaderStart();</span><br><span class="line">    mFragments.doLoaderStop(<span class="literal">true</span>);</span><br><span class="line">    ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity == <span class="literal">null</span> &amp;&amp; children == <span class="literal">null</span> &amp;&amp; fragments == <span class="literal">null</span> &amp;&amp; loaders == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mVoiceInteractor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">    nci.activity = activity;</span><br><span class="line">    nci.children = children;</span><br><span class="line">    nci.fragments = fragments;</span><br><span class="line">    nci.loaders = loaders;</span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.retainInstance();</span><br><span class="line">        nci.voiceInteractor = mVoiceInteractor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="onRetainNonConfigurationInstance"><a href="#onRetainNonConfigurationInstance" class="headerlink" title="onRetainNonConfigurationInstance"></a>onRetainNonConfigurationInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">onRetainNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onRetainNonConfigurationChildInstances"><a href="#onRetainNonConfigurationChildInstances" class="headerlink" title="onRetainNonConfigurationChildInstances"></a>onRetainNonConfigurationChildInstances</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">HashMap&lt;String,Object&gt; <span class="title function_">onRetainNonConfigurationChildInstances</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="androidx-activity-ComponentActivity"><a href="#androidx-activity-ComponentActivity" class="headerlink" title="androidx.activity.ComponentActivity"></a>androidx.activity.ComponentActivity</h2><h3 id="onRetainNonConfigurationInstance-1"><a href="#onRetainNonConfigurationInstance-1" class="headerlink" title="onRetainNonConfigurationInstance"></a>onRetainNonConfigurationInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retain all appropriate non-config state.  You can NOT</span></span><br><span class="line"><span class="comment"> * override this yourself!  Use a &#123;<span class="doctag">@link</span> androidx.lifecycle.ViewModel&#125; if you want to</span></span><br><span class="line"><span class="comment"> * retain your own non config state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">onRetainNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Maintain backward compatibility.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">custom</span> <span class="operator">=</span> onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> mViewModelStore;</span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">        <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            viewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span> &amp;&amp; custom == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">    nci.custom = custom;</span><br><span class="line">    nci.viewModelStore = viewModelStore;</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">nci.custom = custom;</span><br><span class="line">nci.viewModelStore = viewModelStore;</span><br></pre></td></tr></table></figure><p>androidx.activity.ComponentActivity 中实现了 onRetainNonConfigurationInstance</p><p>ViewModelStore 被保存到了 NonConfigurationInstances.viewModelStore 中</p><p>NonConfigurationInstances 又被 ActivityClientRecord 持有</p><h2 id="android-app-ActivityThread-ActivityClientRecord-源代码"><a href="#android-app-ActivityThread-ActivityClientRecord-源代码" class="headerlink" title="android.app.ActivityThread.ActivityClientRecord 源代码"></a>android.app.ActivityThread.ActivityClientRecord 源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ActivityClientRecord</span> &#123;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> IBinder token;</span><br><span class="line">    <span class="keyword">public</span> IBinder assistToken;</span><br><span class="line">    <span class="comment">// A reusable token for other purposes, e.g. content capture, translation. It shouldn&#x27;t be</span></span><br><span class="line">    <span class="comment">// used without security checks</span></span><br><span class="line">    <span class="keyword">public</span> IBinder shareableActivityToken;</span><br><span class="line">    <span class="comment">// The token of the initial TaskFragment that embedded this activity. Do not rely on it</span></span><br><span class="line">    <span class="comment">// after creation because the activity could be reparented.</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">public</span> IBinder mInitialTaskFragmentToken;</span><br><span class="line">    <span class="type">int</span> ident;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    Intent intent;</span><br><span class="line">    String referrer;</span><br><span class="line">    IVoiceInteractor voiceInteractor;</span><br><span class="line">    Bundle state;</span><br><span class="line">    PersistableBundle persistentState;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    Activity activity;</span><br><span class="line">    Window window;</span><br><span class="line">    Activity parent;</span><br><span class="line">    String embeddedID;</span><br><span class="line">    Activity.NonConfigurationInstances lastNonConfigurationInstances;</span><br><span class="line">    <span class="comment">// TODO(lifecycler): Use mLifecycleState instead.</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="type">boolean</span> paused;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="type">boolean</span> stopped;</span><br><span class="line">    <span class="type">boolean</span> hideForNow;</span><br><span class="line">    Configuration createdConfig;</span><br><span class="line">    Configuration overrideConfig;</span><br><span class="line">    <span class="comment">// Used for consolidating configs before sending on to Activity.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Configuration</span> <span class="variable">tmpConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">    <span class="comment">// Callback used for updating activity override config and camera compat control state.</span></span><br><span class="line">    ViewRootImpl.ActivityConfigCallback activityConfigCallback;</span><br><span class="line">    ActivityClientRecord nextIdle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicates whether this activity is currently the topmost resumed one in the system.</span></span><br><span class="line">    <span class="comment">// This holds the last reported value from server.</span></span><br><span class="line">    <span class="type">boolean</span> isTopResumedActivity;</span><br><span class="line">    <span class="comment">// This holds the value last sent to the activity. This is needed, because an update from</span></span><br><span class="line">    <span class="comment">// server may come at random time, but we always need to report changes between ON_RESUME</span></span><br><span class="line">    <span class="comment">// and ON_PAUSE to the app.</span></span><br><span class="line">    <span class="type">boolean</span> lastReportedTopResumedState;</span><br><span class="line"></span><br><span class="line">    ProfilerInfo profilerInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    ActivityInfo activityInfo;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    CompatibilityInfo compatInfo;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> LoadedApk packageInfo;</span><br><span class="line"></span><br><span class="line">    List&lt;ResultInfo&gt; pendingResults;</span><br><span class="line">    List&lt;ReferrerIntent&gt; pendingIntents;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> startsNotResumed;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> isForward;</span><br><span class="line">    <span class="type">int</span> pendingConfigChanges;</span><br><span class="line">    <span class="comment">// Whether we are in the process of performing on user leaving.</span></span><br><span class="line">    <span class="type">boolean</span> mIsUserLeaving;</span><br><span class="line"></span><br><span class="line">    Window mPendingRemoveWindow;</span><br><span class="line">    WindowManager mPendingRemoveWindowManager;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="type">boolean</span> mPreserveWindow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The options for scene transition. */</span></span><br><span class="line">    ActivityOptions mActivityOptions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether this activiy was launched from a bubble. */</span></span><br><span class="line">    <span class="type">boolean</span> mLaunchedFromBubble;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LifecycleState</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mLifecycleState</span> <span class="operator">=</span> PRE_ON_CREATE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SizeConfigurationBuckets mSizeConfigurations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ActivityClientRecord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isForward = <span class="literal">false</span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ActivityClientRecord</span><span class="params">(IBinder token, Intent intent, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">            ActivityInfo info, Configuration overrideConfig, CompatibilityInfo compatInfo,</span></span><br><span class="line"><span class="params">            String referrer, IVoiceInteractor voiceInteractor, Bundle state,</span></span><br><span class="line"><span class="params">            PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults,</span></span><br><span class="line"><span class="params">            List&lt;ReferrerIntent&gt; pendingNewIntents, ActivityOptions activityOptions,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> isForward, ProfilerInfo profilerInfo, ClientTransactionHandler client,</span></span><br><span class="line"><span class="params">            IBinder assistToken, IBinder shareableActivityToken, <span class="type">boolean</span> launchedFromBubble,</span></span><br><span class="line"><span class="params">            IBinder initialTaskFragmentToken)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.token = token;</span><br><span class="line">        <span class="built_in">this</span>.assistToken = assistToken;</span><br><span class="line">        <span class="built_in">this</span>.shareableActivityToken = shareableActivityToken;</span><br><span class="line">        <span class="built_in">this</span>.ident = ident;</span><br><span class="line">        <span class="built_in">this</span>.intent = intent;</span><br><span class="line">        <span class="built_in">this</span>.referrer = referrer;</span><br><span class="line">        <span class="built_in">this</span>.voiceInteractor = voiceInteractor;</span><br><span class="line">        <span class="built_in">this</span>.activityInfo = info;</span><br><span class="line">        <span class="built_in">this</span>.compatInfo = compatInfo;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="built_in">this</span>.persistentState = persistentState;</span><br><span class="line">        <span class="built_in">this</span>.pendingResults = pendingResults;</span><br><span class="line">        <span class="built_in">this</span>.pendingIntents = pendingNewIntents;</span><br><span class="line">        <span class="built_in">this</span>.isForward = isForward;</span><br><span class="line">        <span class="built_in">this</span>.profilerInfo = profilerInfo;</span><br><span class="line">        <span class="built_in">this</span>.overrideConfig = overrideConfig;</span><br><span class="line">        <span class="built_in">this</span>.packageInfo = client.getPackageInfoNoCheck(activityInfo.applicationInfo,</span><br><span class="line">                compatInfo);</span><br><span class="line">        mActivityOptions = activityOptions;</span><br><span class="line">        mLaunchedFromBubble = launchedFromBubble;</span><br><span class="line">        mInitialTaskFragmentToken = initialTaskFragmentToken;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Common initializer for all constructors. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        parent = <span class="literal">null</span>;</span><br><span class="line">        embeddedID = <span class="literal">null</span>;</span><br><span class="line">        paused = <span class="literal">false</span>;</span><br><span class="line">        stopped = <span class="literal">false</span>;</span><br><span class="line">        hideForNow = <span class="literal">false</span>;</span><br><span class="line">        nextIdle = <span class="literal">null</span>;</span><br><span class="line">        activityConfigCallback = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>.ActivityConfigCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigurationChanged</span><span class="params">(Configuration overrideConfig,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> newDisplayId)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                            <span class="string">&quot;Received config update for non-existing activity&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                activity.mMainThread.handleActivityConfigurationChanged(</span><br><span class="line">                        ActivityClientRecord.<span class="built_in">this</span>, overrideConfig, newDisplayId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestCompatCameraControl</span><span class="params">(<span class="type">boolean</span> showControl,</span></span><br><span class="line"><span class="params">                    <span class="type">boolean</span> transformationApplied, ICompatCameraControlCallback callback)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                            <span class="string">&quot;Received camera compat control update for non-existing activity&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ActivityClient.getInstance().requestCompatCameraControl(</span><br><span class="line">                        activity.getResources(), token, showControl, transformationApplied,</span><br><span class="line">                        callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the current lifecycle state. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLifecycleState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Update the current lifecycle state for internal bookkeeping. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="meta">@LifecycleState</span> <span class="type">int</span> newLifecycleState)</span> &#123;</span><br><span class="line">        mLifecycleState = newLifecycleState;</span><br><span class="line">        <span class="keyword">switch</span> (mLifecycleState) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                paused = <span class="literal">true</span>;</span><br><span class="line">                stopped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">                paused = <span class="literal">true</span>;</span><br><span class="line">                stopped = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                paused = <span class="literal">false</span>;</span><br><span class="line">                stopped = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                paused = <span class="literal">true</span>;</span><br><span class="line">                stopped = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                paused = <span class="literal">true</span>;</span><br><span class="line">                stopped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPreHoneycomb</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> activity != <span class="literal">null</span> &amp;&amp; activity.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.HONEYCOMB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPreP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> activity != <span class="literal">null</span> &amp;&amp; activity.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPersistable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> activityInfo.persistableMode == ActivityInfo.PERSIST_ACROSS_REBOOTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVisibleFromServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> activity != <span class="literal">null</span> &amp;&amp; activity.mVisibleFromServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ComponentName</span> <span class="variable">componentName</span> <span class="operator">=</span> intent != <span class="literal">null</span> ? intent.getComponent() : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ActivityRecord&#123;&quot;</span></span><br><span class="line">            + Integer.toHexString(System.identityHashCode(<span class="built_in">this</span>))</span><br><span class="line">            + <span class="string">&quot; token=&quot;</span> + token + <span class="string">&quot; &quot;</span> + (componentName == <span class="literal">null</span></span><br><span class="line">                    ? <span class="string">&quot;no component name&quot;</span> : componentName.toShortString())</span><br><span class="line">            + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStateString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;ActivityClientRecord&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;paused=&quot;</span>).append(paused);</span><br><span class="line">        sb.append(<span class="string">&quot;, stopped=&quot;</span>).append(stopped);</span><br><span class="line">        sb.append(<span class="string">&quot;, hideForNow=&quot;</span>).append(hideForNow);</span><br><span class="line">        sb.append(<span class="string">&quot;, startsNotResumed=&quot;</span>).append(startsNotResumed);</span><br><span class="line">        sb.append(<span class="string">&quot;, isForward=&quot;</span>).append(isForward);</span><br><span class="line">        sb.append(<span class="string">&quot;, pendingConfigChanges=&quot;</span>).append(pendingConfigChanges);</span><br><span class="line">        sb.append(<span class="string">&quot;, preserveWindow=&quot;</span>).append(mPreserveWindow);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;, Activity&#123;&quot;</span>);</span><br><span class="line">            sb.append(<span class="string">&quot;resumed=&quot;</span>).append(activity.mResumed);</span><br><span class="line">            sb.append(<span class="string">&quot;, stopped=&quot;</span>).append(activity.mStopped);</span><br><span class="line">            sb.append(<span class="string">&quot;, finished=&quot;</span>).append(activity.isFinishing());</span><br><span class="line">            sb.append(<span class="string">&quot;, destroyed=&quot;</span>).append(activity.isDestroyed());</span><br><span class="line">            sb.append(<span class="string">&quot;, startedActivity=&quot;</span>).append(activity.mStartedActivity);</span><br><span class="line">            sb.append(<span class="string">&quot;, changingConfigurations=&quot;</span>).append(activity.mChangingConfigurations);</span><br><span class="line">            sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActivityClientRecord</code>是Android系统内部使用的一个类，主要存在于<code>ActivityThread</code>中，用于管理和跟踪Activity的状态信息。这个类作为Activity实例状态的容器，承载了Activity的生命周期状态、Intent信息、窗口和其他与Activity实例相关的配置信息。<code>ActivityClientRecord</code>是<code>ActivityThread</code>处理Activity生命周期事件时的关键数据结构，它帮助<code>ActivityThread</code>高效地管理Activity的创建、启动、恢复、暂停、停止以及销毁过程。</p><h3 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h3><ul><li><p><strong>生命周期管理</strong>：<code>ActivityClientRecord</code>存储了Activity的生命周期状态，例如是否处于暂停状态、是否已经创建等，这对于<code>ActivityThread</code>正确处理Activity生命周期事件至关重要。</p></li><li><p><strong>配置管理</strong>：它还包含了与Activity实例相关的配置信息，如屏幕方向、主题等，这些信息对于Activity在不同配置下正确表现自己非常重要。</p></li><li><p><strong>Intent处理</strong>：<code>ActivityClientRecord</code>包含了启动Activity所用的Intent，这个Intent携带了从其他组件传递给Activity的数据。</p></li><li><p><strong>窗口管理</strong>：它还管理着Activity的窗口信息，包括用于描绘Activity UI的窗口。这对于在屏幕上正确渲染Activity视图非常关键。</p></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>当一个新的Activity被启动时，<code>ActivityThread</code>会接收到一个来自AMS（Activity Manager Service）的请求，此请求包含了创建或启动Activity所需的所有信息，包括Intent和Activity的配置信息。<code>ActivityThread</code>随后会创建一个新的<code>ActivityClientRecord</code>实例，用来存储这些信息，并根据这些信息处理Activity的创建和启动过程。</p><p>在Activity的生命周期中，<code>ActivityThread</code>会根据接收到的来自AMS的指令，更新<code>ActivityClientRecord</code>的状态，并据此调用Activity的相应生命周期方法，如<code>onCreate</code>、<code>onStart</code>、<code>onResume</code>、<code>onPause</code>、<code>onStop</code>和<code>onDestroy</code>。</p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>虽然<code>ActivityClientRecord</code>是一个内部类，不面向普通开发者，但了解它的存在和作用有助于深入理解Android的Activity管理机制。它是<code>ActivityThread</code>和AMS协同工作、高效管理Activity生命周期的关键数据结构，确保了Activity可以在正确的时间执行正确的操作，从而为用户提供流畅的应用体验。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.4 - Jetpacket </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04/80 寻找数组的中心下标</title>
      <link href="/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/04%20%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/"/>
      <url>/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/04%20%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>要在Kotlin中实现寻找数组的中心下标的算法，你可以遵循这个基本思路：遍历数组，对于每个下标，计算其左侧所有元素的和与右侧所有元素的和。如果在某个下标位置，这两个和相等，那么这个下标就是数组的中心下标。</p><p>下面是一个具体的实现示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findPivotIndex</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> totalSum = nums.sum()</span><br><span class="line">    <span class="keyword">var</span> leftSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ((index, value) <span class="keyword">in</span> nums.withIndex()) &#123;</span><br><span class="line">        <span class="comment">// 如果左侧和的两倍加上当前值等于总和，则当前索引是中心索引</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * leftSum + value == totalSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="comment">// 如果没有找到，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数<code>findPivotIndex</code>接受一个整数数组<code>nums</code>作为参数，并返回中心下标。它首先计算数组的总和，然后遍历数组。在遍历过程中，它更新一个名为<code>leftSum</code>的变量，该变量存储当前索引左侧所有元素的和。对于每个元素，它检查<code>2 * leftSum + value</code>是否等于<code>totalSum</code>。如果等于，这意味着左侧所有元素的和等于右侧所有元素的和，因此当前索引是中心下标，函数返回该索引。如果遍历完整个数组都没有找到这样的索引，函数返回-1。</p><p>要使用这个函数，你可以像这样调用它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nums = intArrayOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> pivotIndex = findPivotIndex(nums)</span><br><span class="line">    println(pivotIndex) <span class="comment">// 输出中心下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例会输出数组<code>[1, 7, 3, 6, 5, 6]</code>的中心下标。</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.3 - 80 道基础算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02/80 统计素数个数-埃氏筛选法</title>
      <link href="/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/02%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E5%9F%83%E6%B0%8F%E7%AD%9B%E9%80%89%E6%B3%95/"/>
      <url>/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/02%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E5%9F%83%E6%B0%8F%E7%AD%9B%E9%80%89%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>埃拉托斯特尼筛法（简称埃氏筛）是一种高效的查找素数的算法，它通过排除从2开始到给定数n的所有非素数来找出所有小于或等于n的素数。使用埃氏筛选法改进统计数组中素数元素的个数的算法，我们可以先通过筛法找出数组中所有可能的素数，然后再统计数组中这些素数的个数。</p><p>这里是如何用Kotlin实现基于埃氏筛选法来统计一个数组中素数元素的个数：</p><ol><li>构建埃氏筛: 根据数组中的最大值构建埃氏筛，以找到所有可能的素数。</li><li>统计素数: 遍历数组，利用构建的埃氏筛判断每个元素是否为素数，并计算素数的总数。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countPrimesInArrayWithSieve</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出数组中的最大值，以便构建足够大的筛</span></span><br><span class="line">    <span class="keyword">val</span> max = arr.maxOrNull() ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建埃氏筛</span></span><br><span class="line">    <span class="keyword">val</span> isPrime = BooleanArray(max + <span class="number">1</span>) &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (isPrime.size &gt; <span class="number">1</span>) isPrime[<span class="number">1</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.Math.sqrt(max.toDouble()).toInt()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i * i..max step i) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中的素数个数</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">2</span> &amp;&amp; isPrime[num]) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arr = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>)</span><br><span class="line">    println(<span class="string">&quot;Count of prime numbers in the array with sieve: <span class="subst">$&#123;countPrimesInArrayWithSieve(arr)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，<code>countPrimesInArrayWithSieve</code> 函数首先找出数组中的最大值，以此来确定筛的大小。接着，它通过遍历2到<code>sqrt(max)</code>的数来构建筛，标记所有这些数的倍数为非素数。最后，它遍历数组，统计那些标记为素数的元素个数。</p><p>埃氏筛选法的时间复杂度通常为 O(n log log n)，相比暴力法的 O(n^2)，它在处理大量数据时更加高效。</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.3 - 80 道基础算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03/80 删除排序数组中的重复项</title>
      <link href="/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/03%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/03%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeDuplicates</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span> <span class="comment">// 返回不重复数组的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nums = intArrayOf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> length = removeDuplicates(nums)</span><br><span class="line">    println(<span class="string">&quot;新的数组长度: <span class="variable">$length</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until length) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;nums[i]&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.3 - 80 道基础算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01/80 统计素数个数-暴力算法</title>
      <link href="/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/01%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/01%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPrime</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countPrimesInArray</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(num)) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arr = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>)</span><br><span class="line">    println(<span class="string">&quot;Count of prime numbers in the array: <span class="subst">$&#123;countPrimesInArray(arr)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.3 - 80 道基础算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TextView layout_constrainedWidth 属性</title>
      <link href="/2024/03/22/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/0%20UI%E7%BB%98%E5%88%B6%E6%A8%A1%E7%89%88/TextView-layout_constrainedWidth-%E5%B1%9E%E6%80%A7/"/>
      <url>/2024/03/22/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/0%20UI%E7%BB%98%E5%88%B6%E6%A8%A1%E7%89%88/TextView-layout_constrainedWidth-%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><code>layout_constrainedWidth</code>是<code>ConstraintLayout</code>中的一个属性，用于在处理宽度约束时提供更多的灵活性和控制。当你使用<code>ConstraintLayout</code>构建复杂的布局时，可能会遇到某些视图在其内容过长时需要被约束宽度的情况，以避免它们超出屏幕边界或影响其他视图的布局。<code>layout_constrainedWidth</code>属性就是为了解决这类问题而设计的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>          <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constrainedWidth</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@id/buttonView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_chainStyle</span>=<span class="string">&quot;packed&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/buttonView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_chainStyle</span>=<span class="string">&quot;packed&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;按钮&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 7 - 复杂代码模版 </category>
          
          <category> 7.1 - UI 绘制模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拦截 View 触摸事件，判断滑动方向</title>
      <link href="/2024/03/22/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/1%20%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/%E6%8B%A6%E6%88%AA%20View%20%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%88%A4%E6%96%AD%E6%BB%91%E5%8A%A8%E6%96%B9%E5%90%91/"/>
      <url>/2024/03/22/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/1%20%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/%E6%8B%A6%E6%88%AA%20View%20%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%88%A4%E6%96%AD%E6%BB%91%E5%8A%A8%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">anyView.setOnTouchListener(<span class="keyword">object</span> : View.OnTouchListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initialX = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initialY = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> hasScrolled = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouch</span><span class="params">(v: <span class="type">View</span>?, event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        event ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                <span class="comment">// 记录初始触摸位置</span></span><br><span class="line">                initialX = event.x</span><br><span class="line">                initialY = event.y</span><br><span class="line">                hasScrolled = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasScrolled) &#123;</span><br><span class="line">                    <span class="keyword">val</span> diffX = event.x - initialX</span><br><span class="line">                    <span class="keyword">val</span> diffY = event.y - initialY</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断滑动方向，确保是水平滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (abs(diffX) &gt; abs(diffY)) &#123;</span><br><span class="line">                        <span class="keyword">val</span> direction = <span class="keyword">if</span> (diffX &lt; <span class="number">0</span>) Direction.LEFT <span class="keyword">else</span> Direction.RIGHT</span><br><span class="line"></span><br><span class="line">                        handleHorizontalScroll(direction)</span><br><span class="line">                        hasScrolled = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">                hasScrolled = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleHorizontalScroll</span><span class="params">(direction: <span class="type">Direction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (direction) &#123;</span><br><span class="line">            Direction.LEFT -&gt; &#123; <span class="comment">// 向左滑动</span></span><br><span class="line">                showToast(<span class="string">&quot;发生向左滑动&quot;</span>)</span><br><span class="line">                <span class="comment">// 在这里处理向左滑动的逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">            Direction.RIGHT -&gt; &#123; <span class="comment">// 向右滑动</span></span><br><span class="line">                showToast(<span class="string">&quot;发生向右滑动&quot;</span>)</span><br><span class="line">                <span class="comment">// 在这里处理向右滑动的逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showToast</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">        LEFT, RIGHT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 7 - 复杂代码模版 </category>
          
          <category> 7.2 - 手势分发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能专题 - 插件化预热-拼多多为什么只有26M-GPT4快问快答</title>
      <link href="/2024/02/21/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E6%8F%92%E4%BB%B6%E5%8C%96%E9%A2%84%E7%83%AD-%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%8926M-GPT4%E5%BF%AB%E9%97%AE%E5%BF%AB%E7%AD%94/"/>
      <url>/2024/02/21/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E6%8F%92%E4%BB%B6%E5%8C%96%E9%A2%84%E7%83%AD-%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%8926M-GPT4%E5%BF%AB%E9%97%AE%E5%BF%AB%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h1><p>双亲委派机制（Parent Delegation Model）是Java类加载器（ClassLoader）使用的一种特定模型，在这个模型中，类加载器在尝试加载类或资源时，会首先委托给其父类加载器进行加载，这个过程会一直递归下去，直到达到最顶层的启动类加载器（Bootstrap ClassLoader）。如果父类加载器可以完成类加载工作，就使用父类加载器的定义，如果父类加载器无法完成加载工作（即它搜索的路径中没有找到所需的类），子类加载器才会尝试自己去加载这个类。</p><p>双亲委派机制的优点包括：</p><ol><li><p><strong>避免类的重复加载</strong>：由于在顶层开始尝试加载类，因此类在JVM中只会被加载一次，这样就保证了Java虚拟机中存在的类，都是由唯一的类加载器加载的，从而避免了类的多次加载。</p></li><li><p><strong>保护程序安全</strong>：通过给予Java核心库的加载工作委托给顶层的启动类加载器，保证了Java核心库的类型安全，防止核心API库被随意替换。用户自定义的类加载器不会去尝试加载这些Java核心类库，这样可以防止一些恶意代码替代了这些核心API，从而破坏JVM的安全性。</p></li><li><p><strong>促进正向的类加载工作流</strong>：这种委派模式促进了类加载器之间的协作，遵循了一种从顶层到底层的工作流，使得类加载过程更加清晰。</p></li></ol><p>尽管双亲委派模型带来了上述好处，但在某些情况下，比如在一个Java程序中需要加载一些运行时生成的类，或者是从网络上下载的类，这时可能需要自定义类加载器，并打破双亲委派模型。在Java中，可以通过重写<code>ClassLoader</code>的<code>loadClass</code>方法来实现自定义的类加载逻辑，从而在必要时绕过双亲委派模型。</p><h1 id="为什么可以避免类的重复加载"><a href="#为什么可以避免类的重复加载" class="headerlink" title="为什么可以避免类的重复加载"></a>为什么可以避免类的重复加载</h1><p>双亲委派模型可以避免类的重复加载主要是因为它采用了一种层次化的类加载方式，确保了每个类由一个确定的类加载器负责加载。具体来说，这种机制避免类重复加载的原理和机制包括以下几点：</p><ol><li><p><strong>层次化的类加载器结构</strong>：在Java中，类加载器通常有三层结构（启动类加载器、扩展类加载器、应用程序类加载器），加上可能的自定义类加载器。每个类加载器都有可能有自己的父加载器（除了启动类加载器，它是最顶层的加载器，没有父加载器）。当一个类加载器接收到类加载的请求时，它首先不会尝试自己去加载这个类，而是把这个请求委托给它的父加载器去执行，这样一层层向上直到启动类加载器。</p></li><li><p><strong>委托机制确保类的唯一性</strong>：因为加载请求最终会传递到启动类加载器，如果这个类能被启动类加载器加载，那么它就会由启动类加载器完成加载。如果启动类加载器加载不了，它会返回到下一级加载器尝试，依此类推，直到找到合适的加载器加载这个类。这样一来，无论是哪个类加载器加载的类，都确保了在JVM中的唯一性，因为同一个类在JVM中只会被加载一次。</p></li><li><p><strong>缓存机制</strong>：类加载器在加载类的过程中，会将加载过的类缓存起来。当再次请求加载这个类时，类加载器会首先检查这个类是否已经加载过了，如果已经加载，就直接从缓存中返回这个类的Class对象，而不会再次加载。这个缓存机制进一步保证了类的唯一性和避免重复加载。</p></li><li><p><strong>安全性考虑</strong>：双亲委派模型还有一个重要的安全考量。通过让启动类加载器（负责加载Java核心库的加载器）在加载类的最前线，可以避免核心API被恶意替换。因为用户自定义的类加载器无法直接加载核心API类，所以即使有类的全限定名相同，也不会影响到JVM内部的类实现，这样就避免了核心类库的污染和重复加载。</p></li></ol><p>通过上述机制，双亲委派模型不仅避免了类的重复加载，而且还提升了Java程序的运行时安全性和稳定性。</p><h1 id="向我解释启动类加载器、扩展类加载器、应用程序类加载器"><a href="#向我解释启动类加载器、扩展类加载器、应用程序类加载器" class="headerlink" title="向我解释启动类加载器、扩展类加载器、应用程序类加载器"></a>向我解释启动类加载器、扩展类加载器、应用程序类加载器</h1><p>Java虚拟机（JVM）使用类加载器（ClassLoader）来动态加载类文件到内存中。在JVM中，类加载器遵循双亲委派模型，并且主要分为三种类型：启动（Bootstrap）类加载器、扩展（Extension）类加载器、应用程序（Application）类加载器。它们的作用和层次结构如下：</p><h2 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h2><ul><li><strong>作用</strong>：这是Java类加载器层次结构中的最顶层加载器。它负责加载JVM基础核心类库，如<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>以及类路径中指定的类。这些库位于JDK的<code>jre/lib</code>目录或者是<code>JAVA_HOME/lib</code>目录下。</li><li><strong>实现</strong>：启动类加载器并不是Java实现的，而是由JVM自身的底层代码（如C&#x2F;C++）实现的。这意味着它不继承自<code>java.lang.ClassLoader</code>，不能被Java代码直接引用。</li><li><strong>特点</strong>：由于其加载的是Java的核心类库，因此它不会被Java程序直接控制。它提供了Java运行时环境的基础类，保证了JVM的稳定性和安全性。</li></ul><h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><ul><li><strong>作用</strong>：扩展类加载器负责加载Java的扩展库，即位于JDK的<code>jre/lib/ext</code>目录或者由系统属性<code>java.ext.dirs</code>指定位置的类库。这些库提供了标准Java类库之外的扩展功能。</li><li><strong>实现</strong>：扩展类加载器是用Java实现的，并且它是<code>java.lang.ClassLoader</code>类的一个实例。在类加载器的层次结构中，它是启动类加载器的子加载器。</li><li><strong>特点</strong>：扩展类加载器使得用户可以通过放置jar文件到<code>ext</code>目录来扩展JVM的功能，而不需要放到JVM核心类库目录中去。</li></ul><h2 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h2><ul><li><strong>作用</strong>：应用程序类加载器负责加载用户类路径（Classpath）上的类库，这包括来自于<code>CLASSPATH</code>环境变量、<code>-classpath</code>或<code>-cp</code>命令行选项指定的所有类库。它是程序中默认的类加载器，通常用来加载我们自己写的类和第三方库。</li><li><strong>实现</strong>：这个加载器也是用Java实现的，并且是<code>ClassLoader</code>的一个直接子类。在类加载器的层次结构中，它是扩展类加载器的子加载器。</li><li><strong>特点</strong>：大部分应用程序中的类都是由这个加载器加载的。它保证了应用程序类是由用户定义的路径加载，而不是由JVM的内部路径决定。</li></ul><p>这三个类加载器共同协作，确保了Java应用程序在运行时可以动态加载类，同时保障了系统的安全性和类加载机制的高效性。</p><h1 id="向我介绍什么是Android的插件化"><a href="#向我介绍什么是Android的插件化" class="headerlink" title="向我介绍什么是Android的插件化"></a>向我介绍什么是Android的插件化</h1><p>Android的插件化是一种在Android开发中实现模块化、动态加载和运行时集成第三方组件或模块的技术手段。它允许应用在不需要重新安装或更新整个应用的情况下，动态加载和卸载功能模块。这种技术为应用提供了极高的灵活性和扩展性，使得应用能够根据需要加载新功能或更新现有功能，同时减少了应用的初始下载大小。</p><h2 id="Android插件化的关键特点"><a href="#Android插件化的关键特点" class="headerlink" title="Android插件化的关键特点"></a>Android插件化的关键特点</h2><ol><li><strong>动态性</strong>：插件可以在应用运行时被动态加载和替换，无需重新安装或更新整个应用。</li><li><strong>模块化</strong>：应用的不同功能可以被封装成独立的模块（插件），便于单独开发和管理。</li><li><strong>减小体积</strong>：通过插件化，可以减少应用的初始下载大小，用户可以根据需要下载额外的功能模块。</li><li><strong>更新灵活</strong>：可以单独更新某个功能模块而不影响整个应用，提高了更新的灵活性和效率。</li></ol><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>Android插件化的实现通常涉及到以下几个关键技术点：</p><ul><li><strong>类加载器（ClassLoader）</strong>：利用Android的ClassLoader机制动态加载插件中的类。通过自定义ClassLoader实现类的加载，避免了插件和宿主应用之间的类冲突。</li><li><strong>资源管理</strong>：动态加载插件中的资源（如布局、图片、字符串等），并确保宿主应用和插件能够正常使用这些资源。</li><li><strong>四大组件激活</strong>：动态注册和管理插件中的四大组件（Activity、Service、BroadcastReceiver、ContentProvider），由于这些组件需要在AndroidManifest.xml中静态声明，插件化技术需要绕过这一限制，通过宿主代理或其他机制实现组件的动态激活。</li><li><strong>上下文隔离</strong>：保证插件运行时的上下文（Context）环境与宿主应用隔离，避免相互干扰。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>功能模块化</strong>：将应用的不同功能模块化，按需加载，减轻应用初始体积。</li><li><strong>热更新</strong>：修复bug或更新应用的某部分功能而无需更新整个应用。</li><li><strong>组件共享</strong>：实现跨应用的组件共享和复用。</li></ul><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>尽管插件化为Android应用开发带来了诸多好处，但它也引入了一些挑战，包括复杂的实现机制、性能优化、资源管理、安全性问题等。因此，实现一个稳定、高效的插件化框架需要深入理解Android的底层机制和高级特性。</p><h1 id="双亲委派机制在Android插件化中的作用"><a href="#双亲委派机制在Android插件化中的作用" class="headerlink" title="双亲委派机制在Android插件化中的作用"></a>双亲委派机制在Android插件化中的作用</h1><p>在Android插件化中，双亲委派机制扮演着至关重要的角色，主要体现在插件的加载和运行时隔离方面。由于Android基于Java开发，而Java的类加载器采用双亲委派模型，这对Android插件化的实现产生了直接影响。以下是双亲委派机制在Android插件化中作用的几个关键点：</p><h2 id="确保类的唯一性"><a href="#确保类的唯一性" class="headerlink" title="确保类的唯一性"></a>确保类的唯一性</h2><p>双亲委派机制通过优先委托父加载器加载类的方式，确保了JVM中每个类的唯一性。在Android插件化框架中，这一点尤为重要，因为它可以防止插件中的类与宿主应用或其他插件中的类发生冲突。例如，如果插件和宿主应用都使用了同一个库的不同版本，双亲委派机制可以确保在同一个类加载器上下文中，这个库的类只被加载一次，从而避免版本冲突。</p><h2 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h2><p>双亲委派机制通过限制类的加载来源，提高了应用的安全性。在插件化环境中，通过自定义类加载器加载插件，可以控制插件的权限，防止插件访问或修改宿主应用的私有数据。同时，由于双亲委派模型优先使用父加载器加载类，它还可以防止恶意代码通过插件覆盖或篡改系统类库。</p><h2 id="实现运行时隔离"><a href="#实现运行时隔离" class="headerlink" title="实现运行时隔离"></a>实现运行时隔离</h2><p>在Android插件化中，通常需要实现插件之间以及插件与宿主之间的运行时隔离。双亲委派机制允许插件化框架通过自定义类加载器为每个插件创建独立的命名空间，从而实现隔离。这种隔离机制确保了插件可以独立运行，互不干扰，同时也方便了插件的管理和更新。</p><h2 id="动态加载插件"><a href="#动态加载插件" class="headerlink" title="动态加载插件"></a>动态加载插件</h2><p>插件化框架通常需要动态加载和卸载插件，<strong>双亲委派机制使得这种动态性成为可能</strong>。通过使用自定义的类加载器加载插件，可以在运行时根据需要加载或替换插件，而不需要重新启动应用。这种机制不仅提高了应用的灵活性，也支持了热更新和模块化部署。</p><h2 id="绕过双亲委派模型的挑战"><a href="#绕过双亲委派模型的挑战" class="headerlink" title="绕过双亲委派模型的挑战"></a>绕过双亲委派模型的挑战</h2><p>虽然双亲委派机制有诸多优点，但在实现Android插件化时，有时也需要绕过这种机制。例如，当插件需要使用不同版本的共享库时，可能需要设计复杂的类加载策略来加载正确的类版本，而不是由双亲委派机制自动选择。这就需要插件化框架能够灵活控制类加载过程，可能通过反射或者使用自定义类加载器来实现。</p><p>总的来说，双亲委派机制为Android插件化提供了一个强大的基础，使得插件化框架能够高效、安全地管理和加载插件。但同时，它也带来了一定的挑战，需要开发者深入理解其工作原理，才能有效地利用这一机制实现高质量的插件化方案。</p><h1 id="双亲委派机制如何使得这种动态性成为可能"><a href="#双亲委派机制如何使得这种动态性成为可能" class="headerlink" title="双亲委派机制如何使得这种动态性成为可能"></a>双亲委派机制如何使得这种动态性成为可能</h1><p>双亲委派机制本身是一种类加载机制，确保了类加载的有序性和安全性。在讨论它如何使得动态性成为可能时，我们主要关注的是这种机制如何被用于实现和优化Android插件化中的动态加载和动态更新功能。</p><h2 id="实现动态加载"><a href="#实现动态加载" class="headerlink" title="实现动态加载"></a>实现动态加载</h2><p>在Android插件化中，动态加载指的是应用运行时按需加载外部或者附加的代码和资源，而不是在应用安装时就固定下来。双亲委派机制通过以下方式促进这种动态加载：</p><ul><li><strong>自定义类加载器</strong>：开发者可以通过创建自定义的类加载器来绕过双亲委派机制的一些限制，使得在应用运行时可以加载或替换插件。这些自定义类加载器可以直接或间接继承自<code>ClassLoader</code>类，通过重写<code>findClass</code>方法来实现对插件类的加载。</li><li><strong>隔离和独立</strong>：自定义类加载器可以为每个插件创建独立的命名空间，这意味着即使多个插件包含相同的类名，它们也能够被独立加载和运行，互不干扰。这种隔离保证了插件之间的动态性和独立性。</li></ul><h2 id="支持动态更新"><a href="#支持动态更新" class="headerlink" title="支持动态更新"></a>支持动态更新</h2><p>动态更新是指在不重启应用的情况下更新应用的部分内容或功能。双亲委派机制在这方面的作用体现在：</p><ul><li><strong>类版本的控制</strong>：通过自定义类加载器，应用可以动态地卸载旧的插件类和加载新的插件类。这是因为Java虚拟机(JVM)允许同一个类可以被不同的类加载器加载，只要这些类加载器是不同的实例。因此，通过更新类加载器或者使用不同的类加载器实例，可以实现插件的动态更新。</li><li><strong>资源的动态加载</strong>：除了代码之外，插件化还涉及到资源的动态加载，如图片、布局文件等。自定义类加载器也可以被用来加载这些资源，使得应用能够在运行时不仅更新代码，还可以更新资源。</li></ul><h2 id="如何绕过双亲委派机制"><a href="#如何绕过双亲委派机制" class="headerlink" title="如何绕过双亲委派机制"></a>如何绕过双亲委派机制</h2><p>虽然双亲委派机制的初衷是为了保证安全和一致性，但在插件化场景下，有时需要绕过这一机制以实现更高级的动态性。这通常通过以下方式实现：</p><ul><li><strong>反射和Hook技术</strong>：通过反射调用或修改Android内部的API行为，或者使用Hook技术，可以在不违背双亲委派原则的前提下，实现对类加载过程的控制和干预。</li><li><strong>自定义类加载策略</strong>：通过实现自定义的类加载器，并在其中实现特定的加载策略，可以有选择性地加载或替换特定的类或资源，从而实现对双亲委派机制的有效绕过。</li></ul><p>总的来说，双亲委派机制在Android插件化中的作用并不直接关联到动态性的实现，而是通过自定义类加载器和策略，以及对这一机制的细致控制和适当绕过，使得动态加载和更新成为可能。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能专题 - 启动优化（一）启动耗时</title>
      <link href="/2024/02/21/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
      <url>/2024/02/21/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>声明</strong>：本文是《Android 性能优化入门与实战》——张世欣著 的笔记</p><h1 id="为什么要做启动优化"><a href="#为什么要做启动优化" class="headerlink" title="为什么要做启动优化"></a>为什么要做启动优化</h1><p>App 启动耗时每减少 1s，用户流失率降低 6.9%</p><h1 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">补充知识</span><br><span class="line"></span><br><span class="line">**App 冷温热启动分辨**：根据进程、Activity 是否已经存在</span><br><span class="line"></span><br><span class="line">**冷启动**: 进程初始化 -&gt; Activity.onCreate -&gt; Activity.onStart</span><br><span class="line"></span><br><span class="line">**温启动**: Activity.onCreate -&gt; Activity.onStart</span><br><span class="line"></span><br><span class="line">**热启动**：Activity.onStart</span><br></pre></td></tr></table></figure><p>监控数据设计</p><p>需要比较的对照组：</p><ol><li>旧版本-新版本</li><li>冷启动-温启动-热启动</li></ol><p>数据与目的：</p><ol><li>获取总耗时，判断新版本更快还是更慢</li><li>获取各区间耗时，具体分析耗时到具体区间</li></ol><h1 id="App-启动代码顺序"><a href="#App-启动代码顺序" class="headerlink" title="App 启动代码顺序"></a>App 启动代码顺序</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Application 构造函数</span><br><span class="line"></span><br><span class="line">Application<span class="comment">#attachBaseContext</span></span><br><span class="line"></span><br><span class="line">ContentProvider<span class="comment">#onCreate</span></span><br><span class="line"></span><br><span class="line">Application<span class="comment">#onCreate</span></span><br><span class="line"></span><br><span class="line">Activity<span class="comment">#onStart</span></span><br><span class="line"></span><br><span class="line">Activity<span class="comment">#onResume</span></span><br><span class="line"></span><br><span class="line">View<span class="comment">#onDraw</span></span><br><span class="line"></span><br><span class="line">Activity<span class="comment">#onWindowFocusChanged</span></span><br><span class="line"></span><br><span class="line">起点：Application 构造函数</span><br><span class="line"></span><br><span class="line">终点：</span><br><span class="line"></span><br><span class="line">方案一：MainActivity 的某个 View 的第一次 onDraw(绘制函数)</span><br><span class="line"></span><br><span class="line">- 优点：可以拿到第一帧绘制的耗时</span><br><span class="line">- 缺点：</span><br><span class="line">  <span class="number">1</span>. 执行时第一帧还没绘制完成</span><br><span class="line">  <span class="number">2</span>. 需要选择某个核心布局，业务改造的时候容易影响到启动监控逻辑</span><br><span class="line"></span><br><span class="line">方案二：MainActivity 的 onWindowFocusChanged</span><br><span class="line"></span><br><span class="line">- 优点：不受业务逻辑的影响</span><br><span class="line">- 缺点：被调用的时可能已经不是首帧，会将非首帧的时间算入</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="获取启动各阶段耗时"><a href="#获取启动各阶段耗时" class="headerlink" title="获取启动各阶段耗时"></a>获取启动各阶段耗时</h1><p>方法：</p><ol><li>手动埋点</li><li>编译时 AOP</li></ol><h1 id="获取启动性能数据"><a href="#获取启动性能数据" class="headerlink" title="获取启动性能数据"></a>获取启动性能数据</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分析 App 启动慢的几个重要指标</span><br><span class="line">-&gt; 代码耗时 (判断标准：App 运行的 CPU 时间充足)</span><br><span class="line">-&gt; 获取的 CPU 时间不足 (判断标准：App 运行的 CPU 时间不足)</span><br><span class="line">-&gt; 线程优先级不够 (判断标准：主线程优先级)</span><br><span class="line">  -&gt; 被其他线程抢占过多 (判断标准：主线程被抢占次数)</span><br><span class="line">-&gt; 内存不足 (判断标准：启动期间 GC 执行次数和耗时)</span><br></pre></td></tr></table></figure><h1 id="线下分析"><a href="#线下分析" class="headerlink" title="线下分析"></a>线下分析</h1><p>Logcat 或者 adb logcat 中查看关键字 <strong>Displayed</strong> 相关日志</p><p>自动执行 App的启动并获取启动耗时：通过 adb shell am start 实现多次自动启动 App 并获取第一次的启动耗时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -S -W -R -3 com.antfortune.wealth/com.alipay.mobile.quinox.LauncherActivity</span><br></pre></td></tr></table></figure><ul><li><code>am start</code> 是 ActivityManagerService 提供的命令，用来启动 Activity。</li><li><code>- S</code> 即 Stop，表示在每次启动前，先强制停止 App 运行，以实现冷启动。</li><li><code>- W</code> 即 Wait，表示执行后等待启动完成再退出，以统计整个启动的耗时。</li><li><code>- R</code> 即 Repeat， 表示重复执行启动的次数，<code>-R 3</code> 表示重复启动 3 次。</li></ul><p>会得到以下信息</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Stopping:</span> com.antfortune.wealth</span><br><span class="line"><span class="symbol">Starting:</span> Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.antfortune.wealth/com.alipay.mobile.quinox.LauncherActivity &#125;</span><br><span class="line"><span class="symbol">Status:</span> ok</span><br><span class="line"><span class="symbol">LaunchState:</span> COLD</span><br><span class="line"><span class="symbol">Activity:</span> com.antfortune.wealth/com.alipay.mobile.quinox.LauncherActivity</span><br><span class="line"><span class="symbol">TotalTime:</span> <span class="number">463</span></span><br><span class="line"><span class="symbol">WaitTime:</span> <span class="number">467</span></span><br><span class="line">Complete</span><br></pre></td></tr></table></figure><p>上述 TotalTime 就是整个冷启动的耗时，与 Locat 过滤 <strong>Displayed</strong> 得到的时间基本是一致的。</p><p>这两种方式，统计的都是 <strong>App 启动到 Activity 首次调用的时间 onWindowFocusChanged 的时间</strong>。</p><p>如果想统计<strong>从 App 启动到数据请求成功后某个布局完全展示出来的耗时</strong>，可以在<strong>启动终点调用 Activity#reportFullyDrawn</strong> 来通知当前</p><p>已经完全绘制完成，然后在 Logcat 里过滤 Fully drawn 就可以看到整个流程的耗时。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Glide 三种池子</title>
      <link href="/2024/02/10/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Glide-%E4%B8%89%E7%A7%8D%E6%B1%A0%E5%AD%90/"/>
      <url>/2024/02/10/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Glide-%E4%B8%89%E7%A7%8D%E6%B1%A0%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Glide 中 LruPoolStrategy 是如何设计的</span><br><span class="line"></span><br><span class="line">三个子类 SizeConfigStrategy AttributeStrategy SizeStrategy 的区别</span><br><span class="line"></span><br><span class="line">从精细度管理的角度，对三种池子进行排序</span><br><span class="line"></span><br><span class="line">如果图片都使用 <span class="string">`ARGB_8888`</span> 应该使用哪个池子</span><br></pre></td></tr></table></figure><h1 id="LruPoolStrategy-接口设计"><a href="#LruPoolStrategy-接口设计" class="headerlink" title="LruPoolStrategy 接口设计"></a>LruPoolStrategy 接口设计</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了在LRU（最近最少使用）缓存中管理可重用位图池的策略接口。</span></span><br><span class="line"><span class="comment"> * 该接口的实现负责定义位图的存储、检索和根据缓存策略及位图的属性（如大小和配置）的逐出机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">interface</span> <span class="title class_">LruPoolStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将位图放入池中。实现应根据其大小、配置或其他属性决定如何将位图添加到池中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap 要添加到池中的位图。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试从池中检索并返回与指定宽度、高度和配置匹配的位图。如果没有找到合适的位图，此方法返回null。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width 请求的位图宽度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 请求的位图高度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 所需位图的Bitmap.Config配置。可以为null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 匹配请求属性的位图，如果没有合适的位图可用则返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从池中移除并返回最近最少使用的位图。如果池为空，此方法返回null。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最近最少使用的位图，如果池为空则返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成并返回指定位图属性的日志友好型字符串表示，如其大小和配置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap 要为其生成日志字符串的位图。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 位图属性的字符串表示，用于日志记录目的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的宽度、高度和配置生成并返回一个位图属性的日志友好型字符串表示。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width 位图的宽度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 位图的高度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 位图的Bitmap.Config配置。可以为null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定属性的字符串表示，用于日志记录目的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定位图的大小（以字节为单位）。实现应根据位图的尺寸和配置计算大小。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap 要计算大小的位图。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 位图的字节大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SizeConfigStrategy"><a href="#SizeConfigStrategy" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h1><p><code>SizeConfigStrategy</code> 是一个实现了 <code>LruPoolStrategy</code> 接口的类，用于管理和重用 <code>Bitmap</code> 对象，其核心目标是通过控制 <code>Bitmap</code> 对象的尺寸和配置来优化内存使用。</p><p>这个策略通过将 <code>Bitmap</code> 对象分类存储在一个组织良好的结构中，并在需要时提供快速访问，以减少内存分配和回收的开销。下面是对这个类的关键部分的详细解析：</p><h2 id="核心数据结构和方法"><a href="#核心数据结构和方法" class="headerlink" title="核心数据结构和方法"></a>核心数据结构和方法</h2><ul><li><p><strong>ARGB_8888_IN_CONFIGS</strong></p></li><li><p><strong>RGA_F16_IN_CONFIGS</strong></p></li><li><p><strong>RGB_565_IN_CONFIGS</strong></p></li><li><p><strong>ARGB_4444_IN_CONFIGS</strong></p></li><li><p><strong>ALPHA_8_IN_CONFIGS</strong><br>这些数组定义了在不同 Android 版本下，根据请求的 <code>Bitmap.Config</code> 所能接受的配置类型。例如，如果请求的是 <code>ARGB_8888</code>，那么可能接受的配置就包括了 <code>ARGB_8888</code> 和 <code>RGBA_F16</code>（在支持的 Android 版本上）。</p></li><li><p><strong>keyPool</strong>:<br><code>KeyPool</code>  实例，用于重用 <code>Key</code> 对象。每个 <code>Key</code> 对象代表一个 <code>Bitmap</code> 的尺寸和配置，这样可以减少内存分配。</p></li><li><p><strong>groupedMap</strong>:<br><code>GroupedLinkedMap&lt;Key?, Bitmap&gt;</code> 实例，用于根据 <code>Key</code> 存储和检索 <code>Bitmap</code> 对象。这种结构支持快速查找、插入和删除操作。</p></li><li><p><strong>sortedSizes</strong>:<br><code>NavigableMap&lt;Int, Int&gt;</code> 的映射，用于跟踪每种配置下不同大小的 <code>Bitmap</code> 数量。这对于找到最匹配的 <code>Bitmap</code> 尺寸非常有用。</p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p><strong>put(bitmap: Bitmap)</strong>:<br>将 <code>Bitmap</code> 添加到池中。这个方法计算 <code>Bitmap</code> 的字节大小，创建或获取一个对应的 <code>Key</code>，并更新 <code>groupedMap</code> 和 <code>sortedSizes</code>。</p></li><li><p><strong>get(width: Int, height: Int, config: Bitmap.Config?)</strong>:<br>尝试根据提供的宽度、高度和配置从池中获取一个最匹配的 <code>Bitmap</code>。这涉及到查找一个尺寸合适、配置兼容的 <code>Bitmap</code>，如果找到，就对其进行重新配置并返回。</p></li><li><p><strong>removeLast()</strong>:<br>移除并返回池中最后一个 <code>Bitmap</code>，这通常是最近最少使用的一个。这个方法还会更新 <code>sortedSizes</code> 以反映      变化。</p></li><li><p><strong>logBitmap(bitmap: Bitmap)</strong> 和 <strong>logBitmap(width: Int, height: Int, config: Bitmap.Config?)</strong>:<br>生成表示 <code>Bitmap</code> 尺寸和配置的字符串，用于日志记录和调试。</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><strong>KeyPool</strong> 和 <strong>Key</strong>:<br>这些类支持 <code>Bitmap</code> 尺寸和配置的高效存储和检索。<code>KeyPool</code> 用于管理 <code>Key</code> 对象的池，以减少创建新对象的需要。<code>Key</code> 对象表示一个 <code>Bitmap</code> 的尺寸和配置，用作 <code>groupedMap</code> 中的键。</li></ul><h2 id="整体设计思路"><a href="#整体设计思路" class="headerlink" title="整体设计思路"></a>整体设计思路</h2><p><code>SizeConfigStrategy</code> 的设计旨在通过细致管理 <code>Bitmap</code> 对象的存储和重用来优化内存使用。它通过精确匹配请求的 <code>Bitmap</code> 尺寸和配置，尽量减少创建新 <code>Bitmap</code> 对象的需要，从而降低了内存压力和提高了性能。这个策略特别适用于图片密集型的应用，比如图片浏览器或社交媒体应用，其中频繁地加载和显示图片。</p><h1 id="AttributeStrategy"><a href="#AttributeStrategy" class="headerlink" title="AttributeStrategy"></a>AttributeStrategy</h1><p>这段代码定义了一个名为 <code>AttributeStrategy</code> 的内部类，实现了 <code>LruPoolStrategy</code> 接口，用于管理位图（Bitmap）的缓存策略。这个策略通过位图的宽度、高度和配置（Bitmap.Config）来唯一标识和管理位图。下面是对这个类的主要组成部分和逻辑的解析：</p><h2 id="类的主要组成部分"><a href="#类的主要组成部分" class="headerlink" title="类的主要组成部分"></a>类的主要组成部分</h2><ol><li><p><strong>KeyPool 类</strong>：一个用于管理 <code>Key</code> 对象池的内部类。它通过重写 <code>create()</code> 方法来创建新的 <code>Key</code> 对象，并提供了一个获取 <code>Key</code> 的方法，该方法接受位图的宽度、高度和配置作为参数，用于初始化 <code>Key</code>。</p></li><li><p><strong>Key 类</strong>：一个内部类，实现了 <code>Poolable</code> 接口。每个 <code>Key</code> 对象包含位图的宽度、高度和配置属性。<code>Key</code> 类提供了 <code>init</code> 方法来设置这些属性，<code>equals</code> 和 <code>hashCode</code> 方法被重写以确保 <code>Key</code> 对象可以根据其宽度、高度和配置被唯一地标识和比较。</p></li><li><p><strong>groupedMap</strong>：一个 <code>GroupedLinkedMap</code> 对象，用于根据 <code>Key</code>（位图的宽度、高度和配置）分组存储和管理位图。</p></li></ol><h2 id="类的主要方法"><a href="#类的主要方法" class="headerlink" title="类的主要方法"></a>类的主要方法</h2><ul><li><p><code>put(bitmap: Bitmap)</code>：将位图添加到缓存中。首先通过 <code>keyPool</code> 获取与位图尺寸和配置对应的 <code>Key</code>，然后将位图和 <code>Key</code> 添加到 <code>groupedMap</code> 中。</p></li><li><p><code>get(width: Int, height: Int, config: Bitmap.Config?)</code>：尝试获取一个符合指定尺寸和配置的位图。首先通过 <code>keyPool</code> 获取与指定尺寸和配置对应的 <code>Key</code>，然后从 <code>groupedMap</code> 中查找和返回相应的位图。</p></li><li><p><code>removeLast()</code>：移除并返回最近最少使用的位图。这是通过从 <code>groupedMap</code> 中移除最后一个位图来实现的。</p></li><li><p><code>logBitmap(bitmap: Bitmap)</code> 和 <code>logBitmap(width: Int, height: Int, config: Bitmap.Config?)</code>：用于生成表示位图尺寸和配置的日志字符串。</p></li><li><p><code>getSize(bitmap: Bitmap)</code>：返回位图占用的字节大小。</p></li></ul><h2 id="特点和用途"><a href="#特点和用途" class="headerlink" title="特点和用途"></a>特点和用途</h2><p><code>AttributeStrategy</code> 通过精确地考虑位图的尺寸和配置来管理位图缓存，使其能够更有效地利用内存并提高缓存的效率。通过使用对象池来管理 <code>Key</code> 对象，还可以减少内存分配和垃圾回收的压力。这种策略特别适用于需要存储和管理多种尺寸和配置位图的应用场景。</p><h1 id="SizeStrategy"><a href="#SizeStrategy" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h1><p>这段代码是一个用于管理位图（Bitmap）缓存策略的内部类 <code>SizeStrategy</code>，它实现了 <code>LruPoolStrategy</code> 接口。这个策略的核心是通过位图大小来管理和回收位图资源，以优化内存使用。下面是对这个类和它的主要组成部分的分析：</p><h2 id="成员变量介绍："><a href="#成员变量介绍：" class="headerlink" title="成员变量介绍："></a><strong>成员变量介绍</strong>：</h2><ul><li><p><code>keyPool</code>: 一个 <code>KeyPool</code> 对象，用于管理 <code>Key</code> 对象的池。每个 <code>Key</code> 对象都与一个特定大小的位图相关联。</p></li><li><p><code>groupedMap</code>: 一个 <code>GroupedLinkedMap&lt;Key, Bitmap&gt;</code> 对象，用于根据 <code>Key</code> 分组存储 <code>Bitmap</code> 对象。这允许快速查找和回收特定大小的位图。</p></li><li><p><code>sortedSizes</code>: 一个 <code>NavigableMap&lt;Int?, Int&gt;</code> 对象，存储每个大小的位图数量。这是一个 <code>PrettyPrintTreeMap</code>，可能是为了便于调试和打印。</p><h2 id="方法解析："><a href="#方法解析：" class="headerlink" title="方法解析："></a><strong>方法解析</strong>：</h2></li><li><p><code>put(bitmap: Bitmap)</code>: 将一个位图添加到缓存中。它计算位图的大小，获取或创建相应大小的 <code>Key</code>，将位图和 <code>Key</code> 添加到 <code>groupedMap</code> 中，并更新 <code>sortedSizes</code> 中对应大小的计数。</p></li><li><p><code>get(width: Int, height: Int, config: Bitmap.Config?)</code>: 尝试获取一个符合指定宽度、高度和配置的位图。它计算所需位图的大小，查找是否有足够大的可用位图，如果有，则从 <code>groupedMap</code> 中取出并返回该位图。</p></li><li><p><code>removeLast()</code>: 移除并返回最近最少使用（LRU）的位图。这是通过从 <code>groupedMap</code> 中移除最后一个位图来实现的，并更新 <code>sortedSizes</code> 中的计数。</p></li><li><p><code>decrementBitmapOfSize(size: Int?)</code>: 减少特定大小的位图数量。如果该大小的位图只有一个，则从 <code>sortedSizes</code> 中移除该大小；否则，减少其计数。</p><h2 id="辅助类："><a href="#辅助类：" class="headerlink" title="辅助类："></a><strong>辅助类</strong>：</h2></li><li><p><code>KeyPool</code>: 用于管理 <code>Key</code> 对象池的类。它重写了 <code>create()</code> 方法来生成新的 <code>Key</code> 对象，并提供了一个重载的 <code>get(size: Int)</code> 方法来获取或创建一个初始化了特定大小的 <code>Key</code>。</p></li><li><p><code>Key</code>: 实现了 <code>Poolable</code> 接口的类，表示与位图大小相关联的键。包含一个 <code>size</code> 属性和 <code>init(size: Int)</code> 方法来设置键的大小。重写了 <code>equals()</code> 和 <code>hashCode()</code> 方法以支持正确的键比较和哈希操作。</p></li></ul><h2 id="常量和辅助方法："><a href="#常量和辅助方法：" class="headerlink" title="常量和辅助方法："></a><strong>常量和辅助方法</strong>：</h2><ul><li><code>MAX_SIZE_MULTIPLE</code>: 一个常量，定义了在查找时可以接受的最大位图大小倍数。</li><li><code>getBitmapString(bitmap: Bitmap)</code> 和 <code>getBitmapString(size: Int)</code>: 辅助方法，用于生成表示位图大小的字符串。</li></ul><p>这个类的设计目的是提高位图缓存的效率和灵活性，通过精细地管理不同大小的位图来优化内存使用。通过维护一个有序的大小映射和一个根据大小分组的位图映射，它可以快速地存取和回收位图资源。</p><p> <code>SizeConfigStrategy</code>、<code>AttributeStrategy</code>、和<code>SizeStrategy</code>是Glide图像加载库用于位图缓存管理的三种不同策略，它们在位图的存储、查找和回收方式上各有特点。这些策略优化了内存使用，并改善了图像加载的性能。以下是它们的区别和各自适用的场景：</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><h2 id="SizeConfigStrategy-1"><a href="#SizeConfigStrategy-1" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><p><strong>特点</strong>：<code>SizeConfigStrategy</code>使用位图的大小（以字节为单位）和<code>Bitmap.Config</code>配置作为键来管理缓存。这种方法允许区分具有相同像素大小但不同像素配置的位图，如<code>ARGB_8888</code>和<code>RGB_565</code>。</p><p><strong>适用场景</strong>：这种策略适用于需要根据位图的内存大小和配置精细管理缓存的应用。例如，如果应用中同时使用了不同配置的位图（以优化显示质量和内存使用），<code>SizeConfigStrategy</code>能有效地区分和管理这些位图。</p><h2 id="AttributeStrategy-1"><a href="#AttributeStrategy-1" class="headerlink" title="AttributeStrategy"></a>AttributeStrategy</h2><p><strong>特点</strong>：<code>AttributeStrategy</code>基于位图的宽度、高度和配置（<code>Bitmap.Config</code>）来识别和管理位图。这种方法提供了对缓存的精确控制，允许缓存系统区分尺寸相同但配置不同的位图。</p><p><strong>适用场景</strong>：当应用需要在相同的尺寸下缓存不同配置的位图，且这些配置对位图的使用和性能有明显影响时，<code>AttributeStrategy</code>非常适用。它确保了即使是细微的配置差异也能被正确管理，适合对图像质量和性能有高要求的应用。</p><h2 id="SizeStrategy-1"><a href="#SizeStrategy-1" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h2><p><strong>特点</strong>：<code>SizeStrategy</code>仅基于位图占用的内存大小来管理缓存，不考虑位图的配置或尺寸。这种策略通过一种更简单的方式来回收和重用位图内存，忽略了位图的其他属性。</p><p><strong>适用场景</strong>：对于那些不需要考虑位图配置差异，主要关注于减少内存占用和简化缓存管理的应用，<code>SizeStrategy</code>是一个理想的选择。它适合内存使用更为紧张，或者位图配置较为统一的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>SizeConfigStrategy</code></strong> 和 <strong><code>AttributeStrategy</code></strong> 提供了更细粒度的缓存管理，能够根据位图的具体特征（如配置和尺寸）进行优化，适合需要高度优化内存使用和图像质量的场景。</p><p><strong><code>SizeStrategy</code></strong> 通过一个更简单的方法来管理缓存，适用于对缓存管理的要求相对简单，更关注于减少内存占用的应用。</p><p>选择哪种策略取决于应用的具体需求，包括对内存管理的敏感度、图像的多样性以及性能的要求。</p><h1 id="三种池子的特点"><a href="#三种池子的特点" class="headerlink" title="三种池子的特点"></a>三种池子的特点</h1><h2 id="SizeConfigStrategy-2"><a href="#SizeConfigStrategy-2" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><ul><li><strong>内存大小</strong>：使用位图的内存大小作为缓存的关键因素之一。</li><li><strong>配置敏感</strong>：考虑了<code>Bitmap.Config</code>，区分了相同大小但配置不同的位图。</li><li><strong>精细管理</strong>：允许对缓存的位图进行更精细的管理，适用于内存和显示质量都很重要的场景。</li></ul><h2 id="AttributeStrategy-2"><a href="#AttributeStrategy-2" class="headerlink" title="AttributeStrategy"></a>AttributeStrategy</h2><ul><li><strong>尺寸配置</strong>：基于位图的宽度、高度和<code>Bitmap.Config</code>来管理位图。</li><li><strong>高度区分</strong>：能够精确区分尺寸相同但配置不同的位图。</li><li><strong>细节控制</strong>：提供对位图缓存的细节控制，适用于对图像显示细节有高要求的应用。</li></ul><h2 id="SizeStrategy-2"><a href="#SizeStrategy-2" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h2><ul><li><strong>简化内存</strong>：仅基于位图占用的内存大小来管理缓存，简化了缓存管理。</li><li><strong>统一处理</strong>：不区分位图的尺寸或配置，统一处理所有位图。</li><li><strong>内存优化</strong>：优先考虑内存使用效率，适用于内存敏感且配置统一的应用场景。</li></ul><p>这些关键字概括了每种策略的核心特点和适用场景，有助于在实际开发中根据应用的需求选择最合适的位图缓存管理策略。</p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><h2 id="SizeConfigStrategy-3"><a href="#SizeConfigStrategy-3" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SizeConfigStrategy</span> : <span class="type">LruPoolStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SIZE_MULTIPLE = <span class="number">8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ARGB_8888_IN_CONFIGS: Array&lt;Bitmap.Config?&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = arrayOf(</span><br><span class="line">            Bitmap.Config.ARGB_8888, <span class="comment">// The value returned by Bitmaps with the hidden Bitmap config.</span></span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                result = result.copyOf(result.size + <span class="number">1</span>)</span><br><span class="line">                result[result.size - <span class="number">1</span>] = Bitmap.Config.RGBA_F16</span><br><span class="line">            &#125;</span><br><span class="line">            ARGB_8888_IN_CONFIGS = result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> RGB_565_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.RGB_565)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> ARGB_4444_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.ARGB_4444)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> ALPHA_8_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.ALPHA_8)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[<span class="variable">$size</span>](<span class="variable">$config</span>)&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInConfigs</span><span class="params">(requested: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Array&lt;Bitmap.Config?&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Bitmap.Config.RGBA_F16 == requested) &#123; <span class="comment">// NOPMD - Avoid short circuiting sdk checks.</span></span><br><span class="line">                    <span class="keyword">return</span> RGBA_F16_IN_CONFIGS</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (requested) &#123;</span><br><span class="line">                Bitmap.Config.ARGB_8888 -&gt; ARGB_8888_IN_CONFIGS</span><br><span class="line">                Bitmap.Config.RGB_565 -&gt; RGB_565_IN_CONFIGS</span><br><span class="line">                Bitmap.Config.ARGB_4444 -&gt; ARGB_4444_IN_CONFIGS</span><br><span class="line">                Bitmap.Config.ALPHA_8 -&gt; ALPHA_8_IN_CONFIGS</span><br><span class="line">                <span class="keyword">else</span> -&gt; arrayOf(requested)</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyPool = KeyPool()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupedMap = GroupedLinkedMap&lt;Key?, Bitmap&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sortedSizes: MutableMap&lt;Bitmap.Config?, NavigableMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = EnumMap(Bitmap.Config::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">    <span class="keyword">val</span> key = keyPool[size, bitmap.config]</span><br><span class="line">    groupedMap.put(key, bitmap)</span><br><span class="line">    <span class="keyword">val</span> sizes = getSizesForConfig(bitmap.config)</span><br><span class="line">    <span class="keyword">val</span> current = sizes[key!!.size]</span><br><span class="line">    sizes[key.size] = <span class="keyword">if</span> (current == <span class="literal">null</span>) <span class="number">1</span> <span class="keyword">else</span> current + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap? &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">    <span class="keyword">val</span> bestKey = findBestKey(size, config)</span><br><span class="line">    <span class="keyword">val</span> result = groupedMap[bestKey]</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            decrementBitmapOfSize(bestKey!!.size, result)</span><br><span class="line">            result.reconfigure(width, height, config)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findBestKey</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Key? &#123;</span><br><span class="line">    <span class="keyword">var</span> result = keyPool[size, config]</span><br><span class="line">        <span class="keyword">for</span> (possibleConfig <span class="keyword">in</span> getInConfigs(config)) &#123;</span><br><span class="line">            <span class="keyword">val</span> sizesForPossibleConfig = getSizesForConfig(possibleConfig)</span><br><span class="line">            <span class="keyword">val</span> possibleSize = sizesForPossibleConfig.ceilingKey(size)</span><br><span class="line">            <span class="keyword">if</span> (possibleSize != <span class="literal">null</span> &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleSize != size</span><br><span class="line">                    || <span class="keyword">if</span> (possibleConfig == <span class="literal">null</span>) config != <span class="literal">null</span> <span class="keyword">else</span> possibleConfig != config</span><br><span class="line">                ) &#123;</span><br><span class="line">                    keyPool.offer(result)</span><br><span class="line">                    result = keyPool[possibleSize, possibleConfig]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">    <span class="keyword">val</span> removed = groupedMap.removeLast()</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> removedSize = getBitmapByteSize(removed)</span><br><span class="line">            decrementBitmapOfSize(removedSize, removed)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> removed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">decrementBitmapOfSize</span><span class="params">(size: <span class="type">Int</span>, removed: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> config = removed.config</span><br><span class="line">        <span class="keyword">val</span> sizes = getSizesForConfig(config)</span><br><span class="line">        <span class="keyword">val</span> current = sizes[size]?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">            <span class="string">&quot;Tried to decrement empty size&quot;</span></span><br><span class="line">            + <span class="string">&quot;, size: &quot;</span></span><br><span class="line">            + size</span><br><span class="line">            + <span class="string">&quot;, removed: &quot;</span></span><br><span class="line">            + logBitmap(removed)</span><br><span class="line">            + <span class="string">&quot;, this: &quot;</span></span><br><span class="line">            + <span class="keyword">this</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">1</span>) &#123;</span><br><span class="line">            sizes.remove(size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sizes[size] = current - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSizesForConfig</span><span class="params">(config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: NavigableMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> sizes = sortedSizes[config]</span><br><span class="line">        <span class="keyword">if</span> (sizes == <span class="literal">null</span>) &#123;</span><br><span class="line">            sizes = TreeMap()</span><br><span class="line">            sortedSizes[config] = sizes</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sizes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">    <span class="keyword">return</span> getBitmapString(size, bitmap.config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">    <span class="keyword">return</span> getBitmapString(size, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getBitmapByteSize(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        .append(<span class="string">&quot;SizeConfigStrategy&#123;groupedMap=&quot;</span>)</span><br><span class="line">        .append(groupedMap)</span><br><span class="line">        .append(<span class="string">&quot;, sortedSizes=(&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> ((key, value) <span class="keyword">in</span> sortedSizes) &#123;</span><br><span class="line">            sb.append(key).append(<span class="string">&#x27;[&#x27;</span>).append(value).append(<span class="string">&quot;], &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sortedSizes.isNotEmpty()) &#123;</span><br><span class="line">        sb.replace(sb.length - <span class="number">2</span>, sb.length, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.append(<span class="string">&quot;)&#125;&quot;</span>).toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">KeyPool</span> : <span class="type">BaseKeyPool</span>&lt;<span class="type">Key?</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Key? &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">get</span>()</span><br><span class="line">            result!!.<span class="keyword">init</span>(size, config)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: Key &#123;</span><br><span class="line">    <span class="keyword">return</span> Key(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Key</span>(<span class="keyword">private</span> <span class="keyword">val</span> pool: KeyPool) : Poolable &#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> config: Bitmap.Config? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">constructor</span>(pool: KeyPool, size: <span class="built_in">Int</span>, config: Bitmap.Config?) : <span class="keyword">this</span>(pool) &#123;</span><br><span class="line">    <span class="keyword">init</span>(size, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(size: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size</span><br><span class="line">    <span class="keyword">this</span>.config = config</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool.offer(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> getBitmapString(size, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">is</span> Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (size == other.size &amp;&amp; config == <span class="literal">null</span>) other.config == <span class="literal">null</span> <span class="keyword">else</span> config == other.config</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = size</span><br><span class="line">        result = <span class="number">31</span> * result + <span class="keyword">if</span> (config != <span class="literal">null</span>) config.hashCode() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AttributeStategy"><a href="#AttributeStategy" class="headerlink" title="AttributeStategy"></a>AttributeStategy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.max.hbbitmappool.pool.impl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap</span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.VisibleForTesting</span><br><span class="line"><span class="keyword">import</span> com.max.hbbitmappool.utils.getBitmapByteSize</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AttributeStrategy</span> : <span class="type">LruPoolStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyPool = KeyPool()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupedMap = GroupedLinkedMap&lt;Key?, Bitmap&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> key = keyPool[bitmap.width, bitmap.height, bitmap.config]</span><br><span class="line">        groupedMap.put(key, bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">val</span> key = keyPool[width, height, config]</span><br><span class="line">        <span class="keyword">return</span> groupedMap[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">return</span> groupedMap.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(width, height, config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapByteSize(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AttributeStrategy:\n  <span class="variable">$groupedMap</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">KeyPool</span> : <span class="type">BaseKeyPool</span>&lt;<span class="type">Key?</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Key? &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">get</span>()</span><br><span class="line">            result?.<span class="keyword">init</span>(width, height, config)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: Key &#123;</span><br><span class="line">            <span class="keyword">return</span> Key(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Key</span>(<span class="keyword">private</span> <span class="keyword">val</span> pool: KeyPool) : Poolable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> config: Bitmap.Config? = <span class="literal">null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.width = width</span><br><span class="line">            <span class="keyword">this</span>.height = height</span><br><span class="line">            <span class="keyword">this</span>.config = config</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (other <span class="keyword">is</span> Key) &#123;</span><br><span class="line">                <span class="keyword">return</span> width == other.width &amp;&amp; height == other.height &amp;&amp; config == other.config</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = width</span><br><span class="line">            result = <span class="number">31</span> * result + height</span><br><span class="line">            result = <span class="number">31</span> * result + <span class="keyword">if</span> (config != <span class="literal">null</span>) config.hashCode() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(width, height, config)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">()</span></span> &#123;</span><br><span class="line">            pool.offer(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(bitmap.width, bitmap.height, bitmap.config)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + width + <span class="string">&quot;x&quot;</span> + height + <span class="string">&quot;], &quot;</span> + config</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SizeStrategy-3"><a href="#SizeStrategy-3" class="headerlink" title="SizeStrategy"></a>SizeStrategy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">SizeStrategy</span> : <span class="type">LruPoolStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyPool = KeyPool()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupedMap = GroupedLinkedMap&lt;Key, Bitmap&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> sortedSizes: NavigableMap&lt;<span class="built_in">Int</span>?, <span class="built_in">Int</span>&gt; = PrettyPrintTreeMap()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">        <span class="keyword">val</span> key = keyPool[size]</span><br><span class="line">        groupedMap.put(key, bitmap)</span><br><span class="line">        <span class="keyword">val</span> current = sortedSizes[key.size]</span><br><span class="line">        sortedSizes[key.size] = <span class="keyword">if</span> (current == <span class="literal">null</span>) <span class="number">1</span> <span class="keyword">else</span> current + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">        <span class="keyword">var</span> key = keyPool[size]</span><br><span class="line">        <span class="keyword">val</span> possibleSize = sortedSizes.ceilingKey(size)</span><br><span class="line">        <span class="keyword">if</span> (possibleSize != <span class="literal">null</span> &amp;&amp; possibleSize != size &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class="line">            keyPool.offer(key)</span><br><span class="line">            key = keyPool[possibleSize]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result = groupedMap[key]</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.reconfigure(width, height, config)</span><br><span class="line">            decrementBitmapOfSize(possibleSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">val</span> removed = groupedMap.removeLast()</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> removedSize = getBitmapByteSize(removed)</span><br><span class="line">            decrementBitmapOfSize(removedSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">decrementBitmapOfSize</span><span class="params">(size: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> current = sortedSizes[size]</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">1</span>) &#123;</span><br><span class="line">            sortedSizes.remove(size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sortedSizes[size] = current!! - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logBitmap</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>, config: <span class="type">Bitmap</span>.<span class="type">Config</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> size = getBitmapByteSize(width, height, config)</span><br><span class="line">        <span class="keyword">return</span> getBitmapString(size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBitmapByteSize(bitmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SizeStrategy:\n  <span class="variable">$groupedMap</span>\n  SortedSizes<span class="variable">$sortedSizes</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-final for mocking.</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">KeyPool</span> : <span class="type">BaseKeyPool</span>&lt;<span class="type">Key?</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Key &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">super</span>.<span class="keyword">get</span>()!!</span><br><span class="line">            result.<span class="keyword">init</span>(size)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: Key &#123;</span><br><span class="line">            <span class="keyword">return</span> Key(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Key</span>(<span class="keyword">private</span> <span class="keyword">val</span> pool: KeyPool) : Poolable &#123;</span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(size: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(o: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">is</span> Key) &#123;</span><br><span class="line">                <span class="keyword">return</span> size == o.size</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">()</span></span> &#123;</span><br><span class="line">            pool.offer(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SIZE_MULTIPLE = <span class="number">8</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">val</span> size = getBitmapByteSize(bitmap)</span><br><span class="line">            <span class="keyword">return</span> getBitmapString(size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapString</span><span class="params">(size: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[<span class="variable">$size</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种池子精细化管理排序</p><ol><li><strong>AttributeStrategy</strong></li><li><strong>SizeConfigStrategy</strong></li><li><strong>SizeStrategy</strong></li></ol><h3 id="1-AttributeStrategy"><a href="#1-AttributeStrategy" class="headerlink" title="1. AttributeStrategy"></a>1. AttributeStrategy</h3><ul><li><strong>精细化等级：最高</strong></li><li><strong>原因</strong>：<code>AttributeStrategy</code>基于位图的宽度、高度和<code>Bitmap.Config</code>配置来管理位图，提供了最细致的控制。这允许它区分具有相同像素数量但不同尺寸或配置的位图，实现了对位图缓存的高度精细化管理。</li></ul><h3 id="2-SizeConfigStrategy"><a href="#2-SizeConfigStrategy" class="headerlink" title="2. SizeConfigStrategy"></a>2. SizeConfigStrategy</h3><ul><li><strong>精细化等级：中等</strong></li><li><strong>原因</strong>：<code>SizeConfigStrategy</code>结合了位图的内存大小和配置（如<code>ARGB_8888</code>、<code>RGB_565</code>等）来管理位图。虽然它不如<code>AttributeStrategy</code>能够精确到位图的具体尺寸，但通过考虑配置信息，它在位图的管理上提供了比仅基于大小更精细的控制。</li></ul><h3 id="3-SizeStrategy"><a href="#3-SizeStrategy" class="headerlink" title="3. SizeStrategy"></a>3. SizeStrategy</h3><ul><li><strong>精细化等级：最低</strong></li><li><strong>原因</strong>：<code>SizeStrategy</code>仅基于位图占用的内存大小来管理位图，完全忽略了位图的尺寸和配置信息。这种策略提供了最简单的管理方式，适合于那些内存使用效率是主要关注点、对位图的具体属性（如尺寸和配置）关注较少的场景。</li></ul><p>总结来说，如果需要对缓存中的位图进行非常精细化的管理，优先选择<code>AttributeStrategy</code>；<br>如果希望在精细化管理和简化逻辑之间取得平衡，<code>SizeConfigStrategy</code>是一个好的选择；<br>而如果主要关注简化缓存管理和优化内存使用，<code>SizeStrategy</code>将是最合适的策略。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - router-annotation 路由注解模块</title>
      <link href="/2023/09/10/3%20Android/ARouter/01-ARouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/01-ARouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li><a href="#Autowired">Autowired.java</a> 自动注入的注解</li><li><a href="#Interceptor">Interceptor.java</a> 拦截器的注解</li><li><a href="#Param(%E5%BA%9F%E5%BC%83)">Param.java(废弃)</a> 参数注解: 被 Autowired 淘汰</li><li><a href="#Route">Route.java</a> 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li><a href="#RouteType">RouteType.java</a> 路由类型的枚举</li><li><a href="#TypeKind">TypeKind.java</a> 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li><a href="#RouteMeta">RouteMeta.java</a> 路由元信息的模型类</li><li><a href="#TypeWrapper">TypeWrapper.java</a> 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="router-annotation-路由注解模块"><a href="#router-annotation-路由注解模块" class="headerlink" title="router-annotation 路由注解模块"></a>router-annotation 路由注解模块</h3><h4 id="annotation-存放各种注解类的包"><a href="#annotation-存放各种注解类的包" class="headerlink" title="annotation 存放各种注解类的包"></a>annotation 存放各种注解类的包</h4><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h5><p>自动注入的注解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation for field, which need autowired.</span></span><br><span class="line"><span class="comment"> * 用于需要自动注入的字段的注解。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/20 下午4:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FIELD)</span> <span class="comment">// 表示该注解只能用于字段上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Autowired</span>( <span class="comment">// Mark param&#x27;s name or service name.</span></span><br><span class="line">    <span class="comment">// 标记参数的名称或服务名称</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,  <span class="comment">// If required, app will be crash when value is null.</span></span><br><span class="line">    <span class="comment">// Primitive type wont be check!</span></span><br><span class="line">    <span class="comment">// 如果设置为true，在数值为null时应用程序将崩溃。不会检查原始类型！</span></span><br><span class="line">    <span class="keyword">val</span> required: <span class="built_in">Boolean</span> = <span class="literal">false</span>,  <span class="comment">// Description of the field</span></span><br><span class="line">    <span class="comment">// 字段的描述信息</span></span><br><span class="line">    <span class="keyword">val</span> desc: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>标记需要注入的字段</strong>：在你的类中，标记需要进行自动注入的字段。使用 <code>@Autowired</code> 注解，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyDependency myDependency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>myDependency</code> 字段被标记为需要自动注入的依赖对象。</p><p>假设你有两个相同类型的依赖对象 <code>MyDependency</code>，但它们在功能上略有不同，你需要指定要注入哪一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(name = &quot;dependencyA&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyDependency dependencyA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(name = &quot;dependencyB&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyDependency dependencyB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记拦截器以拦截路由。</span></span><br><span class="line"><span class="comment"> * 注意：此注解仅可用于标记#&#123;IInterceptor&#125;的实现！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/23 14:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)</span> <span class="comment">// 表示该注解只能用于类上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器的优先级，ARouter将按优先级执行它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> priority: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器的名称，可能用于生成javadoc。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;Default&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要使用 <code>@Interceptor</code> 注解，你需要将其标记在实现了 <code>IInterceptor</code> 接口的类上，以定义一个拦截器。然后，你可以使用这个拦截器来拦截路由操作。下面是使用 <code>@Interceptor</code> 注解的一般步骤：</p><p>创建一个实现了 <code>IInterceptor</code> 接口的类，该类将用作拦截器。确保类实现了接口中的 <code>process</code> 方法，该方法定义了拦截器的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kotlinCopy code</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.annotation.Interceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.callback.InterceptorCallback</span><br><span class="line"></span><br><span class="line"><span class="meta">@Interceptor(priority = 1, name = &quot;ExampleInterceptor&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleInterceptor</span> : IInterceptor &#123;</span><br><span class="line">    override fun <span class="title function_">process</span><span class="params">(postcard: Postcard?, callback: InterceptorCallback?)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里编写拦截器的逻辑</span></span><br><span class="line">        <span class="comment">// 可以在进入路由之前或之后执行一些操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后，调用 callback.onContinue(postcard) 继续路由操作，或者 callback.onInterrupt(exception) 中断路由操作</span></span><br><span class="line">        callback?.onContinue(postcard)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Param-废弃"><a href="#Param-废弃" class="headerlink" title="Param(废弃)"></a>Param(废弃)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于标记页面参数的注解。</span></span><br><span class="line"><span class="comment"> * 此注解已被弃用，请使用 &#x27;Autowired&#x27; 代替！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2016/11/22 18:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FIELD)</span> <span class="comment">// 表示该注解只能用于字段上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;&quot;</span>)</span> <span class="comment">// 表示该注解已被弃用</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Param</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段的描述信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> desc: String = <span class="string">&quot;No desc.&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>既已废弃，不浪费时间</p><h5 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记页面可由路由器路由。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/15 下午9:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)</span> <span class="comment">// 表示该注解只能用于类上</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.BINARY) <span class="comment">// 表示该注解的生命周期为编译期</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Route</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> path: String,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于合并路由，组名必须使用常见单词!!!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> group: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的名称，用于生成javadoc。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外的数据，可以由用户设置。</span></span><br><span class="line"><span class="comment">     * 注意：您应该使用整数数值表示开关，通过位进行标记。例如：10001010101010</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> extras: <span class="built_in">Int</span> = <span class="built_in">Int</span>.MIN_VALUE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由的优先级。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> priority: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个类定义了一个用于标记页面可由路由器路由的注解 <code>@Route</code>。该注解包含了五个元素，分别表示路由的路径、组名、名称、额外数据和优先级。</p><p>创建一个页面类，并在该类上添加 <code>@Route</code> 注解，以标记这个页面可以被路由器路由。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @Route 注解标记这个页面</span></span><br><span class="line"><span class="meta">@Route(path = <span class="string">&quot;/example/activity&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="comment">// 页面的代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为 <code>ExampleActivity</code> 的页面类，并使用 <code>@Route</code> 注解标记了这个页面的路由路径为 <code>&quot;/example/activity&quot;</code>。</p><h4 id="enums-包含各种枚举类型的包"><a href="#enums-包含各种枚举类型的包" class="headerlink" title="enums 包含各种枚举类型的包"></a>enums 包含各种枚举类型的包</h4><h5 id="RouteType"><a href="#RouteType" class="headerlink" title="RouteType"></a>RouteType</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.enums</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由类型的枚举。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/23 22:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">RouteType</span>(<span class="comment">// 未知类型的路由</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> className: String</span><br><span class="line">) &#123;</span><br><span class="line">    ACTIVITY(<span class="number">0</span>, <span class="string">&quot;android.app.Activity&quot;</span>),  <span class="comment">// Activity类型的路由</span></span><br><span class="line">    SERVICE(<span class="number">1</span>, <span class="string">&quot;android.app.Service&quot;</span>),  <span class="comment">// Service类型的路由</span></span><br><span class="line">    PROVIDER(<span class="number">2</span>, <span class="string">&quot;com.alibaba.android.arouter.facade.template.IProvider&quot;</span>),  <span class="comment">// Provider类型的路由</span></span><br><span class="line">    CONTENT_PROVIDER(-<span class="number">1</span>, <span class="string">&quot;android.app.ContentProvider&quot;</span>),  <span class="comment">// ContentProvider类型的路由</span></span><br><span class="line">    BOARDCAST(-<span class="number">1</span>, <span class="string">&quot;&quot;</span>),  <span class="comment">// Broadcast类型的路由</span></span><br><span class="line">    METHOD(-<span class="number">1</span>, <span class="string">&quot;&quot;</span>),  <span class="comment">// Method类型的路由</span></span><br><span class="line">    FRAGMENT(-<span class="number">1</span>, <span class="string">&quot;android.app.Fragment&quot;</span>),  <span class="comment">// Fragment类型的路由</span></span><br><span class="line">    UNKNOWN(-<span class="number">1</span>, <span class="string">&quot;Unknown route type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setId</span><span class="params">(id: <span class="type">Int</span>)</span></span>: RouteType &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClassName</span><span class="params">(className: <span class="type">String</span>)</span></span>: RouteType &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(name: <span class="type">String</span>)</span></span>: RouteType &#123;</span><br><span class="line">            <span class="keyword">for</span> (routeType <span class="keyword">in</span> values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (routeType.className == name) &#123;</span><br><span class="line">                    <span class="keyword">return</span> routeType</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TypeKind"><a href="#TypeKind" class="headerlink" title="TypeKind"></a>TypeKind</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.enums</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段类型的种类枚举。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017-03-16 19:13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">TypeKind</span> &#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    BOOLEAN,  <span class="comment">// 布尔类型</span></span><br><span class="line">    BYTE,  <span class="comment">// 字节类型</span></span><br><span class="line">    SHORT,  <span class="comment">// 短整型</span></span><br><span class="line">    INT,  <span class="comment">// 整型</span></span><br><span class="line">    LONG,  <span class="comment">// 长整型</span></span><br><span class="line">    CHAR,  <span class="comment">// 字符类型</span></span><br><span class="line">    FLOAT,  <span class="comment">// 单精度浮点型</span></span><br><span class="line">    DOUBLE,  <span class="comment">// 双精度浮点型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他类型</span></span><br><span class="line">    STRING,  <span class="comment">// 字符串类型</span></span><br><span class="line">    SERIALIZABLE,  <span class="comment">// 可序列化类型</span></span><br><span class="line">    PARCELABLE,  <span class="comment">// Parcelable类型</span></span><br><span class="line">    OBJECT <span class="comment">// 对象类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="model-包含模型类的包"><a href="#model-包含模型类的包" class="headerlink" title="model 包含模型类的包"></a>model 包含模型类的包</h4><h5 id="RouteMeta"><a href="#RouteMeta" class="headerlink" title="RouteMeta"></a>RouteMeta</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Autowired</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"><span class="keyword">import</span> com.miao.router.RouteType</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含基本路由信息的类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我。](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/24 09:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RouteMeta</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> type: RouteType? = <span class="literal">null</span> <span class="comment">// 路由类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rawType: javax.lang.model.element.Element? = <span class="literal">null</span> <span class="comment">// 路由的原始类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> destination : Class&lt;*&gt;? = <span class="literal">null</span> <span class="comment">// 目标类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> path : String? = <span class="literal">null</span> <span class="comment">// 路由路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> group: String? = <span class="literal">null</span> <span class="comment">// 路由分组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> priority = -<span class="number">1</span> <span class="comment">// 优先级，数值越小优先级越高</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> extra = <span class="number">0</span><span class="comment">// 额外数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> paramsType: Map&lt;String?, <span class="built_in">Int</span>?&gt;? = <span class="literal">null</span> <span class="comment">// 参数类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> injectConfig: Map&lt;String, Autowired&gt;? = <span class="literal">null</span> <span class="comment">// 缓存注入配置信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> route       路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        route: Route,</span><br><span class="line">        destination: Class&lt;*&gt;?,</span><br><span class="line">        type: RouteType?</span><br><span class="line">    ) : <span class="keyword">this</span>(</span><br><span class="line">        type,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        destination,</span><br><span class="line">        route.name(),</span><br><span class="line">        route.path(),</span><br><span class="line">        route.group(),</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        route.priority(),</span><br><span class="line">        route.extras()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> route      路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawType    原始类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type       类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramsType 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        route: Route,</span><br><span class="line">        rawType: javax.lang.model.element.Element?,</span><br><span class="line">        type: RouteType?,</span><br><span class="line">        paramsType: Map&lt;String?, <span class="built_in">Int</span>?&gt;?</span><br><span class="line">    ) : <span class="keyword">this</span>(</span><br><span class="line">        type,</span><br><span class="line">        rawType,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        route.name(),</span><br><span class="line">        route.path(),</span><br><span class="line">        route.group(),</span><br><span class="line">        paramsType,</span><br><span class="line">        route.priority(),</span><br><span class="line">        route.extras()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawType     原始类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path        路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group       分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramsType  参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priority    优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extra       额外数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        type: RouteType?,</span><br><span class="line">        rawType: javax.lang.model.element.Element?,</span><br><span class="line">        destination: Class&lt;*&gt;?,</span><br><span class="line">        name: String?,</span><br><span class="line">        path: String?,</span><br><span class="line">        group: String?,</span><br><span class="line">        paramsType: Map&lt;String?, <span class="built_in">Int</span>?&gt;?,</span><br><span class="line">        priority: <span class="built_in">Int</span>,</span><br><span class="line">        extra: <span class="built_in">Int</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.destination = destination</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType</span><br><span class="line">        <span class="keyword">this</span>.path = path</span><br><span class="line">        <span class="keyword">this</span>.group = group</span><br><span class="line">        <span class="keyword">this</span>.paramsType = paramsType</span><br><span class="line">        <span class="keyword">this</span>.priority = priority</span><br><span class="line">        <span class="keyword">this</span>.extra = extra</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setParamsType</span><span class="params">(paramsType: <span class="type">Map</span>&lt;<span class="type">String</span>?, <span class="built_in">Int</span>?&gt;?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.paramsType = paramsType</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRawType</span><span class="params">()</span></span>: javax.lang.model.element.Element? &#123;</span><br><span class="line">        <span class="keyword">return</span> rawType</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setRawType</span><span class="params">(rawType: <span class="type">javax</span>.<span class="type">lang</span>.<span class="type">model</span>.<span class="type">element</span>.<span class="type">Element</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setType</span><span class="params">(type: <span class="type">RouteType</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setDestination</span><span class="params">(destination: <span class="type">Class</span>&lt;*&gt;?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.destination = destination</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setPath</span><span class="params">(path: <span class="type">String</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setGroup</span><span class="params">(group: <span class="type">String</span>?)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.group = group</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setPriority</span><span class="params">(priority: <span class="type">Int</span>)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setExtra</span><span class="params">(extra: <span class="type">Int</span>)</span></span>: RouteMeta &#123;</span><br><span class="line">        <span class="keyword">this</span>.extra = extra</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RouteMeta&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;type=&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;, rawType=&quot;</span> + rawType +</span><br><span class="line">                <span class="string">&quot;, destination=&quot;</span> + destination +</span><br><span class="line">                <span class="string">&quot;, path=&#x27;&quot;</span> + path + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, group=&#x27;&quot;</span> + group + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, priority=&quot;</span> + priority +</span><br><span class="line">                <span class="string">&quot;, extra=&quot;</span> + extra +</span><br><span class="line">                <span class="string">&quot;, paramsType=&quot;</span> + paramsType +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * For versions of &#x27;compiler&#x27; less than 1.0.7, contain 1.0.7</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> path        路径</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> group       分组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> priority    优先级</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> extra       额外数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            type: <span class="type">RouteType</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            destination: <span class="type">Class</span>&lt;*&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            group: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            priority: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            extra: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: RouteMeta &#123;</span><br><span class="line">            <span class="keyword">return</span> RouteMeta(type, <span class="literal">null</span>, destination, <span class="literal">null</span>, path, group, <span class="literal">null</span>, priority, extra)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * For versions of &#x27;compiler&#x27; greater than 1.0.7</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> destination 目标类</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> path        路径</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> group       分组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> paramsType  参数类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> priority    优先级</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> extra       额外数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            type: <span class="type">RouteType</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            destination: <span class="type">Class</span>&lt;*&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">            path: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            group: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            paramsType: <span class="type">Map</span>&lt;<span class="type">String</span>?, <span class="built_in">Int</span>?&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">            priority: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            extra: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: RouteMeta &#123;</span><br><span class="line">            <span class="keyword">return</span> RouteMeta(</span><br><span class="line">                type,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                destination,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                path,</span><br><span class="line">                group,</span><br><span class="line">                paramsType,</span><br><span class="line">                priority,</span><br><span class="line">                extra</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private RouteType type</code>：表示路由的类型，可能是普通路由、自动注入、或者其他类型。<br><code>private Element rawType</code>：表示路由的原始类型的元素。<br><code>private Class&lt;?&gt; destination</code>：表示目标类，即路由到哪个页面。<br><code>private String path</code>：表示路由的路径，用于唯一标识一个路由。<br><code>private String group</code>：表示路由的分组，通常用于组织路由。<br><code>private int priority</code>：表示路由的优先级，数值越小表示优先级越高。<br><code>private int extra</code>：表示额外的数据，可以用于传递一些标记或开关。<br><code>private Map&lt;String, Integer&gt; paramsType</code>：表示参数类型的映射。<br><code>private String name</code>：表示路由的名称。</p><p>RouteMeta 是 Route 原子信息与其构建类</p><h5 id="TypeWrapper"><a href="#TypeWrapper" class="headerlink" title="TypeWrapper"></a>TypeWrapper</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.facade.model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于获取目标对象的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 17/10/26 11:56:22</span></span><br><span class="line"><span class="comment">&lt;/T&gt; */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeWrapper</span>&lt;<span class="type">T</span>&gt; <span class="keyword">protected</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标对象的类型。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标对象的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> type: Type <span class="comment">// 存储目标对象的类型信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> superClass = javaClass.genericSuper<span class="keyword">class</span></span><br><span class="line">        <span class="title class_">type</span> =</span><br><span class="line">            (superClass <span class="keyword">as</span> ParameterizedType).actualTypeArguments[<span class="number">0</span>] <span class="comment">// 获取泛型类型参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Java 反射获取当前类的父类，然后从父类中获取泛型参数的类型信息，并将其赋值给 <code>type</code> 字段。这样，这个类就能够存储目标对象的泛型类型信息。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - base 基础功能 与 core 核心功能</title>
      <link href="/2023/09/10/3%20Android/ARouter/02-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/02-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li><p>base 基础功能相关的包</p><ul><li><a href="#UniqueKeyTreeMap">UniqueKeyTreeMap.java</a> 唯一键树形映射的类</li></ul></li><li><p>core 核心功能相关的包</p><ul><li><a href="#AutowiredLifecyleCallback(%E5%BA%9F%E5%BC%83)">AutowiredLifecyleCallback.java(废弃)</a> 自动注入生命周期回调的类</li><li><a href="#AutowiredServiceImp">AutowiredServiceImpl.java</a> 自动注入服务的实现类</li><li><a href="#InstrumentationHook(%E5%BA%9F%E5%BC%83)">InstrumentationHook.java(废弃)</a> 仪表钩子的类</li><li><a href="#InterceptorServiceImpl">InterceptorServiceImpl.java</a> 拦截器服务的实现类</li><li><a href="#LogisticsCenter">LogisticsCenter.java</a> 物流中心的类</li><li><a href="#Warehouse">Warehouse.java</a> 仓库的类</li></ul></li><li><p>exception 异常相关的包</p><ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li><p>facade 提供各种服务和回调的包</p><ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li><p>service 服务相关的包</p><ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li><p>template 模板相关的包</p><ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li><p>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。</p><ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li><p>thread （线程）包含了与线程管理相关的类。</p><ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li><p>utils 工具类。</p><ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="arouter-api-ARouter框架的API模块"><a href="#arouter-api-ARouter框架的API模块" class="headerlink" title="arouter-api  ARouter框架的API模块"></a>arouter-api  ARouter框架的API模块</h3><h4 id="base-基础功能相关的包"><a href="#base-基础功能相关的包" class="headerlink" title="base 基础功能相关的包"></a>base 基础功能相关的包</h4><h5 id="UniqueKeyTreeMap"><a href="#UniqueKeyTreeMap" class="headerlink" title="UniqueKeyTreeMap"></a>UniqueKeyTreeMap</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.base</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap with unique key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/22 下午5:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueKeyTreeMap</span>&lt;<span class="type">K, V</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> tipText: String) :</span><br><span class="line">    TreeMap&lt;K, V&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: V? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(String.format(tipText, key))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.put(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="core-核心功能相关的包"><a href="#core-核心功能相关的包" class="headerlink" title="core 核心功能相关的包"></a>core 核心功能相关的包</h4><h5 id="AutowiredLifecyleCallback-废弃"><a href="#AutowiredLifecyleCallback-废弃" class="headerlink" title="AutowiredLifecyleCallback(废弃)"></a>AutowiredLifecyleCallback(废弃)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.TargetApi</span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.app.Application.ActivityLifecycleCallbacks</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LifecycleCallback for autowired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/21 上午11:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutowiredLifecycleCallback</span> : <span class="type">ActivityLifecycleCallbacks</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ARouter.getInstance().inject(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStarted</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResumed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityPaused</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(activity: <span class="type">Activity</span>, outState: <span class="type">Bundle</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经废弃，不废话</p><h5 id="AutowiredServiceImpl"><a href="#AutowiredServiceImpl" class="headerlink" title="AutowiredServiceImpl"></a>AutowiredServiceImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.LruCache</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.service.AutowiredService</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.ISyringe</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_AUTOWIRED</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动注入服务的实现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作者: zhilong [联系我](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * 版本: 1.0</span></span><br><span class="line"><span class="comment"> * 创建日期: 2017年2月28日 下午6:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Route(path = <span class="string">&quot;/arouter/service/autowired&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutowiredServiceImpl</span> : <span class="type">AutowiredService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> classCache: LruCache&lt;String, ISyringe&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> blackList: MutableList&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        classCache = LruCache&lt;String, ISyringe&gt;(<span class="number">50</span>)</span><br><span class="line">        blackList = ArrayList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注入方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance 要进行注入的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">autowire</span><span class="params">(instance: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        doInject(instance, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归注入方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance 调用该方法的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent   父类的Class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInject</span><span class="params">(instance: <span class="type">Any</span>, parent: <span class="type">Class</span>&lt;*&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果提供了父类的 Class 对象，则使用父类的 Class；否则，使用实例的 Class</span></span><br><span class="line">        <span class="keyword">val</span> clazz = parent ?: instance.javaClass</span><br><span class="line">        <span class="comment">// 获取适用于当前类的注入器实例</span></span><br><span class="line">        <span class="keyword">val</span> syringe: ISyringe? = getSyringe(clazz)</span><br><span class="line">        <span class="comment">// 如果存在适用的注入器实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != syringe) &#123;</span><br><span class="line">            <span class="comment">// 使用注入器进行注入</span></span><br><span class="line">            syringe.inject(instance)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前类的父类的 Class 对象</span></span><br><span class="line">        <span class="keyword">val</span> superClazz = clazz.superclass</span><br><span class="line">        <span class="comment">// 如果存在父类，并且父类不是 Android 框架类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != superClazz &amp;&amp; !superClazz.name.startsWith(<span class="string">&quot;android&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用 doInject 方法，继续为父类进行自动注入</span></span><br><span class="line">            doInject(instance, superClazz)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注入器实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类的Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入器实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSyringe</span><span class="params">(clazz: <span class="type">Class</span>&lt;*&gt;)</span></span>: ISyringe? &#123;</span><br><span class="line">        <span class="comment">// 获取类的完整名称</span></span><br><span class="line">        <span class="keyword">val</span> className = clazz.name</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查类名是否在黑名单中，如果不在，则尝试获取对应的注入器</span></span><br><span class="line">            <span class="keyword">if</span> (!blackList!!.contains(className)) &#123;</span><br><span class="line">                <span class="comment">// 从缓存中尝试获取注入器实例</span></span><br><span class="line">                <span class="keyword">var</span> syringeHelper: ISyringe? = classCache!![className]</span><br><span class="line">                <span class="comment">// 如果缓存中没有该注入器实例</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == syringeHelper) &#123;</span><br><span class="line">                    <span class="comment">// 动态加载并创建注入器实例</span></span><br><span class="line">                    syringeHelper = Class.forName(</span><br><span class="line">                      clazz.name + SUFFIX_AUTOWIRED</span><br><span class="line">                    ).getConstructor()</span><br><span class="line">                        .newInstance() <span class="keyword">as</span> ISyringe</span><br><span class="line">                    <span class="comment">// 将创建的注入器实例缓存起来，以便下次使用</span></span><br><span class="line">                    classCache!!.put(className, syringeHelper)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回获取到的注入器实例</span></span><br><span class="line">                <span class="keyword">return</span> syringeHelper</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="comment">// 如果在获取注入器的过程中发生异常，将类名添加到黑名单中，表示该实例无需自动注入</span></span><br><span class="line">            blackList!!.add(className)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果无法获取注入器实例，返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doInject</code> 方法用于自动注入依赖到给定的实例（<code>instance</code>）中。</p><h5 id="InstrumentationHook-废弃"><a href="#InstrumentationHook-废弃" class="headerlink" title="InstrumentationHook(废弃)"></a>InstrumentationHook(废弃)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.app.Instrumentation</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.TextUtils</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 ARouter.getInstance().inject(this) 来进行注入！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hook Instrumentation，为 Activity 的字段注入值。</span></span><br><span class="line"><span class="comment"> * 仅支持普通 Activity，不包括单元测试。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作者：Alex [联系我](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * 版本：1.0</span></span><br><span class="line"><span class="comment"> * 创建日期：2016年11月24日 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InstrumentationHook</span> : <span class="type">Instrumentation</span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hook Instrumentation 的 newActivity 方法，进行注入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 执行进程的 [Activity] 对象的实例化。默认实现提供正常的系统行为。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl        用于实例化对象的类加载器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 实现 Activity 对象的类的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent    指定要实例化的活动类的 Intent 对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新创建的 Activity 对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Throws(</span></span><br><span class="line"><span class="meta">        InstantiationException::class,</span></span><br><span class="line"><span class="meta">        IllegalAccessException::class,</span></span><br><span class="line"><span class="meta">        ClassNotFoundException::class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        cl: <span class="type">ClassLoader</span>, className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        intent: <span class="type">Intent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Activity &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        return (Activity)cl.loadClass(className).newInstance();</span></span><br><span class="line">        <span class="comment">// 使用类加载器加载目标 Activity 类的定义</span></span><br><span class="line">        <span class="keyword">val</span> targetActivity = cl.loadClass(className)</span><br><span class="line">        <span class="comment">// 创建目标 Activity 的实例</span></span><br><span class="line">        <span class="keyword">val</span> instanceOfTarget = targetActivity.newInstance()</span><br><span class="line">        <span class="comment">// 检查是否可以自动注入</span></span><br><span class="line">        <span class="keyword">if</span> (ARouter.canAutoInject()) &#123;</span><br><span class="line">            <span class="comment">// 从 Intent 中获取自动注入的参数</span></span><br><span class="line">            <span class="keyword">val</span> autoInjectParams = intent.getStringArrayExtra(ARouter.AUTO_INJECT)</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != autoInjectParams &amp;&amp; autoInjectParams.isNotEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 遍历参数列表</span></span><br><span class="line">                <span class="keyword">for</span> (paramsName <span class="keyword">in</span> autoInjectParams) &#123;</span><br><span class="line">                    <span class="comment">// 从 Intent 的 extras 中获取参数值</span></span><br><span class="line">                    <span class="keyword">val</span> value = intent.extras!![TextUtils.getLeft(paramsName)]</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != value) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取目标 Activity 中的字段</span></span><br><span class="line">                            <span class="keyword">val</span> injectField =</span><br><span class="line">                                targetActivity.getDeclaredField(TextUtils.getLeft(paramsName))</span><br><span class="line">                            <span class="comment">// 设置字段可访问</span></span><br><span class="line">                            injectField.isAccessible = <span class="literal">true</span></span><br><span class="line">                            <span class="comment">// 将提取的值注入到目标 Activity 的字段中</span></span><br><span class="line">                            injectField[instanceOfTarget] = value</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                            <span class="comment">// 记录错误日志，包括异常信息</span></span><br><span class="line">                            ARouter.logger.error(</span><br><span class="line">                                Consts.TAG,</span><br><span class="line">                                <span class="string">&quot;为 Activity 注入值时发生错误！[&quot;</span> + e.message + <span class="string">&quot;]&quot;</span></span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回已注入值的目标 Activity 实例</span></span><br><span class="line">        <span class="keyword">return</span> instanceOfTarget <span class="keyword">as</span> Activity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已废弃，不废话</p><h5 id="InterceptorServiceImpl"><a href="#InterceptorServiceImpl" class="headerlink" title="InterceptorServiceImpl"></a>InterceptorServiceImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.exception.HandlerException</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.Postcard</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.callback.InterceptorCallback</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.service.InterceptorService</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter.logger</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.thread.CancelableCountDownLatch</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.TAG</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.MapUtils</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有拦截器的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [联系我](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/23 下午2:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Route(path = <span class="string">&quot;/arouter/service/interceptor&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorServiceImpl</span> : <span class="type">InterceptorService</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行拦截操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postcard 路由信息，包含了路由的相关信息和配置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 拦截回调，用于在拦截器流程中通知下一步操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doInterceptions</span><span class="params">(postcard: <span class="type">Postcard</span>, callback: <span class="type">InterceptorCallback</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">        <span class="comment">// 检查拦截器是否已经初始化</span></span><br><span class="line">        checkInterceptorsInitStatus()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果拦截器未初始化完成，中断导航并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptorHasInit) &#123;</span><br><span class="line">            callback.onInterrupt(HandlerException(<span class="string">&quot;拦截器初始化花费太长时间。&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在后台线程中执行拦截器操作</span></span><br><span class="line">        LogisticsCenter.executor.execute(Runnable &#123;</span><br><span class="line">            <span class="keyword">val</span> interceptorCounter = CancelableCountDownLatch(Warehouse.interceptors.size())</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 依次执行拦截器</span></span><br><span class="line">                _execute(<span class="number">0</span>, interceptorCounter, postcard)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 等待拦截器执行完成，超时时间由路由配置决定</span></span><br><span class="line">                interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果有未执行的拦截器，取消导航</span></span><br><span class="line">                <span class="keyword">if</span> (interceptorCounter.getCount() &gt; <span class="number">0</span>) &#123;    <span class="comment">// 如果没有返回任何内容，取消导航。</span></span><br><span class="line">                    callback.onInterrupt(HandlerException(<span class="string">&quot;拦截器处理超时。&quot;</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != postcard.getTag()) &#123;    <span class="comment">// 如果标签中有异常信息。</span></span><br><span class="line">                    callback.onInterrupt(postcard.getTag() <span class="keyword">as</span> Throwable)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 所有拦截器执行完毕，继续路由导航</span></span><br><span class="line">                    callback.onContinue(postcard)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                <span class="comment">// 拦截器执行过程中出现异常，中断导航并传递异常信息</span></span><br><span class="line">                callback.onInterrupt(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有注册拦截器，直接继续路由导航</span></span><br><span class="line">        callback.onContinue(postcard)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 上下文对象，用于在拦截器初始化时可能需要的上下文信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">    LogisticsCenter.executor.execute(Runnable &#123;</span><br><span class="line">        <span class="comment">// 检查是否有已注册的拦截器</span></span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">            <span class="keyword">for</span> ((_, interceptorClass): Map.Entry&lt;<span class="built_in">Int</span>?, Class&lt;<span class="keyword">out</span> IInterceptor?&gt;&gt; <span class="keyword">in</span> Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 实例化拦截器</span></span><br><span class="line">                    <span class="keyword">val</span> iInterceptor: IInterceptor =</span><br><span class="line">                        interceptorClass.getConstructor().newInstance()</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 调用拦截器的初始化方法，传入上下文信息</span></span><br><span class="line">                    iInterceptor.<span class="keyword">init</span>(context)</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将拦截器添加到仓库中，以供后续使用</span></span><br><span class="line">                    Warehouse.interceptors.add(iInterceptor)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ex: Exception) &#123;</span><br><span class="line">                    <span class="comment">// 如果初始化过程中发生异常，抛出自定义的异常</span></span><br><span class="line">                    <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;ARouter初始化拦截器错误！名称 = [&quot;</span> + interceptorClass.name + <span class="string">&quot;]，原因 = [&quot;</span> + ex.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记拦截器已经初始化完成</span></span><br><span class="line">            interceptorHasInit = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录日志，表示拦截器初始化已完成</span></span><br><span class="line">            logger.info(TAG, <span class="string">&quot;ARouter拦截器初始化完成。&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知等待的线程，拦截器已经初始化完成</span></span><br><span class="line">            synchronized(interceptorInitLock) &#123; interceptorInitLock.notifyAll() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> interceptorHasInit = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> interceptorInitLock = Any()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行拦截器</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index    当前拦截器索引</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> counter  拦截器计数器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> postcard 路由信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">_execute</span><span class="params">(index: <span class="type">Int</span>, counter: <span class="type">CancelableCountDownLatch</span>, postcard: <span class="type">Postcard</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class="line">                <span class="keyword">val</span> iInterceptor: IInterceptor = Warehouse.interceptors.<span class="keyword">get</span>(index)</span><br><span class="line">                iInterceptor.process(postcard, <span class="keyword">object</span> : InterceptorCallback() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">fun</span> <span class="title">onContinue</span><span class="params">(postcard: <span class="type">Postcard</span>)</span></span> &#123;</span><br><span class="line">                        <span class="comment">// 最后一个拦截器执行完成，没有异常。</span></span><br><span class="line">                        counter.countDown()</span><br><span class="line">                        _execute(</span><br><span class="line">                            index + <span class="number">1</span>,</span><br><span class="line">                            counter,</span><br><span class="line">                            postcard</span><br><span class="line">                        ) <span class="comment">// 当计数器减少时，继续执行，但是索引大于拦截器的大小，此时不会继续执行。</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">fun</span> <span class="title">onInterrupt</span><span class="params">(exception: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">                        <span class="comment">// 最后一个拦截器执行出现严重异常。</span></span><br><span class="line">                        postcard.setTag(</span><br><span class="line">                            exception ?: HandlerException(<span class="string">&quot;没有消息。&quot;</span>)</span><br><span class="line">                        ) <span class="comment">// 保存异常消息以备份。</span></span><br><span class="line">                        counter.cancel()</span><br><span class="line">                        <span class="comment">// 注意，可能回调中的线程已经更改，</span></span><br><span class="line">                        <span class="comment">// 然后捕获块（L207）将无效。</span></span><br><span class="line">                        <span class="comment">// 最糟糕的情况是线程更改为主线程，然后如果抛出此异常，则应用程序将崩溃！</span></span><br><span class="line"><span class="comment">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // 如果线程是主线程，则不应抛出异常。</span></span><br><span class="line"><span class="comment">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkInterceptorsInitStatus</span><span class="params">()</span></span> &#123;</span><br><span class="line">            synchronized(interceptorInitLock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!interceptorHasInit) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        interceptorInitLock.wait((<span class="number">10</span> * <span class="number">1000</span>).toLong())</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;拦截器初始化花费太长时间错误！原因 = [&quot;</span> + e.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个类是ARouter（Android路由框架）的核心拦截器服务实现类，它具有以下作用：</p><ol><li><strong>拦截器管理：</strong> 该类负责管理ARouter框架中的拦截器。拦截器是在路由导航过程中执行的一系列操作，用于处理路由请求或者对路由进行拦截和修改。</li><li><strong>拦截器执行：</strong> 通过<code>doInterceptions</code>方法，该类执行了一系列的拦截器操作。在路由导航之前，它会依次调用已注册的拦截器，检查是否需要拦截路由请求或对请求进行修改。如果有拦截器拦截了请求，将触发拦截器的<code>onInterrupt</code>方法，否则，将继续执行下一个拦截器，直到所有拦截器都完成或者发生了异常。</li><li><strong>拦截器初始化：</strong> 通过<code>init</code>方法，该类还负责初始化所有的拦截器。在ARouter框架初始化的过程中，会注册各种拦截器，这些拦截器需要在合适的时机进行初始化，以便在路由导航时能够正确地执行。</li><li><strong>线程控制：</strong> 该类使用<code>CancelableCountDownLatch</code>来管理拦截器的执行，确保在所有拦截器执行完成或者超时时能够继续路由导航操作。同时，它还使用锁来控制拦截器的初始化过程，以确保在初始化完成之前不会执行路由导航。</li></ol><h5 id="LogisticsCenter"><a href="#LogisticsCenter" class="headerlink" title="LogisticsCenter"></a>LogisticsCenter</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.exception.HandlerException</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.exception.NoRouteFoundException</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.Postcard</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.enums.TypeKind</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.model.RouteMeta</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptorGroup</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IProvider</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IProviderGroup</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IRouteGroup</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IRouteRoot</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.launcher.ARouter.logger</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.ClassUtils</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.AROUTER_SP_CACHE_KEY</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.AROUTER_SP_KEY_MAP</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.DOT</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.ROUTE_ROOT_PAKCAGE</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SDK_NAME</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SEPARATOR</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_INTERCEPTORS</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_PROVIDERS</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.SUFFIX_ROOT</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.Consts.TAG</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.MapUtils</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.PackageUtils</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.utils.TextUtils</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> kotlin.Exception</span><br><span class="line"><span class="keyword">import</span> kotlin.<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">import</span> kotlin.String</span><br><span class="line"><span class="keyword">import</span> kotlin.Throwable</span><br><span class="line"><span class="keyword">import</span> kotlin.Throws</span><br><span class="line"><span class="keyword">import</span> kotlin.arrayOf</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LogisticsCenter 包含了所有的路由映射信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 在首次使用时创建实例。</span></span><br><span class="line"><span class="comment"> * 2. 处理多模块之间的映射关系(*)</span></span><br><span class="line"><span class="comment"> * 3. 解决重复组定义的复杂逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alex [联系我](mailto:zhilong.liu<span class="doctag">@aliyun</span>.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 16/8/23 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> LogisticsCenter &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mContext: Context? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> executor: ThreadPoolExecutor? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> registerByPlugin = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arouter-auto-register 插件将在这个方法中生成代码</span></span><br><span class="line"><span class="comment">     * 调用这个方法来注册所有的路由、拦截器和提供者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadRouterMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        registerByPlugin = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 自动生成的注册代码由 Gradle 插件 arouter-auto-register 生成</span></span><br><span class="line">        <span class="comment">// 看起来像下面这样：</span></span><br><span class="line">        <span class="comment">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class="line">        <span class="comment">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名注册</span></span><br><span class="line"><span class="comment">     * 为了解决主 dex 文件过大的问题，牺牲了一些效率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(className: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> clazz = Class.forName(className)</span><br><span class="line">                <span class="keyword">val</span> obj = clazz.getConstructor().newInstance()</span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">is</span> IRouteRoot) &#123;</span><br><span class="line">                    registerRouteRoot(obj <span class="keyword">as</span> IRouteRoot)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">is</span> IProviderGroup) &#123;</span><br><span class="line">                    registerProvider(obj <span class="keyword">as</span> IProviderGroup)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">is</span> IInterceptorGroup) &#123;</span><br><span class="line">                    registerInterceptor(obj <span class="keyword">as</span> IInterceptorGroup)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(</span><br><span class="line">                        TAG, <span class="string">&quot;注册失败，类名：&quot;</span> + className</span><br><span class="line">                                + <span class="string">&quot; 应该实现其中一个接口 IRouteRoot/IProviderGroup/IInterceptorGroup。&quot;</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                logger.error(TAG, <span class="string">&quot;注册类错误：<span class="variable">$className</span>&quot;</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于 arouter-auto-register 插件注册路由的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routeRoot IRouteRoot 实现类，位于包 com.alibaba.android.arouter.core.routers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerRouteRoot</span><span class="params">(routeRoot: <span class="type">IRouteRoot</span>?)</span></span> &#123;</span><br><span class="line">        markRegisteredByPlugin()</span><br><span class="line">        <span class="keyword">if</span> (routeRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">            routeRoot.loadInto(Warehouse.groupsIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于 arouter-auto-register 插件注册拦截器的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptorGroup IInterceptorGroup 实现类，位于包 com.alibaba.android.arouter.core.routers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerInterceptor</span><span class="params">(interceptorGroup: <span class="type">IInterceptorGroup</span>?)</span></span> &#123;</span><br><span class="line">        markRegisteredByPlugin()</span><br><span class="line">        <span class="keyword">if</span> (interceptorGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            interceptorGroup.loadInto(Warehouse.interceptorsIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于 arouter-auto-register 插件注册提供者的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> providerGroup IProviderGroup 实现类，位于包 com.alibaba.android.arouter.core.routers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerProvider</span><span class="params">(providerGroup: <span class="type">IProviderGroup</span>?)</span></span> &#123;</span><br><span class="line">        markRegisteredByPlugin()</span><br><span class="line">        <span class="keyword">if</span> (providerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            providerGroup.loadInto(Warehouse.providersIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记已由 arouter-auto-register 插件注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markRegisteredByPlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!registerByPlugin) &#123;</span><br><span class="line">            registerByPlugin = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LogisticsCenter 初始化，加载所有路由信息到内存中，需要在首次使用时进行初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="meta">@Throws(HandlerException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>, tpe: <span class="type">ThreadPoolExecutor</span>?)</span></span> &#123;</span><br><span class="line">        mContext = context</span><br><span class="line">        executor = tpe</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> startInit = System.currentTimeMillis()</span><br><span class="line">            <span class="comment">// 首先通过插件加载路由信息</span></span><br><span class="line">            loadRouterMap()</span><br><span class="line">            <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">&quot;通过 arouter-auto-register 插件加载路由映射信息。&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> routerMap: Set&lt;String&gt;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在调试模式或安装新版本时，每次都会重建路由映射</span></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;在调试模式下或安装新版本，重新构建路由映射。&quot;</span>)</span><br><span class="line">                    <span class="comment">// 这些类是由 arouter-compiler 自动生成的</span></span><br><span class="line">                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE)</span><br><span class="line">                    <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE)</span><br><span class="line">                            .edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply()</span><br><span class="line">                    &#125;</span><br><span class="line">                    PackageUtils.updateVersion(context) <span class="comment">// 保存新版本名，当路由映射更新完成时使用</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;从缓存中加载路由映射信息。&quot;</span>)</span><br><span class="line">                    routerMap = HashSet(</span><br><span class="line">                        context.getSharedPreferences(</span><br><span class="line">                            AROUTER_SP_CACHE_KEY,</span><br><span class="line">                            Context.MODE_PRIVATE</span><br><span class="line">                        ).getStringSet(AROUTER_SP_KEY_MAP, HashSet())</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(</span><br><span class="line">                    TAG,</span><br><span class="line">                    <span class="string">&quot;找到路由映射信息，映射大小 = &quot;</span> + routerMap.size + <span class="string">&quot;，耗时 &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; 毫秒。&quot;</span></span><br><span class="line">                )</span><br><span class="line">                startInit = System.currentTimeMillis()</span><br><span class="line">                <span class="keyword">for</span> (className <span class="keyword">in</span> routerMap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                        <span class="comment">// 这是根元素之一，加载根元素</span></span><br><span class="line">                        (Class.forName(className).getConstructor()</span><br><span class="line">                            .newInstance() <span class="keyword">as</span> IRouteRoot).loadInto(Warehouse.groupsIndex)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                        <span class="comment">// 加载拦截器映射信息</span></span><br><span class="line">                        (Class.forName(className).getConstructor()</span><br><span class="line">                            .newInstance() <span class="keyword">as</span> IInterceptorGroup).loadInto(Warehouse.interceptorsIndex)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                        <span class="comment">// 加载提供者映射信息</span></span><br><span class="line">                        (Class.forName(className).getConstructor()</span><br><span class="line">                            .newInstance() <span class="keyword">as</span> IProviderGroup).loadInto(Warehouse.providersIndex)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(</span><br><span class="line">                TAG,</span><br><span class="line">                <span class="string">&quot;加载根元素完成，耗时 &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; 毫秒。&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (Warehouse.groupsIndex.size() === <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(TAG, <span class="string">&quot;未找到映射文件，请检查您的配置！&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                logger.debug(</span><br><span class="line">                    TAG,</span><br><span class="line">                    java.lang.String.format(</span><br><span class="line">                        Locale.getDefault(),</span><br><span class="line">                        <span class="string">&quot;LogisticsCenter 已经加载，GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]&quot;</span>,</span><br><span class="line">                        Warehouse.groupsIndex.size(),</span><br><span class="line">                        Warehouse.interceptorsIndex.size(),</span><br><span class="line">                        Warehouse.providersIndex.size()</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;ARouter 初始化物流中心异常！ [&quot;</span> + e.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名构建 Postcard</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 接口名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Postcard</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">buildProvider</span><span class="params">(serviceName: <span class="type">String</span>?)</span></span>: Postcard? &#123;</span><br><span class="line">        <span class="keyword">val</span> meta: RouteMeta = Warehouse.providersIndex.<span class="keyword">get</span>(serviceName)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (<span class="literal">null</span> == meta) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Postcard(meta.getPath(), meta.getGroup())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由元信息完成 Postcard 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postcard 不完整的 Postcard，应由此方法完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">completion</span><span class="params">(postcard: <span class="type">Postcard</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == postcard) &#123;</span><br><span class="line">            <span class="keyword">throw</span> NoRouteFoundException(TAG.toString() + <span class="string">&quot;没有 Postcard！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> routeMeta: RouteMeta = Warehouse.routes.<span class="keyword">get</span>(postcard.getPath())</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == routeMeta) &#123;</span><br><span class="line">            <span class="comment">// 可能不存在或尚未加载</span></span><br><span class="line">            <span class="keyword">if</span> (!Warehouse.groupsIndex.containsKey(postcard.getGroup())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NoRouteFoundException(TAG.toString() + <span class="string">&quot;没有匹配路径 [&quot;</span> + postcard.getPath() + <span class="string">&quot;]，在组 [&quot;</span> + postcard.getGroup() + <span class="string">&quot;] 中。&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 加载路由信息并缓存到内存中，然后从路由元信息中删除</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                        logger.debug(</span><br><span class="line">                            TAG,</span><br><span class="line">                            java.lang.String.format(</span><br><span class="line">                                Locale.getDefault(),</span><br><span class="line">                                <span class="string">&quot;开始加载组 [%s]，由 [%s] 触发。&quot;</span>,</span><br><span class="line">                                postcard.getGroup(),</span><br><span class="line">                                postcard.getPath()</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                    addRouteGroupDynamic(postcard.getGroup(), <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                        logger.debug(</span><br><span class="line">                            TAG,</span><br><span class="line">                            java.lang.String.format(</span><br><span class="line">                                Locale.getDefault(),</span><br><span class="line">                                <span class="string">&quot;组 [%s] 已经加载，由 [%s] 触发。&quot;</span>,</span><br><span class="line">                                postcard.getGroup(),</span><br><span class="line">                                postcard.getPath()</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> HandlerException(TAG.toString() + <span class="string">&quot;加载组元信息时发生致命异常。 [&quot;</span> + e.message + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                completion(postcard) <span class="comment">// 重新加载</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postcard.setDestination(routeMeta.getDestination())</span><br><span class="line">            postcard.setType(routeMeta.getType())</span><br><span class="line">            postcard.setPriority(routeMeta.getPriority())</span><br><span class="line">            postcard.setExtra(routeMeta.getExtra())</span><br><span class="line">            <span class="keyword">val</span> rawUri: Uri = postcard.getUri()</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != rawUri) &#123;   <span class="comment">// 尝试将参数设置到 Bundle 中</span></span><br><span class="line">                <span class="keyword">val</span> resultMap: Map&lt;String, String&gt; = TextUtils.splitQueryParameters(rawUri)</span><br><span class="line">                <span class="keyword">val</span> paramsType: Map&lt;String, <span class="built_in">Int</span>?&gt; = routeMeta.getParamsType()</span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                    <span class="comment">// 根据参数类型设置值，仅对使用 @Param 注解的参数有效</span></span><br><span class="line">                    <span class="keyword">for</span> ((key, value): Map.Entry&lt;String, <span class="built_in">Int</span>?&gt; <span class="keyword">in</span> paramsType) &#123;</span><br><span class="line">                        setValue(</span><br><span class="line">                            postcard,</span><br><span class="line">                            value,</span><br><span class="line">                            key,</span><br><span class="line">                            resultMap[key]</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 保存需要自动注入的参数名</span></span><br><span class="line">                    postcard.getExtras().putStringArray(</span><br><span class="line">                        ARouter.AUTO_INJECT,</span><br><span class="line">                        paramsType.keys.toArray(arrayOf&lt;String&gt;())</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存原始 URI</span></span><br><span class="line">                postcard.withString(ARouter.RAW_URI, rawUri.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">when</span> (routeMeta.getType()) &#123;</span><br><span class="line">                PROVIDER -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 这是提供者，所以必须实现 IProvider 接口</span></span><br><span class="line">                    <span class="keyword">val</span> providerMeta: Class&lt;<span class="keyword">out</span> IProvider?&gt; = routeMeta.getDestination()</span><br><span class="line">                    <span class="keyword">var</span> instance: IProvider? = Warehouse.providers.<span class="keyword">get</span>(providerMeta)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123; <span class="comment">// 没有此提供者的实例</span></span><br><span class="line">                        <span class="keyword">val</span> provider: IProvider</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            provider = providerMeta.getConstructor().newInstance()</span><br><span class="line">                            provider.<span class="keyword">init</span>(mContext)</span><br><span class="line">                            Warehouse.providers.put(providerMeta, provider)</span><br><span class="line">                            instance = provider</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                            logger.error(TAG, <span class="string">&quot;初始化提供者失败！&quot;</span>, e)</span><br><span class="line">                            <span class="keyword">throw</span> HandlerException(<span class="string">&quot;初始化提供者失败！&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    postcard.setProvider(instance)</span><br><span class="line">                    postcard.greenChannel() <span class="comment">// 提供者应跳过所有拦截器</span></span><br><span class="line">                &#125;</span><br><span class="line">                FRAGMENT -&gt; postcard.greenChannel() <span class="comment">// Fragment 不需要拦截器</span></span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据已知类型设置值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postcard postcard</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeDef  类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(postcard: <span class="type">Postcard</span>, typeDef: <span class="type">Int</span>?, key: <span class="type">String</span>, value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(key) || TextUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != typeDef) &#123;</span><br><span class="line">                <span class="keyword">if</span> (typeDef === TypeKind.BOOLEAN.ordinal()) &#123;</span><br><span class="line">                    postcard.withBoolean(key, <span class="built_in">Boolean</span>.parseBoolean(value))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.BYTE.ordinal()) &#123;</span><br><span class="line">                    postcard.withByte(key, value!!.toByte())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.SHORT.ordinal()) &#123;</span><br><span class="line">                    postcard.withShort(key, value!!.toShort())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.INT.ordinal()) &#123;</span><br><span class="line">                    postcard.withInt(key, value!!.toInt())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.LONG.ordinal()) &#123;</span><br><span class="line">                    postcard.withLong(key, value!!.toLong())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.FLOAT.ordinal()) &#123;</span><br><span class="line">                    postcard.withFloat(key, value!!.toFloat())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.DOUBLE.ordinal()) &#123;</span><br><span class="line">                    postcard.withDouble(key, value!!.toDouble())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.STRING.ordinal()) &#123;</span><br><span class="line">                    postcard.withString(key, value)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.PARCELABLE.ordinal()) &#123;</span><br><span class="line">                    <span class="comment">// TODO : 如何使用字符串描述可传递的值？</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef === TypeKind.OBJECT.ordinal()) &#123;</span><br><span class="line">                    postcard.withString(key, value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 兼容编译器 SDK 1.0.3，在该版本中，字符串类型 = 18</span></span><br><span class="line">                    postcard.withString(key, value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                postcard.withString(key, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;</span><br><span class="line">            logger.warning(Consts.TAG, <span class="string">&quot;LogisticsCenter setValue 失败！&quot;</span> + ex.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挂起业务，清除缓存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">suspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Warehouse.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="meta">@Throws(</span></span><br><span class="line"><span class="meta">        NoSuchMethodException::class,</span></span><br><span class="line"><span class="meta">        IllegalAccessException::class,</span></span><br><span class="line"><span class="meta">        InvocationTargetException::class,</span></span><br><span class="line"><span class="meta">        InstantiationException::class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addRouteGroupDynamic</span><span class="params">(groupName: <span class="type">String</span>?, group: <span class="type">IRouteGroup</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Warehouse.groupsIndex.containsKey(groupName)) &#123;</span><br><span class="line">            <span class="comment">// 如果已包含此组，但尚未加载</span></span><br><span class="line">            <span class="comment">// 先加载此组，因为动态路由具有较高的优先级。</span></span><br><span class="line">            Warehouse.groupsIndex.<span class="keyword">get</span>(groupName).getConstructor().newInstance()</span><br><span class="line">                .loadInto(Warehouse.routes)</span><br><span class="line">            Warehouse.groupsIndex.remove(groupName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖旧组。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != group) &#123;</span><br><span class="line">            group.loadInto(Warehouse.routes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是ARouter库的核心组件之一，它的主要作用是负责管理和维护ARouter路由框架中的各种映射关系和配置信息，以便实现路由功能。以下是这个类的主要作用描述：</p><ol><li><p><strong>加载路由映射信息：</strong> LogisticsCenter负责加载和管理所有的路由映射信息。这些路由映射信息包括路由路径、路由分组、拦截器、提供者等相关信息，它们在ARouter框架中用于实现路由跳转和服务提供。</p></li><li><p><strong>支持自动注册：</strong> 通过ARouter的插件机制，LogisticsCenter可以支持自动注册路由信息，使得开发者无需手动配置路由信息，提高了开发效率。插件会自动生成代码来调用LogisticsCenter的方法注册路由信息。</p></li><li><p><strong>初始化和管理线程池：</strong> LogisticsCenter负责初始化和管理线程池，用于异步加载路由信息和执行路由任务。线程池的管理有助于提高ARouter框架的性能和并发处理能力。</p></li><li><p><strong>动态加载路由信息：</strong> 当需要跳转到某个路由时，LogisticsCenter会根据路由信息动态加载相关的路由元信息，包括路由组信息和拦截器信息，以便进行路由跳转和拦截器处理。</p></li><li><p><strong>提供路由跳转和服务提供支持：</strong> LogisticsCenter提供了一系列方法，用于构建路由跳转的Postcard对象和获取服务提供者的实例。它还负责处理路由跳转的逻辑，包括路由路径匹配、拦截器处理和服务提供。</p></li><li><p><strong>支持路由信息的缓存和更新：</strong> LogisticsCenter支持路由信息的缓存和更新，以提高ARouter框架的性能。当路由信息有更新时，可以通过插件机制重新生成路由映射信息。</p></li></ol><p>总之，LogisticsCenter是ARouter框架中的核心组件，它通过加载、管理和动态获取路由信息，实现了路由跳转和服务提供的功能，提供了便捷的路由框架和服务化解决方案。</p><h5 id="Warehouse"><a href="#Warehouse" class="headerlink" title="Warehouse"></a>Warehouse</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.android.arouter.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.base.UniqueKeyTreeMap</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.model.RouteMeta</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IInterceptor</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IProvider</span><br><span class="line"><span class="keyword">import</span> com.alibaba.android.arouter.facade.template.IRouteGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由元信息和其他数据的存储仓库。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Warehouse（仓库）负责存储路由元信息以及其他相关数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhilong [Contact me.](mailto:zhilong.lzl<span class="doctag">@alibaba</span>-inc.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/2/23 下午1:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> Warehouse &#123;</span><br><span class="line">    <span class="comment">// 缓存路由组和路由元信息</span></span><br><span class="line">    <span class="keyword">var</span> groupsIndex: MutableMap&lt;String, Class&lt;<span class="keyword">out</span> IRouteGroup?&gt;&gt; =</span><br><span class="line">        HashMap&lt;String, Class&lt;<span class="keyword">out</span> IRouteGroup?&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> routes: MutableMap&lt;String, RouteMeta&gt; = HashMap&lt;String, RouteMeta&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存服务提供者</span></span><br><span class="line">    <span class="keyword">var</span> providers: MutableMap&lt;Class&lt;*&gt;, IProvider&gt; = HashMap&lt;Class&lt;*&gt;, IProvider&gt;()</span><br><span class="line">    <span class="keyword">var</span> providersIndex: MutableMap&lt;String, RouteMeta&gt; = HashMap&lt;String, RouteMeta&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存拦截器</span></span><br><span class="line">    <span class="keyword">var</span> interceptorsIndex: MutableMap&lt;<span class="built_in">Int</span>, Class&lt;<span class="keyword">out</span> IInterceptor?&gt;&gt; =</span><br><span class="line">        UniqueKeyTreeMap(<span class="string">&quot;多个拦截器使用相同的优先级 [%s]&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> interceptors: MutableList&lt;IInterceptor&gt; = ArrayList&lt;IInterceptor&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空仓库中的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        routes.clear()</span><br><span class="line">        groupsIndex.clear()</span><br><span class="line">        providers.clear()</span><br><span class="line">        providersIndex.clear()</span><br><span class="line">        interceptors.clear()</span><br><span class="line">        interceptorsIndex.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是ARouter框架内部的一个存储仓库，用于缓存路由元信息、路由组信息、服务提供者信息以及拦截器信息等相关数据。这些数据在ARouter框架中用于实现路由跳转和服务提供功能。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - exception 异常与 callback 回调</title>
      <link href="/2023/09/10/3%20Android/ARouter/03-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/03-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li>router-annotation 路由注解模块<ul><li><p>src.main.java</p><ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li><a href="#HandlerException">HandlerException.java</a> 处理异常的类</li><li><a href="#InitException">InitException.java</a> 初始化异常的类</li><li><a href="#NoRouteFoundException">NoRouteFoundException.java</a> 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li><a href="#InterceptorCallback">InterceptorCallback.java</a> 拦截器回调的接口</li><li><a href="#NavigationCallback">NavigationCallback.java</a> 导航回调的接口</li><li><a href="#NoRouteFoundException">NoRouteFoundException.java</a> 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - service 服务</title>
      <link href="/2023/09/10/3%20Android/ARouter/04-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/04-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li><a href="#AutowiredService">AutowiredService.java</a> 自动注入服务的接口</li><li><a href="#ClassLoaderService">ClassLoaderService.java</a> 类加载器服务的接口</li><li><a href="#DegradeService">DegradeService.java</a> 降级服务的接口</li><li><a href="#InterceptorService">InterceptorService.java</a> 拦截器服务的接口</li><li><a href="#PathReplaceService">PathReplaceService.java</a> 路径替换服务的接口</li><li><a href="#PretreatmentService">PretreatmentService.java</a> 预处理服务的接口</li><li><a href="#SerializationService">SerializationService.java</a> 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - template 模板</title>
      <link href="/2023/09/10/3%20Android/ARouter/05-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/05-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li><a href="#IInterceptor">IInterceptor.java</a> 拦截器接口</li><li><a href="#IInterceptorGroup">IInterceptorGroup.java</a> 拦截器分组接口</li><li><a href="#Ilogger">Ilogger.java</a> 日志记录器接口</li><li><a href="#IPolicy">IPolicy.java</a> 策略接口</li><li><a href="#IProvider">IProvider.java</a> 提供者接口</li><li><a href="#IProviderGroup">IProviderGroup.java</a> 提供者分组接口</li><li><a href="#IRouteGroup">IRouteGroup.java</a> 路由分组接口</li><li><a href="#IRouteRoot">IRouteRoot.java</a> 路由根接口</li><li><a href="#Isyringe">Isyringe.java</a> 注射器接口</li><li><a href="#Postcard">Postcard.java</a> 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - launcher 启动器</title>
      <link href="/2023/09/10/3%20Android/ARouter/06-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/06-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li><a href="#_Arouter">_Arouter.java</a> ARouter框架的内部启动类，用于初始化ARouter。</li><li><a href="#Arouter">Arouter.java</a> ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li><a href="#CancelableCountDownLatch">CancelableCountDownLatch.java</a> 可取消的倒计时计数器，用于线程同步。</li><li><a href="#DefaultPoolExecutor">DefaultPoolExecutor.java</a> 默认的线程池执行器，用于执行异步任务。</li><li><a href="#DefaultThreadFactory">DefaultThreadFactory.java</a> 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - utils 工具类</title>
      <link href="/2023/09/10/3%20Android/ARouter/07-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/07-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li>ARouter<ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li><a href="#ClassUtils">ClassUtils.java</a> 用于操作类的实用工具类。</li><li><a href="#Consts">Consts.java</a> 包含一些常量值的类。</li><li><a href="#DefaultLogger">DefaultLogger.java</a> 默认的日志记录器类。</li><li><a href="#MapUtils">MapUtils.java</a> 用于操作地图数据的实用工具类。</li><li><a href="#PackageUtils">PackageUtils.java</a> 用于操作包信息的实用工具类。</li><li><a href="#TextUtils">TextUtils.java</a> 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li>RouteDoc.java 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li>AutowiredProcessor.java 自动注入处理器</li><li>BaseProcessor.java 基础处理器</li><li>InterceptorProcessor.java 拦截器处理器</li><li>RouteProcessor.java 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li>Consts.java 常量类</li><li>Logger.java 日志记录器类</li><li>TypeUtils.java 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始写一个 ARouter - compiler 编译模块</title>
      <link href="/2023/09/10/3%20Android/ARouter/08-Arouter/"/>
      <url>/2023/09/10/3%20Android/ARouter/08-Arouter/</url>
      
        <content type="html"><![CDATA[<ul><li><p>ARouter</p><ul><li><p>router-annotation 路由注解模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>facade 提供注解和枚举的包<ul><li>annotation 存放各种注解类的包<ul><li>Autowired.java 自动注入的注解</li><li>Interceptor.java 拦截器的注解</li><li>Param.java(废弃) 参数注解: 被 Autowired 淘汰</li><li>Route.java 路由信息注解</li></ul></li><li>enums 包含各种枚举类型的包<ul><li>RouteType.java 路由类型的枚举</li><li>TypeKind.java 类型种类的枚举</li></ul></li><li>model 包含模型类的包<ul><li>RouteMeta.java 路由元信息的模型类</li><li>TypeWrapper.java 存储目标对象的泛型类型信息的类</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-api ARouter框架的API模块</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>base 基础功能相关的包<ul><li>UniqueKeyTreeMap.java 唯一键树形映射的类</li></ul></li><li>core 核心功能相关的包<ul><li>AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类</li><li>AutowiredServiceImpl.java 自动注入服务的实现类</li><li>InstrumentationHook.java(废弃) 仪表钩子的类</li><li>InterceptorServiceImpl.java 拦截器服务的实现类</li><li>LogisticsCenter.java 物流中心的类</li><li>Warehouse.java 仓库的类</li></ul></li><li>exception 异常相关的包<ul><li>HandlerException.java 处理异常的类</li><li>InitException.java 初始化异常的类</li><li>NoRouteFoundException.java 未找到路由的异常类</li></ul></li><li>facade 提供各种服务和回调的包<ul><li>callback 回调相关的包<ul><li>InterceptorCallback.java 拦截器回调的接口</li><li>NavigationCallback.java 导航回调的接口</li><li>NoRouteFoundException.java 未找到路由的异常接口</li></ul></li></ul></li><li>service 服务相关的包<ul><li>AutowiredService.java 自动注入服务的接口</li><li>ClassLoaderService.java 类加载器服务的接口</li><li>DegradeService.java 降级服务的接口</li><li>InterceptorService.java 拦截器服务的接口</li><li>PathReplaceService.java 路径替换服务的接口</li><li>PretreatmentService.java 预处理服务的接口</li><li>SerializationService.java 序列化服务的接口</li></ul></li><li>template 模板相关的包<ul><li>IInterceptor.java 拦截器接口</li><li>IInterceptorGroup.java 拦截器分组接口</li><li>Ilogger.java 日志记录器接口</li><li>IPolicy.java 策略接口</li><li>IProvider.java 提供者接口</li><li>IProviderGroup.java 提供者分组接口</li><li>IRouteGroup.java 路由分组接口</li><li>IRouteRoot.java 路由根接口</li><li>Isyringe.java 注射器接口</li><li>Postcard.java 路由信息封装类</li></ul></li><li>launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。<ul><li>_Arouter.java ARouter框架的内部启动类，用于初始化ARouter。</li><li>Arouter.java ARouter框架的启动类，用于初始化ARouter。</li></ul></li><li>thread （线程）包含了与线程管理相关的类。<ul><li>CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。</li><li>DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。</li><li>DefaultThreadFactory.java 默认线程工厂，用于创建线程。</li></ul></li><li>utils 工具类。<ul><li>ClassUtils.java 用于操作类的实用工具类。</li><li>Consts.java 包含一些常量值的类。</li><li>DefaultLogger.java 默认的日志记录器类。</li><li>MapUtils.java 用于操作地图数据的实用工具类。</li><li>PackageUtils.java 用于操作包信息的实用工具类。</li><li>TextUtils.java 用于操作文本数据的实用工具类。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>arouter-compiler</p><ul><li>src.main.java<ul><li>com.alibaba.android.arouter<ul><li>compiler 编译相关的包<ul><li>entity 实体类相关的包<ul><li><a href="#RouteDoc">RouteDoc.java</a> 路由文档实体类</li></ul></li><li>processor 处理器相关的包<ul><li><a href="#AutowiredProcessor">AutowiredProcessor.java</a> 自动注入处理器</li><li><a href="#BaseProcessor">BaseProcessor.java</a> 基础处理器</li><li><a href="#InterceptorProcessor">InterceptorProcessor.java</a> 拦截器处理器</li><li><a href="#RouteProcessor">RouteProcessor.java</a> 路由处理器</li></ul></li><li>utils 工具类相关的包<ul><li><a href="#Consts">Consts.java</a> 常量类</li><li><a href="#Logger">Logger.java</a> 日志记录器类</li><li><a href="#TypeUtils">TypeUtils.java</a> 类型工具类</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.2 - Arouter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 二叉树-DFS (迭代)</title>
      <link href="/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/11%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E8%BF%AD%E4%BB%A3)/"/>
      <url>/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/11%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E8%BF%AD%E4%BB%A3)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="先序遍历（写法一）"><a href="#先序遍历（写法一）" class="headerlink" title="先序遍历（写法一）"></a>先序遍历（写法一）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    root ?: <span class="keyword">return</span></span><br><span class="line">    stack.addFirst(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> current = stack.removeFirst()</span><br><span class="line">        visit(current)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将右子节点入栈，再将左子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(current.right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(current.left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(root: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序遍历（写法二）"><a href="#先序遍历（写法二）" class="headerlink" title="先序遍历（写法二）"></a>先序遍历（写法二）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">var</span> cur: TreeNode = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            visit(cur)</span><br><span class="line">            stack.addFirst(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> top: TreeNode = stack.removeFirst(();</span><br><span class="line">        cur = top.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(node: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">var</span> cur: TreeNode = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visit(cur)</span><br><span class="line">        <span class="keyword">val</span> top: TreeNode = stack.removeFirst(();</span><br><span class="line">        cur = top.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(node: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorder</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack: LinkList = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> cur = root</span><br><span class="line">    <span class="keyword">var</span> last = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 左节点先入栈</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123; </span><br><span class="line">            stack.addFirst(cur)                        <span class="comment">// 第一次访问</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> top = stack.peekFirst()                    <span class="comment">// 第二次访问</span></span><br><span class="line">        <span class="keyword">if</span> (top.right == <span class="literal">null</span> || top.right == last) &#123;  <span class="comment">// 第三次访问</span></span><br><span class="line">            visit(top)</span><br><span class="line">            last = top</span><br><span class="line">            stack.removeFirst()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = top.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(node: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归后续遍历比较有意思<br>结合注释我们来一语道破天机<br>先序，中序，后序遍历<br>第一次经过结点（从双亲过来）: 先序<br>第二次经过结点（从左孩子过来）: 中序<br>第三次经过结点（右孩子过来）: 后序</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12. 二叉树-BFS</title>
      <link href="/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/12%20%E4%BA%8C%E5%8F%89%E6%A0%91-BFS/"/>
      <url>/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/12%20%E4%BA%8C%E5%8F%89%E6%A0%91-BFS/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue: LinkedList&lt;TreeNode&gt; = LinkedList()</span><br><span class="line">    queue.add(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node: TreeNode = queue.removeFirst()</span><br><span class="line">        visit(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node.left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(root: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(root.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10. 二叉树-DFS (递归)</title>
      <link href="/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/10%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E9%80%92%E5%BD%92)/"/>
      <url>/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/10%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E9%80%92%E5%BD%92)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    root?: <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// visit() // 先序遍历</span></span><br><span class="line">    dfs(root.left)  </span><br><span class="line">    <span class="comment">// visit() // 中序遍历</span></span><br><span class="line">    dfs(root.right)  </span><br><span class="line">    <span class="comment">// visit() // 后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(root: <span class="type">TreeNode</span>)</span></span>&#123;</span><br><span class="line">    println(root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android MVI GPT4 快问快答</title>
      <link href="/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/01%20MVI/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/"/>
      <url>/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/01%20MVI/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="MVI-层级架构"><a href="#MVI-层级架构" class="headerlink" title="MVI 层级架构"></a>MVI 层级架构</h1><ul><li><strong>App</strong> 用于依赖注入 —— 可以访问所有层</li><li><strong>Data</strong> 负责内部和外部存储 —— 可以访问 <strong>Domain</strong></li><li><strong>Domain</strong> 负责仓库和用例 —— 不访问任何层 </li><li><strong>Presentation</strong> 负责UI逻辑 —— 可以访问 <strong>Domain</strong></li></ul><h1 id="GPT-4-块问快答：究竟什么是-MVI"><a href="#GPT-4-块问快答：究竟什么是-MVI" class="headerlink" title="GPT 4 块问快答：究竟什么是 MVI"></a>GPT 4 块问快答：究竟什么是 MVI</h1><h2 id="为什么-Data-和-Presentation-可以访问领域层，举例子怎么访问的"><a href="#为什么-Data-和-Presentation-可以访问领域层，举例子怎么访问的" class="headerlink" title="为什么 Data 和 Presentation 可以访问领域层，举例子怎么访问的"></a>为什么 Data 和 Presentation 可以访问领域层，举例子怎么访问的</h2><p>在一个典型的分层架构中，每一层都有其独特的职责，而且这种架构通常允许某些层访问其他特定的层。在你提到的结构中，<code>App</code>、<code>Data</code>、<code>Domain</code>和<code>Presentation</code>层各自担负不同的角色，其中<code>Data</code>和<code>Presentation</code>层被允许访问<code>Domain</code>层，主要是因为<code>Domain</code>层包含了应用程序的核心业务逻辑和规则，是其他层依赖的基础。</p><h3 id="Data-层访问-Domain-层"><a href="#Data-层访问-Domain-层" class="headerlink" title="Data 层访问 Domain 层"></a>Data 层访问 Domain 层</h3><ul><li><strong>职责</strong>：<code>Data</code>层负责处理数据的存取，无论是来自内部存储（如SQLite数据库、内存缓存等）还是外部存储（如网络API、远程数据库等）。</li><li><strong>访问方式</strong>：<code>Data</code>层访问<code>Domain</code>层通常是通过实现<code>Domain</code>层定义的仓库接口（Repository Interfaces）。这些仓库接口定义了应用程序需要的数据操作（如获取用户数据、保存订单等），而<code>Data</code>层实现这些接口，具体处理数据的存取逻辑。</li></ul><p><strong>示例</strong>：<br>假设在<code>Domain</code>层有一个<code>UserRepository</code>接口，它定义了获取用户信息的方法。<code>Data</code>层将实现这个接口，通过网络API或本地数据库获取用户信息。</p><h3 id="Presentation-层访问-Domain-层"><a href="#Presentation-层访问-Domain-层" class="headerlink" title="Presentation 层访问 Domain 层"></a>Presentation 层访问 Domain 层</h3><ul><li><strong>职责</strong>：<code>Presentation</code>层负责处理所有与用户界面（UI）相关的逻辑，如显示数据、响应用户操作等。</li><li><strong>访问方式</strong>：<code>Presentation</code>层通过使用<code>Domain</code>层中定义的用例（Use Cases）或服务（Services）来获取所需的数据或执行特定的业务逻辑。用例封装了特定的业务逻辑操作，为<code>Presentation</code>层提供了清晰、简洁的API。</li></ul><p><strong>示例</strong>：<br>如果有一个显示用户个人信息的界面，<code>Presentation</code>层的一个ViewModel或Presenter可能会调用一个<code>GetUserProfile</code>用例（从<code>Domain</code>层获取），该用例封装了获取用户个人信息的业务逻辑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过允许<code>Data</code>和<code>Presentation</code>层访问<code>Domain</code>层，可以确保应用程序的核心业务逻辑集中管理，并且易于测试和维护。同时，这种结构还有助于解耦，使得数据源的更改或UI的修改不会直接影响到业务逻辑的实现，从而提高了应用程序的灵活性和可维护性。</p><h2 id="给出-GetUserProfile-代码例子"><a href="#给出-GetUserProfile-代码例子" class="headerlink" title="给出 GetUserProfile 代码例子"></a>给出 GetUserProfile 代码例子</h2><p>为了提供一个<code>GetUserProfile</code>的示例，我们将遵循典型的分层架构中的<code>Domain</code>、<code>Data</code>和<code>Presentation</code>层的交互方式。这个例子将使用Kotlin语言，因为它是在Android开发中常用的语言，同时也适用于Kotlin多平台移动（KMM）项目。</p><h3 id="Domain-层"><a href="#Domain-层" class="headerlink" title="Domain 层"></a>Domain 层</h3><p>在<code>Domain</code>层，我们定义一个用例（Use Case）<code>GetUserProfile</code>，它是业务逻辑的一部分。这个用例会从仓库（Repository）中获取用户的个人信息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Domain层 - 定义用例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetUserProfile</span>(<span class="keyword">private</span> <span class="keyword">val</span> userRepository: UserRepository) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(userId: <span class="type">String</span>)</span></span>: UserProfile &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.getUserProfile(userId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Domain层 - 定义仓库接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserProfile</span><span class="params">(userId: <span class="type">String</span>)</span></span>: UserProfile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户个人信息的数据模型</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span>(<span class="keyword">val</span> userId: String, <span class="keyword">val</span> name: String, <span class="keyword">val</span> email: String)</span><br></pre></td></tr></table></figure><h3 id="Data-层"><a href="#Data-层" class="headerlink" title="Data 层"></a>Data 层</h3><p>在<code>Data</code>层，我们实现了<code>Domain</code>层定义的<code>UserRepository</code>接口，提供了获取用户个人信息的实际逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data层 - 仓库实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepositoryImpl</span> : <span class="type">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserProfile</span><span class="params">(userId: <span class="type">String</span>)</span></span>: UserProfile &#123;</span><br><span class="line">        <span class="comment">// 假设这里是从网络或本地数据库获取数据</span></span><br><span class="line">        <span class="keyword">return</span> UserProfile(userId, <span class="string">&quot;John Doe&quot;</span>, <span class="string">&quot;johndoe@example.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Presentation-层"><a href="#Presentation-层" class="headerlink" title="Presentation 层"></a>Presentation 层</h3><p>在<code>Presentation</code>层，我们使用<code>GetUserProfile</code>用例来获取用户个人信息，并展示到UI上。这里以一个简单的ViewModel为例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Presentation层 - ViewModel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserProfileViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> getUserProfile: GetUserProfile) : ViewModel() &#123;</span><br><span class="line">    <span class="comment">// LiveData用于观察数据变化，更新UI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _userProfile = MutableLiveData&lt;UserProfile&gt;()</span><br><span class="line">    <span class="keyword">val</span> userProfile: LiveData&lt;UserProfile&gt; = _userProfile</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUserProfile</span><span class="params">(userId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            _userProfile.value = getUserProfile.execute(userId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个例子演示了在一个分层架构中，如何通过<code>Domain</code>层的用例来协调<code>Data</code>层和<code>Presentation</code>层的交互。<code>Domain</code>层定义了业务逻辑和接口，<code>Data</code>层实现了数据获取的逻辑，而<code>Presentation</code>层负责调用这些逻辑并更新UI。这种分层的方式有助于保持代码的清晰和可维护性。</p><h2 id="描述一下，数据在几个层之间的传递，从起始到结束"><a href="#描述一下，数据在几个层之间的传递，从起始到结束" class="headerlink" title="描述一下，数据在几个层之间的传递，从起始到结束"></a>描述一下，数据在几个层之间的传递，从起始到结束</h2><p>数据在分层架构中的传递通常遵循一个定义良好的流程，确保应用的各个组成部分职责明确、解耦合，同时促进模块间的协作。以下是一个典型的从起始到结束的数据传递流程，以一个简化的用户个人信息获取功能为例，该功能遵循<code>Presentation</code>、<code>Domain</code>和<code>Data</code>层的架构模式：</p><h3 id="1-用户界面触发"><a href="#1-用户界面触发" class="headerlink" title="1. 用户界面触发"></a>1. 用户界面触发</h3><ul><li><strong>起始点</strong>：用户在应用的界面上执行一个动作（比如点击一个按钮），请求查看个人信息。</li><li><strong>处理</strong>：这个动作被<code>Presentation</code>层的一个组件（例如，一个ViewModel或Activity）捕获。</li></ul><h3 id="2-Presentation-层处理"><a href="#2-Presentation-层处理" class="headerlink" title="2. Presentation 层处理"></a>2. Presentation 层处理</h3><ul><li><code>Presentation</code>层的组件调用<code>Domain</code>层定义的用例（Use Case），比如<code>GetUserProfile</code>，来获取用户的个人信息。这个调用通常是异步的，以避免阻塞UI线程。</li><li>ViewModel通过用例接口，向<code>Domain</code>层表达获取数据的需求。</li></ul><h3 id="3-Domain-层中转"><a href="#3-Domain-层中转" class="headerlink" title="3. Domain 层中转"></a>3. Domain 层中转</h3><ul><li><code>Domain</code>层的<code>GetUserProfile</code>用例接收到请求，并将其转发给相应的<code>UserRepository</code>接口。此时，<code>GetUserProfile</code>仅知道需要调用仓库接口来获取数据，但不关心数据的具体来源。</li><li><code>Domain</code>层起到了定义业务规则和操作流程的角色，但本身不处理数据的存取。</li></ul><h3 id="4-Data-层响应"><a href="#4-Data-层响应" class="headerlink" title="4. Data 层响应"></a>4. Data 层响应</h3><ul><li><code>Data</code>层中，具体实现了<code>UserRepository</code>接口的类（如<code>UserRepositoryImpl</code>）负责处理数据的实际获取操作。这可能涉及访问网络API、查询本地数据库或读取缓存等操作。</li><li>一旦数据被成功获取，它会被封装成一个模型（如<code>UserProfile</code>），并返回给调用者——在这个例子中是<code>Domain</code>层的<code>GetUserProfile</code>用例。</li></ul><h3 id="5-数据回流到Presentation层"><a href="#5-数据回流到Presentation层" class="headerlink" title="5. 数据回流到Presentation层"></a>5. 数据回流到Presentation层</h3><ul><li><code>GetUserProfile</code>用例收到<code>Data</code>层提供的用户信息后，将这些信息返回给最初请求它的<code>Presentation</code>层的组件。</li><li><code>Presentation</code>层的ViewModel接收到这些数据后，更新UI绑定的数据模型，通常是通过LiveData或类似机制。</li></ul><h3 id="6-UI更新显示数据"><a href="#6-UI更新显示数据" class="headerlink" title="6. UI更新显示数据"></a>6. UI更新显示数据</h3><ul><li>最后，随着ViewModel中LiveData（或其他观察者模式实现）的更新，UI监听这些变化，并据此刷新显示，向用户展示最新获取的用户个人信息。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这个过程展示了数据从用户触发获取请求，通过应用的各层传递，并最终显示回用户界面的完整流程。每一层都有其特定的职责：<code>Presentation</code>层管理UI逻辑和用户交互，<code>Domain</code>层定义业务规则和数据获取的抽象接口，而<code>Data</code>层负责具体的数据存取逻辑。这种分层架构不仅有助于保持代码的组织性和可维护性，还促进了各模块间的清晰分离和互操作性。</p><h2 id="解释-Domain-层如何定义业务规则"><a href="#解释-Domain-层如何定义业务规则" class="headerlink" title="解释 Domain 层如何定义业务规则"></a>解释 Domain 层如何定义业务规则</h2><p><code>Domain</code>层在分层架构中扮演着核心角色，它定义了应用程序的业务规则和逻辑。这一层是独立于用户界面（UI）和数据存储机制的，意味着它不应该依赖于任何特定的框架或库，以便于业务逻辑能够在不同的环境中重用和测试。<code>Domain</code>层的设计主要关注于应用程序的“什么”和“为什么”，而不是“怎么做”。</p><h3 id="业务规则的定义"><a href="#业务规则的定义" class="headerlink" title="业务规则的定义"></a>业务规则的定义</h3><p>业务规则是指那些定义企业如何运作、决策应如何做出、业务流程应如何管理的规则。在软件开发中，这些规则转化为可以执行的代码，用于指导应用程序的行为。业务规则包括但不限于：</p><ul><li><strong>实体（Entities）</strong>：代表业务概念的对象，如用户、订单等，以及这些对象的属性和行为。</li><li><strong>用例（Use Cases）或服务（Services）</strong>：封装了应用程序的核心功能，每个用例代表一个或多个业务操作，如“获取用户信息”、“创建订单”等。</li><li><strong>值对象（Value Objects）</strong>：描述了业务中的值和它们的属性，但没有唯一标识符（与实体不同）。</li><li><strong>仓库接口（Repository Interfaces）</strong>：定义了如何访问外部数据源（如数据库或远程服务）的抽象接口，但不实现具体的数据访问逻辑。</li></ul><h3 id="Domain层的职责"><a href="#Domain层的职责" class="headerlink" title="Domain层的职责"></a><code>Domain</code>层的职责</h3><ul><li><strong>封装业务逻辑</strong>：<code>Domain</code>层包含应用程序的业务逻辑，确保业务操作的正确性、有效性和连贯性。</li><li><strong>定义业务模型</strong>：通过实体和值对象定义业务领域内的数据模型和它们之间的关系。</li><li><strong>业务决策的实现</strong>：实现业务决策逻辑，如验证规则、计算和数据转换等。</li><li><strong>保持独立性</strong>：<code>Domain</code>层的设计应确保它不依赖于特定的UI实现或数据存储策略，使得业务逻辑可以在不同的应用场景下重用。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有一个在线商店应用，其<code>Domain</code>层可能包含如下定义：</p><ul><li><strong>实体</strong>：<code>Product</code>（产品）、<code>Customer</code>（客户）、<code>Order</code>（订单）。</li><li><strong>用例</strong>：<code>PlaceOrder</code>（下订单）、<code>CancelOrder</code>（取消订单）、<code>UpdateCustomerProfile</code>（更新客户资料）。</li><li><strong>值对象</strong>：<code>Address</code>（地址）、<code>Money</code>（货币）。</li><li><strong>仓库接口</strong>：<code>OrderRepository</code>（提供对订单数据的访问）、<code>CustomerRepository</code>（提供对客户数据的访问）。</li></ul><p>在这个例子中，<code>Domain</code>层定义了在线商店运作的基本规则和逻辑，如何处理订单、如何管理客户信息，以及如何执行业务决策，所有这些都与特定的UI实现或数据持久化机制无关。</p><p>总结，<code>Domain</code>层的设计是为了确保应用程序的核心业务逻辑得到清晰定义、良好封装，从而易于维护和测试，同时提高了代码的可重用性。</p><h2 id="解释-Domain-层定义了基本规则和逻辑，与特定的-UI-实现或数据持久化机制无关"><a href="#解释-Domain-层定义了基本规则和逻辑，与特定的-UI-实现或数据持久化机制无关" class="headerlink" title="解释 Domain 层定义了基本规则和逻辑，与特定的 UI 实现或数据持久化机制无关"></a>解释 Domain 层定义了基本规则和逻辑，与特定的 UI 实现或数据持久化机制无关</h2><p><code>Domain</code>层在软件架构中的作用是封装和实现应用程序的核心业务逻辑，独立于用户界面（UI）和数据持久化（数据库等）的具体实现。这种设计方法使得业务逻辑更加模块化、清晰，并且易于测试和维护。在在线商店的例子中，<code>Domain</code>层定义的业务规则和逻辑涉及以下几个关键方面：</p><h3 id="如何处理订单"><a href="#如何处理订单" class="headerlink" title="如何处理订单"></a>如何处理订单</h3><p>在<code>Domain</code>层中，处理订单的逻辑包括订单的创建、验证、支付、取消等步骤。这些操作反映了订单生命周期中的各个阶段，每个阶段都基于业务规则来执行。例如，订单支付前需要验证订单详情和客户支付信息的有效性；订单一旦支付成功，就不能随意取消，除非满足特定的退款条件。</p><h3 id="如何管理客户信息"><a href="#如何管理客户信息" class="headerlink" title="如何管理客户信息"></a>如何管理客户信息</h3><p>客户信息管理包括客户注册、信息更新、历史订单查询等功能。<code>Domain</code>层通过定义客户实体（<code>Customer</code>）和相关的业务操作（如<code>UpdateCustomerProfile</code>）来实现这一点。这些操作确保了客户信息的一致性和安全性，例如，客户密码需要加密存储，客户信息更新需要验证客户的身份。</p><h3 id="如何执行业务决策"><a href="#如何执行业务决策" class="headerlink" title="如何执行业务决策"></a>如何执行业务决策</h3><p>业务决策涉及到基于特定条件执行的逻辑选择，比如根据库存量决定是否接受订单、根据客户购买历史提供个性化推荐等。这些决策通常通过<code>Domain</code>层中的业务规则来实现，业务规则可能包括各种验证逻辑、计算公式和决策树。</p><h3 id="与UI和数据持久化机制的独立性"><a href="#与UI和数据持久化机制的独立性" class="headerlink" title="与UI和数据持久化机制的独立性"></a>与UI和数据持久化机制的独立性</h3><p><code>Domain</code>层的设计目的是保持对UI层和数据持久化层的独立性。这意味着，不管UI如何变化（无论是移动应用、Web页面还是桌面应用），<code>Domain</code>层的业务逻辑不需要做出改变。同样，数据存储的细节（是使用SQL数据库、NoSQL数据库还是云服务）对<code>Domain</code>层也是透明的。这一层只通过抽象的接口（如<code>Repository</code>接口）与数据交互，具体的实现细节由<code>Data</code>层负责。</p><p>通过将业务逻辑集中在<code>Domain</code>层，应用程序的核心功能和规则得到了清晰的定义和封装，这不仅有助于减少不同层之间的耦合，还使得业务逻辑更容易理解、测试和维护。此外，这种架构设计还增加了应用程序的灵活性，使得未来对应用程序的扩展和修改变得更加容易。</p><h2 id="抽出-domain-层的意义是什么"><a href="#抽出-domain-层的意义是什么" class="headerlink" title="抽出 domain 层的意义是什么"></a>抽出 domain 层的意义是什么</h2><p>抽出<code>Domain</code>层在软件架构中的意义主要体现在以下几个方面：</p><h3 id="1-业务逻辑集中化"><a href="#1-业务逻辑集中化" class="headerlink" title="1. 业务逻辑集中化"></a>1. 业务逻辑集中化</h3><p>将业务逻辑集中在<code>Domain</code>层，有助于明确应用程序的核心功能和规则，使得这些逻辑独立于其他层（如表示层和数据持久化层）的实现。这种集中化有助于保持业务规则的一致性，确保业务操作遵循同一套逻辑，无论是通过何种途径执行。</p><h3 id="2-提高可维护性"><a href="#2-提高可维护性" class="headerlink" title="2. 提高可维护性"></a>2. 提高可维护性</h3><p>通过将业务逻辑与数据访问代码（<code>Data</code>层）和用户界面代码（<code>Presentation</code>层）分离，开发人员可以更容易地理解、修改和扩展业务规则。当业务需求发生变化时，通常只需要修改<code>Domain</code>层的代码，而无需触及到其他层的实现，这大大降低了维护成本和复杂性。</p><h3 id="3-增强可测试性"><a href="#3-增强可测试性" class="headerlink" title="3. 增强可测试性"></a>3. 增强可测试性</h3><p>独立的<code>Domain</code>层使得业务逻辑的单元测试变得更加直接和简单。因为业务逻辑与外部的界面显示和数据存取逻辑解耦，测试可以集中在业务规则的正确性上，而不必担心UI或数据库的具体实现。这有助于提高测试覆盖率和发现潜在的业务逻辑错误。</p><h3 id="4-促进技术栈灵活性"><a href="#4-促进技术栈灵活性" class="headerlink" title="4. 促进技术栈灵活性"></a>4. 促进技术栈灵活性</h3><p>由于<code>Domain</code>层独立于具体的技术实现，因此可以在不影响业务逻辑的前提下更换表示层框架或数据持久化技术。例如，可以从一个数据库系统迁移到另一个，或者在不同的前端技术（如Web、移动应用）之间共享相同的业务逻辑。</p><h3 id="5-便于多团队协作"><a href="#5-便于多团队协作" class="headerlink" title="5. 便于多团队协作"></a>5. 便于多团队协作</h3><p>在大型项目中，不同的团队可以负责不同的应用层，例如一个团队专注于<code>Domain</code>层的业务逻辑开发，而另一个团队专注于用户界面的实现。这种分工有助于提高开发效率，因为团队可以并行工作，而且减少了彼此工作的直接依赖。</p><h3 id="6-支持多种应用场景"><a href="#6-支持多种应用场景" class="headerlink" title="6. 支持多种应用场景"></a>6. 支持多种应用场景</h3><p><code>Domain</code>层的业务逻辑可以被不同的应用场景重用，比如同一个业务逻辑既能服务于Web应用，也能服务于移动应用或桌面应用。这种重用性可以显著降低开发和维护新平台应用的成本和时间。</p><p>总之，抽出<code>Domain</code>层是实现软件架构清晰分层、提高代码质量和维护性的重要策略，它有助于构建更加健壯、灵活和可持续发展的软件系统。</p><h1 id="这样做为什么可以只需要修改Domain层的代码，而无需触及到其他层的实现"><a href="#这样做为什么可以只需要修改Domain层的代码，而无需触及到其他层的实现" class="headerlink" title="这样做为什么可以只需要修改Domain层的代码，而无需触及到其他层的实现"></a>这样做为什么可以只需要修改Domain层的代码，而无需触及到其他层的实现</h1><p>当业务需求发生变化时，通常只需要修改<code>Domain</code>层的代码而无需触及到其他层的实现，这个原理主要是基于软件设计中的分层架构和关注点分离的原则。让我们来详细解释一下为什么这样做是可行的：</p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>在一个典型的分层架构中，软件被划分为几个层次，每个层次负责处理不同的任务。这些层次通常包括：</p><ul><li><strong>表示层（Presentation Layer）</strong>：负责用户界面和用户交云的处理。</li><li><strong>领域层（Domain Layer）</strong>：包含业务逻辑和业务规则。</li><li><strong>数据访问层（Data Access Layer）</strong>：负责数据持久化和数据检索。</li></ul><h3 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h3><p>分层架构实现了关注点分离（Separation of Concerns, SoC）的原则，即不同的层次关注不同的方面。通过这种方式，每一层都可以独立于其他层变化，只要它们之间的接口保持不变。</p><h3 id="对于业务逻辑的变化"><a href="#对于业务逻辑的变化" class="headerlink" title="对于业务逻辑的变化"></a>对于业务逻辑的变化</h3><ul><li><strong>业务逻辑变化通常发生在Domain层</strong>：因为<code>Domain</code>层封装了应用程序的核心业务规则和逻辑。当业务需求变化时，这些变化几乎总是直接影响到业务规则和逻辑，而这些都是<code>Domain</code>层的职责范畴。</li><li><strong>表示层和数据访问层的独立性</strong>：由于表示层主要负责界面显示和用户交互，数据访问层主要负责数据的持久化和检索，这两层的工作与业务逻辑的具体内容相对独立。它们通过定义良好的接口与<code>Domain</code>层交互，只要这些接口不变，业务逻辑的变更就不会直接影响到它们。</li><li><strong>接口作为契约</strong>：<code>Domain</code>层通过接口与其他层进行交互。当业务需求变化导致<code>Domain</code>层的逻辑变化时，只要接口保持不变，表示层和数据访问层就无需变化。即使接口需要变化，现代编程语言和框架提供的抽象和封装机制也能最小化这种变化的影响。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假设一个电子商务应用，其中有一个计算订单总价的业务逻辑。如果业务规定更改了订单的折扣计算方式，这个变化直接关系到订单总价的计算规则，这是<code>Domain</code>层的一部分。只需修改<code>Domain</code>层中计算总价的代码即可。只要<code>Domain</code>层对外提供的计算总价的接口不变，表示层（可能显示总价的界面）和数据访问层（可能存储订单详情的数据库操作）就不需要任何改动。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，将业务逻辑封装在<code>Domain</code>层，确保了应用程序在面对业务需求变化时，可以局部化修改影响，减少了需要修改的代码量，从而降低了维护成本和复杂性。这种设计使得软件系统更加灵活和可维护，更容易适应和响应业务变化。</p><h2 id="给出代码例子"><a href="#给出代码例子" class="headerlink" title="给出代码例子"></a>给出代码例子</h2><p>让我们通过一个简化的代码示例来说明当业务需求发生变化时，通常只需要修改<code>Domain</code>层的代码而无需触及到其他层的实现。考虑一个电子商务应用，其中包含一个功能：计算订单总价。我们将展示<code>Domain</code>层、<code>Data</code>层和<code>Presentation</code>层的简化代码，并展示当业务规则（例如，订单折扣规则）变化时，如何只修改<code>Domain</code>层代码来应对这一变化。</p><h3 id="初始实现"><a href="#初始实现" class="headerlink" title="初始实现"></a>初始实现</h3><h4 id="Domain层"><a href="#Domain层" class="headerlink" title="Domain层"></a>Domain层</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Domain层 - 定义业务逻辑接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateTotalPrice</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">OrderItem</span>&gt;)</span></span>: <span class="built_in">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Domain层 - 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> : <span class="type">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateTotalPrice</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">OrderItem</span>&gt;)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.sumOf &#123; it.price * it.quantity &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span>(<span class="keyword">val</span> price: <span class="built_in">Double</span>, <span class="keyword">val</span> quantity: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><h4 id="Data层"><a href="#Data层" class="headerlink" title="Data层"></a>Data层</h4><p>假设数据层处理订单数据的存储和检索，但与计算总价无关，因此在此示例中略过。</p><h4 id="Presentation层"><a href="#Presentation层" class="headerlink" title="Presentation层"></a>Presentation层</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Presentation层 - 使用Domain层的服务展示总价</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> orderService: OrderService) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">displayTotalPrice</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">OrderItem</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> totalPrice = orderService.calculateTotalPrice(items)</span><br><span class="line">        println(<span class="string">&quot;Total Price: <span class="variable">$totalPrice</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务需求变化"><a href="#业务需求变化" class="headerlink" title="业务需求变化"></a>业务需求变化</h3><p>假设业务需求变化，现在需要对订单总价应用10%的折扣。</p><h4 id="修改Domain层"><a href="#修改Domain层" class="headerlink" title="修改Domain层"></a>修改Domain层</h4><p>我们只需要在<code>Domain</code>层中修改<code>OrderServiceImpl</code>的实现来反映这一变化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Domain层 - 修改后的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> : <span class="type">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateTotalPrice</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">OrderItem</span>&gt;)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> originalTotal = items.sumOf &#123; it.price * it.quantity &#125;</span><br><span class="line">        <span class="keyword">val</span> discount = originalTotal * <span class="number">0.1</span> <span class="comment">// 应用10%的折扣</span></span><br><span class="line">        <span class="keyword">return</span> originalTotal - discount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个修改中，我们没有触及<code>Presentation</code>层或<code>Data</code>层的代码。<code>Presentation</code>层仍然以相同的方式调用<code>Domain</code>层的<code>calculateTotalPrice</code>方法，而<code>Data</code>层（假设它负责数据的持久化）也不需要变化，因为它与订单价格的计算逻辑无关。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>通过这个简化的例子，我们可以看到，当业务规则变化（如订单折扣规则）时，只需修改<code>Domain</code>层中的业务逻辑实现。<code>Presentation</code>层和<code>Data</code>层不需要修改，因为它们与<code>Domain</code>层通过抽象的接口进行交互，这个接口（在本例中是<code>OrderService.calculateTotalPrice</code>）保持不变。这种设计使得应用程序能够灵活应对业务需求的变化，同时最小化了修改的影响范围，提高了代码的可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 4 - 架构方案设计 </category>
          
          <category> 4.1 - MVI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频屏幕旋转方案</title>
      <link href="/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/02%20%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/"/>
      <url>/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/02%20%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在Android平台上，实现音视频播放过程中的屏幕旋转涉及到以下几个方面：界面布局的调整、Activity的生命周期管理、保存和恢复播放状态、以及处理屏幕旋转时可能引发的音视频播放问题。以下是一个基本的音视频屏幕旋转方案的步骤：</p><h4 id="布局调整"><a href="#布局调整" class="headerlink" title="布局调整"></a>布局调整</h4><p>在<code>res</code>文件夹中创建不同方向的布局文件，例如<code>layout/activity_main.xml</code>和<code>layout-land/activity_main.xml</code>分别表示竖屏和横屏时的布局。在这些布局文件中，你可以调整控件的摆放位置以适应不同方向的屏幕。</p><h4 id="Activity的生命周期管理"><a href="#Activity的生命周期管理" class="headerlink" title="Activity的生命周期管理"></a>Activity的生命周期管理</h4><p>当屏幕发生旋转时，Activity会经历重新创建的过程。确保你的Activity正确处理生命周期事件，特别是<code>onCreate</code>、<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>等方法。</p><h4 id="保存和恢复播放状态"><a href="#保存和恢复播放状态" class="headerlink" title="保存和恢复播放状态"></a>保存和恢复播放状态</h4><p>在<code>onSaveInstanceState</code>方法中保存当前的播放状态，例如播放位置、播放状态（播放、暂停等），以及其他相关信息。然后在<code>onCreate</code>和<code>onRestoreInstanceState</code>方法中恢复这些状态。</p><h4 id="处理屏幕旋转可能引发的问题"><a href="#处理屏幕旋转可能引发的问题" class="headerlink" title="处理屏幕旋转可能引发的问题"></a>处理屏幕旋转可能引发的问题</h4><p>屏幕旋转可能会导致播放器重新创建或重置，从而影响播放状态。你需要在Activity重新创建时恢复播放状态，并确保播放器不会中断或重置播放进度。</p><h4 id="使用ViewModel来保存播放状态（可选）"><a href="#使用ViewModel来保存播放状态（可选）" class="headerlink" title="使用ViewModel来保存播放状态（可选）"></a>使用ViewModel来保存播放状态（可选）</h4><p>使用ViewModel可以更方便地在屏幕旋转时保持数据。ViewModel会在Activity重新创建时保持其状态，因此你可以将播放状态等数据存储在ViewModel中，以确保不会丢失。</p><h4 id="锁定屏幕方向（可选）"><a href="#锁定屏幕方向（可选）" class="headerlink" title="锁定屏幕方向（可选）"></a>锁定屏幕方向（可选）</h4><p>如果你希望在播放音视频时固定屏幕方向，可以在AndroidManifest.xml中的相应Activity中使用<code>android:screenOrientation</code>属性来指定所需的屏幕方向（如<code>portrait</code>或<code>landscape</code>）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，处理音视频播放过程中的屏幕旋转需要综合考虑界面布局、生命周期管理、数据保存和恢复等方面的问题。合理使用布局文件、Activity生命周期方法、ViewModel等工具，可以帮助你实现稳定且用户友好的音视频播放体验。</p>]]></content>
      
      
      <categories>
          
          <category> 4 - 架构方案设计 </category>
          
          <category> 4.1 - 播放器架构方案设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 音视频屏幕旋转方案</title>
      <link href="/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/03%20Android%20%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/Android-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
      <url>/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/03%20Android%20%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/Android-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Q：我应该去哪里获取不同版本的存储策略</p><p>A：要获取不同版本的 Android 存储策略（Storage Policies），您可以访问以下资源，这些资源提供了详细的版本特定存储策略和变更的信息：</p><h3 id="官方-Android-文档"><a href="#官方-Android-文档" class="headerlink" title="官方 Android 文档"></a>官方 Android 文档</h3><p>Android 官方文档是了解不同版本存储策略最可靠的来源。以下是一些重要的链接：</p><ol><li><p>**<a href="https://developer.android.com/guide/topics/data/data-storage">Android Developers Storage Documentation</a>**：<br>这是 Android 官方的存储文档，涵盖了各种存储选项和最佳实践。</p></li><li><p>**<a href="https://developer.android.com/about/versions">Android Platform Releases</a>**：<br>这个页面提供了每个 Android 版本的详细变更，包括存储策略的变更。</p></li><li><p>**<a href="https://developer.android.com/training/data-storage">Scoped Storage</a>**：<br>针对 Android 10（API Level 29）及更高版本的分区存储（Scoped Storage），是存储策略的重要变更点。</p></li></ol><h3 id="官方博客和公告"><a href="#官方博客和公告" class="headerlink" title="官方博客和公告"></a>官方博客和公告</h3><p>Android 官方博客和公告也是了解存储策略变更的好资源：</p><ol><li>**<a href="https://android-developers.googleblog.com/">Android Developers Blog</a>**：<br>在这个博客上，Google 发布了关于新功能和存储策略变更的详细信息和指导。</li></ol><h3 id="GitHub-和社区资源"><a href="#GitHub-和社区资源" class="headerlink" title="GitHub 和社区资源"></a>GitHub 和社区资源</h3><p>开源社区和开发者论坛也提供了大量关于存储策略的信息：</p><ol><li><p>**<a href="https://github.com/android/sunflower">Google Samples on GitHub</a>**：<br>Google 提供的示例项目，可以查看不同版本的存储策略实现。</p></li><li><p>**<a href="https://stackoverflow.com/">Stack Overflow</a>**：<br>搜索关于 Android 存储策略的问题和答案，可以获取社区的解决方案和建议。</p></li></ol><h3 id="具体版本的存储策略变更"><a href="#具体版本的存储策略变更" class="headerlink" title="具体版本的存储策略变更"></a>具体版本的存储策略变更</h3><p>要了解具体版本的存储策略变更，可以参考以下步骤：</p><ol><li><p><strong>访问 Android 开发者文档中的版本变更日志</strong>：<br>每个 Android 版本的变更日志会详细列出该版本的新特性和变更，包括存储策略。</p></li><li><p><strong>查找特定版本的存储策略文档</strong>：<br>在 Android Developers 网站上，您可以找到特定版本的 API 参考和变更日志。</p></li></ol><h3 id="直接搜索具体问题"><a href="#直接搜索具体问题" class="headerlink" title="直接搜索具体问题"></a>直接搜索具体问题</h3><p>如果您有特定的存储策略问题，可以直接在 Google 搜索：</p><ul><li>例如：<code>Android 10 Scoped Storage</code></li><li>例如：<code>Android 11 Storage Policy Changes</code></li></ul><p>通过这些资源，您应该能够找到详细的 Android 存储策略信息，并理解每个版本的特定变更。</p><h1 id="Android-6-以下的文件存储和读取策略"><a href="#Android-6-以下的文件存储和读取策略" class="headerlink" title="Android 6 以下的文件存储和读取策略"></a>Android 6 以下的文件存储和读取策略</h1><p>在Android 6.0（API Level 23）及以下版本中，文件存储和读取的策略主要涉及以下几个方面：</p><h3 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1. 存储位置"></a>1. 存储位置</h3><p>Android系统提供了两种主要的存储位置：内部存储和外部存储。</p><h4 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h4><ul><li>内部存储是应用的私有存储区域，只有该应用可以访问。</li><li>存储在内部存储中的文件默认在应用卸载时会被删除。</li><li>使用<code>Context</code>对象的方法可以在内部存储中读写文件，例如：<ul><li><code>openFileOutput(String name, int mode)</code>：写文件</li><li><code>openFileInput(String name)</code>：读文件</li></ul></li></ul><h4 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h4><ul><li>外部存储可以是设备的外部存储卡或者内置存储分区。</li><li>分为公共外部存储和应用私有外部存储。</li><li>公共外部存储可以被所有应用访问，例如图片、音频文件等。</li><li>应用私有外部存储只能被创建该文件的应用访问，在应用卸载时会被删除。</li><li>使用<code>Environment</code>类和<code>Context</code>对象的方法可以在外部存储中读写文件，例如：<ul><li><code>getExternalFilesDir(String type)</code>：获取应用私有外部存储目录</li><li><code>Environment.getExternalStoragePublicDirectory(String type)</code>：获取公共外部存储目录</li></ul></li></ul><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><p>在Android 6.0及以下版本中，应用需要在<code>AndroidManifest.xml</code>中声明对外部存储的读写权限：</p><ul><li>读权限：<code>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</code></li><li>写权限：<code>&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></li></ul><p>这些权限在应用安装时由用户批准。</p><h3 id="3-文件操作代码示例"><a href="#3-文件操作代码示例" class="headerlink" title="3. 文件操作代码示例"></a>3. 文件操作代码示例</h3><h4 id="内部存储-1"><a href="#内部存储-1" class="headerlink" title="内部存储"></a>内部存储</h4><p>写文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;myfile.txt&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">fileContents</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> openFileOutput(filename, Context.MODE_PRIVATE);</span><br><span class="line">fos.write(fileContents.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>读文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> openFileInput(filename);</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    sb.append(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">fileContents</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h4 id="外部存储-1"><a href="#外部存储-1" class="headerlink" title="外部存储"></a>外部存储</h4><p>检查存储状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Environment.getExternalStorageState();</span><br><span class="line"><span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">    <span class="comment">// 可以读写外部存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalFilesDir(<span class="literal">null</span>), <span class="string">&quot;myfile.txt&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">fos.write(fileContents.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>读文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalFilesDir(<span class="literal">null</span>), <span class="string">&quot;myfile.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    sb.append(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">fileContents</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>这些代码示例展示了在Android 6.0及以下版本中如何进行基本的文件读写操作。随着Android版本的升级，文件存储和权限管理策略也发生了显著变化，因此在开发过程中需要根据目标API版本进行适配。</p><h1 id="Android-6-以上文件存储和读取策略"><a href="#Android-6-以上文件存储和读取策略" class="headerlink" title="Android 6 以上文件存储和读取策略"></a>Android 6 以上文件存储和读取策略</h1><p>在Android 6.0（API Level 23）及以上版本中，文件存储和读取策略发生了一些变化，特别是在权限管理和存储位置的使用方面。以下是各版本的策略变化和相应的文件存储读写方法。</p><h3 id="1-Android-6-0-API-Level-23"><a href="#1-Android-6-0-API-Level-23" class="headerlink" title="1. Android 6.0 (API Level 23)"></a>1. Android 6.0 (API Level 23)</h3><h4 id="动态权限"><a href="#动态权限" class="headerlink" title="动态权限"></a>动态权限</h4><ul><li>从Android 6.0开始，权限管理采用动态权限模式。用户可以在运行时授予或拒绝权限。</li><li>应用在使用外部存储时，需要在<code>AndroidManifest.xml</code>中声明权限，并在运行时请求权限。</li></ul><p><strong>权限请求代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)</span><br><span class="line">        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_CODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Android-7-0-API-Level-24"><a href="#2-Android-7-0-API-Level-24" class="headerlink" title="2. Android 7.0 (API Level 24)"></a>2. Android 7.0 (API Level 24)</h3><h4 id="文件URI策略"><a href="#文件URI策略" class="headerlink" title="文件URI策略"></a>文件URI策略</h4><ul><li>从Android 7.0开始，<code>File</code> URI不再被允许在应用之间共享。必须使用<code>FileProvider</code>来共享文件URI。</li></ul><p><strong><code>FileProvider</code>配置示例：</strong><br>在<code>AndroidManifest.xml</code>中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>res/xml/file_paths.xml</code>中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">&quot;external_files&quot;</span> <span class="attr">path</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Android-8-0-API-Level-26"><a href="#3-Android-8-0-API-Level-26" class="headerlink" title="3. Android 8.0 (API Level 26)"></a>3. Android 8.0 (API Level 26)</h3><h4 id="安全性增强"><a href="#安全性增强" class="headerlink" title="安全性增强"></a>安全性增强</h4><ul><li>在后台执行文件操作受到限制，必须在前台任务或通过服务进行文件操作。</li></ul><h3 id="4-Android-9-0-API-Level-28"><a href="#4-Android-9-0-API-Level-28" class="headerlink" title="4. Android 9.0 (API Level 28)"></a>4. Android 9.0 (API Level 28)</h3><h4 id="共享存储访问"><a href="#共享存储访问" class="headerlink" title="共享存储访问"></a>共享存储访问</h4><ul><li>在Android 9.0中引入了新的API，用于访问共享存储，推荐使用<code>ACTION_OPEN_DOCUMENT</code>和<code>ACTION_CREATE_DOCUMENT</code>来访问和创建文件。</li></ul><p><strong>使用示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_OPEN_DOCUMENT);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">intent.setType(<span class="string">&quot;*/*&quot;</span>);</span><br><span class="line">startActivityForResult(intent, REQUEST_CODE_OPEN_DOCUMENT);</span><br></pre></td></tr></table></figure><h3 id="5-Android-10-API-Level-29"><a href="#5-Android-10-API-Level-29" class="headerlink" title="5. Android 10 (API Level 29)"></a>5. Android 10 (API Level 29)</h3><h4 id="分区存储-Scoped-Storage"><a href="#分区存储-Scoped-Storage" class="headerlink" title="分区存储 (Scoped Storage)"></a>分区存储 (Scoped Storage)</h4><ul><li>引入了分区存储，应用只能访问其私有的外部存储空间，除非使用特定的API访问公共存储。</li><li>可以通过请求Legacy存储模式来继续使用传统的存储访问方式（直到Android 11）。</li></ul><p><strong>分区存储代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalFilesDir(<span class="literal">null</span>), <span class="string">&quot;myfile.txt&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">fos.write(fileContents.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="6-Android-11-API-Level-30"><a href="#6-Android-11-API-Level-30" class="headerlink" title="6. Android 11 (API Level 30)"></a>6. Android 11 (API Level 30)</h3><h4 id="强制分区存储"><a href="#强制分区存储" class="headerlink" title="强制分区存储"></a>强制分区存储</h4><ul><li>强制启用分区存储，应用无法再使用<code>requestLegacyExternalStorage</code>标志。</li><li>提供了新的访问存储的API，如<code>MediaStore</code>。</li></ul><p><strong>MediaStore使用示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(MediaStore.MediaColumns.DISPLAY_NAME, <span class="string">&quot;myfile.txt&quot;</span>);</span><br><span class="line">values.put(MediaStore.MediaColumns.MIME_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOCUMENTS);</span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> getContentResolver().insert(MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>), values);</span><br><span class="line"><span class="keyword">if</span> (uri != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> getContentResolver().openOutputStream(uri);</span><br><span class="line">    outputStream.write(fileContents.getBytes());</span><br><span class="line">    outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Android-12-API-Level-31-及更高版本"><a href="#7-Android-12-API-Level-31-及更高版本" class="headerlink" title="7. Android 12 (API Level 31) 及更高版本"></a>7. Android 12 (API Level 31) 及更高版本</h3><h4 id="进一步限制外部存储访问"><a href="#进一步限制外部存储访问" class="headerlink" title="进一步限制外部存储访问"></a>进一步限制外部存储访问</h4><ul><li>在Android 12中，对特定类型的文件访问进行了更多的限制，需要使用特定的API来访问不同类型的文件，如音频、视频和图片等。</li></ul><p><strong>总结：</strong></p><ul><li>Android 6.0及以上版本在权限管理上采用动态权限，需要在运行时请求权限。</li><li>Android 7.0开始引入<code>FileProvider</code>来共享文件URI。</li><li>Android 10引入分区存储，Android 11强制启用分区存储，进一步限制了应用对外部存储的访问。</li><li>使用<code>MediaStore</code>等新的API来进行文件的读写操作，以适应最新的存储策略。</li></ul><p>了解并适应这些变化，可以确保应用在不同Android版本上的文件存储和读取操作安全且有效。</p>]]></content>
      
      
      <categories>
          
          <category> 4 - 架构方案设计 </category>
          
          <category> 4.2 - Android 存储文件方案设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 第一课-万物皆地址</title>
      <link href="/2023/08/29/5%20C++/C++%E7%AC%AC%E4%B8%80%E8%AF%BE-%E4%B8%87%E7%89%A9%E7%9A%86%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/08/29/5%20C++/C++%E7%AC%AC%E4%B8%80%E8%AF%BE-%E4%B8%87%E7%89%A9%E7%9A%86%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>作者：朕小猫与GPT4</p><h1 id="怎么理解C-万物皆地址"><a href="#怎么理解C-万物皆地址" class="headerlink" title="怎么理解C++万物皆地址"></a>怎么理解C++万物皆地址</h1><p>在 C++ 程序中，几乎所有元素（包括变量、对象、函数等）都可以通过它们的内存地址来引用或操作。这一点归根结底是因为 C++ 是一种底层的编程语言，它允许直接访问内存和底层硬件资源。这种能力带来了极高的灵活性和控制能力，但同时也要求程序员对程序的内存使用有深入的理解。下面是如何通过内存地址来引用或操作元素的几个方面：</p><ol><li><h2 id="变量和对象的内存地址："><a href="#变量和对象的内存地址：" class="headerlink" title="变量和对象的内存地址："></a><strong>变量和对象的内存地址</strong>：</h2><p>在 C++ 中，每个变量或对象都占据内存中的一个或多个连续位置。你可以使用 <code>&amp;</code> 操作符获得一个变量的内存地址，这个地址可以赋给一个指针变量。通过指针，你可以读取或修改存储在该地址的数据。这对于数组和自定义数据结构尤其有用，因为可以通过指针算术进行高效的遍历和访问。</p></li><li><h2 id="函数的地址："><a href="#函数的地址：" class="headerlink" title="函数的地址："></a><strong>函数的地址</strong>：</h2><p>C++ 允许获取函数的地址，并将其赋给函数指针。这使得程序可以在运行时决定调用哪个函数，提高了代码的灵活性和可重用性。函数指针广泛应用于回调机制、事件驱动编程和接口设计中。</p></li><li><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><strong>引用</strong>：</h2><p>C++ 的引用机制实际上是一种特殊的语法糖，它在内部使用地址来实现。引用允许你创建一个变量的别名，通过别名可以直接访问和修改原始变量，而无需显式解引用。这样不仅代码更加简洁，而且避免了指针可能带来的错误。</p></li><li><h2 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a><strong>动态内存分配</strong>：</h2><p>C++ 通过 <code>new</code> 和 <code>delete</code> 操作符提供了动态内存分配的能力。使用 <code>new</code> 分配的内存位于堆区，它会返回指向分配内存的指针。通过这个指针，程序可以在运行时动态地分配、访问和释放内存。</p></li></ol><p>通过上述机制，C++ 程序可以精确地控制内存的使用方式，从而优化程序性能和资源管理。然而，这也意呀着程序员必须对指针、内存地址以及内存管理有充分的理解，才能有效地利用这些特性编写高效、安全的代码。</p><p>编写教程时，目标是清晰、简洁且具有实用性。以下是一个关于“如何在 C++ 中使用指针和地址”教程的示例内容。这段内容旨在介绍初学者到 C++ 的指针和地址概念，帮助他们理解和运用“万物皆地址”的原则。</p><hr><h1 id="C-指针和地址入门"><a href="#C-指针和地址入门" class="headerlink" title="C++ 指针和地址入门"></a>C++ 指针和地址入门</h1><p>在 C++ 中，理解指针和地址是掌握语言的基石。本教程将引导你通过简单的步骤来理解和使用指针和地址。</p><h2 id="1-理解地址"><a href="#1-理解地址" class="headerlink" title="1. 理解地址"></a>1. 理解地址</h2><p>在 C++ 中，每个变量都存储在内存的一个特定位置，这个位置可以通过地址来访问。你可以使用 <code>&amp;</code> 操作符来获取变量的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;变量的地址: &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会输出变量 <code>var</code> 的内存地址。</p><h2 id="2-使用指针"><a href="#2-使用指针" class="headerlink" title="2. 使用指针"></a>2. 使用指针</h2><p>指针是存储另一个变量地址的变量。在 C++ 中，你可以使用 <code>*</code> 来声明指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;var;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 指向的地址: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 指向的地址上的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr</code> 是一个指向 <code>var</code> 地址的指针。通过 <code>*ptr</code>，我们可以访问这个地址上的值。</p><h2 id="3-指针的使用场景"><a href="#3-指针的使用场景" class="headerlink" title="3. 指针的使用场景"></a>3. 指针的使用场景</h2><p>指针在 C++ 中的应用非常广泛，包括：</p><ul><li><strong>动态内存管理</strong>：使用 <code>new</code> 和 <code>delete</code> 操作符分配和释放内存。</li><li><strong>函数参数传递</strong>：通过传递指针或引用来修改函数外的变量。</li><li><strong>构建复杂数据结构</strong>：如链表、树等。</li></ul><h2 id="4-练习：使用指针交换两个变量的值"><a href="#4-练习：使用指针交换两个变量的值" class="headerlink" title="4. 练习：使用指针交换两个变量的值"></a>4. 练习：使用指针交换两个变量的值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个练习演示了如何使用指针来交换两个变量的值。</p><h1 id="C-通过地址修改值"><a href="#C-通过地址修改值" class="headerlink" title="C++ 通过地址修改值"></a>C++ 通过地址修改值</h1><p>在 C++ 中，通过地址修改值是指针操作的一个基本用途。指针是一种特殊的变量，其值为另一个变量的内存地址。<br>通过指针，你可以直接访问和修改它指向的内存位置上存储的数据。<br>这一过程涉及几个关键步骤：获取变量的地址、使用指针指向该地址、通过指针修改该地址上的值。<br>下面通过一个简单的示例来说明这一过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;    <span class="comment">// 定义一个变量value并初始化为10</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;value; <span class="comment">// 定义一个指针ptr，将其初始化为value的地址</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original value: &quot;</span> &lt;&lt; value &lt;&lt; endl; <span class="comment">// 显示原始的value值</span></span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">// 通过指针ptr修改value的值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; value &lt;&lt; endl; <span class="comment">// 显示修改后的value值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中：</p><ol><li>我们首先定义了一个类型为 <code>int</code> 的变量 <code>value</code> 并初始化为 10。</li><li>然后，我们定义了一个类型为 <code>int*</code> 的指针 <code>ptr</code> 并将其初始化为 <code>value</code> 的地址（<code>&amp;value</code>）。</li><li>通过 <code>cout</code> 输出语句，我们可以看到 <code>value</code> 的原始值。</li><li>接着，我们通过指针 <code>ptr</code> 来修改 <code>value</code> 的值。这里的 <code>*ptr = 20;</code> 表示将 <code>ptr</code> 指向的内存位置（即 <code>value</code> 的位置）上的数据修改为 20。<code>*ptr</code> 是解引用操作符的应用，它获取指针指向的内存地址上存储的值。</li><li>最后，再次通过 <code>cout</code> 输出 <code>value</code> 的值，可以看到它已经被修改为 20。</li></ol><h1 id="函数传参的内存地址"><a href="#函数传参的内存地址" class="headerlink" title="函数传参的内存地址"></a>函数传参的内存地址</h1><p>在 C++ 中，理解函数传参的内存地址涉及到两个主要概念：按值传递（Pass by Value）和按引用传递（Pass by Reference）。理解这些概念有助于深入理解 C++ 如何在函数调用中处理参数的内存地址。</p><h2 id="按值传递（Pass-by-Value）"><a href="#按值传递（Pass-by-Value）" class="headerlink" title="按值传递（Pass by Value）"></a>按值传递（Pass by Value）</h2><p>当函数参数是按值传递时，函数接收的是实参的一个副本。这意味着函数内部对参数所做的任何修改都不会影响到原始数据。在内存层面，这个过程涉及到将原始数据的值复制到新的内存地址中。这个新的地址是函数参数在函数调用栈上的局部地址。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>保护了原始数据，避免了意外修改。</li><li>对于基本数据类型，这种方式简单且效率较高。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对于大型结构或类实例，复制可能导致性能下降。</li><li>无法在函数外部反映函数内部对数据的修改。</li></ul><h2 id="按引用传递（Pass-by-Reference）"><a href="#按引用传递（Pass-by-Reference）" class="headerlink" title="按引用传递（Pass by Reference）"></a>按引用传递（Pass by Reference）</h2><p>按引用传递意味着函数接收的是实参的引用（或者说是内存地址）。这样，函数内部对参数的任何修改都会直接影响到原始数据。在内存层面，这避免了数据的复制，函数参数直接使用了实参的地址。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>可以直接修改原始数据。</li><li>避免了大型数据结构的复制，提高了效率。</li><li>可以通过返回多个结果值（通过修改传入的引用或指针参数）。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果不希望修改原始数据，需要谨慎操作。</li><li>使用不当可能导致错误或数据损坏。</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设我们有一个简单的函数，目的是修改一个整数的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTenByValue</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    number += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 这里修改的是number的副本，外部的原始变量不受影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTenByReference</span><span class="params">(<span class="type">int</span> &amp;number)</span> </span>&#123;</span><br><span class="line">    number += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 这里直接修改的是传入变量的值，外部的原始变量也会被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>addTenByValue</code> 函数无法修改外部变量的值，因为它仅操作了参数的副本。而 <code>addTenByReference</code> 函数则直接操作了实参的内存地址，因此它能够修改外部变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> 8 - C++ </category>
          
          <category> 8.1 - C++理论基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数指针与指针函数,C++11 新特性</title>
      <link href="/2023/08/29/5%20C++/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0,C++11%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/08/29/5%20C++/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0,C++11%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>作者：朕小猫与GPT4</p><h1 id="C-函数指针"><a href="#C-函数指针" class="headerlink" title="C++函数指针"></a>C++函数指针</h1><p>在 C++ 中，函数指针是指向函数的指针，允许通过指针调用函数。这种特性让程序在运行时能够选择要调用的函数，增加了代码的灵活性和动态性。理解函数指针对于高级编程技巧，如回调函数、命令模式等是非常重要的。</p><h2 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h2><p>函数指针的定义需要指定函数的返回类型、指针名称以及函数参数的类型。定义函数指针的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (*指针变量名)(参数类型列表);</span><br></pre></td></tr></table></figure><p>例如，如果你有一个返回类型为 <code>int</code> 并接受两个 <code>int</code> 类型参数的函数，你可以这样定义一个指向该函数的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><h2 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h2><p>一旦定义了函数指针，就可以将其指向具有相应签名的任何函数，然后通过该指针调用函数。这里有一个使用函数指针的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针并使其指向add函数</span></span><br><span class="line">    <span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">funcPtr</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum is: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针的用途"><a href="#函数指针的用途" class="headerlink" title="函数指针的用途"></a>函数指针的用途</h2><p>函数指针最常见的用途包括：</p><ul><li><strong>回调函数</strong>：允许库或框架调用在使用库的代码中定义的函数。</li><li><strong>事件处理</strong>：在发生特定事件时动态决定调用哪个函数。</li><li><strong>接口实现</strong>：通过函数指针数组或结构体实现类似于面向对象编程中接口或虚函数的功能。</li><li><strong>命令模式</strong>：将操作封装为对象，允许存储、传递和调用操作。</li></ul><h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><p>随着 C++11 的引入，现代 C++ 更倾向于使用 std::function 和 lambda 表达式来替代裸函数指针，因为它们提供了更高的灵活性和更简洁的语法。例如，<code>std::function</code> 可以存储并调用任何可调用的实体，包括普通函数、lambda 表达式、以及其他具有 <code>operator()</code> 的对象。</p><h1 id="举例子，说明函数指针使用的几种场景"><a href="#举例子，说明函数指针使用的几种场景" class="headerlink" title="举例子，说明函数指针使用的几种场景"></a>举例子，说明函数指针使用的几种场景</h1><p>函数指针在 C++ 中的应用非常广泛，提供了编程的灵活性和动态性。以下是几种典型场景，展示了函数指针的使用：</p><h2 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. 回调函数</h2><p>回调函数是由用户编写的，但由系统或库在适当的时候调用的函数。函数指针允许用户提供具体的回调函数实现，使得库或框架可以在运行时调用用户定义的代码。</p><p><strong>示例：</strong> 设计一个简单的事件处理器，当发生某个事件时，调用用户提供的回调函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回调函数类型</span></span><br><span class="line"><span class="keyword">using</span> Callback = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(Callback cb)</span> </span>&#123;</span><br><span class="line">        callbacks.<span class="built_in">push_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">triggerEvent</span><span class="params">(<span class="type">int</span> eventData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cb : callbacks) &#123;</span><br><span class="line">            <span class="built_in">cb</span>(eventData); <span class="comment">// 调用回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Callback&gt; callbacks; <span class="comment">// 回调函数列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户定义的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onEventTriggered</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Event triggered with data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventProcessor ep;</span><br><span class="line">    ep.<span class="built_in">registerCallback</span>(onEventTriggered); <span class="comment">// 注册回调函数</span></span><br><span class="line">    ep.<span class="built_in">triggerEvent</span>(<span class="number">42</span>); <span class="comment">// 触发事件，调用回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数指针数组"><a href="#2-函数指针数组" class="headerlink" title="2. 函数指针数组"></a>2. 函数指针数组</h2><p>函数指针数组可以存储指向不同函数的指针，使得程序可以基于运行时决策调用不同的函数。</p><p><strong>示例：</strong> 创建一个简单的菜单系统，用户输入不同的选项执行不同的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executing Function 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executing Function 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Executing Function 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(*functions[<span class="number">3</span>])() = &#123;function1, function2, function3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a choice (0-2): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choice &gt;= <span class="number">0</span> &amp;&amp; choice &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        (*functions[choice])(); <span class="comment">// 调用选中的函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid choice&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-接口实现和策略模式"><a href="#3-接口实现和策略模式" class="headerlink" title="3. 接口实现和策略模式"></a>3. 接口实现和策略模式</h2><p>通过函数指针，可以模拟面向对象编程中的接口或策略模式，允许在运行时选择不同的算法或行为。</p><p><strong>示例：</strong> 设计一个简单的排序策略，用户可以选择不同的排序算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SortAlgorithm = <span class="built_in">void</span>(*)(std::vector&lt;<span class="type">int</span>&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ascendingSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">descendingSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortData</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data, SortAlgorithm algorithm)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">algorithm</span>(data); <span class="comment">// 使用指定的排序算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sortData</span>(data, ascendingSort);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : data) std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sortData</span>(data, descendingSort);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : data) std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些示例展示了函数指针在回调、决策和策略选择等不同编程场景中的应用，证明了其为 C++ 编程带来的灵活性和动态性。</p><h1 id="使用-std-function-和-lambda-表达式来替代裸函数指针，举例子"><a href="#使用-std-function-和-lambda-表达式来替代裸函数指针，举例子" class="headerlink" title="使用 std::function 和 lambda 表达式来替代裸函数指针，举例子"></a>使用 std::function 和 lambda 表达式来替代裸函数指针，举例子</h1><p><code>std::function</code> 和 lambda 表达式在 C++11 及之后的版本中提供了一种更加灵活和方便的方式来处理可调用对象。它们使得代码更加简洁且易于理解，特别是在需要函数作为参数或回调时。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式提供了一种匿名函数的实现，允许你在需要函数对象的地方快速定义一个函数。Lambda 表达式的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-std-function-和-Lambda-表达式"><a href="#使用-std-function-和-Lambda-表达式" class="headerlink" title="使用 std::function 和 Lambda 表达式"></a>使用 <code>std::function</code> 和 Lambda 表达式</h2><p><code>std::function</code> 是一个模板类，它可以用来存储任何可以调用的目标，如普通函数、Lambda 表达式、成员函数和函数对象。这提供了比裸函数指针更大的灵活性和功能。</p><p>下面是一个示例，展示了如何使用 <code>std::function</code> 和 Lambda 表达式来替代裸函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 必须包含这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个普通的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 存储普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum using a normal function: &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 存储 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lambdaFunc = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum using a lambda expression: &quot;</span> &lt;&lt; <span class="built_in">lambdaFunc</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了一个普通的函数 <code>add</code>。然后，我们创建了两个 <code>std::function</code> 对象，一个用来存储普通函数 <code>add</code>，另一个用来存储一个实现相同功能的 Lambda 表达式。通过这种方式，我们可以看到 <code>std::function</code> 和 Lambda 表达式如何提供了一种更加灵活的方式来处理可调用对象，而不必直接使用函数指针。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><code>std::function</code> 可以存储任何类型的可调用对象，提供了极大的灵活性。</li><li>Lambda 表达式使得定义和使用匿名函数变得简单，特别是在作为一次性使用函数或局部函数时非常有用。</li><li>使用 <code>std::function</code> 和 Lambda 表达式可以使代码更加清晰和易于维护，特别是在复杂的项目中。</li></ul><p>通过这种方式，C++11 提供的这些特性让处理函数和回调等场景变得更加优雅和高效。</p><h1 id="C-指针函数"><a href="#C-指针函数" class="headerlink" title="C ++ 指针函数"></a>C ++ 指针函数</h1><p>在 C++ 中，术语“指针函数”通常被误解或使用不当。实际上，人们通常是指返回指针的函数，或者简称为“函数返回指针”。这种类型的函数在使用时非常有用，尤其是当你需要从函数中返回动态分配的内存或数组、多级指针、或者指向不同数据结构的指针时。</p><h2 id="定义返回指针的函数"><a href="#定义返回指针的函数" class="headerlink" title="定义返回指针的函数"></a>定义返回指针的函数</h2><p>要定义一个返回指针的函数，你需要在函数声明的返回类型前加上<code>*</code>来指明返回的是指针。这里有一个简单的例子，说明如何定义和使用返回指针的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个返回int指针的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getIntPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="keyword">return</span> ptr; <span class="comment">// 返回指向int的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* myPtr = <span class="built_in">getIntPtr</span>(); <span class="comment">// 调用函数，获取返回的指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *myPtr &lt;&lt; std::endl; <span class="comment">// 使用指针访问值</span></span><br><span class="line">    <span class="keyword">delete</span> myPtr; <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getIntPtr</code>函数分配了一个<code>int</code>类型的动态内存，并返回一个指向这块内存的指针。在<code>main</code>函数中，我们调用了<code>getIntPtr</code>，并使用返回的指针来访问和操作内存。最后，不要忘记使用<code>delete</code>释放动态分配的内存，以避免内存泄露。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>返回局部变量的地址是危险的，因为当函数执行完毕后，局部变量的存储空间会被回收，这样返回的指针会指向一个不再有效的内存区域，导致未定义行为。</li><li>当你的函数返回指向动态分配内存的指针时，确保在适当的时候释放这些内存，以避免内存泄露。</li><li>考虑使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理动态分配的内存，这样可以自动管理内存的生命周期，减少内存泄露的风险。</li></ul><p>返回指针的函数提供了一种灵活的方式来创建和管理动态资源，但同时也需要谨慎处理指针和内存管理相关的问题。</p><h1 id="如何使用智能指针（如std-unique-ptr或std-shared-ptr）来管理动态分配的内存"><a href="#如何使用智能指针（如std-unique-ptr或std-shared-ptr）来管理动态分配的内存" class="headerlink" title="如何使用智能指针（如std::unique_ptr或std::shared_ptr）来管理动态分配的内存"></a>如何使用智能指针（如std::unique_ptr或std::shared_ptr）来管理动态分配的内存</h1><p>在 C++ 中，智能指针是一种模板类，用于自动管理动态分配的内存，确保资源在不再需要时被正确释放，从而避免内存泄露。C++11 引入了两种主要的智能指针类型：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>，它们分别用于独占所有权和共享所有权的场景。</p><h2 id="使用-std-unique-ptr"><a href="#使用-std-unique-ptr" class="headerlink" title="使用 std::unique_ptr"></a>使用 <code>std::unique_ptr</code></h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，保证同一时间只有一个 <code>std::unique_ptr</code> 指向特定的资源。当 <code>std::unique_ptr</code> 被销毁或被重新分配时，它指向的对象也会被自动删除。</p><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a><strong>基本用法：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyMethod called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;MyObject&gt; myUniquePtr = std::<span class="built_in">make_unique</span>&lt;MyObject&gt;();</span><br><span class="line">    myUniquePtr-&gt;<span class="built_in">myMethod</span>(); <span class="comment">// 使用-&gt;操作符调用成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要手动删除对象，当unique_ptr离开作用域时，对象会被自动销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-std-shared-ptr"><a href="#使用-std-shared-ptr" class="headerlink" title="使用 std::shared_ptr"></a>使用 <code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，允许多个 <code>std::shared_ptr</code> 实例指向同一个对象。内部使用引用计数来跟踪有多少个 <code>std::shared_ptr</code> 指向同一个资源，当最后一个这样的指针被销毁时，所指向的对象也会被删除。</p><h3 id="基本用法：-1"><a href="#基本用法：-1" class="headerlink" title="基本用法："></a><strong>基本用法：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyObject destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyMethod called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyObject&gt; mySharedPtr1 = std::<span class="built_in">make_shared</span>&lt;MyObject&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;MyObject&gt; mySharedPtr2 = mySharedPtr1; <span class="comment">// 共享所有权</span></span><br><span class="line">        mySharedPtr2-&gt;<span class="built_in">myMethod</span>();</span><br><span class="line">        <span class="comment">// 当mySharedPtr2离开作用域时，对象不会被销毁，因为mySharedPtr1仍然存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有当最后一个指向对象的shared_ptr（这里是mySharedPtr1）离开作用域时，对象才会被销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用智能指针可以减少内存泄露的风险，但仍需要注意循环引用问题，尤其是在使用 <code>std::shared_ptr</code> 时。循环引用会阻止引用计数达到零，导致内存泄露。解决循环引用问题通常使用 <code>std::weak_ptr</code>。</li><li><code>std::unique_ptr</code> 通过移动语义实现所有权的转移，不能被复制。</li><li><code>std::shared_ptr</code> 适用于资源需要被多个所有者共享的情况，但增加了额外的开销（引用计数管理）。</li></ul><p>智能指针是现代 C++ 管理动态资源的首选方式，相比裸指针，它们提供了更安全、更简洁的资源管理机制。</p>]]></content>
      
      
      <categories>
          
          <category> 8 - C++ </category>
          
          <category> 8.1 - C++理论基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - IPC Binder 机制（一）</title>
      <link href="/2023/08/27/3%20Android/Framework/04-Android-Framework-%E4%B8%93%E9%A1%B9-IPC-Binder-%E6%9C%BA%E5%88%B61/"/>
      <url>/2023/08/27/3%20Android/Framework/04-Android-Framework-%E4%B8%93%E9%A1%B9-IPC-Binder-%E6%9C%BA%E5%88%B61/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure><p>Q: Binder 是什么？binder 是如何出现的</p><p>Q: Binder 通信模型是什么？</p><p>Q: Aidl 通信机制是什么？</p><p>Q: Bindservice 流程分析</p><p>Q: Binder 通信是如何走到 Native 层的</p><p>Q: ServiceManager 是什么？</p><p>Q: Binder 通信之 Client 端调度流程解析</p><h3 id="从-Android-系统设计说起"><a href="#从-Android-系统设计说起" class="headerlink" title="从 Android 系统设计说起"></a>从 Android 系统设计说起</h3><h4 id="Android-的系统的三个层次"><a href="#Android-的系统的三个层次" class="headerlink" title="Android 的系统的三个层次"></a>Android 的系统的三个层次</h4><p>application 应用层 - Framework 层- native 层</p><p>Android 中的应用层和系统服务层不在同一个进程，系统服务在单独的进程中。<br>Android 中的不同应用属于不同的进程，每一个应用是 zygote fork 出来的</p><p>为了安全，Android 的应用层与系统层之间是隔离的</p><h3 id="Android-系统-IPC-原理"><a href="#Android-系统-IPC-原理" class="headerlink" title="Android 系统 IPC 原理"></a>Android 系统 IPC 原理</h3><p><img src="https://s21.ax1x.com/2024/04/09/pFOKnAI.png" alt="pFOKnAI.png"></p><p>每个 Android 的进程，只能运行在自己进程所拥有的虚拟地址空间。<br>对应一个 4GB 的<strong>虚拟地址空间</strong>，其中 3GB 是用户空间，1GB 是内核空间，当然内核空间的大小是可以通过参数配置调整的。<br>对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。<br>Client 进程向 Server 进程通信，恰恰是<strong>利用进程间可共享的内核内存空间来完成底层通信工作的</strong>，Client 端与 Server 端进程往往采用 ioctl 等方法跟内核空间的驱动进行交互。</p><h4 id="用户空间和内核空间知识补充"><a href="#用户空间和内核空间知识补充" class="headerlink" title="用户空间和内核空间知识补充"></a>用户空间和内核空间知识补充</h4><p>怎么理解不同进程之间用户空间不能共享，而内核空间却是可共享的？</p><ol><li><strong>用户空间的共享：</strong> 在标准情况下，不同进程的用户空间是彼此隔离的，不能直接共享内存。每个进程有自己独立的虚拟地址空间，不同进程的相同虚拟地址并不会映射到相同的物理内存。这意味着一个进程不能直接访问另一个进程的用户空间。</li><li><strong>内核空间的共享：</strong> 内核空间是操作系统内核的一部分，对所有进程来说都是共享的。这是因为内核提供了操作系统的核心功能，比如进程调度、内存管理、文件系统等。不同进程需要与内核进行交互来请求服务和操作资源。因此，<strong>所有进程都共享一个操作系统内核</strong>。</li><li><strong>内核空间中的数据隔离：</strong> 尽管内核空间对所有进程来说是共享的，但<strong>内核本身会实施严格的隔离措施</strong>，以防止一个进程的操作影响其他进程。内核使用许多机制来确保不同进程的请求和数据是独立的，从而保障系统的稳定性和安全性。</li><li><strong>内核空间中的共享数据结构：</strong> 在某些情况下，内核中可能存在一些数据结构是为多个进程共享的，例如文件描述符表、进程控制块等。这种共享是通过内核维护的数据结构来实现的，而不是直接让不同进程的内核空间映射到相同的物理内存。</li></ol><p>总结起来，不同进程的用户空间通常是不能直接共享的，每个进程都有自己的独立虚拟地址空间。但所有进程共享同一个内核空间，内核提供了操作系统的核心功能。<strong>内核空间中的数据隔离和共享是通过内核内部的机制来实现的</strong>。</p><h4 id="页表知识补充"><a href="#页表知识补充" class="headerlink" title="页表知识补充"></a>页表知识补充</h4><p>页表是操作系统中用于管理虚拟内存与物理内存之间映射关系的数据结构。在计算机中，虚拟内存是指操作系统为每个进程提供的独立的内存地址空间，而物理内存则是实际的硬件内存。由于物理内存有限，虚拟内存允许多个进程同时运行，而不会受到物理内存大小的限制。</p><p>页表的主要功能是将虚拟地址转换为物理地址。当进程访问虚拟地址时，操作系统通过页表查找，找到对应的物理地址，从而实际完成内存的读写操作。</p><p>具体来说，页表包含了虚拟地址和物理地址之间的映射关系。每个进程都有自己的页表，其中的页表项记录了虚拟地址的页号（page number）与物理地址的页框号（page frame number）之间的对应关系。页框是物理内存的一个固定大小的块，而页是虚拟内存的一个固定大小的块。通过查找页表，操作系统可以找到虚拟地址对应的物理地址，从而实现内存访问。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><strong>用户空间与内核空间</strong>: IPC 机制总的操作又可以分为用户空间进行的操作和内核空间进行的操作</li><li><strong>内核空间中的数据结构不同</strong>: 不同 IPC 机制内核中的数据结构不同</li><li><strong>复制与映射</strong>: IPC 机制利用进程间可共享的内核空间来完成底层通信工作，其中我们可以简单的分为复制和虚拟内存映射两种方式</li></ol><p>我们从这几个角度来快速的区分 IPC 机制</p><h3 id="IPC-共享内存"><a href="#IPC-共享内存" class="headerlink" title="IPC-共享内存"></a>IPC-共享内存</h3><h4 id="用户空间与内核空间行为"><a href="#用户空间与内核空间行为" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建共享内存：</strong> 进程通过系统调用在用户空间申请一块共享内存，得到一个唯一的标识符。</li><li><strong>映射共享内存：</strong> 进程使用系统调用将共享内存映射到自己的虚拟地址空间，从而可以直接访问这块内存区域。这个映射实际上是指向了内核空间中设置的共享页表项。</li><li><strong>读写数据：</strong> 进程可以在映射的共享内存区域进行读写操作，与普通内存一样，无需复杂的通信操作。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>设置共享内存页表：</strong> 内核负责在共享内存的物理地址和虚拟地址之间建立映射关系，设置页表项，确保多个进程能够访问相同的物理内存。</li><li><strong>同步和权限控制：</strong> 内核维护共享内存的元信息，包括大小、权限等。在多个进程访问时，内核会处理访问的同步和权限控制问题。</li><li><strong>不同进程的映射：</strong> 当不同进程请求映射共享内存时，内核将相同的物理内存映射到不同的进程虚拟地址空间，使它们共享同一块内存。它们共享相同的页表项，由 TLB（Translation Lookaside Buffer，页表查找缓冲器）实现。</li></ol><h4 id="内核空间中的关键数据结构"><a href="#内核空间中的关键数据结构" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>共享的页表项</p><h4 id="复制与映射"><a href="#复制与映射" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>双进程分享的是共享页表项，物理地址内数据只有一份，复制次数 0</p><h3 id="IPC-管道"><a href="#IPC-管道" class="headerlink" title="IPC-管道"></a>IPC-管道</h3><h4 id="不同管道类型"><a href="#不同管道类型" class="headerlink" title="不同管道类型"></a>不同管道类型</h4><h5 id="无名管道（Unnamed-Pipe）"><a href="#无名管道（Unnamed-Pipe）" class="headerlink" title="无名管道（Unnamed Pipe）"></a>无名管道（Unnamed Pipe）</h5><ul><li>无名管道是一种单向通信机制，<strong>只能用于父子进程或者具有共同祖先的进程之间通信</strong>。</li><li>创建无名管道使用的是 <code>pipe()</code> 系统调用。该调用返回一对文件描述符，一个用于读取，一个用于写入。</li><li>无名管道的数据传输是单向的，数据写入一个描述符后可以被另一个描述符读取。</li><li>在很多系统上，<strong>无名管道的缓冲区大小是固定的</strong>，通常为一页大小（例如4KB）。这意味着管道的数据容量有限，无法容纳大规模的数据。</li></ul><h5 id="有名管道（Named-Pipe，FIFO）"><a href="#有名管道（Named-Pipe，FIFO）" class="headerlink" title="有名管道（Named Pipe，FIFO）:"></a>有名管道（Named Pipe，FIFO）:</h5><ul><li><p>有名管道是一种<strong>基于文件系统的命名管道</strong>，可以用于任意进程之间通信，<strong>不受关系限制</strong>。</p></li><li><p>使用 <code>mkfifo</code> 命令或 <code>mkfifo()</code> 系统调用创建有名管道。它在文件系统中创建一个特殊的文件节点，进程可以像读写普通文件一样读写这个节点来进行通信。</p></li><li><p>有名管道的<strong>数据传输是单向的</strong>，需要同时创建一个读取端和一个写入端。多个进程可以连接到同一个有名管道进行通信。</p></li><li><p>有名管道（Named Pipe，FIFO）的<strong>缓冲区大小是由系统内核设置</strong>的，并且<strong>通常与页大小（Page Size）有关</strong>。在大多数Linux系统中，页大小通常为4KB，因此默认情况下，有名管道的缓冲区大小也会是4KB。</p><p><strong>某些系统可能会允许你通过特定的系统参数进行配置</strong>。具体的设置方法可能会因操作系统版本和发行版而异。</p></li></ul><h4 id="管道的指针操作，写满与阻塞"><a href="#管道的指针操作，写满与阻塞" class="headerlink" title="管道的指针操作，写满与阻塞"></a>管道的指针操作，写满与阻塞</h4><p>写入从头指针开始，读取从尾指针开始。写入之后，头指针挪动，读取之后尾指针挪动。<br>如果是头指针赶上尾指针，那么管道被写满，写就会被阻塞。如果是尾指针赶上头指针，那么管道为空，read阻塞。</p><h4 id="用户空间与内核空间行为-1"><a href="#用户空间与内核空间行为-1" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建管道：</strong> 进程通过系统调用在用户空间创建一个管道，得到两个文件描述符，一个用于读取，一个用于写入。</li><li><strong>写入数据：</strong> 进程使用写入文件描述符将数据写入管道。</li><li><strong>读取数据：</strong> 进程使用读取文件描述符从管道中读取数据。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>管道管理：</strong> 内核维护管道的数据结构，包括缓冲区和读写指针。</li><li><strong>数据传递：</strong> 内核通过管道将写入的数据从一个进程的写入文件描述符复制到另一个进程的读取文件描述符。</li><li><strong>进程同步：</strong> 内核确保在多个进程访问管道时的同步，避免数据错乱。</li></ol><h4 id="内核空间中的关键数据结构-1"><a href="#内核空间中的关键数据结构-1" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>单向管道</p><h4 id="复制与映射-1"><a href="#复制与映射-1" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>在基本的管道（Pipe）IPC 机制中，数据实际上只涉及一次复制操作，因为管道是一个字节流传输机制，数据在管道中以字节为单位连续传输。</p><p>简单的说 Linux 是文件系统，管道也是文件，这个文件由两个指针进行操作，一头写入一头读取，当一个进程将数据写入管道时，数据直接写入这个文件内，即管道的缓冲区中，当另一个进程从管道中读取数据时，这些数据会被从管道的缓冲区读取到接收方进程的内存中，而<strong>管道不持有这些数据</strong>，数据的角度来看，实际上只有一次数据复制。</p><h3 id="IPC-消息队列"><a href="#IPC-消息队列" class="headerlink" title="IPC-消息队列"></a>IPC-消息队列</h3><h4 id="用户空间与内核空间行为-2"><a href="#用户空间与内核空间行为-2" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建消息队列：</strong> 进程通过系统调用在用户空间创建一个消息队列，得到一个唯一的标识符。</li><li><strong>发送消息：</strong> 进程使用系统调用将消息发送到消息队列，包括消息类型和数据（需要通信双方约定好）。</li><li><strong>接收消息：</strong> 进程使用系统调用从消息队列中接收消息，根据消息类型读取相应的数据。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>消息队列管理：</strong> 内核维护消息队列的元信息，包括消息队列的状态、大小等。</li><li><strong>消息传递：</strong> 内核<strong>将进程发送的消息复制到消息队列中</strong>，或<strong>从消息队列中复制消息给接收的进程</strong>。（跨进程消息队列<strong>两次复制</strong>）</li><li><strong>进程同步：</strong> 内核确保在多个进程访问消息队列时的同步，以避免竞态条件。</li></ol><h4 id="内核空间中的关键数据结构-2"><a href="#内核空间中的关键数据结构-2" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>消息队列</p><h4 id="复制与映射-2"><a href="#复制与映射-2" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>两次复制</p><ol><li><strong>写入数据：</strong> 当一个进程将消息写入消息队列时，消息数据会从发送方进程的内存复制到消息队列的内核缓冲区中。这是第一次复制操作。</li><li><strong>读取数据：</strong> 在接收方进程中，数据需要从内核缓冲区复制到接收方进程的内核空间中。这是第二次复制操作。</li></ol><h3 id="IPC-Socket"><a href="#IPC-Socket" class="headerlink" title="IPC-Socket"></a>IPC-Socket</h3><h4 id="用户空间与内核空间行为-3"><a href="#用户空间与内核空间行为-3" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p><strong>用户空间：</strong></p><ol><li><strong>创建 Socket：</strong> 进程通过系统调用在用户空间创建一个 Socket，得到一个文件描述符，用于读写数据。</li><li><strong>发送数据：</strong> 进程使用文件描述符发送数据到指定的 Socket。</li><li><strong>接收数据：</strong> 进程使用文件描述符从 Socket 中接收数据。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>Socket 管理：</strong> 内核维护 Socket 的数据结构，包括缓冲区、连接状态等。</li><li><strong>数据传递：</strong> 内核通过 Socket 将进程发送的数据从一个进程的发送缓冲区复制到另一个进程的接收缓冲区。</li><li><strong>连接管理：</strong> 内核负责管理连接的建立、维护和断开，以及处理各种网络协议。</li></ol><p>内核空间中的关键数据结构</p><h4 id="内核空间中的关键数据结构-3"><a href="#内核空间中的关键数据结构-3" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><ol><li><strong>发送缓冲区：</strong> 发送方进程使用 Socket 发送数据时，数据首先被复制到发送缓冲区（Send Buffer）中。这个缓冲区在内核空间中，用于临时存储待发送的数据。发送缓冲区的大小可以由操作系统参数或套接字选项进行配置。</li><li><strong>接收缓冲区：</strong> 接收方进程使用 Socket 接收数据时，数据会被存储在接收缓冲区（Receive Buffer）中。这个缓冲区同样位于内核空间，用于临时存储接收到的数据。接收缓冲区的大小也可以通过操作系统参数或套接字选项进行配置</li></ol><h4 id="复制与映射-3"><a href="#复制与映射-3" class="headerlink" title="复制与映射"></a>复制与映射</h4><h5 id="linux-2-4-内核以下"><a href="#linux-2-4-内核以下" class="headerlink" title="linux 2.4 内核以下"></a>linux 2.4 内核以下</h5><p>两次用户、内核态的切换，三次数据拷贝</p><h5 id="linux-2-4-内核及其以上"><a href="#linux-2-4-内核及其以上" class="headerlink" title="linux 2.4 内核及其以上"></a>linux 2.4 内核及其以上</h5><p>两次用户、内核态的切换，两次数据拷贝</p><h6 id="内核态零拷贝原理"><a href="#内核态零拷贝原理" class="headerlink" title="内核态零拷贝原理"></a>内核态零拷贝原理</h6><p>数据不再被复制到 socket 关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到 socket 关联的缓冲区中。DMA 直接将内核中的缓冲区中的数据传输给协议引擎，消除了那一次需要 cpu 周期的数据复制。</p><h3 id="IPC-Binder"><a href="#IPC-Binder" class="headerlink" title="IPC-Binder"></a>IPC-Binder</h3><h4 id="用户空间与内核空间行为-4"><a href="#用户空间与内核空间行为-4" class="headerlink" title="用户空间与内核空间行为"></a>用户空间与内核空间行为</h4><p>从用户空间和内核空间的角度来看，IPC（Inter-Process Communication，进程间通信）Binder 的工作可以简洁地描述如下：</p><p><strong>用户空间：</strong></p><ol><li><strong>创建 Binder 对象：</strong> 进程通过系统调用创建 Binder 对象，通常是 <code>Binder</code> 类的子类实例。这个对象用于表示一个通信通道，可以用来发送和接收数据。</li><li><strong>发送数据：</strong> 进程通过 Binder 对象将数据（通常是 Parcel 对象）发送到另一个进程。这个过程会<strong>将数据传递给内核空间的 Binder 驱动</strong>。</li><li><strong>接收数据：</strong> 进程通过 Binder 对象接收另一个进程发送的数据。接收的数据也是以 Parcel 对象的形式返回给用户空间。</li></ol><p><strong>内核空间：</strong></p><ol><li><strong>Binder 驱动：</strong> Binder 驱动位于内核空间，负责管理 Binder 通信。当进程发送数据时，数据会传递给 Binder 驱动。</li><li><strong>数据传递：</strong> Binder 驱动将进程发送的数据<strong>从发送方进程的用户空间复制到接收方进程的用户空间</strong>，这一过程中<strong>涉及数据的复制和映射</strong>。</li><li><strong>线程池管理：</strong> Binder 驱动还管理了一个线程池，用于处理进程间的数据传递请求。这确保了数据的传递不会阻塞主线程，提高了性能。</li><li><strong>权限和安全性：</strong> Binder 驱动实施权限和安全性控制，确保只有经过授权的进程可以进行 Binder 通信。</li></ol><h4 id="内核空间中的关键数据结构-4"><a href="#内核空间中的关键数据结构-4" class="headerlink" title="内核空间中的关键数据结构"></a>内核空间中的关键数据结构</h4><p>指向物理内存的内核空间虚拟内存</p><h4 id="复制与映射-4"><a href="#复制与映射-4" class="headerlink" title="复制与映射"></a>复制与映射</h4><p>复制：发送方进程将数据复制到内核空间虚拟内存中。<br>映射：将这个内核中的虚拟内存映射给接收方进程。</p><h2 id="为什么-Android-要采用-Binder-作为-IPC-机制？"><a href="#为什么-Android-要采用-Binder-作为-IPC-机制？" class="headerlink" title="为什么 Android 要采用 Binder 作为 IPC 机制？"></a>为什么 Android 要采用 Binder 作为 IPC 机制？</h2><p><strong>在下不才，这个问题，交给大佬回答</strong></p><p>作者：Gityuan<br>链接：<a href="https://www.zhihu.com/question/39440766/answer/89210950">https://www.zhihu.com/question/39440766/answer/89210950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>在开始回答 前，先简单概括性地说说Linux现有的所有进程间IPC方式：</strong></p><ol><li><strong>管道</strong>: 在创建时分配一个page大小的内存，缓存区大小比较有限。</li><li><strong>消息队列</strong>: 信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信。</li><li><strong>共享内存</strong>: 无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快，但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决。</li><li><strong>套接字</strong>: 作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信。</li><li><strong>信号量</strong>: 常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>信号</strong>: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等。</li></ol><p><strong>Android的内核也是基于Linux内核，为何不直接采用Linux现有的进程IPC方案呢，难道Linux社区那么多优秀人员都没有考虑到有Binder这样一个更优秀的方案，是google太过于牛B吗？事实是真相并非如此，请细细往下看，您就明白了。</strong></p><hr><p><strong>接下来正面回答这个问题，从5个角度来展开对Binder的分析：</strong></p><p><strong>（1）从性能的角度</strong> <strong>数据拷贝次数：</strong>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</p><p><strong>（2）从稳定性的角度</strong><br>Binder是基于C&#x2F;S架构的，简单解释下C&#x2F;S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。</p><p>仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制，那么更重要的原因是：</p><p><strong>（3）从安全的角度</strong><br>传统Linux IPC的接收方无法获得对方进程可靠的UID&#x2F;PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。 </p><p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C&#x2F;S架构，<strong>Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID&#x2F;PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行</strong>。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。</p><p>针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但<strong>同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。</strong>对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。</p><p>Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：<br><a href="https://www.zhihu.com/question/41003297/answer/89328987?from=profile_answer_card">Android源码的Binder权限是如何控制？ -Gityuan的回答</a></p><p><strong>传统IPC</strong>只能由用户在数据包里填入UID&#x2F;PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p><p><strong>说到这，可能有人要反驳</strong>，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在<strong>Google举办的Android Bootcamp 2016</strong>大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。 </p><p>话题扯远了，继续说Binder。</p><p><strong>（4）从语言层面的角度</strong><br>大家多知道Linux是基于C语言面向过程的语言，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。</p><p><strong>另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。</strong>也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在<strong>Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制</strong>，Android中的<strong>Kill Process采用的signal（信号）机制</strong>等等。而<strong>Binder更多则用在system_server进程与上层App层的IPC交互</strong>。</p><p><strong>(5) 从公司战略的角度</strong></p><p>总所周知，Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。 </p><p>而Android 之父 Andy Rubin对于GPL显然是不能接受的，为此，Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性，仍有较大争议，但至少目前缓解Android，让GPL止步于内核空间，这是Google在GPL Linux下 开源与商业化共存的一个成功典范。</p><p><strong>有了这些铺垫，我们再说说Binder的今世前缘</strong></p><p>Binder是基于开源的 OpenBinder实现的，OpenBinder是一个开源的系统IPC机制,最初是由 Be Inc.开发，接着由 Palm, Inc. 公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择。</p><p>另外，再说一点关于OpenBinder，在2015年OpenBinder以及合入到Linux Kernel主线 3.19版本，这也算是Google对Linux的一点回馈吧。</p><p><strong>综合上述5点，可知Binder是Android系统上层进程间通信的不二选择。</strong></p><hr><p>IPC 原理来自于</p><p>gityuan: <a href="http://gityuan.com/2015/10/31/binder-prepare/">http://gityuan.com/2015/10/31/binder-prepare/</a></p><p>参考资料：《计算机操作系统》</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - Handler（三）</title>
      <link href="/2023/08/27/3%20Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/"/>
      <url>/2023/08/27/3%20Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/</url>
      
        <content type="html"><![CDATA[<h4 id="要理解-Message-的创建，先要说内存抖动"><a href="#要理解-Message-的创建，先要说内存抖动" class="headerlink" title="要理解 Message 的创建，先要说内存抖动"></a>要理解 Message 的创建，先要说内存抖动</h4><h5 id="内存抖动的原因及引发的问题"><a href="#内存抖动的原因及引发的问题" class="headerlink" title="内存抖动的原因及引发的问题"></a>内存抖动的原因及引发的问题</h5><p>在 Android 虚拟机中，当我们在应用程序中创建大量的临时对象，并且这些对象的存在时间很短暂，虚拟机会识别这些临时对象并将它们标记为待清理的垃圾对象，以便在适当的时候回收它们。然而，这个垃圾回收过程可能会引发一个称为“stop the world”的现象。所谓“stop the world”指的是，在进行垃圾回收的过程中，虚拟机会暂停应用程序的正常执行，以便能够安全地识别和回收这些临时对象。</p><p>在 Java 字节码中，创建一个对象通常需要执行三个关键操作: <code>new</code>、<code>dup</code> 和 <code>invokespecial</code>。这三个操作合在一起构成了对象创建的原子过程。</p><p>虚拟机通常通过两种方式来判断一个对象是否是垃圾。一种方式是使用“引用计数”机制，但这种方法存在循环引用的问题，因此无法完全准确地标记垃圾对象，从而导致垃圾回收不彻底。另一种方式是使用“根可达”（或称为“根引用”）的方式，即从根对象（如线程栈、静态变量等）开始，追踪对象之间的引用关系，从而判断哪些对象是可达的，哪些是垃圾。</p><p>然而，在标记垃圾对象的过程中，如果垃圾回收线程与创建对象的线程同时工作，就可能出现问题。例如，如果一个对象刚刚被创建但尚未与变量关联，而垃圾回收线程已经扫描到这个对象并标记为垃圾，那么在后续的垃圾回收过程中，这个对象可能会被回收，而在应用程序中使用相关变量时可能会触发空指针异常。为了避免这种情况，标记垃圾的过程通常需要暂停所有工作线程，确保在标记过程中不会有对象的状态发生变化。这就是为什么在进行垃圾回收时会出现应用程序“停顿”的现象。</p><p>然而，如果垃圾回收过程耗时过长，会导致应用程序长时间无响应，造成卡顿现象。因此，我们需要尽量避免在应用中创建大量生命周期很短的临时对象，以减少垃圾回收的频率和影响。</p><p>内存抖动的原因: 创建了大量的生命周期很短的对象。<br>导致的问题: 在用户看来程序出现了卡顿。</p><h4 id="Message-中-obtain-与-recycle"><a href="#Message-中-obtain-与-recycle" class="headerlink" title="Message 中 obtain() 与 recycle()"></a>Message 中 obtain() 与 recycle()</h4><p>显而易见，Message 那真是生命周期极短数量极其庞大，是最容易内存抖动的地方<br>所以 Message 内存必须被复用</p><p>我们说说 Message 的销毁与创建</p><h5 id="创建-android-os-Message-obtain"><a href="#创建-android-os-Message-obtain" class="headerlink" title="创建: android.os.Message#obtain()"></a>创建: android.os.Message#obtain()</h5><p><strong>注意：说创建是不准确的，应该是提供</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="literal">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是用于在 Android 中创建和管理消息对象的一部分。它通过维护一个对象池，允许在需要时重复利用已有的消息对象，从而减少内存分配和垃圾回收的开销。当需要获取一个新的消息对象时，它会首先检查对象池是否有可用的对象。如果有，它会从对象池中取出一个对象并重置其状态，然后返回；如果对象池为空，它会创建一个新的消息对象并返回。这种做法有助于提高应用程序的性能和效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/09/pFOuBmd.png" alt="pFOuBmd.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/09/pFOuD0A.png" alt="pFOuD0A.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sPool = m.next;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/09/pFOuwOH.png" alt="pFOuwOH.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.next = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/09/pFOu6tP.png" alt="pFOu6tP.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.flags=<span class="number">0</span>;</span><br><span class="line">sPoolSize--;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure><h5 id="回收-android-os-Message-recycle"><a href="#回收-android-os-Message-recycle" class="headerlink" title="回收: android.os.Message#recycle()"></a>回收: android.os.Message#recycle()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a Message instance to the global pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * You MUST NOT touch the Message after calling this function because it has</span></span><br><span class="line"><span class="comment"> * effectively been freed.  It is an error to recycle a message that is currently</span></span><br><span class="line"><span class="comment"> * enqueued or that is in the process of being delivered to a Handler.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一下 gCheckRecycle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateCheckRecycle</span><span class="params">(<span class="type">int</span> targetSdkVersion)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        gCheckRecycle = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在较低版本的 Android 上 ( &lt; 5.0 )，某些检查可能会导致不必要的异常情况，如 <code>IllegalStateException</code>。这可能会影响应用程序的稳定性。通过避免这些检查，可以避免异常的抛出，提高应用程序的可靠性。</p><h5 id="回收-android-os-Message-recycleUnchecked"><a href="#回收-android-os-Message-recycleUnchecked" class="headerlink" title="回收: android.os.Message#recycleUnchecked"></a>回收: android.os.Message#recycleUnchecked</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment">  * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">      flags = FLAG_IN_USE;</span><br><span class="line">      what = <span class="number">0</span>;</span><br><span class="line">      arg1 = <span class="number">0</span>;</span><br><span class="line">      arg2 = <span class="number">0</span>;</span><br><span class="line">      obj = <span class="literal">null</span>;</span><br><span class="line">      replyTo = <span class="literal">null</span>;</span><br><span class="line">      sendingUid = UID_NONE;</span><br><span class="line">      workSourceUid = UID_NONE;</span><br><span class="line">      when = <span class="number">0</span>;</span><br><span class="line">      target = <span class="literal">null</span>;</span><br><span class="line">      callback = <span class="literal">null</span>;</span><br><span class="line">      data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="built_in">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flags = FLAG_IN_USE;</span><br><span class="line">what = <span class="number">0</span>;</span><br><span class="line">arg1 = <span class="number">0</span>;</span><br><span class="line">arg2 = <span class="number">0</span>;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">replyTo = <span class="literal">null</span>;</span><br><span class="line">sendingUid = UID_NONE;</span><br><span class="line">workSourceUid = UID_NONE;</span><br><span class="line">when = <span class="number">0</span>;</span><br><span class="line">target = <span class="literal">null</span>;</span><br><span class="line">callback = <span class="literal">null</span>;</span><br><span class="line">data = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>消息的标志位 <code>flags</code> 的含义是消息对象是否正在使用中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同步块中，检查消息池的大小是否小于最大池大小（<code>MAX_POOL_SIZE</code>）。</p><ul><li>如果是，将当前消息对象放入消息池的链表中，以供将来重用。</li><li>更新消息池的大小。</li></ul><p><img src="https://s21.ax1x.com/2024/04/09/pFOud6e.png" alt="pFOud6e.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next=sPool;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/09/pFOurTI.png" alt="pFOurTI.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sPool=<span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/04/09/pFOuykt.png" alt="pFOuykt.png"></p><hr><p>内存抖动参考自:<br>知乎博主Android小瓜: Android 性能优化大法——内存抖动<br>原文链接: <a href="https://zhuanlan.zhihu.com/p/575959909">https://zhuanlan.zhihu.com/p/575959909</a></p><p>android.os.Message#obtain() 与 android.os.Message#recycleUnchecked 相关图片来自于:<br>版权声明：本文为CSDN博主「-_-void」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xmh19936688/article/details/51901338">https://blog.csdn.net/xmh19936688/article/details/51901338</a></p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - Handler（二）</title>
      <link href="/2023/08/23/3%20Android/Framework/02-Android-Framework-%E4%B8%93%E9%A1%B9-Handler2/"/>
      <url>/2023/08/23/3%20Android/Framework/02-Android-Framework-%E4%B8%93%E9%A1%B9-Handler2/</url>
      
        <content type="html"><![CDATA[<h3 id="MessageQueue-到底是什么"><a href="#MessageQueue-到底是什么" class="headerlink" title="MessageQueue 到底是什么?"></a>MessageQueue 到底是什么?</h3><h4 id="从-MessageQueue-的创建说起"><a href="#从-MessageQueue-的创建说起" class="headerlink" title="从 MessageQueue 的创建说起"></a>从 MessageQueue 的创建说起</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">     mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);<span class="comment">//保证了MessageQueue的唯一性</span></span><br><span class="line">     mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue 就是在 Looper 的构造方法里创建的，一个 <strong>Looper 就对应了一个 MessageQueue</strong>。</p><h4 id="MessageQueue-如何实现线程间的数据隔离"><a href="#MessageQueue-如何实现线程间的数据隔离" class="headerlink" title="MessageQueue 如何实现线程间的数据隔离"></a>MessageQueue 如何实现线程间的数据隔离</h4><p>线程是不持有系统资源的进程，所以同一个进程中的线程是共用的同一个进程持有的内存，说人话就是进程中持有的内存中的变量和数据每个线程都可以直接读取，MessageQueue 是存放线程要处理的消息的，我们当然不希望它是进程持有的线程之间共享的，不能被其他的线程所干扰，换句话说 MessageQueue 必须是线程隔离的</p><p>android.os.Looper#prepare(boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));<span class="comment">//把新创建的 Looper 和 ThreadLocal 关联起来，保证 looper 的唯一性</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意 <strong>Looper 是一个静态类非一个实例</strong>，在 Looper 的 prepare 阶段，会去 new Looper(quitAllowed)，并将其放入 ThreadLocal，这样就让 Looper 成为了 <em><strong>线程变量</strong></em>，而 MessageQueue 由 Looper 创建并持有，所以 MessageQueue 自然也成了 <strong>线程变量</strong>，这样就实现了每个线程有自己独立的 Looper 和 MessageQueue 实例，且相互隔离。</p><p><code>MessageQueue</code> 是每个线程独有的。每个线程都拥有自己的消息队列，因此在不同的线程之间无法直接共享消息队列。消息是在一个线程中创建和发送到该线程的消息队列，然后由该线程的 <code>Looper</code> 从队列中取出并处理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ThreadLocal` 是一个线程级别的存储，它在每个线程中维护一个独立的存储空间（`ThreadLocalMap`），每个存储空间使用 `ThreadLocal` 对象作为键。不同线程的存储空间互不干扰，实现了线程间的数据隔离；但在同一个线程内，`ThreadLocal` 对象可以共享，对应的数据副本在不同方法间保持一致。、</span><br></pre></td></tr></table></figure><h4 id="MessageQueue-同步屏障"><a href="#MessageQueue-同步屏障" class="headerlink" title="MessageQueue 同步屏障"></a>MessageQueue 同步屏障</h4><p>试想一种情况 MessageQueue 需要处理</p><h5 id="android-os-MessageQueue-next-中的另一种执行逻辑"><a href="#android-os-MessageQueue-next-中的另一种执行逻辑" class="headerlink" title="android.os.MessageQueue#next 中的另一种执行逻辑"></a>android.os.MessageQueue#next 中的另一种执行逻辑</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们重点看这一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">prevMsg = msg;</span><br><span class="line">msg = msg.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 msg !&#x3D; null，而 msg.target &#x3D;&#x3D; null 的时候，android.os.MessageQueue#next 执行了完全不同的另一种逻辑，target 就是 msg 的目标 handler，也就是说如果 msg 没有目标 handler 的时候，那么 msg 就是一个屏障消息，android.os.MessageQueue#next 就会进入无限循环读取异步消息的逻辑</p><p>从这里我们知道 MessageQueue 提供了一个屏障，这个屏障可以让 MessageQueue 越过所有同步消息优先执行异步消息</p><p>我们看看这个屏障该如何升起与取消</p><h5 id="简单的发送一个-msg-target-x3D-x3D-null-的消息升起同步屏障"><a href="#简单的发送一个-msg-target-x3D-x3D-null-的消息升起同步屏障" class="headerlink" title="简单的发送一个 msg.target &#x3D;&#x3D; null 的消息升起同步屏障"></a>简单的发送一个 msg.target &#x3D;&#x3D; null 的消息升起同步屏障</h5><p>可以简单的发送一个 msg.target &#x3D;&#x3D; null 的消息来升起这个屏障吗？<br>尝试一下你就会发现出现了”Message must have a target.”的异常</p><h5 id="android-os-MessageQueue-enqueueMessage-msg-target-x3D-x3D-null-的危险性与抛出的异常"><a href="#android-os-MessageQueue-enqueueMessage-msg-target-x3D-x3D-null-的危险性与抛出的异常" class="headerlink" title="android.os.MessageQueue#enqueueMessage msg.target &#x3D;&#x3D; null 的危险性与抛出的异常"></a>android.os.MessageQueue#enqueueMessage msg.target &#x3D;&#x3D; null 的危险性与抛出的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 android.os.MessageQueue#enqueueMessage 第一步就是检查 msg.target 是否为 null，msg.target &#x3D;&#x3D; null 极度危险，一旦消息没有正确的被处理，会导致整个 MessageQueue 进入异步消息的死循环无法退出，因此 消息屏障的触发与取消必须被管控起来</p><h5 id="严格管控下的同步屏障的触发"><a href="#严格管控下的同步屏障的触发" class="headerlink" title="严格管控下的同步屏障的触发"></a>严格管控下的同步屏障的触发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a synchronization barrier to the Looper&#x27;s message queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Message processing occurs as usual until the message queue encounters the</span></span><br><span class="line"><span class="comment"> * synchronization barrier that has been posted.  When the barrier is encountered,</span></span><br><span class="line"><span class="comment"> * later synchronous messages in the queue are stalled (prevented from being executed)</span></span><br><span class="line"><span class="comment"> * until the barrier is released by calling &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; and specifying</span></span><br><span class="line"><span class="comment"> * the token that identifies the synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method is used to immediately postpone execution of all subsequently posted</span></span><br><span class="line"><span class="comment"> * synchronous messages until a condition is met that releases the barrier.</span></span><br><span class="line"><span class="comment"> * Asynchronous messages (see &#123;<span class="doctag">@link</span> Message#isAsynchronous&#125; are exempt from the barrier</span></span><br><span class="line"><span class="comment"> * and continue to be processed as usual.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call must be always matched by a call to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; with</span></span><br><span class="line"><span class="comment"> * the same token to ensure that the message queue resumes normal operation.</span></span><br><span class="line"><span class="comment"> * Otherwise the application will probably hang!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A token that uniquely identifies the barrier.  This token must be</span></span><br><span class="line"><span class="comment"> * passed to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; to release the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是 Android 消息机制中的一部分，用于实现同步屏障（Sync Barrier）。同步屏障是一种机制，可以用来控制消息队列中的消息执行顺序，特别是用于确保后续的同步消息在某个条件满足之前被阻塞执行。下面对这段代码进行分析：</p><ul><li><p><code>postSyncBarrier()</code> 方法：</p><ul><li>这个方法是向消息队列中添加一个同步屏障。</li><li>同步屏障是一种特殊的消息，它会阻塞后续的同步消息的执行，直到同步屏障被释放。</li><li>该方法返回一个用于标识同步屏障的 token，这个 token 在稍后调用 <code>removeSyncBarrier()</code> 方法时需要使用。</li></ul></li><li><p><code>postSyncBarrier(long when)</code> 方法：</p><ul><li>这个方法是 <code>postSyncBarrier()</code> 的内部实现。</li><li>该方法会创建一个同步屏障消息，设置其触发时间（when）和一个唯一的 token。</li><li>同步屏障消息将被插入消息队列中，并根据触发时间排序。</li></ul></li><li><p>在插入同步屏障消息时：</p><ul><li>遍历消息队列，找到合适的位置插入同步屏障消息，以保持消息队列的顺序。</li><li>如果同步屏障消息需要插入的位置在已有消息之后，将同步屏障消息插入到该位置之后。</li><li>如果同步屏障消息需要插入的位置在已有消息之前，将同步屏障消息作为新的头部消息。</li></ul></li></ul><p>总结起来，这段代码实现了向消息队列中插入同步屏障消息的功能。同步屏障消息的作用是阻塞后续的同步消息的执行，直到满足某个条件后释放同步屏障。这种机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足之前某些消息不被执行。</p><h5 id="严格管控下的同步屏障的取消"><a href="#严格管控下的同步屏障的取消" class="headerlink" title="严格管控下的同步屏障的取消"></a>严格管控下的同步屏障的取消</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes a synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #postSyncBarrier&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSyncBarrier</span><span class="params">(<span class="type">int</span> token)</span> &#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; (p.target != <span class="literal">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="literal">null</span> || mMessages.target != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是用于移除同步屏障（Sync Barrier）的逻辑。它会从消息队列中移除指定的同步屏障消息，并在必要时唤醒消息队列，以继续处理后续的消息。下面对这段代码进行分析：</p><ul><li><p><code>removeSyncBarrier(int token)</code> 方法：</p><ul><li>这个方法用于移除同步屏障。</li><li>它接受一个参数 <code>token</code>，即之前调用 <code>postSyncBarrier()</code> 方法返回的标识同步屏障的 token。</li><li>如果指定的同步屏障消息被找到并移除，将会在必要时唤醒消息队列。</li></ul></li><li><p>在移除同步屏障消息时：</p><ul><li>遍历消息队列，寻找包含指定 token 的同步屏障消息。</li><li>如果找到了匹配的同步屏障消息，将其从消息队列中移除。</li><li>如果在移除同步屏障消息后，消息队列不再被其他消息阻塞，会将队列唤醒，以继续处理后续的消息。</li></ul></li><li><p><code>recycleUnchecked()</code> 方法：</p><ul><li>在移除同步屏障消息后，调用这个方法将消息对象回收，以便释放资源。</li></ul></li></ul><p>总结起来，这段代码实现了移除同步屏障消息的功能。当同步屏障条件满足后，通过调用 <code>removeSyncBarrier()</code> 方法来移除同步屏障消息，从而解除对后续同步消息的阻塞。这个机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足后执行后续的同步消息。</p><h4 id="从-ViewRootImpl-看同步屏障的使用"><a href="#从-ViewRootImpl-看同步屏障的使用" class="headerlink" title="从 ViewRootImpl 看同步屏障的使用"></a>从 ViewRootImpl 看同步屏障的使用</h4><p>android.view.ViewRootImpl#scheduleTraversals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步屏障的触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br></pre></td></tr></table></figure><p>再看一下发送消息的逻辑</p><p>android.view.Choreographer#postCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a callback to run on the next frame.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The callback runs once then is automatically removed.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callbackType The callback type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The callback action to run during the next frame.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The callback token, or null if none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #removeCallbacks</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallback</span><span class="params">(<span class="type">int</span> callbackType, Runnable action, Object token)</span> &#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.view.Choreographer#postCallbackDelayed</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a callback to run on the next frame after the specified delay.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The callback runs once then is automatically removed.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callbackType The callback type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The callback action to run during the next frame after the specified delay.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The callback token, or null if none.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delayMillis The delay time in milliseconds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #removeCallback</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayed</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Runnable action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;action must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callbackType &lt; <span class="number">0</span> || callbackType &gt; CALLBACK_LAST) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callbackType is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点</strong>: android.view.Choreographer#postCallbackDelayedInternal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType</span><br><span class="line">                + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token</span><br><span class="line">                + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看异步消息的发送逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">msg.arg1 = callbackType;</span><br><span class="line">msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">mHandler.sendMessageAtTime(msg, dueTime);</span><br></pre></td></tr></table></figure><p>android.view.ViewRootImpl#unscheduleTraversals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">unscheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        mChoreographer.removeCallbacks(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.view.ViewRootImpl#unscheduleTraversals 的调用时机比较有意思，这里暂不做更多的分析</p><h4 id="Skipped-30-frames"><a href="#Skipped-30-frames" class="headerlink" title="Skipped 30 frames!"></a>Skipped 30 frames!</h4><h6 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h6><p>在进行 UI 更新的时候，如果 UI 线程忙碌，主线程有时会抛出异常信息：Skipped 30 frames! The application may be doing too much work on its main thread.</p><h6 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h6><p>这是因为触发屏障的实际操作是发送一个 target 为 null 的 msg，但是如果这个 target 为 null 的消息被前面的耗时消息所耽误而一直没能执行，导致后面不断发送来的需要立即执行的异步消息都被耽误，触发同步屏障之后，系统发现，本该立即执行的异步消息已经积累了30帧只会，就会报出这个主线程忙碌的错误</p><h6 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h6><p>罪魁祸首就是那个耽误了 target &#x3D;&#x3D; null 的同步屏障 msg 执行的 msg，这个同步消息的执行如此之耗时，以至于我们必须考虑对其优化或者考虑是不是适合放在主线程<br>可以放到其他线程去执行</p><h4 id="MessageQueue-中的-synchronized"><a href="#MessageQueue-中的-synchronized" class="headerlink" title="MessageQueue 中的 synchronized"></a>MessageQueue 中的 synchronized</h4><h5 id="android-os-MessageQueue-next-中的-synchronized"><a href="#android-os-MessageQueue-next-中的-synchronized" class="headerlink" title="android.os.MessageQueue#next 中的 synchronized"></a>android.os.MessageQueue#next 中的 synchronized</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h6><p><code>synchronized</code> 用于同步代码块的范围涵盖了整个 <code>next()</code> 方法。具体来说，这段代码实现了一个消息循环（message loop）用于处理消息队列中的消息。在多线程环境下，有多个线程可能会调用 <code>next()</code> 方法来获取下一个消息，因此需要确保对共享资源的访问是安全的。</p><h6 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h6><p><code>mIdleHandlers.remove(idler)</code>：这行代码从 <code>mIdleHandlers</code> 集合中移除一个 <code>IdleHandler</code>。由于多个线程可能同时访问和修改 <code>mIdleHandlers</code>，因此需要确保这个操作是原子的，以避免不一致或意外的结果。</p><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>都是 synchronized 保护下的<br>MessageQueue 是 Android 框架中用于处理消息传递和线程通信的关键组件，多个线程可能会同时访问和修改消息队列，因此需要使用同步机制来避免竞态条件和其他线程安全问题。</p><h4 id="MessageQueue-中的-IdleHandler"><a href="#MessageQueue-中的-IdleHandler" class="headerlink" title="MessageQueue 中的 IdleHandler"></a>MessageQueue 中的 IdleHandler</h4><h5 id="使用与意义"><a href="#使用与意义" class="headerlink" title="使用与意义"></a>使用与意义</h5><p><code>IdleHandler</code> 是 Android 消息传递机制中的一个重要概念，它允许你在消息队列空闲时执行一些额外的操作。</p><ol><li><strong>使用：</strong> 你可以通过 <code>MessageQueue</code> 的 <code>addIdleHandler()</code> 方法将一个或多个 <code>IdleHandler</code> 添加到消息队列中。</li><li><strong>意义：</strong> <code>IdleHandler</code> 允许你在消息队列空闲时执行一些轻量级的任务，这些任务通常是一些不需要立即处理、不会阻塞主线程的操作。常见的用例包括资源回收、后台数据同步、性能优化等。通过利用空闲时间执行这些任务，可以提高应用的性能和资源利用率。</li><li><strong>执行时机：</strong> <code>IdleHandler</code> 的 <code>queueIdle()</code> 方法在消息队列没有即时任务需要处理时调用。如果 <code>queueIdle()</code> 返回 <code>true</code>，该 <code>IdleHandler</code> 将继续保持在队列中，以便在下一次空闲时调用；如果返回 <code>false</code>，则该 <code>IdleHandler</code> 将从队列中移除。</li></ol><h5 id="为什么会有多个-IdleHandler"><a href="#为什么会有多个-IdleHandler" class="headerlink" title="为什么会有多个 IdleHandler"></a>为什么会有多个 IdleHandler</h5><ol><li><strong>功能分离：</strong> 不同的 <code>IdleHandler</code> 可以用于执行不同类型的任务，如资源回收、后台数据同步、性能优化等。通过将不同的任务逻辑分离到不同的 <code>IdleHandler</code> 中，可以使代码更加模块化和可维护。</li><li><strong>任务优先级：</strong> 不同的 <code>IdleHandler</code> 可以根据优先级来执行任务。高优先级任务可以通过将对应的 <code>IdleHandler</code> 添加到队列中，确保在空闲时尽快执行。低优先级任务则可以延迟到更空闲的时候执行。</li><li><strong>动态注册和注销：</strong> 多个 <code>IdleHandler</code> 允许开发者在不同的时刻动态地注册和注销任务。这使得可以根据应用程序的状态和需求来动态地调整任务的执行。</li><li><strong>任务复用：</strong> 如果有多个相似的任务需要在空闲时执行，可以通过不同的 <code>IdleHandler</code> 实现任务的复用，避免重复编写类似的代码。</li><li><strong>提高性能：</strong> 通过将不同的任务拆分到多个 <code>IdleHandler</code> 中，可以减少单个 <code>IdleHandler</code> 的负载，从而提高任务的执行效率。</li></ol><h5 id="关键行为分析"><a href="#关键行为分析" class="headerlink" title="关键行为分析"></a>关键行为分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果首次进入空闲状态，则获取要运行的空闲处理程序数量。</span></span><br><span class="line"><span class="comment">             * 空闲处理程序仅在消息队列为空或队列中的第一个消息（可能是一个屏障）将在未来被处理时运行。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                <span class="comment">// 没有要运行的空闲处理程序。继续循环并等待一段时间。</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 运行空闲处理程序。</span></span><br><span class="line"><span class="comment">         * 我们只会在第一次迭代期间到达这个代码块。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mPendingIdleHandlers-与-mIdleHandlers"><a href="#mPendingIdleHandlers-与-mIdleHandlers" class="headerlink" title="mPendingIdleHandlers 与 mIdleHandlers"></a>mPendingIdleHandlers 与 mIdleHandlers</h4><ol><li><strong>mPendingIdleHandlers</strong>：<ul><li>类型：<code>IdleHandler[]</code></li><li>作用：用于存储当前等待执行的空闲时处理对象（<code>IdleHandler</code>）数组。在消息队列空闲时，这些处理会被调用，以执行额外的任务。</li><li>使用场景：用于临时存储等待执行的空闲时处理，直接与循环内部逻辑相关。</li></ul></li><li><strong>mIdleHandlers</strong>：<ul><li>类型：<code>ArrayList&lt;IdleHandler&gt;</code></li><li>作用：用于存储注册的空闲时处理对象。开发者可以将多个 <code>IdleHandler</code> 添加到这个列表中，以便在消息队列空闲时执行不同的任务。</li><li>使用场景：用于持久存储注册的空闲时处理，可以在任何时候添加或移除 <code>IdleHandler</code>。</li></ul></li></ol><p>总结区别：</p><ul><li><code>mPendingIdleHandlers</code> 是一个数组，用于存储当前等待执行的空闲时处理对象。它是循环内部临时使用的，用于遍历调用每个等待执行的空闲时处理。</li><li><code>mIdleHandlers</code> 是一个列表，用于持久存储注册的空闲时处理对象。开发者可以随时将 <code>IdleHandler</code> 添加到列表中，以便在消息队列空闲时执行不同的任务。</li></ul><h5 id="给-PendingIdleHandlers-分配新的数组空间"><a href="#给-PendingIdleHandlers-分配新的数组空间" class="headerlink" title="给 PendingIdleHandlers 分配新的数组空间"></a>给 PendingIdleHandlers 分配新的数组空间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是在消息队列空闲时，检查是否需要运行空闲时处理。如果当前没有消息或者队列中的第一个消息的处理时间还未到来，并且之前的 <code>pendingIdleHandlerCount</code> 小于 0，那么它会获取当前注册的空闲时处理的数量，并将其赋值给 <code>pendingIdleHandlerCount</code>。这样，当队列为空或者第一个消息处理时间未到来时，代码会准备好运行已注册的空闲时处理。通常情况下，这个检查用于确保空闲时处理在适当的时机被调度执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    <span class="comment">// 没有要运行的空闲处理程序。继续循环并等待一段时间。</span></span><br><span class="line">    mBlocked = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是在消息队列空闲时，如果没有等待执行的空闲时处理，就将消息队列标记为被阻塞状态，并继续等待更多的消息或任务进入队列。这个逻辑用于优化资源管理，确保在没有即时任务需要处理时，程序仍然能够保持运行，以便在有任务时能够立即执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">    mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：隐含的条件是 pendingIdleHandlerCount &lt;&#x3D; 0 才能走到这里，所以判断条件其实是 pendingIdleHandlerCount &lt;&#x3D; 0 &amp;&amp; mPendingIdleHandlers &#x3D;&#x3D; null，通常表示这是第一次运行空闲时处理</p><p>如果 <code>mPendingIdleHandlers</code> 为 <code>null</code>，则进入条件判断。在这里，使用 <code>Math.max(pendingIdleHandlerCount, 4)</code> 来计算数组的长度，其中 <code>pendingIdleHandlerCount</code> 是等待执行的空闲时处理的数量。如果等待执行的处理数量小于 4，则数组长度取值为 4，否则取值为 <code>pendingIdleHandlerCount</code></p><h5 id="PendingIdleHandlers-赋值"><a href="#PendingIdleHandlers-赋值" class="headerlink" title="PendingIdleHandlers 赋值"></a>PendingIdleHandlers 赋值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br></pre></td></tr></table></figure><h5 id="运行空闲时处理-PendingIdleHandlers"><a href="#运行空闲时处理-PendingIdleHandlers" class="headerlink" title="运行空闲时处理 PendingIdleHandlers"></a>运行空闲时处理 PendingIdleHandlers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the idle handlers.</span></span><br><span class="line"><span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行空闲处理程序。</span></span><br><span class="line"><span class="comment"> * 我们只会在第一次迭代期间到达这个代码块。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">    mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里注释中的第一次迭代是指的消息队列第一次处理完所有已经在队列中的消息的那一次迭代，是想说明在后续的迭代中，如果消息队列仍然处于空闲状态，那么这段代码块不会再执行，因为它只在消息队列刚刚变为空闲时运行。</p><h4 id="队列的唤醒与阻塞"><a href="#队列的唤醒与阻塞" class="headerlink" title="队列的唤醒与阻塞"></a>队列的唤醒与阻塞</h4><h5 id="android-os-MessageQueue-enqueueMessage"><a href="#android-os-MessageQueue-enqueueMessage" class="headerlink" title="android.os.MessageQueue#enqueueMessage"></a>android.os.MessageQueue#enqueueMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>mBlocked</code> 在两个地方起到了不同的作用：</p><ol><li><p><strong>第一个 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needWake = mBlocked;</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 被赋值给变量 <code>needWake</code>。这个操作是为了判断是否需要唤醒事件队列（消息循环）。具体情况如下：</p><ul><li>如果 <code>mBlocked</code> 为 <code>true</code>，表示事件队列当前正处于阻塞状态，即没有立即需要处理的消息。在这种情况下，如果新消息的插入导致事件队列不再阻塞，就需要唤醒事件队列，以便消息循环继续执行。</li><li>如果 <code>mBlocked</code> 为 <code>false</code>，表示事件队列没有阻塞，新消息的插入不会改变这个状态，因此不需要唤醒。</li></ul></li><li><p><strong>第二个 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 参与了判断条件。这个条件用于判断是否需要唤醒事件队列，以提醒消息循环处理新消息。具体情况如下：</p><ul><li>如果 <code>mBlocked</code> 为 <code>true</code>，表示事件队列当前正处于阻塞状态。然后，进一步判断消息队列中是否有异步消息，并且插入的新消息也是异步消息，那么需要唤醒事件队列，以便消息循环能够立即处理这个异步消息。</li></ul></li></ol><p>综上所述，<code>mBlocked</code> 在这段代码中的两个地方都与判断是否需要唤醒事件队列有关。第一个地方是用来判断是否需要在新消息插入时唤醒事件队列，以便消息循环继续执行。第二个地方是在特定条件下，判断是否需要唤醒事件队列来处理异步消息。</p><h5 id="android-os-MessageQueue-next"><a href="#android-os-MessageQueue-next" class="headerlink" title="android.os.MessageQueue#next"></a>android.os.MessageQueue#next</h5><p>在提供的代码片段中，有三处不同的地方使用了 <code>mBlocked</code> 参数，并且它们在不同的上下文中起到了不同的作用。以下是每个位置的详细分析：</p><p><strong>第一处 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBlocked = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 被设置为 <code>false</code>，表示消息队列不再处于阻塞状态。这是在找到了一个准备好被处理的消息后执行的操作。通过将 <code>mBlocked</code> 设置为 <code>false</code>，消息循环可以继续处理消息，而不需要等待。</p><p><strong>第二处 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBlocked = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>在这里，<code>mBlocked</code> 被设置为 <code>true</code>，表示消息队列当前处于阻塞状态。这是在判断没有可处理的消息，并且没有要运行的空闲处理程序时执行的操作。通过将 <code>mBlocked</code> 设置为 <code>true</code>，消息循环进入了等待状态，等待新的消息或者空闲处理程序的到来。</p><p><strong>第三处 mBlocked 作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBlocked = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这里的 <code>mBlocked</code> 也被设置为 <code>true</code>，与第二处的作用相同。这是在消息队列处理完所有的空闲处理程序之后，仍然没有要运行的空闲处理程序时执行的操作。通过将 <code>mBlocked</code> 设置为 <code>true</code>，消息循环会继续等待，直到有新的消息到达或者空闲处理程序需要运行。</p><p>总结来说，<code>mBlocked</code> 在这段代码中的三处不同的作用是：</p><ol><li>在找到一个准备好被处理的消息后，将其设置为 <code>false</code>，使得消息循环可以继续处理消息。</li><li>在没有可处理的消息且没有要运行的空闲处理程序时，将其设置为 <code>true</code>，使得消息循环进入等待状态。</li><li>在所有空闲处理程序都被处理后，仍然没有要运行的空闲处理程序时，将其设置为 <code>true</code>，继续等待。</li></ol><p>通过这样的设置，消息循环能够根据不同的情况来控制阻塞和等待状态，以便有效地处理消息和任务。</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Framework 专项 - Handler（一）</title>
      <link href="/2023/08/23/3%20Android/Framework/01-Android-Framework-%E4%B8%93%E9%A1%B9-Handler1/"/>
      <url>/2023/08/23/3%20Android/Framework/01-Android-Framework-%E4%B8%93%E9%A1%B9-Handler1/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure><p>Q：一个线程有几个 Handler？</p><p>Q: 线程间的通信的原理是怎样的？</p><p>Q: Handler 内存泄漏的原因？为什么其他的内部类没有说过这个问题？</p><p>Q: 为何主线程可以 new Handler ？如果想要在子线程中 new Handler 要做些什么准备？</p><p>Q: 子线程中维护的 Looper，消息队列无消息的时候的处理方案是什么？有什么用？</p><p>Q: 既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个 Handler 可能处于不同线程），那它内部时如何确保线程安全的？</p><p>Q: Looper 死循环为什么不会导致应用卡死</p><p>Q: 为什么主线程不需要自己创建和管理消息循环</p><h3 id="Handler-在-Android-中的应用"><a href="#Handler-在-Android-中的应用" class="headerlink" title="Handler 在 Android 中的应用"></a>Handler 在 Android 中的应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler 是针对 Android 系统中与 UI 线程通信而专门设计的多线程通信机制</span><br></pre></td></tr></table></figure><p>Retorfit，eventbus，rxjava，Looper</p><h3 id="Handler-源代码分析"><a href="#Handler-源代码分析" class="headerlink" title="Handler 源代码分析"></a>Handler 源代码分析</h3><h4 id="子线程-发送-MSG"><a href="#子线程-发送-MSG" class="headerlink" title="子线程 发送 MSG"></a>子线程 发送 MSG</h4><p>​android.os.Handler#sendMessage -&gt;<br>​android.os.Handler#sendMessageDelayed -&gt;<br>​android.os.Handler#sendMessageAtTime -&gt;<br>​android.os.Handler#enqueueMessage -&gt;<br>​android.os.MessageQueue#enqueueMessage -&gt;<br>​android.os.Looper#loop</p><h5 id="android-os-Handler-sendMessage"><a href="#android-os-Handler-sendMessage" class="headerlink" title="android.os.Handler#sendMessage"></a>android.os.Handler#sendMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes a message onto the end of the message queue after all pending messages</span></span><br><span class="line"><span class="comment">     * before the current time. It will be received in &#123;<span class="doctag">@link</span> #handleMessage&#125;,</span></span><br><span class="line"><span class="comment">     * in the thread attached to this handler.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment">     *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">     *         looper processing the message queue is exiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有挂起的消息之后将消息推送到消息队列的末尾</span></span><br><span class="line"><span class="comment">     * 当前时间之前。它将在 &#123;<span class="doctag">@link</span> #handleMessage&#125; 中收到，</span></span><br><span class="line"><span class="comment">     * 在附加到该处理程序的线程中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果消息成功放入则返回 true</span></span><br><span class="line"><span class="comment">     * 消息队列。失败时返回 false，通常是因为</span></span><br><span class="line"><span class="comment">     * 处理消息队列的 looper 正在退出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="android-os-Handler-sendMessageDelayed"><a href="#android-os-Handler-sendMessageDelayed" class="headerlink" title="android.os.Handler#sendMessageDelayed"></a>android.os.Handler#sendMessageDelayed</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before (current time + delayMillis). You will receive it in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached to this handler.</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一条消息放入消息队列中，位于所有挂起的消息之后</span></span><br><span class="line"><span class="comment"> * 之前（当前时间+delayMillis）。您将在以下时间收到它：</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #handleMessage&#125;，在附加到该处理程序的线程中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果消息成功放入则返回 true</span></span><br><span class="line"><span class="comment"> * 消息队列。失败时返回 false，通常是因为</span></span><br><span class="line"><span class="comment"> * 处理消息队列的 looper 正在退出。请注意，一个</span></span><br><span class="line"><span class="comment"> * true 的结果并不意味着该消息将被处理 -- 如果</span></span><br><span class="line"><span class="comment"> * Looper 在消息发送之前退出</span></span><br><span class="line"><span class="comment"> * 发生则消息将被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="android-os-Handler-sendMessageAtTime"><a href="#android-os-Handler-sendMessageAtTime" class="headerlink" title="android.os.Handler#sendMessageAtTime"></a>android.os.Handler#sendMessageAtTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * Time spent in deep sleep will add an additional delay to execution.</span></span><br><span class="line"><span class="comment"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment"> * to this handler.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment"> *         delivered, using the</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将消息排队到消息队列中，在绝对时间（以毫秒为单位）&lt;var&gt;uptimeMillis&lt;/var&gt;之后的所有挂起消息之后。</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;时间基准是 &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * 在深度睡眠期间花费的时间将会额外延迟执行。</span></span><br><span class="line"><span class="comment"> * 您将在&#123;<span class="doctag">@link</span> #handleMessage&#125;中接收它，该方法会在与此处理程序连接的线程中执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis 消息应该传递的绝对时间，使用&#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;作为时间基准。</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果消息成功放置到消息队列中，则返回 true 。如果失败，则返回 false ，通常是因为处理消息队列的消息循环正在退出。</span></span><br><span class="line"><span class="comment"> * 请注意，返回true并不意味着消息将被处理 - 如果消息传递时间之前消息循环被退出，则消息将被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><h5 id="android-os-Handler-enqueueMessage"><a href="#android-os-Handler-enqueueMessage" class="headerlink" title="android.os.Handler#enqueueMessage"></a>android.os.Handler#enqueueMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，发送流程都没什么好说的</p><h5 id="重点：android-os-Handler-handleMessage"><a href="#重点：android-os-Handler-handleMessage" class="headerlink" title="重点：android.os.Handler#handleMessage"></a>重点：android.os.Handler#handleMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="msg-target-是什么"><a href="#msg-target-是什么" class="headerlink" title="msg.target 是什么"></a>msg.target 是什么</h6><p>注意：<strong>这里 msg.target 就是 msg 持有的 handler 也是 为什么会有内存泄漏风险的原因。</strong></p><p>分析代码：</p><h6 id="Handler-内存泄漏原因"><a href="#Handler-内存泄漏原因" class="headerlink" title="Handler 内存泄漏原因"></a>Handler 内存泄漏原因</h6><p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。</p><p>它的主要作用是将消息按照时间顺序插入到消息队列中，并在必要时唤醒队列以处理这些消息。下面逐步分析代码的功能和逻辑。</p><ol><li><p>首先，代码对传入的消息 <code>msg</code> 进行一些验证。它确保消息有一个非空的目标（<code>msg.target != null</code>），否则抛出 <code>IllegalArgumentException</code>。</p></li><li><p>然后，代码在同步块内执行以下操作：</p><ul><li><p>检查消息是否已经在使用中，如果是，则抛出 <code>IllegalStateException</code>。这可能是为了防止重复使用消息，确保每个消息只被处理一次。</p></li><li><p>检查当前处理器是否正在退出（<code>mQuitting</code> 标志），如果是，就回收消息并返回 false，表示消息未被成功加入队列。</p></li><li><p>将消息标记为正在使用，并设置消息的触发时间 <code>msg.when</code> 为传入的 <code>when</code>。</p></li><li><p>获取消息队列的头部消息 <code>p</code>。</p></li></ul></li><li><p>接下来，代码根据以下条件进行处理：</p><ul><li><p>如果消息队列为空，或者传入的触发时间 <code>when</code> 为 0，或者传入的 <code>when</code> 小于队列头部消息的触发时间 <code>p.when</code>，则将新消息插入到队列头部。如果队列当前被阻塞（<code>mBlocked</code> 标志），则设置需要唤醒队列（<code>needWake = true</code>）。</p></li><li><p>否则，如果消息需要插入队列中间，则根据条件判断是否需要唤醒队列。具体判断条件是：队列被阻塞、队列头部消息的目标为 null，且传入的消息是异步消息。然后，代码在一个循环中遍历消息队列，找到合适的位置插入新消息。循环会一直迭代，直到找到合适的位置或者遍历完整个队列。</p></li><li><p>在找到合适的位置后，代码将新消息 <code>msg</code> 插入到队列中。具体做法是，将 <code>msg.next</code> 设置为当前消息 <code>p</code>，然后将前一个消息 <code>prev.next</code> 设置为新消息 <code>msg</code>。</p></li></ul></li><li><p>最后，代码根据之前的标志 <code>needWake</code> 来决定是否唤醒队列。如果需要唤醒，则调用本地的 <code>nativeWake</code> 方法（可能是一个底层的本地方法）来唤醒消息队列。</p></li><li><p>整个同步块结束后，代码返回 true，表示消息已经成功加入队列。</p></li></ol><p>这段代码的核心功能是在消息队列中插入消息并进行适当的排序，以确保消息按照触发时间顺序进行处理。同时，它还处理了一些异常情况，如消息已经在使用中或者处理器正在退出。唤醒队列的逻辑也在代码的最后部分进行处理。</p><p>让我们逐步分析 MSG 插入队列的位置：</p><h6 id="第一种插入头部的情况："><a href="#第一种插入头部的情况：" class="headerlink" title="第一种插入头部的情况："></a>第一种插入头部的情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">      <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">      needWake = mBlocked;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果消息队列为空，意味着<strong>当前没有任何消息在队列中等待处理</strong>。在这种情况下，不需要比较触发时间，<strong>直接将新消息插入到队列的头部</strong>。这会让新消息成为队列的第一个要处理的消息。</li><li>如果<strong>传入的触发时间 <code>when</code> 为 0</strong>，这可能表示<strong>该消息需要尽快处理</strong>，因此同样将它插入到队列的头部。</li><li>如果<strong>传入的触发时间</strong> <code>when</code> <strong>小于队列头部消息的触发时间</strong> <code>p.when</code>，这意味着新消息应该在队列中位于当前头部消息之前，因此<strong>同样将它插入到队列的头部</strong>。</li></ol><p>综合上述情况，无论是<strong>队列为空</strong>，还是<strong>传入的 <code>when</code> 值为 0</strong>，或者<strong>传入的 <code>when</code> 值小于队列头部消息的触发时间</strong>，都会<strong>将新消息插入到队列的头部</strong>。</p><h6 id="第二种插入中间的情况："><a href="#第二种插入中间的情况：" class="headerlink" title="第二种插入中间的情况："></a>第二种插入中间的情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">       <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">       <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">       needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">       Message prev;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                needWake = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">       prev.next = msg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li>首先，如果不满足前面提到的条件（消息队列为空，传入的触发时间为0，或传入的触发时间小于队列头部消息的触发时间），那么意味着要插入的新消息 <code>msg</code> 应该位于队列中间。</li><li>在这种情况下，代码会进入一个循环。这个循环的目的是遍历消息队列，以找到合适的位置将新消息 <code>msg</code> 插入队列中。</li><li>循环的条件是 <code>for (;;)</code>，这将创建一个无限循环，直到内部的某个条件满足而跳出循环。</li><li>在每次循环迭代中，代码会做以下事情：<ul><li>将当前消息 <code>p</code> 的引用赋值给 <code>prev</code>，这样可以记录下前一个消息。</li><li>将 <code>p</code> 移动到下一个消息（<code>p = p.next</code>）。</li></ul></li><li>然后，代码检查两个条件：<ul><li>如果当前消息 <code>p</code> 为空，意味着已经遍历了整个队列，或者队列只有一个消息且当前消息是最后一个消息。</li><li>如果传入的触发时间 <code>when</code> 小于队列中当前消息 <code>p</code> 的触发时间 <code>p.when</code>。</li></ul></li><li>如果满足以上任一条件，循环会被中断，这表示找到了合适的位置将新消息 <code>msg</code> 插入到消息队列中。</li><li>在循环的每个迭代中，代码还会检查以下条件：<ul><li>如果需要唤醒队列（<code>needWake = true</code>），并且当前消息 <code>p</code> 是异步消息（<code>p.isAsynchronous()</code> 返回 true），则将 <code>needWake</code> 设置为 false。这个步骤可能是为了控制是否需要在队列中插入异步消息时唤醒队列。</li></ul></li><li>一旦找到了合适的位置，代码会执行以下操作：<ul><li>将新消息 <code>msg</code> 的 <code>next</code> 指针指向当前消息 <code>p</code>，这相当于将新消息插入到当前消息 <code>p</code> 之前。</li><li>将前一个消息 <code>prev</code> 的 <code>next</code> 指针指向新消息 <code>msg</code>，以确保队列中消息的连接关系正确。</li></ul></li><li>循环结束后，新消息 <code>msg</code> 已经被插入到队列的合适位置，保持了消息队列的有序性。</li></ol><p>总之，这段代码的目的是在消息队列中将新消息插入到适当的位置，以保持消息的时间顺序。在找到合适位置时，会根据一些条件来决定是否需要唤醒队列，这可能与队列的处理机制相关。</p><p>此外，如果当前消息队列被阻塞（<code>mBlocked</code> 为 true），则将标志 <code>needWake</code> 设置为 true。这是为了确保在需要唤醒队列以处理消息的情况下，能够在适当的时候执行唤醒操作。唤醒队列的操作可能涉及到一些底层机制，具体如何唤醒可能需要查看更多上下文代码。</p><p>总的来说，这段代码逻辑的目的是在特定条件下将新消息插入到消息队列的头部，并根据当前队列的阻塞状态决定是否需要唤醒队列以确保消息能够被及时处理。</p><h4 id="主线程-取出-MSG"><a href="#主线程-取出-MSG" class="headerlink" title="主线程 取出 MSG"></a>主线程 取出 MSG</h4><p>​android.os.Looper#loop -&gt;<br>​android.os.MessageQueue#next -&gt;<br>​android.os.Handler#dispatchMessage -&gt;<br>​android.os.Handler#handleMessage</p><h6 id="主线程中的-Loop"><a href="#主线程中的-Loop" class="headerlink" title="主线程中的 Loop"></a>主线程中的 Loop</h6><p>我们来看主线程的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format &quot;seq=114&quot;</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 handler 相关的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">  ...</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br><span class="line">      </span><br><span class="line">    Looper.loop();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>准备</strong> Looper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure><p>android.os.Looper#prepareMainLooper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.os.Looper#prepare(boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备 Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.app.ActivityThread#getHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">public</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> mH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.app.ActivityThread#mH</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br></pre></td></tr></table></figure><p>开启循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure><h5 id="重点：android-os-Looper-loop"><a href="#重点：android-os-Looper-loop" class="headerlink" title="重点：android.os.Looper#loop"></a>重点：android.os.Looper#loop</h5><h6 id="loop"><a href="#loop" class="headerlink" title="#loop"></a>#loop</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是 Android 框架中 Looper 类的 <code>loop()</code> 方法的实现，负责在当前线程的消息循环中执行消息的分发和处理。</p><ol><li>首先，通过 <code>myLooper()</code> 获取当前线程的 Looper 实例 <code>me</code>，如果没有 Looper 实例则抛出异常，表示未调用 <code>Looper.prepare()</code> 来准备 Looper。</li><li>检查 <code>me.mInLoop</code>，如果当前线程已经在消息循环中，则打印警告日志。</li><li>将 <code>me.mInLoop</code> 标志设置为 <code>true</code>，表示当前线程正在消息循环中。</li><li>使用 <code>Binder.clearCallingIdentity()</code> 来清除当前线程的调用标识，然后再次调用它并将返回的标识 <code>ident</code> 保存下来。</li><li>获取一个可能的系统属性覆盖值 <code>thresholdOverride</code>，用于调整慢分发的阈值。</li><li>将 <code>me.mSlowDeliveryDetected</code> 设置为 <code>false</code>，用于标记是否检测到慢投递。</li><li>进入一个无限循环，不断地执行消息分发和处理。</li><li>在循环中，调用 <code>loopOnce(me, ident, thresholdOverride)</code> 来执行一次消息分发。如果返回值为 <code>false</code>，表示没有更多的消息需要分发，退出循环。</li></ol><p>总之，这段代码描述了 Android 中消息循环的核心逻辑。它会在一个无限循环中，不断地从消息队列中获取消息并执行消息分发和处理，直到没有更多的消息需要处理为止。在循环中，还会检查是否有慢分发阈值的系统属性覆盖，并根据需要清除调用标识。如果发现当前线程已经在消息循环中，则会打印警告信息。</p><h6 id="loopOnce"><a href="#loopOnce" class="headerlink" title="#loopOnce"></a>#loopOnce</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">        <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">        <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">            <span class="keyword">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                    me.mSlowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是 Android 框架中 Looper 类的一个方法 <code>loopOnce</code> 的实现，主要负责处理消息队列中的消息分发过程。我会逐步解释代码的功能。</p><ol><li><p>首先，通过 <code>me.mQueue.next()</code> 获取下一个消息，如果没有消息则表示消息队列正在退出，函数返回 <code>false</code>。</p></li><li><p>如果获取到了消息，则会根据是否设置了日志打印，打印消息的分发信息。</p></li><li><p>获取当前的观察者对象和跟踪标签。</p></li><li><p>根据阈值覆盖值，更新慢分发和慢投递的阈值。</p></li><li><p>判断是否需要记录开始时间和结束时间，如果需要，则记录当前时间作为分发开始时间。</p></li><li><p>如果设置了跟踪标签且跟踪标签是启用的，则开始跟踪。</p></li><li><p>设置开始分发时间，并获取一个 token 以用于观察者的消息分发起始回调。</p></li><li><p>设置当前线程的工作源为消息的工作源 UID。</p></li><li><p>使用目标 Handler（Handler 是消息处理的目标）来分发消息。</p></li><li><p>如果设置了观察者，通知观察者消息已分发。</p></li><li><p>结束分发，记录结束时间。</p></li><li><p>如果发生异常，通知观察者分发过程中出现异常，并将异常抛出。</p></li><li><p>最终，无论是否发生异常，都会恢复线程的工作源，并根据跟踪标签是否启用，结束跟踪。</p></li><li><p>如果设置了慢投递日志，会根据条件判断是否记录慢投递日志。</p></li><li><p>如果设置了慢分发日志，会根据条件记录慢分发日志。</p></li><li><p>如果设置了日志打印，会打印消息分发完成信息。</p></li><li><p>最后，检查分发过程中线程标识是否被更改，如果发生改变，会打印警告日志。</p></li><li><p>回收消息对象并返回 <code>true</code>，表示成功分发消息。</p></li></ol><p>总之，这段代码描述了 Android 中消息队列中消息的分发过程，涵盖了消息的跟踪、日志记录、观察者通知等多个方面，确保消息能够按照正确的顺序分发到目标处理程序。</p><h5 id="重点：android-os-MessageQueue-next"><a href="#重点：android-os-MessageQueue-next" class="headerlink" title="重点：android.os.MessageQueue#next"></a>重点：android.os.MessageQueue#next</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Android 消息循环（Message Loop）的一部分，它用于处理消息队列中的消息。消息循环是 Android 应用程序的核心部分，用于处理用户界面事件、线程间通信等。</p><p>以下是代码的主要功能和逻辑：</p><ol><li><p>代码开头使用了一个注解 <code>@UnsupportedAppUsage</code>，这是 Android 的一个标记注解，用于标识不推荐使用的 API 或方法。</p></li><li><p><code>next()</code> 方法是一个消息循环的主要函数。它会循环从消息队列中获取消息，然后处理这些消息。</p></li><li><p>首先，代码会获取 <code>mPtr</code>，这是一个表示消息队列的指针。如果 <code>ptr</code> 为 0，表示消息队列已经被释放，函数会返回 <code>null</code>。</p></li><li><p>接下来，进入一个无限循环 <code>for (;;) &#123;...&#125;</code>，在循环内部做以下操作：</p><ul><li><p>如果 <code>nextPollTimeoutMillis</code> 不为 0，会刷新待处理的 Binder 命令（一种 Android 进程间通信机制）。</p></li><li><p>调用 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>，它是一个本地方法，用于轮询获取下一个消息。</p></li><li><p>进入同步块，开始处理消息队列中的消息。</p></li><li><p>首先，获取当前时间 <code>now</code>，然后尝试获取下一个消息。如果消息的目标为 <code>null</code>，表示该消息是一个异步消息（可能由于障碍而被阻塞），会查找下一个异步消息。</p></li><li><p>如果找到消息并且消息的触发时间在当前时间之后，会设置一个定时器来在消息准备好时唤醒循环。</p></li><li><p>如果消息已经准备好（触发时间已到），会将消息从队列中移除，并返回该消息。</p></li><li><p>如果没有找到消息，会将 <code>nextPollTimeoutMillis</code> 设为 -1，表示没有更多消息。</p></li><li><p>如果 <code>mQuitting</code> 为 true，表示消息队列已经被停止，会调用 <code>dispose()</code> 释放资源，并返回 <code>null</code>。</p></li><li><p>如果是第一次空闲（没有消息待处理），会获取待运行的空闲处理器数量。</p></li><li><p>如果没有空闲处理器需要运行，会将 <code>mBlocked</code> 设为 true，继续等待。</p></li><li><p>如果有待运行的空闲处理器，会将它们放入 <code>mPendingIdleHandlers</code> 数组中。</p></li><li><p>执行空闲处理器的 <code>queueIdle()</code> 方法，该方法用于处理空闲状态。</p></li><li><p>如果 <code>queueIdle()</code> 返回 false，表示该空闲处理器不再需要运行，会将其从列表中移除。</p></li><li><p>重置空闲处理器数量为 0，以防止重复运行。</p></li><li><p>在处理完空闲处理器后，将 <code>nextPollTimeoutMillis</code> 设为 0，以便立即查找待处理的消息。</p></li></ul></li></ol><p>以上就是这段代码的主要逻辑。它负责不断地从消息队列中获取消息并处理，同时也处理了一些特殊情况，如消息队列已停止、空闲处理等。这种消息循环机制保证了 Android 应用程序的响应性和流畅性。</p><h6 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h6><p>给定代码中最重要的部分是主循环，该循环处理消息并运行空闲处理程序，在Android消息循环系统中负责处理消息并及时有效地运行空闲处理程序。让我们逐步分解关键组成部分及其重要性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 收到一条消息。</span></span><br><span class="line">                mBlocked = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 从队列中移除消息并返回。</span></span><br><span class="line">                <span class="comment">// 这是消息处理的核心操作。</span></span><br><span class="line">                <span class="comment">// 它允许根据其预定时间依次执行消息。</span></span><br><span class="line">                <span class="comment">// 返回的“msg”对象包含用于处理的数据和指令。</span></span><br><span class="line">                msg.markInUse();</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有更多消息。</span></span><br><span class="line">            nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理退出消息并处理空闲处理程序。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行空闲处理程序。</span></span><br><span class="line">        <span class="comment">// 该块遍历待处理的空闲处理程序并执行它们。</span></span><br><span class="line">        <span class="comment">// 空闲处理程序用于在消息队列为空时执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置空闲处理程序计数并检查是否有新消息。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分及其重要性如下：</p><ol><li><code>nativePollOnce(ptr, nextPollTimeoutMillis);</code>：这个本地方法用于轮询来自底层系统的传入消息和事件。它等待指定的超时时间以获取新的消息。</li><li>消息处理：<ul><li>循环检查是否有待处理的消息，并根据其预定时间（<code>msg.when</code>）对其进行处理。</li><li>如果一条消息准备好执行，它会从队列中移除并返回（<code>return msg;</code>）。</li><li>这是消息循环的核心，消息按照它们被发布的顺序逐个执行。</li><li><code>markInUse()</code> 方法表示消息正在被处理。</li></ul></li><li>退出消息和空闲处理程序：<ul><li>循环检查消息循环是否正在退出（<code>mQuitting</code>）并在需要时释放资源。</li><li>还会处理空闲处理程序，这些程序在没有待处理消息时执行。</li><li>空闲处理程序是在消息循环处于非活动状态时执行任务的函数。</li></ul></li></ol><p>总的来说，这段代码片段代表了Android消息循环的核心机制，它对于管理异步任务、UI交互和基于事件的编程在Android应用中至关重要。这个循环的正常运行对于维持响应迅速、交互式的用户体验至关重要。</p><h5 id="android-os-Handler-dispatchMessage"><a href="#android-os-Handler-dispatchMessage" class="headerlink" title="android.os.Handler#dispatchMessage"></a>android.os.Handler#dispatchMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Android 消息分发方法，用于处理系统消息。在 Android 中，消息分发是消息循环的一部分，用于将消息传递给相应的处理方法或回调函数。</p><p>以下是代码的主要功能和逻辑：</p><ol><li><p>方法名为 <code>dispatchMessage</code>，接受一个非空的 <code>Message</code> 对象作为参数，用于处理系统消息。</p></li><li><p>首先，代码检查 <code>msg</code> 中是否存在一个非空的回调函数 <code>callback</code>。如果存在，表示该消息具有一个回调函数，将调用 <code>handleCallback(msg)</code> 来处理该回调函数。</p></li><li><p>如果 <code>msg</code> 中没有回调函数，代码会进入下一步判断。</p></li><li><p>首先，检查是否存在一个非空的成员变量 <code>mCallback</code>，它是一个消息处理器的回调接口。如果存在 <code>mCallback</code>，代码会调用 <code>handleMessage(msg)</code> 来处理消息。如果 <code>mCallback.handleMessage(msg)</code> 返回 <code>true</code>，表示消息已经被处理，函数会直接返回，不会继续执行后续的 <code>handleMessage(msg)</code>。</p></li><li><p>如果 <code>mCallback.handleMessage(msg)</code> 返回 <code>false</code>，表示 <code>mCallback</code> 没有处理该消息，代码会调用当前类的 <code>handleMessage(msg)</code> 方法来处理消息。</p></li></ol><p>综合起来，这段代码实现了一个消息分发的逻辑，首先检查消息是否有回调函数，然后尝试使用回调函数处理消息。如果没有回调函数，它会检查是否存在一个全局的消息处理器 <code>mCallback</code>，尝试让它处理消息。如果都没有成功处理，最后会调用当前类的 <code>handleMessage(msg)</code> 方法来处理消息。</p><p>这种消息分发机制使得消息能够在不同的处理方法和回调函数之间进行传递和处理，提高了代码的灵活性和可扩展性。</p><h5 id="android-os-Handler-handleMessage"><a href="#android-os-Handler-handleMessage" class="headerlink" title="android.os.Handler#handleMessage"></a>android.os.Handler#handleMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个方法声明，用于在子类中实现消息处理的逻辑。在 Android 中，消息处理是一种常见的模式，用于处理来自消息队列的不同类型的消息。</p><p>以下是代码的主要功能和逻辑：</p><ol><li><p>方法名为 <code>handleMessage</code>，接受一个非空的 <code>Message</code> 对象作为参数，用于处理消息。</p></li><li><p>这是一个抽象方法，没有具体的实现，因此需要在子类中进行实现。</p></li><li><p>子类必须重写这个方法，并根据具体的业务逻辑来处理传递进来的消息。</p></li><li><p>通过在子类中实现不同的 <code>handleMessage</code> 方法，可以实现不同类型的消息处理，从而达到分离不同功能的目的。</p></li></ol><p>在 Android 应用程序开发中，常常会使用这种消息处理机制来进行异步任务的处理、UI 更新、线程间通信等。子类可以根据不同的需求，实现不同的消息处理逻辑，使代码结构更加清晰和模块化。</p><h5 id="使用-handler-通信机制由主线程向子线程发送消息"><a href="#使用-handler-通信机制由主线程向子线程发送消息" class="headerlink" title="使用 handler 通信机制由主线程向子线程发送消息"></a>使用 handler 通信机制由主线程向子线程发送消息</h5><p>我们已经了解了主线程中会创建 Looper 和 handler，也明白了期运行逻辑<br>下面我们在子线程中创建这一套通信机制，用于主线程向子线程发送消息</p><h6 id="创建一个-CustomLooperThread"><a href="#创建一个-CustomLooperThread" class="headerlink" title="创建一个 CustomLooperThread"></a>创建一个 CustomLooperThread</h6><p> 手动创建子线程的 <code>Looper</code> 和关联的 <code>Handler</code>，以便在子线程中处理消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomLooperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mLooper) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mHandler.post(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            mLooper.quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二: <strong>使用 <code>HandlerThread</code>：</strong> 使用 <code>HandlerThread</code> 类封装了子线程的 <code>Looper</code> 和关联的 <code>Handler</code> 创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLooperThread</span> <span class="keyword">extends</span> <span class="title class_">HandlerThread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomLooperThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在子线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageToThread</span><span class="params">(<span class="type">int</span> what)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> mHandler.obtainMessage(what);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建一个-MyThreadManager"><a href="#创建一个-MyThreadManager" class="headerlink" title="创建一个 MyThreadManager"></a>创建一个 MyThreadManager</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyThread mThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程并启动</span></span><br><span class="line">        mThread = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在线程的消息循环中创建 Handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到线程中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> mHandler.obtainMessage(what);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务在线程中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTaskInThread</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mThread.executeTask(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程和消息循环</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mThread.quit();</span><br><span class="line">            mThread = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h5><h6 id="方式一，自定义-Looper-和-Handler-创建的-CustomLooperThread-中的-getLooper-有没有问题？"><a href="#方式一，自定义-Looper-和-Handler-创建的-CustomLooperThread-中的-getLooper-有没有问题？" class="headerlink" title="方式一，自定义 Looper 和 Handler 创建的 CustomLooperThread 中的 getLooper 有没有问题？"></a>方式一，自定义 <code>Looper</code> 和 <code>Handler</code> 创建的 CustomLooperThread 中的 getLooper 有没有问题？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mThread.start();</span><br></pre></td></tr></table></figure><p>是在子线程中执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线程的消息循环中创建 Handler</span></span><br><span class="line">mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mThread.getLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 在线程中处理消息</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;thread.start()是在子线程中</span><br></pre></td></tr></table></figure><p>是在主线程执行的<br>也就是说在 mThread.getLooper() 时，有可能 mThread.start() 还没执行完<br>所以这里有<strong>多线程并发问题</strong></p><p>我们看一下 HandlerThread 中是怎么解决的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment"> * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment"> * has been started, this method will block until the looper has been initialized.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasInterrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                wasInterrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We may need to restore the thread&#x27;s interrupted flag, because it may</span></span><br><span class="line"><span class="comment">     * have been cleared above since we eat InterruptedExceptions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h6 id="Thread-中的-Handler-和-MyThreadManager-中-Handler-有什么不同"><a href="#Thread-中的-Handler-和-MyThreadManager-中-Handler-有什么不同" class="headerlink" title="Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同"></a>Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同</h6><ol><li><strong><code>MyThread</code> 类中的 <code>Handler</code>：</strong> 在 <code>MyThread</code> 类中的 <code>Handler</code> 用于处理子线程 <code>MyThread</code> 中的消息。它负责监听并处理从 <code>MyThread</code> 类的消息循环中传递过来的消息。这个 <code>Handler</code> 是在 <code>MyThread</code> 类的 <code>run()</code> 方法中创建并与 <code>Looper</code> 关联，以便在 <code>MyThread</code> 线程中处理消息。</li><li><strong><code>MyThreadManager</code> 类中的 <code>Handler</code>：</strong> 在 <code>MyThreadManager</code> 类中的 <code>Handler</code> 用于将消息发送到 <code>MyThread</code> 线程。它负责将来自主线程或其他地方的消息发送给 <code>MyThread</code> 线程的消息循环。这个 <code>Handler</code> 负责与 <code>MyThread</code> 线程进行通信，从而实现了在主线程或其他线程中触发 <code>MyThread</code> 线程执行特定任务。</li></ol><p>  这里我们提到了消息循环，我们下一章说 MessageQueue</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Game Project 核心 Renderer.cpp</title>
      <link href="/2023/08/23/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01%20%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/01%20Android%20GameProject%20%E4%B8%AD%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%20Renderer/"/>
      <url>/2023/08/23/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01%20%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/01%20Android%20GameProject%20%E4%B8%AD%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%20Renderer/</url>
      
        <content type="html"><![CDATA[<h3 id="Renderer-类图组成："><a href="#Renderer-类图组成：" class="headerlink" title="Renderer 类图组成："></a>Renderer 类图组成：</h3><ul><li><p><strong>类名</strong>：Renderer</p></li><li><p><strong>属性</strong></p><ul><li><strong>EGLDisplay display_</strong>: 用于OpenGL ES渲染的显示设备。它是一个与本地显示系统相关联的EGL显示连接。</li><li><strong>EGLSurface surface_</strong>: OpenGL ES渲染的表面。这是一个EGL表面，代表可以渲染OpenGL ES图形的绘图目标。</li><li><strong>EGLContext context_</strong>: OpenGL ES渲染的上下文。它是一个封装了OpenGL ES状态机的EGL渲染上下文。</li><li><strong>int width_</strong>: 渲染表面的宽度，以像素为单位。</li><li><strong>int height_</strong>: 渲染表面的高度，以像素为单位。</li><li><strong>bool shaderNeedsNewProjectionMatrix_</strong>: 一个标志，指示是否需要为着色器生成新的投影矩阵。当渲染表面的大小改变时，这个标志会被设置为<code>true</code>。</li><li><strong>std::unique_ptr<Shader> shader_</Shader></strong>: 指向当前使用的<code>Shader</code>对象的智能指针。<code>Shader</code>对象用于编译、链接和使用顶点和片段着色器。</li><li><strong>std::vector<Model> models_</Model></strong>: 包含所有要渲染的模型的容器。每个<code>Model</code>对象包含顶点数据、索引数据和纹理数据。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><strong>析构函数 <code>~Renderer()</code></strong>: 清理<code>Renderer</code>对象，包括释放EGL资源（如显示设备、渲染表面和上下文）。</li><li><strong>void render()</strong>: 执行渲染循环的一次迭代。这包括更新渲染状态、绘制模型和交换渲染表面的缓冲区。</li><li><strong>void initRenderer()</strong>: 初始化渲染器，包括设置EGL上下文、选择EGL配置、创建渲染表面和上下文、初始化OpenGL ES状态和加载着色器。</li><li><strong>void updateRenderArea()</strong>: 更新渲染区域的大小。如果渲染表面的大小发生变化，此方法更新<code>width_</code>和<code>height_</code>属性，并标记需要为着色器生成新的投影矩阵。</li><li><strong>void createModels()</strong>: 创建演示模型。这个方法加载模型的顶点、索引和纹理数据，然后将模型添加到<code>models_</code>容器中。</li><li><strong>void handleInput()</strong>: 处理输入事件，如触摸和按键。这个方法从Android的输入事件队列中读取事件，并根据需要响应这些事件。</li></ul></li><li><p><strong>关联和依赖关系</strong>：</p><ul><li>依赖于<code>Shader</code>类：由于<code>shader_</code>属性和在<code>initRenderer()</code>方法中对<code>Shader</code>的调用。</li><li>依赖于<code>Vertex</code>和<code>Index</code>类型：在<code>createModels()</code>方法中使用这些类型来创建模型。</li><li>依赖于<code>TextureAsset</code>类：在<code>createModels()</code>方法中加载纹理资源。</li><li>使用了标准库中的类型，如<code>std::vector</code>、<code>std::unique_ptr</code>。</li></ul></li></ul><p>这个类图还可以展示<code>Renderer</code>类如何与Android的本地应用粘合层（native_app_glue）和OpenGL ES 3.0交互，特别是如何处理EGL上下文、表面创建和渲染循环。</p><p>下面是一个简化的类图表示，重点在于<code>Renderer</code>类及其直接关系：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Renderer</span>] --|&gt; [EGLDisplay]</span><br><span class="line">[<span class="meta">Renderer</span>] --|&gt; [EGLSurface]</span><br><span class="line">[<span class="meta">Renderer</span>] --|&gt; [EGLContext]</span><br><span class="line">[<span class="meta">Renderer</span>] ---&gt; [Shader]</span><br><span class="line">[<span class="meta">Renderer</span>] --* [Model]</span><br><span class="line">[<span class="meta">Model</span>] --* [Vertex]</span><br><span class="line">[<span class="meta">Model</span>] --* [Index]</span><br><span class="line">[<span class="meta">Model</span>] ---&gt; [TextureAsset]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>--|&gt;</code> 表示拥有或创建关系。</li><li><code>---&gt;</code> 表示依赖关系。</li><li><code>--*</code> 表示包含或集合关系。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;game-activity/native_app_glue/android_native_app_glue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLES3/gl3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/imagedecoder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AndroidOut.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Utility.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TextureAsset.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义，执行glGetString并将结果输出到logcat</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_GL_STRING(s) &#123;aout &lt;&lt; #s<span class="string">&quot;: &quot;</span>&lt;&lt; glGetString(s) &lt;&lt; std::endl;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义，如果glGetString返回一个空格分隔的列表，则将每个元素打印在新行上</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief if glGetString returns a space separated list of elements, prints each one on a new line</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This works by creating an istringstream of the input c-style string. Then that is used to create</span></span><br><span class="line"><span class="comment"> * a vector -- each element of the vector is a new element in the input string. Finally a foreach</span></span><br><span class="line"><span class="comment"> * loop consumes this and outputs it to logcat using @a aout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_GL_STRING_AS_LIST(s) &#123; \</span></span><br><span class="line"><span class="meta">std::istringstream extensionStream((const char *) glGetString(s));\</span></span><br><span class="line"><span class="meta">std::vector<span class="string">&lt;std::string&gt;</span> extensionList(\</span></span><br><span class="line"><span class="meta">        std::istream_iterator<span class="string">&lt;std::string&gt;</span>&#123;extensionStream&#125;,\</span></span><br><span class="line"><span class="meta">        std::istream_iterator<span class="string">&lt;std::string&gt;</span>());\</span></span><br><span class="line"><span class="meta">aout &lt;&lt; #s<span class="string">&quot;:\n&quot;</span>;\</span></span><br><span class="line"><span class="meta">for (auto&amp; extension: extensionList) &#123;\</span></span><br><span class="line"><span class="meta">    aout &lt;&lt; extension &lt;&lt; <span class="string">&quot;\n&quot;</span>;\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">aout &lt;&lt; std::endl;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一种颜色，玉米花蓝色。可以直接发送给glClearColor函数。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORNFLOWER_BLUE 100 / 255.f, 149 / 255.f, 237 / 255.f, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器和片段着色器的代码，通常这些会从资源文件中加载</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *vertex = <span class="string">R&quot;vertex(#version 300 es</span></span><br><span class="line"><span class="string">in vec3 inPosition;</span></span><br><span class="line"><span class="string">in vec2 inUV;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec2 fragUV;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform mat4 uProjection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">    fragUV = inUV;</span></span><br><span class="line"><span class="string">    gl_Position = uProjection * vec4(inPosition, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)vertex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *fragment = <span class="string">R&quot;fragment(#version 300 es</span></span><br><span class="line"><span class="string">precision mediump float;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">in vec2 fragUV;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform sampler2D uTexture;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec4 outColor;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">    outColor = texture(uTexture, fragUV);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)fragment&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 投影矩阵的半高度，这将给你一个从-2到2的高度为4的可渲染区域</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> kProjectionHalfHeight = <span class="number">2.f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 投影矩阵的近平面距离。由于这是一个正交投影矩阵，负值便于排序（避免在0处的z-fighting）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> kProjectionNearPlane = <span class="number">-1.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 投影矩阵的远平面距离。与近平面等距的设置便于处理。</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * The far plane distance for the projection matrix. Since this is an orthographic porjection</span></span><br><span class="line"><span class="comment"> * matrix, it&#x27;s convenient to have the far plane equidistant from 0 as the near plane.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> kProjectionFarPlane = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Renderer析构函数，处理EGL上下文的清理工作。</span></span><br><span class="line">Renderer::~<span class="built_in">Renderer</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (display_ != EGL_NO_DISPLAY) &#123;</span><br><span class="line">        <span class="built_in">eglMakeCurrent</span>(display_, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</span><br><span class="line">        <span class="keyword">if</span> (context_ != EGL_NO_CONTEXT) &#123;</span><br><span class="line">            <span class="built_in">eglDestroyContext</span>(display_, context_);</span><br><span class="line">            context_ = EGL_NO_CONTEXT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (surface_ != EGL_NO_SURFACE) &#123;</span><br><span class="line">            <span class="built_in">eglDestroySurface</span>(display_, surface_);</span><br><span class="line">            surface_ = EGL_NO_SURFACE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">eglTerminate</span>(display_);</span><br><span class="line">        display_ = EGL_NO_DISPLAY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数，包括渲染过程中的各种状态更新和绘制调用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if the surface has changed size. This is _necessary_ to do every frame when</span></span><br><span class="line">    <span class="comment">// using immersive mode as you&#x27;ll get no other notification that your renderable area has</span></span><br><span class="line">    <span class="comment">// changed.</span></span><br><span class="line">    <span class="built_in">updateRenderArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the renderable area changes, the projection matrix has to also be updated. This is true</span></span><br><span class="line">    <span class="comment">// even if you change from the sample orthographic projection matrix as your aspect ratio has</span></span><br><span class="line">    <span class="comment">// likely changed.</span></span><br><span class="line">    <span class="keyword">if</span> (shaderNeedsNewProjectionMatrix_) &#123;</span><br><span class="line">        <span class="comment">// a placeholder projection matrix allocated on the stack. Column-major memory layout</span></span><br><span class="line">        <span class="type">float</span> projectionMatrix[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build an orthographic projection matrix for 2d rendering</span></span><br><span class="line">        Utility::<span class="built_in">buildOrthographicMatrix</span>(</span><br><span class="line">                projectionMatrix,</span><br><span class="line">                kProjectionHalfHeight,</span><br><span class="line">                <span class="built_in">float</span>(width_) / height_,</span><br><span class="line">                kProjectionNearPlane,</span><br><span class="line">                kProjectionFarPlane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send the matrix to the shader</span></span><br><span class="line">        <span class="comment">// Note: the shader must be active for this to work. Since we only have one shader for this</span></span><br><span class="line">        <span class="comment">// demo, we can assume that it&#x27;s active.</span></span><br><span class="line">        shader_-&gt;<span class="built_in">setProjectionMatrix</span>(projectionMatrix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make sure the matrix isn&#x27;t generated every frame</span></span><br><span class="line">        shaderNeedsNewProjectionMatrix_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the color buffer</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render all the models. There&#x27;s no depth testing in this sample so they&#x27;re accepted in the</span></span><br><span class="line">    <span class="comment">// order provided. But the sample EGL setup requests a 24 bit depth buffer so you could</span></span><br><span class="line">    <span class="comment">// configure it at the end of initRenderer</span></span><br><span class="line">    <span class="keyword">if</span> (!models_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;model: models_) &#123;</span><br><span class="line">            shader_-&gt;<span class="built_in">drawModel</span>(model);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Present the rendered image. This is an implicit glFlush.</span></span><br><span class="line">    <span class="keyword">auto</span> swapResult = <span class="built_in">eglSwapBuffers</span>(display_, surface_);</span><br><span class="line">    <span class="built_in">assert</span>(swapResult == EGL_TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器，设置EGL上下文和OpenGL状态。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::initRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Choose your render attributes</span></span><br><span class="line">    <span class="keyword">constexpr</span></span><br><span class="line">    EGLint attribs[] = &#123;</span><br><span class="line">            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,</span><br><span class="line">            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,</span><br><span class="line">            EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_DEPTH_SIZE, <span class="number">24</span>,</span><br><span class="line">            EGL_NONE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The default display is probably what you want on Android</span></span><br><span class="line">    <span class="keyword">auto</span> display = <span class="built_in">eglGetDisplay</span>(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="built_in">eglInitialize</span>(display, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out how many configs there are</span></span><br><span class="line">    EGLint numConfigs;</span><br><span class="line">    <span class="built_in">eglChooseConfig</span>(display, attribs, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;numConfigs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the list of configurations</span></span><br><span class="line">    std::unique_ptr &lt; EGLConfig[] &gt; <span class="built_in">supportedConfigs</span>(<span class="keyword">new</span> EGLConfig[numConfigs]);</span><br><span class="line">    <span class="built_in">eglChooseConfig</span>(display, attribs, supportedConfigs.<span class="built_in">get</span>(), numConfigs, &amp;numConfigs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a config we like.</span></span><br><span class="line">    <span class="comment">// Could likely just grab the first if we don&#x27;t care about anything else in the config.</span></span><br><span class="line">    <span class="comment">// Otherwise hook in your own heuristic</span></span><br><span class="line">    <span class="keyword">auto</span> config = *std::<span class="built_in">find_if</span>(</span><br><span class="line">            supportedConfigs.<span class="built_in">get</span>(),</span><br><span class="line">            supportedConfigs.<span class="built_in">get</span>() + numConfigs,</span><br><span class="line">            [&amp;display](<span class="type">const</span> EGLConfig &amp;config) &#123;</span><br><span class="line">                EGLint red, green, blue, depth;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_RED_SIZE, &amp;red)</span><br><span class="line">                    &amp;&amp; <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_GREEN_SIZE, &amp;green)</span><br><span class="line">                    &amp;&amp; <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_BLUE_SIZE, &amp;blue)</span><br><span class="line">                    &amp;&amp; <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_DEPTH_SIZE, &amp;depth)) &#123;</span><br><span class="line"></span><br><span class="line">                    aout &lt;&lt; <span class="string">&quot;Found config with &quot;</span> &lt;&lt; red &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; blue &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                         &lt;&lt; depth &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">return</span> red == <span class="number">8</span> &amp;&amp; green == <span class="number">8</span> &amp;&amp; blue == <span class="number">8</span> &amp;&amp; depth == <span class="number">24</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    aout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; numConfigs &lt;&lt; <span class="string">&quot; configs&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    aout &lt;&lt; <span class="string">&quot;Chose &quot;</span> &lt;&lt; config &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the proper window surface</span></span><br><span class="line">    EGLint format;</span><br><span class="line">    <span class="built_in">eglGetConfigAttrib</span>(display, config, EGL_NATIVE_VISUAL_ID, &amp;format);</span><br><span class="line">    EGLSurface surface = <span class="built_in">eglCreateWindowSurface</span>(display, config, app_-&gt;window, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a GLES 3 context</span></span><br><span class="line">    EGLint contextAttribs[] = &#123;EGL_CONTEXT_CLIENT_VERSION, <span class="number">3</span>, EGL_NONE&#125;;</span><br><span class="line">    EGLContext context = <span class="built_in">eglCreateContext</span>(display, config, <span class="literal">nullptr</span>, contextAttribs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get some window metrics</span></span><br><span class="line">    <span class="keyword">auto</span> madeCurrent = <span class="built_in">eglMakeCurrent</span>(display, surface, surface, context);</span><br><span class="line">    <span class="built_in">assert</span>(madeCurrent);</span><br><span class="line"></span><br><span class="line">    display_ = display;</span><br><span class="line">    surface_ = surface;</span><br><span class="line">    context_ = context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make width and height invalid so it gets updated the first frame in @a updateRenderArea()</span></span><br><span class="line">    width_ = <span class="number">-1</span>;</span><br><span class="line">    height_ = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PRINT_GL_STRING</span>(GL_VENDOR);</span><br><span class="line">    <span class="built_in">PRINT_GL_STRING</span>(GL_RENDERER);</span><br><span class="line">    <span class="built_in">PRINT_GL_STRING</span>(GL_VERSION);</span><br><span class="line">    <span class="built_in">PRINT_GL_STRING_AS_LIST</span>(GL_EXTENSIONS);</span><br><span class="line"></span><br><span class="line">    shader_ = std::<span class="built_in">unique_ptr</span>&lt;Shader&gt;(</span><br><span class="line">            Shader::<span class="built_in">loadShader</span>(vertex, fragment, <span class="string">&quot;inPosition&quot;</span>, <span class="string">&quot;inUV&quot;</span>, <span class="string">&quot;uProjection&quot;</span>));</span><br><span class="line">    <span class="built_in">assert</span>(shader_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: there&#x27;s only one shader in this demo, so I&#x27;ll activate it here. For a more complex game</span></span><br><span class="line">    <span class="comment">// you&#x27;ll want to track the active shader and activate/deactivate it as necessary</span></span><br><span class="line">    shader_-&gt;<span class="built_in">activate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup any other gl related global states</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(CORNFLOWER_BLUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enable alpha globally for now, you probably don&#x27;t want to do this in a game</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get some demo models into memory</span></span><br><span class="line">    <span class="built_in">createModels</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新渲染区域的大小，如果有变化，则更新视口和投影矩阵。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::updateRenderArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EGLint width;</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display_, surface_, EGL_WIDTH, &amp;width);</span><br><span class="line"></span><br><span class="line">    EGLint height;</span><br><span class="line">    <span class="built_in">eglQuerySurface</span>(display_, surface_, EGL_HEIGHT, &amp;height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (width != width_ || height != height_) &#123;</span><br><span class="line">        width_ = width;</span><br><span class="line">        height_ = height;</span><br><span class="line">        <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make sure that we lazily recreate the projection matrix before we render</span></span><br><span class="line">        shaderNeedsNewProjectionMatrix_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建演示模型的函数。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Create any demo models we want for this demo.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::createModels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a square:</span></span><br><span class="line"><span class="comment">     * 0 --- 1</span></span><br><span class="line"><span class="comment">     * | \   |</span></span><br><span class="line"><span class="comment">     * |  \  |</span></span><br><span class="line"><span class="comment">     * |   \ |</span></span><br><span class="line"><span class="comment">     * 3 --- 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::vector &lt;Vertex&gt; vertices = &#123;</span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;), <span class="comment">// 0</span></span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">1</span>, <span class="number">0</span>&#125;), <span class="comment">// 1</span></span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">1</span>, <span class="number">1</span>&#125;), <span class="comment">// 2</span></span><br><span class="line">            <span class="built_in">Vertex</span>(Vector3&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, Vector2&#123;<span class="number">0</span>, <span class="number">1</span>&#125;) <span class="comment">// 3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector &lt;Index&gt; indices = &#123;</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loads an image and assigns it to the square.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note: there is no texture management in this sample, so if you reuse an image be careful not</span></span><br><span class="line">    <span class="comment">// to load it repeatedly. Since you get a shared_ptr you can safely reuse it in many models.</span></span><br><span class="line">    <span class="keyword">auto</span> assetManager = app_-&gt;activity-&gt;assetManager;</span><br><span class="line">    <span class="keyword">auto</span> spAndroidRobotTexture = TextureAsset::<span class="built_in">loadAsset</span>(assetManager, <span class="string">&quot;android_robot.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a model and put it in the back of the render list.</span></span><br><span class="line">    models_.<span class="built_in">emplace_back</span>(vertices, indices, spAndroidRobotTexture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理输入事件的函数，如触摸和按键事件。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::handleInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// handle all queued inputs</span></span><br><span class="line">    <span class="keyword">auto</span> *inputBuffer = <span class="built_in">android_app_swap_input_buffers</span>(app_);</span><br><span class="line">    <span class="keyword">if</span> (!inputBuffer) &#123;</span><br><span class="line">        <span class="comment">// no inputs yet.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle motion events (motionEventsCounts can be 0).</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; inputBuffer-&gt;motionEventsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;motionEvent = inputBuffer-&gt;motionEvents[i];</span><br><span class="line">        <span class="keyword">auto</span> action = motionEvent.action;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the pointer index, mask and bitshift to turn it into a readable value.</span></span><br><span class="line">        <span class="keyword">auto</span> pointerIndex = (action &amp; AMOTION_EVENT_ACTION_POINTER_INDEX_MASK)</span><br><span class="line">                &gt;&gt; AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;</span><br><span class="line">        aout &lt;&lt; <span class="string">&quot;Pointer(s): &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the x and y position of this event if it is not ACTION_MOVE.</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;pointer = motionEvent.pointers[pointerIndex];</span><br><span class="line">        <span class="keyword">auto</span> x = <span class="built_in">GameActivityPointerAxes_getX</span>(&amp;pointer);</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">GameActivityPointerAxes_getY</span>(&amp;pointer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// determine the action type and process the event accordingly.</span></span><br><span class="line">        <span class="keyword">switch</span> (action &amp; AMOTION_EVENT_ACTION_MASK) &#123;</span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_DOWN:</span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_POINTER_DOWN:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pointer.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;) &quot;</span></span><br><span class="line">                     &lt;&lt; <span class="string">&quot;Pointer Down&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_CANCEL:</span><br><span class="line">                <span class="comment">// treat the CANCEL as an UP event: doing nothing in the app, except</span></span><br><span class="line">                <span class="comment">// removing the pointer from the cache if pointers are locally saved.</span></span><br><span class="line">                <span class="comment">// code pass through on purpose.</span></span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_POINTER_UP:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pointer.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;) &quot;</span></span><br><span class="line">                     &lt;&lt; <span class="string">&quot;Pointer Up&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> AMOTION_EVENT_ACTION_MOVE:</span><br><span class="line">                <span class="comment">// There is no pointer index for ACTION_MOVE, only a snapshot of</span></span><br><span class="line">                <span class="comment">// all active pointers; app needs to cache previous active pointers</span></span><br><span class="line">                <span class="comment">// to figure out which ones are actually moved.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> index = <span class="number">0</span>; index &lt; motionEvent.pointerCount; index++) &#123;</span><br><span class="line">                    pointer = motionEvent.pointers[index];</span><br><span class="line">                    x = <span class="built_in">GameActivityPointerAxes_getX</span>(&amp;pointer);</span><br><span class="line">                    y = <span class="built_in">GameActivityPointerAxes_getY</span>(&amp;pointer);</span><br><span class="line">                    aout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pointer.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (index != (motionEvent.pointerCount - <span class="number">1</span>)) aout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                    aout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Pointer Move&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Unknown MotionEvent Action: &quot;</span> &lt;&lt; action;</span><br><span class="line">        &#125;</span><br><span class="line">        aout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear the motion input count in this buffer for main thread to re-use.</span></span><br><span class="line">    <span class="built_in">android_app_clear_motion_events</span>(inputBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle input key events.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; inputBuffer-&gt;keyEventsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;keyEvent = inputBuffer-&gt;keyEvents[i];</span><br><span class="line">        aout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; keyEvent.keyCode &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (keyEvent.action) &#123;</span><br><span class="line">            <span class="keyword">case</span> AKEY_EVENT_ACTION_DOWN:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Key Down&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AKEY_EVENT_ACTION_UP:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Key Up&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AKEY_EVENT_ACTION_MULTIPLE:</span><br><span class="line">                <span class="comment">// Deprecated since Android API level 29.</span></span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Multiple Key Actions&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                aout &lt;&lt; <span class="string">&quot;Unknown KeyEvent Action: &quot;</span> &lt;&lt; keyEvent.action;</span><br><span class="line">        &#125;</span><br><span class="line">        aout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear the key input count too.</span></span><br><span class="line">    <span class="built_in">android_app_clear_key_events</span>(inputBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8 - 渲染引擎 </category>
          
          <category> 8.1 - 基础项目拆解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Game Project 项目结构</title>
      <link href="/2023/08/23/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01%20%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/02%20Android%20GameProject%20%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/08/23/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01%20%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/02%20Android%20GameProject%20%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>author: 朕小猫-GPT4</strong></p><p>图片显示的是一个典型的Android项目目录结构，这个项目中集成了C++原生代码。以下是各个组件的结构和作用的简述：</p><ul><li><code>src</code><ul><li><code>main</code><ul><li><code>assets</code><ul><li><code>android_robot.png</code> 一个图像资产，可能用于应用的用户界面或游戏图形。</li></ul></li><li><code>cpp</code><ul><li><code>AndroidOut.cpp</code> 和 <code>AndroidOut.h</code>：C++源文件和头文件，可能用于原生代码中的日志或输出目的。</li><li><code>CMakeLists.txt</code>：CMake配置文件，CMake是用于管理原生代码编译的构建系统。</li><li><code>main.cpp</code>：主要的C++源文件，可能包含原生代码执行的入口点。</li><li><code>Model.h</code>：很可能定义了一个数据模型或对象的头文件。</li><li><code>Renderer.cpp</code> 和 <code>Renderer.h</code>：渲染相关的源文件和头文件，或许处理屏幕上图形的绘制。</li><li><code>Shader.cpp</code> 和 <code>Shader.h</code>：与着色器程序相关的源文件和头文件，用于高级图形效果。</li><li><code>TextureAsset.cpp</code> 和 <code>TextureAsset.h</code>：处理原生代码中纹理资产的源文件和头文件。</li><li><code>Utility.cpp</code> 和 <code>Utility.h</code>：在原生代码库中使用的工具函数或类的源文件和头文件。</li></ul></li><li><code>java</code><ul><li><code>com.jason.game</code><ul><li><code>MainActivity</code></li></ul></li></ul></li><li><code>res</code>：<ul><li><code>AndroidManifest.xml</code></li></ul></li></ul></li></ul></li><li><code>.gitignore</code>：Git的配置文件，指定在版本控制中忽略哪些文件或目录。</li><li><code>build.gradle.kts</code>：用Kotlin脚本编写的Gradle构建系统的构建配置文件，指定依赖和构建设置。</li><li><code>proguard-rules.pro</code>：ProGuard的配置文件，ProGuard是一个用于代码缩减和混淆的工具，以防止应用发布构建的反向工程。</li></ul><p>这个结构表明这是一个复杂的Android项目，它使用Java&#x2F;Kotlin来实现Android特定功能，并使用C++来处理性能密集型任务，可能用于游戏开发或计算密集型应用。 </p>]]></content>
      
      
      <categories>
          
          <category> 8 - 渲染引擎 </category>
          
          <category> 8.1 - 基础项目拆解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Bitmap 性能专题 - Bitmap 内存从申请到回收</title>
      <link href="/2023/08/15/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/"/>
      <url>/2023/08/15/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure><p>Q：Bitmap 如何开辟内存？</p><p>Q：Bitmap 内存是怎么复用和销毁的？本地资源图片应该怎么去做适配？</p><p>Q：该如何去优化这些占用较大内存的本地资源图片？</p><p>Q：如何判断和优化 Bitmap OOM，如何 dump 线上内存来做优化分析？</p><h3 id="从-Bitmap-的创建说起"><a href="#从-Bitmap-的创建说起" class="headerlink" title="从 Bitmap 的创建说起"></a>从 Bitmap 的创建说起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private constructor that must received an already allocated native bitmap</span></span><br><span class="line"><span class="comment"> * int (pointer).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">        <span class="type">boolean</span> isMutable, <span class="type">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="type">byte</span>[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;internal error: native bitmap is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mIsMutable = isMutable;</span><br><span class="line">    mRequestPremultiplied = requestPremultiplied;</span><br><span class="line"></span><br><span class="line">    mNinePatchChunk = ninePatchChunk;</span><br><span class="line">    mNinePatchInsets = ninePatchInsets;</span><br><span class="line">    <span class="keyword">if</span> (density &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mDensity = density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line">    <span class="type">NativeAllocationRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(</span><br><span class="line">        Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ResourcesImpl.TRACE_FOR_DETAILED_PRELOAD) &#123;</span><br><span class="line">        sPreloadTracingNumInstantiatedBitmaps++;</span><br><span class="line">        sPreloadTracingTotalBitmapsSize += nativeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>called from JNI 这个解释其实已经很明确了，也就是说这个对象是 Native 层构建返回的。因此我们跟踪到 BitmapFactory.decodeResource() 中去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">decodeResource</span><span class="params">(Resources res, <span class="type">int</span> id, Options opts)</span> &#123;</span><br><span class="line">    validate(opts);</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypedValue</span>();</span><br><span class="line">        is = res.openRawResource(id, value);</span><br><span class="line"></span><br><span class="line">        bm = decodeResourceStream(res, value, is, <span class="literal">null</span>, opts);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">/*  do nothing.</span></span><br><span class="line"><span class="comment">            If the exception happened on open, bm will be null.</span></span><br><span class="line"><span class="comment">            If it happened on close, bm is still valid.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bm == <span class="literal">null</span> &amp;&amp; opts != <span class="literal">null</span> &amp;&amp; opts.inBitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Problem decoding into existing bitmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">decodeResourceStream</span><span class="params">(<span class="meta">@Nullable</span> Resources res, <span class="meta">@Nullable</span> TypedValue value,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> InputStream is, <span class="meta">@Nullable</span> Rect pad, <span class="meta">@Nullable</span> Options opts)</span> &#123;</span><br><span class="line">    validate(opts);</span><br><span class="line">    <span class="keyword">if</span> (opts == <span class="literal">null</span>) &#123;</span><br><span class="line">        opts = <span class="keyword">new</span> <span class="title class_">Options</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">density</span> <span class="operator">=</span> value.density;</span><br><span class="line">        <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">            opts.inDensity = density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前手机设备的 dpi </span></span><br><span class="line">    <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="literal">null</span>) &#123;</span><br><span class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略部分跟踪代码 ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title function_">nativeDecodeStream</span><span class="params">(InputStream is, <span class="type">byte</span>[] storage,</span></span><br><span class="line"><span class="params">        Rect padding, Options opts)</span>;</span><br></pre></td></tr></table></figure><p>最终调用的是 native 方法 nativeDecodeStream</p><p>这里以 Android N 版本为例:</p><p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;BitmapFactory.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">nativeDecodeStream</span><span class="params">(JNIEnv *env, jobject clazz, jobject is, jbyteArray storage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line">    jobject bitmap = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SkStream&gt; <span class="title">stream</span><span class="params">(CreateJavaInputStreamAdaptor(env, is, storage))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;SkStreamRewindable&gt; <span class="title">bufferedStream</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                SkFrontBufferedStream::Create(stream.release(), SkCodec::MinBufferedBytesNeeded()))</span></span>;</span><br><span class="line">        <span class="built_in">SkASSERT</span>(bufferedStream.<span class="built_in">get</span>() != <span class="literal">NULL</span>);</span><br><span class="line">        bitmap = <span class="built_in">doDecode</span>(env, bufferedStream.<span class="built_in">release</span>(), padding, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv *env, SkStreamRewindable *stream, jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function takes ownership of the input stream.  Since the SkAndroidCodec</span></span><br><span class="line">    <span class="comment">// will take ownership of the stream, we don&#x27;t necessarily need to take ownership</span></span><br><span class="line">    <span class="comment">// here.  This is a precaution - if we were to return before creating the codec,</span></span><br><span class="line">    <span class="comment">// we need to make sure that we delete the stream.</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;SkStreamRewindable&gt; <span class="title">streamDeleter</span><span class="params">(stream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set default values for the options parameters.</span></span><br><span class="line">    <span class="type">int</span> sampleSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否只是获取图片的大小</span></span><br><span class="line">    <span class="type">bool</span> onlyDecodeSize = <span class="literal">false</span>;</span><br><span class="line">    SkColorType prefColorType = kN32_SkColorType;</span><br><span class="line">    <span class="type">bool</span> isMutable = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> scale = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">bool</span> requireUnpremultiplied = <span class="literal">false</span>;</span><br><span class="line">    jobject javaBitmap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update with options supplied by the client.</span></span><br><span class="line">    <span class="comment">// 解析 options 参数</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sampleSize = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_sampleSizeFieldID);</span><br><span class="line">        <span class="comment">// Correct a non-positive sampleSize.  sampleSize defaults to zero within the</span></span><br><span class="line">        <span class="comment">// options object, which is strange.</span></span><br><span class="line">        <span class="keyword">if</span> (sampleSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sampleSize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_justBoundsFieldID)) &#123;</span><br><span class="line">            onlyDecodeSize = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize these, in case we fail later on</span></span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_widthFieldID, <span class="number">-1</span>);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_heightFieldID, <span class="number">-1</span>);</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectField</span>(options, gOptions_mimeFieldID, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 解析 ColorType ，复用参数等等</span></span><br><span class="line">        jobject jconfig = env-&gt;<span class="built_in">GetObjectField</span>(options, gOptions_configFieldID);</span><br><span class="line">        prefColorType = GraphicsJNI::<span class="built_in">getNativeBitmapColorType</span>(env, jconfig);</span><br><span class="line">        isMutable = env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_mutableFieldID);</span><br><span class="line">        requireUnpremultiplied = !env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_premultipliedFieldID);</span><br><span class="line">        javaBitmap = env-&gt;<span class="built_in">GetObjectField</span>(options, gOptions_bitmapFieldID);</span><br><span class="line">        <span class="comment">// 计算缩放的比例</span></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">            <span class="comment">// 获取图片当前 xhdpi 的 density</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> density = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_densityFieldID);</span><br><span class="line">            <span class="comment">// 获取当前设备的 dpi</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> targetDensity = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_targetDensityFieldID);</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> screenDensity = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_screenDensityFieldID);</span><br><span class="line">            <span class="keyword">if</span> (density != <span class="number">0</span> &amp;&amp; targetDensity != <span class="number">0</span> &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">                <span class="comment">// scale = 当前设备的 dpi / xhdpi 的 density</span></span><br><span class="line">                <span class="comment">// scale = 420/320 = 1.3125</span></span><br><span class="line">                scale = (<span class="type">float</span>) targetDensity / density;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the codec.</span></span><br><span class="line">    NinePatchPeeker peeker;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;SkAndroidCodec&gt; <span class="title">codec</span><span class="params">(SkAndroidCodec::NewFromStream(streamDeleter.release(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                        <span class="number">280</span> &amp; peeker))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!codec.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;SkAndroidCodec::NewFromStream returned null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not allow ninepatch decodes to 565.  In the past, decodes to 565</span></span><br><span class="line">    <span class="comment">// would dither, and we do not want to pre-dither ninepatches, since we</span></span><br><span class="line">    <span class="comment">// know that they will be stretched.  We no longer dither 565 decodes,</span></span><br><span class="line">    <span class="comment">// but we continue to prevent ninepatches from decoding to 565, in order</span></span><br><span class="line">    <span class="comment">// to maintain the old behavior.</span></span><br><span class="line">    <span class="keyword">if</span> (peeker.mPatch &amp;&amp; kRGB_565_SkColorType == prefColorType) &#123;</span><br><span class="line">        prefColorType = kN32_SkColorType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前图片的大小</span></span><br><span class="line">    <span class="comment">// Determine the output size.</span></span><br><span class="line">    SkISize size = codec-&gt;<span class="built_in">getSampledDimensions</span>(sampleSize);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> scaledWidth = size.<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">int</span> scaledHeight = size.<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">bool</span> willScale = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 处理 simpleSize 压缩，我们这里没穿，上面默认是 1 </span></span><br><span class="line">    <span class="comment">// Apply a fine scaling step if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">needsFineScale</span>(codec-&gt;<span class="built_in">getInfo</span>().<span class="built_in">dimensions</span>(), size, sampleSize)) &#123;</span><br><span class="line">        willScale = <span class="literal">true</span>;</span><br><span class="line">        scaledWidth = codec-&gt;<span class="built_in">getInfo</span>().<span class="built_in">width</span>() / sampleSize;</span><br><span class="line">        scaledHeight = codec-&gt;<span class="built_in">getInfo</span>().<span class="built_in">height</span>() / sampleSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the options and return if the client only wants the size.</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jstring mimeType = <span class="built_in">encodedFormatToString</span>(env, codec-&gt;<span class="built_in">getEncodedFormat</span>());</span><br><span class="line">        <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;OOM in encodedFormatToString()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 options 对象中的 outWidth 和 outHeight</span></span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_widthFieldID, scaledWidth);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(options, gOptions_heightFieldID, scaledHeight);</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectField</span>(options, gOptions_mimeFieldID, mimeType);</span><br><span class="line">        <span class="comment">// 如果只是获取大小直接 return null 这里是 nullptr 而不是 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (onlyDecodeSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale is necessary due to density differences.</span></span><br><span class="line">    <span class="keyword">if</span> (scale != <span class="number">1.0f</span>) &#123;</span><br><span class="line">        willScale = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 计算 scaledWidth 和 scaledHeight</span></span><br><span class="line">        <span class="comment">// scaledWidth = 864 * 1.3125 + 0.5f = 1134 + 0.5f = 1134</span></span><br><span class="line">        scaledWidth = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(scaledWidth * scale + <span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">// scaledHeight = 582 * 1.3125 + 0.5f = 763.875 + 0.5f = 764</span></span><br><span class="line">        scaledHeight = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(scaledHeight * scale + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有复用的 Bitmap</span></span><br><span class="line">    android::Bitmap *reuseBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> existingBufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reuseBitmap = GraphicsJNI::<span class="built_in">getBitmap</span>(env, javaBitmap);</span><br><span class="line">        <span class="keyword">if</span> (reuseBitmap-&gt;<span class="built_in">peekAtPixelRef</span>()-&gt;<span class="built_in">isImmutable</span>()) &#123;</span><br><span class="line">            <span class="comment">// 无法重用一个不变的位图图像解码器的目标。</span></span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Unable to reuse an immutable bitmap as an image decoder target.&quot;</span>);</span><br><span class="line">            javaBitmap = <span class="literal">NULL</span>;</span><br><span class="line">            reuseBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            existingBufferSize = GraphicsJNI::<span class="built_in">getBitmapAllocationByteCount</span>(env, javaBitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">JavaPixelAllocator <span class="title">javaAllocator</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="function">RecyclingPixelAllocator <span class="title">recyclingAllocator</span><span class="params">(reuseBitmap, existingBufferSize)</span></span>;</span><br><span class="line">    <span class="function">ScaleCheckingAllocator <span class="title">scaleCheckingAllocator</span><span class="params">(scale, existingBufferSize)</span></span>;</span><br><span class="line">    SkBitmap::HeapAllocator heapAllocator;</span><br><span class="line">    SkBitmap::Allocator *decodeAllocator;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span> &amp;&amp; willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.  This allocator</span></span><br><span class="line">        <span class="comment">// also checks that the recycled javaBitmap is large enough.</span></span><br><span class="line">        decodeAllocator = &amp;scaleCheckingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        decodeAllocator = &amp;recyclingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.</span></span><br><span class="line">        decodeAllocator = &amp;heapAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeAllocator = &amp;javaAllocator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the decode colorType.  This is necessary because we can&#x27;t always support</span></span><br><span class="line">    <span class="comment">// the requested colorType.</span></span><br><span class="line">    SkColorType decodeColorType = codec-&gt;<span class="built_in">computeOutputColorType</span>(prefColorType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a color table for the decode if necessary</span></span><br><span class="line">    SkAutoTUnref &lt;SkColorTable&gt; <span class="built_in">colorTable</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    SkPMColor *colorPtr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> *colorCount = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> maxColors = <span class="number">256</span>;</span><br><span class="line">    SkPMColor colors[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">if</span> (kIndex_8_SkColorType == decodeColorType) &#123;</span><br><span class="line">        colorTable.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SkColorTable</span>(colors, maxColors));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SkColorTable expects us to initialize all of the colors before creating an</span></span><br><span class="line">        <span class="comment">// SkColorTable.  However, we are using SkBitmap with an Allocator to allocate</span></span><br><span class="line">        <span class="comment">// memory for the decode, so we need to create the SkColorTable before decoding.</span></span><br><span class="line">        <span class="comment">// It is safe for SkAndroidCodec to modify the colors because this SkBitmap is</span></span><br><span class="line">        <span class="comment">// not being used elsewhere.</span></span><br><span class="line">        colorPtr = <span class="built_in">const_cast</span>&lt;SkPMColor *&gt;(colorTable-&gt;<span class="built_in">readColors</span>());</span><br><span class="line">        colorCount = &amp;maxColors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the alpha type for the decode.</span></span><br><span class="line">    SkAlphaType alphaType = codec-&gt;<span class="built_in">computeOutputAlphaType</span>(requireUnpremultiplied);</span><br><span class="line">    <span class="comment">// 创建 SkImageInfo 信息，宽，高，ColorType，alphaType</span></span><br><span class="line">    <span class="type">const</span> SkImageInfo decodeInfo = SkImageInfo::<span class="built_in">Make</span>(size.<span class="built_in">width</span>(), size.<span class="built_in">height</span>(), decodeColorType,</span><br><span class="line">                                                     alphaType);</span><br><span class="line">    SkImageInfo bitmapInfo = decodeInfo;</span><br><span class="line">    <span class="keyword">if</span> (decodeColorType == kGray_8_SkColorType) &#123;</span><br><span class="line">        <span class="comment">// The legacy implementation of BitmapFactory used kAlpha8 for</span></span><br><span class="line">        <span class="comment">// grayscale images (before kGray8 existed).  While the codec</span></span><br><span class="line">        <span class="comment">// recognizes kGray8, we need to decode into a kAlpha8 bitmap</span></span><br><span class="line">        <span class="comment">// in order to avoid a behavior change.</span></span><br><span class="line">        bitmapInfo = SkImageInfo::<span class="built_in">MakeA8</span>(size.<span class="built_in">width</span>(), size.<span class="built_in">height</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析 SkBitmap 设置 bitmapInfo，tryAllocPixels 开辟内存，具体分析在后面 </span></span><br><span class="line">    SkBitmap decodingBitmap;</span><br><span class="line">    <span class="keyword">if</span> (!decodingBitmap.<span class="built_in">setInfo</span>(bitmapInfo) ||</span><br><span class="line">        !decodingBitmap.<span class="built_in">tryAllocPixels</span>(decodeAllocator, colorTable)) &#123;</span><br><span class="line">        <span class="comment">// SkAndroidCodec should recommend a valid SkImageInfo, so setInfo()</span></span><br><span class="line">        <span class="comment">// should only only fail if the calculated value for rowBytes is too</span></span><br><span class="line">        <span class="comment">// large.</span></span><br><span class="line">        <span class="comment">// tryAllocPixels() can fail due to OOM on the Java heap, OOM on the</span></span><br><span class="line">        <span class="comment">// native heap, or the recycled javaBitmap being too small to reuse.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SkAndroidCodec to perform the decode.</span></span><br><span class="line">    SkAndroidCodec::AndroidOptions codecOptions;</span><br><span class="line">    codecOptions.fZeroInitialized = (decodeAllocator == &amp;javaAllocator) ?</span><br><span class="line">    SkCodec::kYes_ZeroInitialized : SkCodec::kNo_ZeroInitialized;</span><br><span class="line">    codecOptions.fColorPtr = colorPtr;</span><br><span class="line">    codecOptions.fColorCount = colorCount;</span><br><span class="line">    codecOptions.fSampleSize = sampleSize;</span><br><span class="line">    <span class="comment">// 解析获取像素值</span></span><br><span class="line">    SkCodec::Result result = codec-&gt;<span class="built_in">getAndroidPixels</span>(decodeInfo, decodingBitmap.<span class="built_in">getPixels</span>(),</span><br><span class="line">                                                     decodingBitmap.<span class="built_in">rowBytes</span>(), &amp;codecOptions);</span><br><span class="line">    <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">        <span class="keyword">case</span> SkCodec::kSuccess:</span><br><span class="line">        <span class="keyword">case</span> SkCodec::kIncompleteInput:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;codec-&gt;getAndroidPixels() failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jbyteArray ninePatchChunk = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (peeker.mPatch != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">            <span class="built_in">scaleNinePatchChunk</span>(peeker.mPatch, scale, scaledWidth, scaledHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> ninePatchArraySize = peeker.mPatch-&gt;<span class="built_in">serializedSize</span>();</span><br><span class="line">        ninePatchChunk = env-&gt;<span class="built_in">NewByteArray</span>(ninePatchArraySize);</span><br><span class="line">        <span class="keyword">if</span> (ninePatchChunk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;ninePatchChunk == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jbyte *array = (jbyte *) env-&gt;<span class="built_in">GetPrimitiveArrayCritical</span>(ninePatchChunk, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;primitive array == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(array, peeker.mPatch, peeker.mPatchSize);</span><br><span class="line">        env-&gt;<span class="built_in">ReleasePrimitiveArrayCritical</span>(ninePatchChunk, array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject ninePatchInsets = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (peeker.mHasInsets) &#123;</span><br><span class="line">        ninePatchInsets = env-&gt;<span class="built_in">NewObject</span>(gInsetStruct_class, gInsetStruct_constructorMethodID,</span><br><span class="line">        peeker.mOpticalInsets[<span class="number">0</span>], peeker.mOpticalInsets[<span class="number">1</span>], peeker.mOpticalInsets[<span class="number">2</span>], peeker.mOpticalInsets[<span class="number">3</span>],</span><br><span class="line">                peeker.mOutlineInsets[<span class="number">0</span>], peeker.mOutlineInsets[<span class="number">1</span>], peeker.mOutlineInsets[<span class="number">2</span>], peeker.mOutlineInsets[<span class="number">3</span>],</span><br><span class="line">                peeker.mOutlineRadius, peeker.mOutlineAlpha, scale);</span><br><span class="line">        <span class="keyword">if</span> (ninePatchInsets == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;nine patch insets == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (javaBitmap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            env-&gt;<span class="built_in">SetObjectField</span>(javaBitmap, gBitmap_ninePatchInsetsFieldID, ninePatchInsets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 SkBitmap 这个才是最终的</span></span><br><span class="line">    SkBitmap outputBitmap;</span><br><span class="line">    <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// 如果需要缩放，那需要重新创建一张图片，上面加载的是图片的本身大小</span></span><br><span class="line">        <span class="comment">// This is weird so let me explain: we could use the scale parameter</span></span><br><span class="line">        <span class="comment">// directly, but for historical reasons this is how the corresponding</span></span><br><span class="line">        <span class="comment">// Dalvik code has always behaved. We simply recreate the behavior here.</span></span><br><span class="line">        <span class="comment">// The result is slightly different from simply using scale because of</span></span><br><span class="line">        <span class="comment">// the 0.5f rounding bias applied when computing the target image size</span></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> sx = scaledWidth / <span class="built_in">float</span>(decodingBitmap.<span class="built_in">width</span>());</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> sy = scaledHeight / <span class="built_in">float</span>(decodingBitmap.<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the allocator for the outputBitmap.</span></span><br><span class="line">        SkBitmap::Allocator *outputAllocator;</span><br><span class="line">        <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            outputAllocator = &amp;recyclingAllocator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputAllocator = &amp;javaAllocator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkColorType scaledColorType = <span class="built_in">colorTypeForScaledOutput</span>(decodingBitmap.<span class="built_in">colorType</span>());</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">        <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">        <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">        <span class="comment">// 设置 SkImageInfo ，注意这里是 scaledWidth ，scaledHeight </span></span><br><span class="line">        outputBitmap.<span class="built_in">setInfo</span>(SkImageInfo::<span class="built_in">Make</span>(scaledWidth, scaledHeight,</span><br><span class="line">        scaledColorType, decodingBitmap.<span class="built_in">alphaType</span>()));</span><br><span class="line">        <span class="comment">// 开辟当前 Bitmap 图片的内存</span></span><br><span class="line">        <span class="keyword">if</span> (!outputBitmap.<span class="built_in">tryAllocPixels</span>(outputAllocator, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// This should only fail on OOM.  The recyclingAllocator should have</span></span><br><span class="line">            <span class="comment">// enough memory since we check this before decoding using the</span></span><br><span class="line">            <span class="comment">// scaleCheckingAllocator.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;allocation failed for scaled bitmap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkPaint paint;</span><br><span class="line">        <span class="comment">// kSrc_Mode instructs us to overwrite the unininitialized pixels in</span></span><br><span class="line">        <span class="comment">// outputBitmap.  Otherwise we would blend by default, which is not</span></span><br><span class="line">        <span class="comment">// what we want.</span></span><br><span class="line">        paint.<span class="built_in">setXfermodeMode</span>(SkXfermode::kSrc_Mode);</span><br><span class="line">        paint.<span class="built_in">setFilterQuality</span>(kLow_SkFilterQuality);</span><br><span class="line">        <span class="comment">// decodingBitmap -&gt; 画到 outputBitmap</span></span><br><span class="line">        <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(outputBitmap)</span></span>;</span><br><span class="line">        canvas.<span class="built_in">scale</span>(sx, sy);</span><br><span class="line">        canvas.<span class="built_in">drawBitmap</span>(decodingBitmap, <span class="number">0.0f</span>, <span class="number">0.0f</span>, &amp;paint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outputBitmap.<span class="built_in">swap</span>(decodingBitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peeker.mPatch != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            GraphicsJNI::<span class="built_in">set_jrect</span>(env, padding,</span><br><span class="line">            peeker.mPatch-&gt;paddingLeft, peeker.mPatch-&gt;paddingTop,</span><br><span class="line">            peeker.mPatch-&gt;paddingRight, peeker.mPatch-&gt;paddingBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GraphicsJNI::<span class="built_in">set_jrect</span>(env, padding, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we get here, the outputBitmap should have an installed pixelref.</span></span><br><span class="line">    <span class="keyword">if</span> (outputBitmap.<span class="built_in">pixelRef</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;Got null SkPixelRef&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isMutable &amp;&amp; javaBitmap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// promise we will never change our pixels (great for sharing and pictures)</span></span><br><span class="line">        outputBitmap.<span class="built_in">setImmutable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有复用返回原来的 javaBitmap</span></span><br><span class="line">    <span class="type">bool</span> isPremultiplied = !requireUnpremultiplied;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        GraphicsJNI::<span class="built_in">reinitBitmap</span>(env, javaBitmap, outputBitmap.<span class="built_in">info</span>(), isPremultiplied);</span><br><span class="line">        outputBitmap.<span class="built_in">notifyPixelsChanged</span>();</span><br><span class="line">        <span class="comment">// If a java bitmap was passed in for reuse, pass it back</span></span><br><span class="line">        <span class="keyword">return</span> javaBitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bitmapCreateFlags = <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isMutable) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Mutable;</span><br><span class="line">    <span class="keyword">if</span> (isPremultiplied) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Premultiplied;</span><br><span class="line">    <span class="comment">// 没有复用的 Bitmap 创建一个新的 Bitmap</span></span><br><span class="line">    <span class="comment">// now create the java bitmap</span></span><br><span class="line">    <span class="keyword">return</span> GraphicsJNI::<span class="built_in">createBitmap</span>(env, javaAllocator.<span class="built_in">getStorageObjAndReset</span>(),</span><br><span class="line">    bitmapCreateFlags, ninePatchChunk, ninePatchInsets, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">GraphicsJNI::createBitmap</span><span class="params">(JNIEnv *env, android::Bitmap *bitmap,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> bitmapCreateFlags, jbyteArray ninePatchChunk,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  jobject ninePatchInsets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> density)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> isMutable = bitmapCreateFlags &amp; kBitmapCreateFlag_Mutable;</span><br><span class="line">    <span class="type">bool</span> isPremultiplied = bitmapCreateFlags &amp; kBitmapCreateFlag_Premultiplied;</span><br><span class="line">    <span class="comment">// The caller needs to have already set the alpha type properly, so the</span></span><br><span class="line">    <span class="comment">// native SkBitmap stays in sync with the Java Bitmap.</span></span><br><span class="line">    <span class="built_in">assert_premultiplied</span>(bitmap-&gt;<span class="built_in">info</span>(), isPremultiplied);</span><br><span class="line"></span><br><span class="line">    jobject obj = env-&gt;<span class="built_in">NewObject</span>(gBitmap_class, gBitmap_constructorMethodID,</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(bitmap), bitmap-&gt;<span class="built_in">javaByteArray</span>(),</span><br><span class="line">            bitmap-&gt;<span class="built_in">width</span>(), bitmap-&gt;<span class="built_in">height</span>(), density, isMutable, isPremultiplied,</span><br><span class="line">            ninePatchChunk, ninePatchInsets);</span><br><span class="line">    <span class="built_in">hasException</span>(env); <span class="comment">// For the side effect of logging.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来比较长，其实是非常简单的，相信大家都能看得懂，这里我对上面的流程再做一些总结：</p><ol><li>解析 java 层传递过来的 Options 的参数，如 simpleSize ，isMutable，javaBitmap 等等，同时计算出 scale 。</li><li>获取当前图片的大小，根据 sampleSize 判断是否需要压缩，同时计算出 scaledWidth ，scaledHeight。</li><li>设置 options 宽高为 scaledWidth ，scaledHeight ，如果只是解析宽高那么就直接返回，也就是 options.inJustDecodeBounds &#x3D; true 时，但是这里需要注意返回的是，资源图片的宽高并不是 Bitmap 最终的宽高。（我们大部分人对这个有误解）</li><li>创建 native 层的 SkImageInfo 和 SkBitmap ，然后调用 tryAllocPixels 去开辟图片的内存空间，然后调用 getAndroidPixels 去解析像素值 ，这里的 decodingBitmap 也并不是最终需要返回的 Bitmap ，而是原资源图片的 Bitmap 。</li><li>构建需要返回的 outputBitmap ，如果需要缩放那么重新去开辟一块内存空间，如果不需要缩放直接调用 swap 方法即可。最后判断有没有复用的 JavaBitmap ,如果有复用调用 reinitBitmap 然后直接返回，如果没有则调用 createBitmap 去创建一个新的 Bitmap 。</li></ol><h4 id="究竟需要多少内存？"><a href="#究竟需要多少内存？" class="headerlink" title="究竟需要多少内存？"></a>究竟需要多少内存？</h4><p><strong>通过上面的分析，我们可能会有疑问？我们调用了两次 tryAllocPixels ，那如果加载一张 (1440x2560) 10M 的图片，岂不是需要 20M 的内存？</strong></p><p>在 Android 平台上，Bitmap 的内存申请操作通常涉及到 Java 层和 Native 层的协作，而 tryAllocPixels 方法的多次调用可能是由于内部的内存分配和管理流程所致。</p><p>在 Android 4.4 及以上版本中，当你尝试为 Bitmap 对象申请内存时，tryAllocPixels 方法可能会在底层进行两次调用。这个行为在底层库中被设计用来提高内存分配的成功率。</p><p>第一次调用 tryAllocPixels 旨在检查是否有足够的内存来分配 Bitmap 的像素数据。如果这次调用失败，系统会尝试触发一次垃圾回收（GC）操作，以释放一些已不再使用的内存资源。</p><p>第二次调用 tryAllocPixels 发生在垃圾回收之后，此时系统期望能够分配足够的内存来满足 Bitmap 的需求。如果第二次调用仍然失败，那么可能会抛出 OutOfMemoryError 错误。</p><p>这种设计的目的是为了提高 Bitmap 内存分配的成功率。由于 Android 平台上的内存管理和垃圾回收机制是相对复杂的，经过多次尝试分配内存和触发垃圾回收，可以增加 Bitmap 成功分配内存的可能性。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">问题：两次调用需要两倍的内存吗</span><br><span class="line"></span><br><span class="line"><span class="symbol">GPT4:</span> 在处理Android图片加载时，内存管理是一个关键考虑因素。</span><br><span class="line">特别是对于高分辨率的图片，如<span class="number">1440</span>x2560像素大小的图片，</span><br><span class="line">观上可能会担心单纯通过分析像素数和颜色深度得出的内存需求量会加倍，</span><br><span class="line">尤其是在调用像<span class="string">`tryAllocPixels`</span>这样的函数两次时。</span><br><span class="line">这里的关键在于理解<span class="string">`tryAllocPixels`</span>函数的作用及其在Android图片处理中的实际行为。</span><br><span class="line"></span><br><span class="line"><span class="string">`tryAllocPixels`</span>是 Android Skia 图形库中的一个函数，用于尝试分配内存以存储图片的像素数据。</span><br><span class="line">当你看到代码中似乎调用了两次<span class="string">`tryAllocPixels`</span>，</span><br><span class="line">可能会误以为这意味着图片数据会被加载或复制两次，</span><br><span class="line">从而导致内存使用翻倍。然而，实际情况可能并非如此。</span><br><span class="line"></span><br><span class="line">首先，调用<span class="string">`tryAllocPixels`</span>并不总是意味着实际的内存分配。</span><br><span class="line">这个函数的行为取决于多个因素，</span><br><span class="line">包括图片的存储格式、是否已经有足够的内存分配给图片，以及图像解码器的实现等。</span><br><span class="line">在某些情况下，如果图片已经在内存中有一个分配好的空间，</span><br><span class="line">第二次调用可能仅仅是一个重复的操作，而不会实际增加内存消耗。</span><br><span class="line"></span><br><span class="line">其次，即使图片数据需要被重新处理或在内存中重新定位，</span><br><span class="line">这也不一定意味着整个图片大小的内存会被再次完整分配。</span><br><span class="line">例如，某些优化操作可能仅仅需要额外的小量内存来处理图片数据，而不是复制整个图片。</span><br><span class="line"></span><br><span class="line">最后，Android平台和许多现代操作系统都采用了高效的内存管理和图像处理策略。</span><br><span class="line">这包括图片的压缩存储、延迟解码（只有在显示图片时才完全解码）、以及内存共享和重用机制等。</span><br><span class="line">这些机制意味着即使处理大型图片，系统也能通过优化减少实际的内存占用。</span><br><span class="line"></span><br><span class="line">因此，尽管从理论上分析像素和颜色深度可能会让人担心高内存消耗，</span><br><span class="line">实际上Android的图片加载和处理框架设计有多种优化，以保持内存使用的效率。</span><br><span class="line">对于开发者而言，关键是了解并利用这些机制，例如使用适当的图片加载库（如Glide、Picasso等），</span><br><span class="line">它们为图片处理提供了进一步的优化和内存管理策略。</span><br></pre></td></tr></table></figure><p>在 Android 中，<code>Bitmap</code> 对象的内存使用量取决于图像的像素数量、每个像素的位深度和像素数据的存储方式。一个 10MB 的图片通常指的是文件大小，而不是图像的像素数量，因此具体的内存使用量会根据图像的属性而有所不同。</p><p>假设你有一张 10MB 的图片，我们可以估算一下将其加载为 <code>Bitmap</code> 时可能需要的内存量。请注意，以下是一个粗略的估算，实际内存使用量可能会受到压缩、图像格式和设备性能的影响。</p><ol><li><p><strong>图像大小：</strong> 假设你的图片大小为 10MB，这指的是文件的大小。这并不直接表示图像的像素数量，因为图像可以使用不同的压缩算法和格式存储。通常情况下，JPEG 格式的图像文件较小，而无损格式如 PNG 或 BMP 文件较大。</p></li><li><p><strong>解码后的像素数据：</strong> 当你将图片解码为 <code>Bitmap</code> 时，其像素数据将被加载到内存中。假设该图片是一个 24 位的彩色图片（每个像素使用 8 位红、绿、蓝通道），那么像素数据的大小将是图像的宽度乘以高度乘以 3（每个像素 3 个通道）字节。这个估算不考虑额外的颜色通道、Alpha 通道等。</p></li></ol><p>所以，一个粗略的估算如下：</p><p>假设图片的像素数据大小为 <code>pixelsSize</code> 字节，则需要的内存量约为：<code>pixelsSize + Overhead</code>。</p><p><code>Overhead</code> 是 <code>Bitmap</code> 对象的开销，它通常取决于设备的位数、对象头信息、内存对齐等因素。对于一个普通的 24 位彩色图片，<code>Overhead</code> 大约在 4-8MB 左右。</p><p>需要注意的是，这只是一个估算，并且实际情况可能因为图片格式、加载库的实现、设备性能等因素而有所不同。在实际开发中，你可以使用一些工具来测量实际的内存使用量，例如 Android Studio 的内存分析工具。</p><h3 id="Bitmap-的内存申请"><a href="#Bitmap-的内存申请" class="headerlink" title="Bitmap 的内存申请"></a>Bitmap 的内存申请</h3><p>Bitmap 的内存申请不同版本间有些许差异，在 3.0-7.0 的 bitmap 像素内存都是存放在 Java heap 中的，而 8.0 以后则是放在 Native heap 中的</p><h4 id="8-0-Bitmap-内存申请"><a href="#8-0-Bitmap-内存申请" class="headerlink" title="8.0 Bitmap  内存申请"></a>8.0 Bitmap  内存申请</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    logMemory();</span><br><span class="line"></span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> Bitmap.createBitmap(<span class="number">1024</span>, <span class="number">1024</span> * <span class="number">500</span>, Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><br><span class="line">    logMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ActivityManager</span> <span class="variable">activityManager</span> <span class="operator">=</span> (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.<span class="type">MemoryInfo</span> <span class="variable">memoryInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityManager</span>.MemoryInfo();</span><br><span class="line">    activityManager.getMemoryInfo(memoryInfo);</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;AvailMem :&quot;</span> + memoryInfo.availMem / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;lowMemory：&quot;</span> + memoryInfo.lowMemory);</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;NativeHeapAllocatedSize :&quot;</span> + Debug.getNativeHeapAllocatedSize() / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们创建了一张 2G 大小的 bitmap 我们在 8.0 以下的版本运行是会 OOM 的，而我们在 8.0 以上的版本运行是完全没问题，但 Native 内存多了 2G 的内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E/TAG: AvailMem :1654</span><br><span class="line">E/TAG: lowMemory：<span class="literal">false</span></span><br><span class="line">E/TAG: NativeHeapAllocatedSize :4</span><br><span class="line"></span><br><span class="line">E/TAG: AvailMem :1656</span><br><span class="line">E/TAG: lowMemory：<span class="literal">false</span></span><br><span class="line">E/TAG: NativeHeapAllocatedSize :2052</span><br></pre></td></tr></table></figure><h4 id="为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况"><a href="#为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况" class="headerlink" title="为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况"></a>为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况</h4><p>在 Android 应用中，一张大图片的像素数据如果放在 Java 层可能会导致 OutOfMemoryError (OOM) 错误，而放在 Native 层不会出现这个问题。这涉及到 Java 层和 Native 层内存管理的不同方式以及底层实现的细节。</p><ol><li><p><strong>Java 层内存管理：</strong> 在 Java 层，对象的内存管理由 Java 虚拟机 (JVM) 负责。当你创建一个 <code>Bitmap</code> 对象并加载大图片的像素数据时，这些像素数据会在 Java 堆内存中分配。Android 应用的 Java 堆内存限制通常较小，这是为了确保系统的稳定性，避免应用占用过多内存影响其他应用和系统的运行。Java 堆内存受到限制，当堆内存用尽时就会触发 OutOfMemoryError 错误。由于 Java 层的内存管理涉及垃圾回收和其他 Java 虚拟机机制，加载大量像素数据可能会导致内存碎片和性能问题，最终导致 OOM 错误。</p></li><li><p><strong>Native 层内存管理：</strong> 在 Native 层，像素数据的内存分配和释放由底层操作系统和 C&#x2F;C++ 代码负责。通过在 Native 层使用本地代码（如 C&#x2F;C++），你可以更好地控制内存的分配和释放。Native 层不受 Java 堆内存限制，因此可以更灵活地处理大量的像素数据，减少内存碎片问题，并降低 OOM 风险。</p></li></ol><h4 id="7-0-与-8-0-Bitmap-内存申请-tryAllocPixels-方法"><a href="#7-0-与-8-0-Bitmap-内存申请-tryAllocPixels-方法" class="headerlink" title="7.0 与 8.0 Bitmap 内存申请 tryAllocPixels 方法"></a>7.0 与 8.0 Bitmap 内存申请 tryAllocPixels 方法</h4><p>通过之前的源码分析可知 bitmap 的内存创建都是通过 tryAllocPixels 方法来申请的，我们通过源码来对比一下他们之间的区别，我们首先来看下 7.0 的代码：</p><p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkBitmap::tryAllocPixels</span><span class="params">(Allocator *allocator, SkColorTable *ctable)</span> </span>&#123;</span><br><span class="line">    HeapAllocator stdalloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == allocator) &#123;</span><br><span class="line">        allocator = &amp;stdalloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocator-&gt;<span class="built_in">allocPixelRef</span>(<span class="keyword">this</span>, ctable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JavaPixelAllocator::allocPixelRef</span><span class="params">(SkBitmap *bitmap, SkColorTable *ctable)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="built_in">vm2env</span>(mJavaVM);</span><br><span class="line"></span><br><span class="line">    mStorage = GraphicsJNI::<span class="built_in">allocateJavaPixelRef</span>(env, bitmap, ctable);</span><br><span class="line">    <span class="keyword">return</span> mStorage != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">android::Bitmap *<span class="title">GraphicsJNI::allocateJavaPixelRef</span><span class="params">(JNIEnv *env, SkBitmap *bitmap,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    SkColorTable *ctable)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> SkImageInfo &amp;info = bitmap-&gt;<span class="built_in">info</span>();</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">colorType</span>() == kUnknown_SkColorType) &#123;</span><br><span class="line">        <span class="built_in">doThrowIAE</span>(env, <span class="string">&quot;unknown bitmap configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">computeAllocationSize</span>(*bitmap, &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we must respect the rowBytes value already set on the bitmap instead of</span></span><br><span class="line">    <span class="comment">// attempting to compute our own.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> rowBytes = bitmap-&gt;<span class="built_in">rowBytes</span>();</span><br><span class="line"></span><br><span class="line">    jbyteArray arrayObj = (jbyteArray) env-&gt;<span class="built_in">CallObjectMethod</span>(gVMRuntime,</span><br><span class="line">                                                             gVMRuntime_newNonMovableArray,</span><br><span class="line">                                                             gByte_class, size);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SkASSERT</span>(arrayObj);</span><br><span class="line">    jbyte *addr = (jbyte *) env-&gt;<span class="built_in">CallLongMethod</span>(gVMRuntime, gVMRuntime_addressOf, arrayObj);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SkASSERT</span>(addr);</span><br><span class="line">    android::Bitmap *wrapper = <span class="keyword">new</span> android::<span class="built_in">Bitmap</span>(env, arrayObj, (<span class="type">void</span> *) addr, info, rowBytes,</span><br><span class="line">                                                   ctable);</span><br><span class="line">    wrapper-&gt;<span class="built_in">getSkBitmap</span>(bitmap);</span><br><span class="line">    <span class="comment">// since we&#x27;re already allocated, we lockPixels right away</span></span><br><span class="line">    <span class="comment">// HeapAllocator behaves this way too</span></span><br><span class="line">    bitmap-&gt;<span class="built_in">lockPixels</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面就可以看到, new android::Bitmap 见：<br> frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bitmap::<span class="built_in">Bitmap</span>(JNIEnv *env, jbyteArray storageObj, <span class="type">void</span> *address,</span><br><span class="line">               <span class="type">const</span> SkImageInfo &amp;info, <span class="type">size_t</span> rowBytes, SkColorTable *ctable)</span><br><span class="line">        : <span class="built_in">mPixelStorageType</span>(PixelStorageType::Java) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">GetJavaVM</span>(&amp;mPixelStorage.java.jvm);</span><br><span class="line">    mPixelStorage.java.jweakRef = env-&gt;<span class="built_in">NewWeakGlobalRef</span>(storageObj);</span><br><span class="line">    mPixelStorage.java.jstrongRef = <span class="literal">nullptr</span>;</span><br><span class="line">    mPixelRef.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">WrappedPixelRef</span>(<span class="keyword">this</span>, address, info, rowBytes, ctable));</span><br><span class="line">    <span class="comment">// Note: this will trigger a call to onStrongRefDestroyed(), but</span></span><br><span class="line">    <span class="comment">// we want the pixel ref to have a ref count of 0 at this point</span></span><br><span class="line">    mPixelRef-&gt;<span class="built_in">unref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>address 获取的是 arrayObj 的地址，而 arrayObj 是 jbyteArray 数据类型，也就是说这里是通过 JNI 进入了 Java 世界开辟了内存，好比 Zygote 进入 Java 世界是通过 JNI 调用 com.android.internal.os.ZygoteInit 类的 main 函数是一个道理~ 我们还可以继续跟到 gVMRuntime_newNonMovableArray 中去看看实现，最后是 runtime-&gt;GetHeap() 上分配内存也就是 Java heap 内存。</p><p>我们还得看下 8.0 的源码，比较一下它与 7.0 之间的区别：<br> <a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/external/skia/src/core/SkBitmap.cpp">external&#x2F;skia&#x2F;src&#x2F;core&#x2F;SkBitmap.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkBitmap::tryAllocPixels</span><span class="params">(Allocator *allocator, SkColorTable *ctable)</span> </span>&#123;</span><br><span class="line">    HeapAllocator stdalloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == allocator) &#123;</span><br><span class="line">        allocator = &amp;stdalloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocator-&gt;<span class="built_in">allocPixelRef</span>(<span class="keyword">this</span>, ctable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapAllocator::allocPixelRef</span><span class="params">(SkBitmap *bitmap, SkColorTable *ctable)</span> </span>&#123;</span><br><span class="line">    mStorage = android::Bitmap::<span class="built_in">allocateHeapBitmap</span>(bitmap, ctable);</span><br><span class="line">    <span class="keyword">return</span> !!mStorage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocateHeapBitmap方法会最终new Bitmap,分配内存 ,见:<br> <a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp">&#x2F;frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;hwui&#x2F;Bitmap.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sk_sp &lt;Bitmap&gt; Bitmap::<span class="built_in">allocateHeapBitmap</span>(SkBitmap *bitmap, SkColorTable *ctable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">allocateBitmap</span>(bitmap, ctable, &amp;android::allocateHeapBitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> sk_sp &lt;Bitmap&gt; <span class="built_in">allocateBitmap</span>(SkBitmap *bitmap, SkColorTable *ctable, AllocPixeRef alloc) &#123;</span><br><span class="line">    <span class="type">const</span> SkImageInfo &amp;info = bitmap-&gt;<span class="built_in">info</span>();</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">colorType</span>() == kUnknown_SkColorType) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;unknown bitmap configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we must respect the rowBytes value already set on the bitmap instead of</span></span><br><span class="line">    <span class="comment">// attempting to compute our own.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> rowBytes = bitmap-&gt;<span class="built_in">rowBytes</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">computeAllocationSize</span>(rowBytes, bitmap-&gt;<span class="built_in">height</span>(), &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> wrapper = <span class="built_in">alloc</span>(size, info, rowBytes, ctable);</span><br><span class="line">    <span class="keyword">if</span> (wrapper) &#123;</span><br><span class="line">        wrapper-&gt;<span class="built_in">getSkBitmap</span>(bitmap);</span><br><span class="line">        <span class="comment">// since we&#x27;re already allocated, we lockPixels right away</span></span><br><span class="line">        <span class="comment">// HeapAllocator behaves this way too</span></span><br><span class="line">        bitmap-&gt;<span class="built_in">lockPixels</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bitmap-内存模型"><a href="#Bitmap-内存模型" class="headerlink" title="Bitmap 内存模型"></a>Bitmap 内存模型</h3><table><thead><tr><th>0-2.3</th><th>3.0-4.4</th><th>5.0-7.1</th><th>8.0</th></tr></thead><tbody><tr><td>Bitmap对象</td><td>Java Heap</td><td>Java Heap</td><td>Java Heap</td></tr><tr><td>像素数据</td><td>Native Heap</td><td>Java Heap</td><td>Native Heap</td></tr><tr><td>迁移原因</td><td></td><td>解决Native Bitmap内存泄漏</td><td>共享整个系统的内存减少OOM</td></tr></tbody></table><h3 id="Android-Bitmap-回收机制源代码分析-从2-3到7-0，8-0"><a href="#Android-Bitmap-回收机制源代码分析-从2-3到7-0，8-0" class="headerlink" title="Android Bitmap 回收机制源代码分析 (从2.3到7.0，8.0)"></a>Android Bitmap 回收机制源代码分析 (从2.3到7.0，8.0)</h3><h4 id="android-2-3-3-和-更低的版本"><a href="#android-2-3-3-和-更低的版本" class="headerlink" title="android 2.3.3 和 更低的版本"></a>android 2.3.3 和 更低的版本</h4><p>在 Android 2.3.3 之前开发者必须手动调用 recycle 方法去释放 Native 内存，因为那个时候管理Bitmap内存比较复杂，需要手动维护引用计数器</p><p>官网解释:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On Android <span class="number">2.3</span><span class="number">.3</span> (API level <span class="number">10</span>) <span class="keyword">and</span> lower, <span class="function"><span class="keyword">using</span> <span class="title">recycle</span>() <span class="keyword">is</span> recommended. If you&#x27;re displaying large amounts of bitmap data <span class="keyword">in</span> your app, you&#x27;re likely to run <span class="keyword">into</span> OutOfMemoryError errors. The <span class="title">recycle</span>()method allows an app to reclaim memory <span class="keyword">as</span> soon <span class="keyword">as</span> possible.</span></span><br><span class="line"><span class="function">Caution: You should use <span class="title">recycle</span>() only <span class="keyword">when</span> you are sure that the bitmap <span class="keyword">is</span> no longer being used. If you call <span class="title">recycle</span>() <span class="keyword">and</span> later attempt to draw the bitmap, you will <span class="keyword">get</span> the error: &quot;Canvas: trying to use a recycled bitmap&quot;.</span></span><br><span class="line"><span class="function">The following code snippet gives an example of calling <span class="title">recycle</span>(). It uses reference <span class="title">counting</span> (<span class="params"><span class="keyword">in</span> the variables mDisplayRefCount <span class="keyword">and</span> mCacheRefCount</span>) to track whether a bitmap <span class="keyword">is</span> currently being displayed <span class="keyword">or</span> <span class="keyword">in</span> the cache. The code recycles the bitmap <span class="keyword">when</span> these conditions are met:</span></span><br><span class="line"><span class="function">The reference count <span class="keyword">for</span> both mDisplayRefCount <span class="keyword">and</span> mCacheRefCount <span class="keyword">is</span> 0.</span></span><br><span class="line"><span class="function">The bitmap <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>, <span class="keyword">and</span> it hasn&#x27;t been recycled yet.</span></span><br></pre></td></tr></table></figure><p>在 Android 2.3.3 以后不需要开发者主动调用 recycle 方法来回收内存了，但 Android K,L,M,N,O 版本上，都还能看到 recycle 方法，为什么没有干掉呢? 调用它会不会真正的释放内存呢？既然不需要手动释放 Native Bitmap ，那 Native 层的对象是怎么自动释放的？我们先来看下 7.0 和 8.0 中 recycle 的方法实现。</p><h4 id="7-0-和-8-0-中-recycle-的方法实现"><a href="#7-0-和-8-0-中-recycle-的方法实现" class="headerlink" title="7.0 和 8.0 中 recycle 的方法实现"></a>7.0 和 8.0 中 recycle 的方法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Free the native object associated with this bitmap, and clear the</span></span><br><span class="line"><span class="comment">  * reference to the pixel data. This will not free the pixel data synchronously;</span></span><br><span class="line"><span class="comment">  * it simply allows it to be garbage collected if there are no other references.</span></span><br><span class="line"><span class="comment">  * The bitmap is marked as &quot;dead&quot;, meaning it will throw an exception if</span></span><br><span class="line"><span class="comment">  * getPixels() or setPixels() is called, and will draw nothing. This operation</span></span><br><span class="line"><span class="comment">  * cannot be reversed, so it should only be called if you are sure there are no</span></span><br><span class="line"><span class="comment">  * further uses for the bitmap. This is an advanced call, and normally need</span></span><br><span class="line"><span class="comment">  * not be called, since the normal GC process will free up this memory when</span></span><br><span class="line"><span class="comment">  * there are no more references to this bitmap.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放与此位图关联的本机对象，并清除对像素数据的引用。这不会立即释放像素数据；</span></span><br><span class="line"><span class="comment"> * 它只是允许在没有其他引用时进行垃圾回收。该位图被标记为&quot;无效&quot;，这意味着如果调用   </span></span><br><span class="line"><span class="comment"> * getPixels()或setPixels()，它将抛出异常，</span></span><br><span class="line"><span class="comment"> * 并且不会绘制任何内容。此操作无法撤销，因此只有在确保不再需要位图时才应调用此方法。</span></span><br><span class="line"><span class="comment"> * 这是一个高级调用，通常不需要调用，因为正常的垃圾回收过程将在不再引用该位图时释放此内</span></span><br><span class="line"><span class="comment"> * 存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRecycled &amp;&amp; mNativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nativeRecycle(mNativePtr)) &#123;</span><br><span class="line">        <span class="comment">// return value indicates whether native pixel object was actually recycled.</span></span><br><span class="line">        <span class="comment">// false indicates that it is still in use at the native level and these</span></span><br><span class="line">        <span class="comment">// objects should not be collected now. They will be collected later when the</span></span><br><span class="line">        <span class="comment">// Bitmap itself is collected.</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 返回值指示本机像素对象是否实际已被回收。</span></span><br><span class="line">      <span class="comment">// false 表示它仍在本机级别上使用，现在不应收集这些对象。它们将在位图本身被回收时稍后收集。 </span></span><br><span class="line">        mNinePatchChunk = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mRecycled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">nativeRecycle</span><span class="params">(<span class="type">long</span> nativeBitmap)</span>;</span><br></pre></td></tr></table></figure><p>都是调用了native方法，下面看一下native方法</p><p>8.0 见：<br><a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp">&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv *env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    <span class="function">LocalScopedBitmap <span class="title">bitmap</span><span class="params">(bitmapHandle)</span></span>;</span><br><span class="line">    bitmap-&gt;<span class="built_in">freePixels</span>();</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mInfo = mBitmap-&gt;<span class="built_in">info</span>();</span><br><span class="line">    mHasHardwareMipMap = mBitmap-&gt;<span class="built_in">hasHardwareMipMap</span>();</span><br><span class="line">    mAllocationSize = mBitmap-&gt;<span class="built_in">getAllocationByteCount</span>();</span><br><span class="line">    mRowBytes = mBitmap-&gt;<span class="built_in">rowBytes</span>();</span><br><span class="line">    mGenerationId = mBitmap-&gt;<span class="built_in">getGenerationID</span>();</span><br><span class="line">    mIsHardware = mBitmap-&gt;<span class="built_in">isHardware</span>();</span><br><span class="line">    <span class="comment">// 清空了数据</span></span><br><span class="line">    mBitmap.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure><p>7.0 见：<br><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp">&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv *env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    <span class="function">LocalScopedBitmap <span class="title">bitmap</span><span class="params">(bitmapHandle)</span></span>;</span><br><span class="line">    bitmap-&gt;<span class="built_in">freePixels</span>();</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bitmap::doFreePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mPixelStorageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Invalid:</span><br><span class="line">            <span class="comment">// already free&#x27;d, nothing to do</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::External:</span><br><span class="line">            mPixelStorage.external.<span class="built_in">freeFunc</span>(mPixelStorage.external.address,</span><br><span class="line">            mPixelStorage.external.context);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Ashmem:</span><br><span class="line">            <span class="built_in">munmap</span>(mPixelStorage.ashmem.address, mPixelStorage.ashmem.size);</span><br><span class="line">            <span class="built_in">close</span>(mPixelStorage.ashmem.fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Java:</span><br><span class="line">            <span class="comment">// 只是释放了 Java 层之前创建的引用</span></span><br><span class="line">            JNIEnv *env = <span class="built_in">jniEnv</span>();</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(</span><br><span class="line">              mPixelStorage.java.jstrongRef,</span><br><span class="line">              <span class="string">&quot;Deleting a bitmap wrapper while there are outstanding strong &quot;</span></span><br><span class="line">                    <span class="string">&quot;references! mPinnedRefCount = %d&quot;</span>, mPinnedRefCount);</span><br><span class="line">            env-&gt;<span class="built_in">DeleteWeakGlobalRef</span>(mPixelStorage.java.jweakRef);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (android::uirenderer::Caches::<span class="built_in">hasInstance</span>()) &#123;</span><br><span class="line">        android::uirenderer::Caches::<span class="built_in">getInstance</span>().textureCache.<span class="built_in">releaseTexture</span>(</span><br><span class="line">                mPixelRef-&gt;<span class="built_in">getStableID</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-0-和-8-0-中-手动调用-recycle-的方法，像素数据会被回收吗"><a href="#7-0-和-8-0-中-手动调用-recycle-的方法，像素数据会被回收吗" class="headerlink" title="7.0 和 8.0 中 手动调用 recycle 的方法，像素数据会被回收吗"></a>7.0 和 8.0 中 手动调用 recycle 的方法，像素数据会被回收吗</h4><p>从上面的源码可以看出，如果是<br>        <strong>8.0</strong> : 我们手动调用 recycle 方法，数据是会立即释放的，因为像素数据本身就是在 Native 层开辟的。<br>        <strong>8.0 以下</strong>，就算我们手动调用 recycle 方法，数据也是不会立即释放的，而是 DeleteWeakGlobalRef 交由 Java GC 来回收。</p><p><strong>注意：以上的所说的释放数据仅代表释放像素数据，并未释放 Native 层的 Bitmap 对象。</strong></p><h4 id="Android-M-版本及以前的版本-Bitmap-的内存回收"><a href="#Android-M-版本及以前的版本-Bitmap-的内存回收" class="headerlink" title="Android M 版本及以前的版本, Bitmap 的内存回收"></a>Android M 版本及以前的版本, Bitmap 的内存回收</h4><p>Android M 版本及以前的版本, Bitmap 的内存回收主要是通过 BitmapFinalizer 来完成的见:<br> <a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.0_r1/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">&#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">byte</span>[] buffer, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">        <span class="type">boolean</span> isMutable, <span class="type">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="type">byte</span>[] ninePatchChunk, NinePatchInsetStruct ninePatchInsets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;internal error: native bitmap is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mIsMutable = isMutable;</span><br><span class="line">    mRequestPremultiplied = requestPremultiplied;</span><br><span class="line">    mBuffer = buffer;</span><br><span class="line"></span><br><span class="line">    mNinePatchChunk = ninePatchChunk;</span><br><span class="line">    mNinePatchInsets = ninePatchInsets;</span><br><span class="line">    <span class="keyword">if</span> (density &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mDensity = density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    <span class="comment">// 这个对象对象来回收</span></span><br><span class="line">    mFinalizer = <span class="keyword">new</span> <span class="title class_">BitmapFinalizer</span>(nativeBitmap);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nativeAllocationByteCount</span> <span class="operator">=</span> (buffer == <span class="literal">null</span> ? getByteCount() : <span class="number">0</span>);</span><br><span class="line">    mFinalizer.setNativeAllocationByteCount(nativeAllocationByteCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BitmapFinalizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mNativeBitmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Native memory allocated for the duration of the Bitmap,</span></span><br><span class="line">    <span class="comment">// if pixel data allocated into native memory, instead of java byte[]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mNativeAllocationByteCount;</span><br><span class="line"></span><br><span class="line">    BitmapFinalizer(<span class="type">long</span> nativeBitmap) &#123;</span><br><span class="line">        mNativeBitmap = nativeBitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNativeAllocationByteCount</span><span class="params">(<span class="type">int</span> nativeByteCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeAllocationByteCount != <span class="number">0</span>) &#123;</span><br><span class="line">            VMRuntime.getRuntime().registerNativeFree(mNativeAllocationByteCount);</span><br><span class="line">        &#125;</span><br><span class="line">        mNativeAllocationByteCount = nativeByteCount;</span><br><span class="line">        <span class="keyword">if</span> (mNativeAllocationByteCount != <span class="number">0</span>) &#123;</span><br><span class="line">            VMRuntime.getRuntime().registerNativeAllocation(mNativeAllocationByteCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// finalize 这里是 GC 回收该对象时会调用</span></span><br><span class="line">            setNativeAllocationByteCount(<span class="number">0</span>);</span><br><span class="line">            nativeDestructor(mNativeBitmap);</span><br><span class="line">            mNativeBitmap = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeDestructor</span><span class="params">(<span class="type">long</span> nativeBitmap)</span>;</span><br></pre></td></tr></table></figure><h4 id="Android-N-和-Android-O-后，Bitmap-的内存回收"><a href="#Android-N-和-Android-O-后，Bitmap-的内存回收" class="headerlink" title="Android N 和 Android O 后，Bitmap 的内存回收"></a>Android N 和 Android O 后，Bitmap 的内存回收</h4><p>没有了 BitmapFinalizer 类，但在 new Bitmap 时会注册 native 的 Finalizer 方法见: <a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">&#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java</a></p><p>使用 NativeAllocationRegistry 回收 native 内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private constructor that must received an already allocated native bitmap</span></span><br><span class="line"><span class="comment"> * int (pointer).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">        <span class="type">boolean</span> isMutable, <span class="type">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="type">byte</span>[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;internal error: native bitmap is 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mIsMutable = isMutable;</span><br><span class="line">    mRequestPremultiplied = requestPremultiplied;</span><br><span class="line"></span><br><span class="line">    mNinePatchChunk = ninePatchChunk;</span><br><span class="line">    mNinePatchInsets = ninePatchInsets;</span><br><span class="line">    <span class="keyword">if</span> (density &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mDensity = density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line">    <span class="type">NativeAllocationRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(</span><br><span class="line">            Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bitmap-的-Java-对象-GC-之后，对应的-native-内存如何回收"><a href="#Bitmap-的-Java-对象-GC-之后，对应的-native-内存如何回收" class="headerlink" title="Bitmap 的 Java 对象 GC 之后，对应的 native 内存如何回收"></a>Bitmap 的 Java 对象 GC 之后，对应的 native 内存如何回收</h3><h4 id="NativeAllocationRegistry-的原理与设计思想"><a href="#NativeAllocationRegistry-的原理与设计思想" class="headerlink" title="NativeAllocationRegistry 的原理与设计思想"></a>NativeAllocationRegistry 的原理与设计思想</h4><p><code>NativeAllocationRegistry</code>是<code>Android 8.0（API 27）</code>引入的一种辅助回收<code>native</code>内存的机制</p><ul><li><p>Bitmap 的内存分配分外两块：Java 堆和 native 堆。我们都知道 JVM 有垃圾回收机制，那么当 Bitmap的Java对象GC之后，对应的 native 堆内存会回收吗？</p></li><li><h4 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h4><p>掌握了<code>NativeAllocationRegistry</code>的作用和使用步骤后，很自然地会有一些疑问：</p><ul><li><strong>为什么在<code>Java</code>层对象被垃圾回收后，<code>native</code>内存会自动被回收呢？</strong></li><li><strong><code>NativeAllocationRegistry</code>是从<code>Android 8.0（API 27）</code>开始引入，那么在此之前，<code>native</code>内存是如何回收的呢？</strong></li></ul></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>从<code>Android 8.0（API 27）</code>开始，<code>Android</code>中很多地方可以看到<code>NativeAllocationRegistry</code>的身影，我们以<code>Bitmap</code>为例子介绍<code>NativeAllocationRegistry</code>的使用步骤，涉及文件：<a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">Bitmap.java</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.h">Bitmap.h</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp">Bitmap.cpp</a></p><h5 id="步骤1：创建-NativeAllocationRegistry"><a href="#步骤1：创建-NativeAllocationRegistry" class="headerlink" title="步骤1：创建 NativeAllocationRegistry"></a>步骤1：创建 NativeAllocationRegistry</h5><p>首先，我们看看实例化<code>NativeAllocationRegistry</code>的地方，具体在<code>Bitmap</code>的构造函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # Android 8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap,...)&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【分析点 1：native 层需要的内存大小】</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line">    <span class="comment">// 【分析点 2：回收函数 nativeGetNativeFinalizer()】</span></span><br><span class="line">    <span class="comment">// 【分析点 3：加载回收函数的类加载器：Bitmap.class.getClassLoader()】</span></span><br><span class="line">    <span class="type">NativeAllocationRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(</span><br><span class="line">        Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    <span class="comment">// 注册 Java 层对象引用与 native 层对象的地址</span></span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NATIVE_ALLOCATION_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeGetNativeFinalizer</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Bitmap</code>的构造函数（在从<code>JNI</code>中调用）中实例化了<code>NativeAllocationRegistry</code>，并传递了三个参数：</p><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>classLoader</code></td><td align="left">加载<code>freeFunction</code>函数的类加载器</td></tr><tr><td align="left"><code>freeFunction</code></td><td align="left">回收<code>native</code>内存的<code>native</code>函数直接地址</td></tr><tr><td align="left"><code>size</code></td><td align="left">分配的<code>native</code>内存大小（单位：字节）</td></tr></tbody></table><h5 id="步骤2：注册对象"><a href="#步骤2：注册对象" class="headerlink" title="步骤2：注册对象"></a>步骤2：注册对象</h5><p>紧接着，调用了<code>registerNativeAllocation(...)</code>，并传递两个参数：</p><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>referent</code></td><td align="left"><code>Java</code>层对象的引用</td></tr><tr><td align="left"><code>nativeBitmap</code></td><td align="left"><code>native</code>层对象的地址</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called from JNI</span></span><br><span class="line">Bitmap(<span class="type">long</span> nativeBitmap,...)&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line">    <span class="comment">// 注册 Java 层对象引用与 native 层对象的地址</span></span><br><span class="line">    registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Runnable <span class="title function_">registerNativeAllocation</span><span class="params">(Object referent, <span class="type">long</span> nativePtr)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码省略，下文补充...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3：回收内存"><a href="#步骤3：回收内存" class="headerlink" title="步骤3：回收内存"></a>步骤3：回收内存</h5><p>完成前面两步后，当<code>Java</code>层对象被垃圾回收后，<code>NativeAllocationRegistry</code>会自动回收注册的<code>native</code>内存。例如，我们加载几张图片，随后释放<code>Bitmap</code>的引用，可以观察到<code>GC</code>之后，<code>native</code>层的内存也自动回收了：</p><figure class="highlight plaintext"><figcaption><span>ava</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tv.setOnClickListener&#123;</span><br><span class="line">    val map = HashSet&lt;Any&gt;()</span><br><span class="line">    for(index in 0 .. 2)&#123;</span><br><span class="line">        map.add(BitmapFactory.decodeResource(resources,R.drawable.test))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>GC 前的内存分配情况 —— Android 8.0</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10107787-56315037f2269bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><ul><li>GC 后的内存分配情况 —— Android 8.0</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10107787-96f6ad82c89a00f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><hr><p>- </p><p>通过分析<code>NativeAllocationRegistry</code>源码，我们将一步步解答这些问题，请继续往下看。</p><hr><h4 id="NativeAllocationRegistry-源码分析"><a href="#NativeAllocationRegistry-源码分析" class="headerlink" title="NativeAllocationRegistry 源码分析"></a>NativeAllocationRegistry 源码分析</h4><p>现在我们将视野回到到<code>NativeAllocationRegistry</code>的源码，涉及文件：<a href="https://links.jianshu.com/go?to=http://androidxref.com/9.0.0_r3/xref/libcore/luni/src/main/java/libcore/util/NativeAllocationRegistry.java">NativeAllocationRegistry.java</a> 、<a href="https://links.jianshu.com/go?to=http://androidxref.com/9.0.0_r3/xref/frameworks/layoutlib/bridge/src/libcore/util/NativeAllocationRegistry_Delegate.java">NativeAllocationRegistry_Delegate.java</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/9.0.0_r3/xref/libcore/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp">libcore_util_NativeAllocationRegistry.cpp</a></p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeAllocationRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 加载 freeFunction 函数的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    <span class="comment">// 回收 native 内存的 native 函数直接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> freeFunction;</span><br><span class="line">    <span class="comment">// 分配的 native 内存大小（字节）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> size;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NativeAllocationRegistry</span><span class="params">(ClassLoader classLoader, <span class="type">long</span> freeFunction, <span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid native allocation size: &quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.classLoader = classLoader;</span><br><span class="line">        <span class="built_in">this</span>.freeFunction = freeFunction;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>NativeAllocationRegistry</code>的构造函数只是将三个参数保存下来，并没有执行额外操作。以<code>Bitmap</code>为例，三个参数在<code>Bitmap</code>的构造函数中获得，我们继续上一节未完成的分析过程：</p><ul><li><strong>分析点 1：native 层需要的内存大小</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【分析点 1：native 层需要的内存大小】</span></span><br><span class="line"><span class="type">long</span> <span class="variable">nativeSize</span> <span class="operator">=</span> NATIVE_ALLOCATION_SIZE + getAllocationByteCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAllocationByteCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRecycled) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Called getAllocationByteCount() on a recycle()&#x27;d bitmap! &quot;</span></span><br><span class="line">                    + <span class="string">&quot;This is undefined behavior!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 native 方法</span></span><br><span class="line">    <span class="keyword">return</span> nativeGetAllocationByteCount(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NATIVE_ALLOCATION_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>nativeSize</code>由固定的<code>32</code>字节加上<code>getAllocationByteCount()</code>，总之，<code>NativeAllocationRegistry</code>需要一个<code>native</code>层内存大小的参数。</p><ul><li><strong>分析点 2：回收函数 nativeGetNativeFinalizer()</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【分析点 2：回收函数 nativeGetNativeFinalizer()】</span></span><br><span class="line">NativeAllocationRegistry registry = <span class="keyword">new</span> <span class="built_in">NativeAllocationRegistry</span>(</span><br><span class="line">    Bitmap.<span class="keyword">class</span>.<span class="built_in">getClassLoader</span>(), <span class="built_in">nativeGetNativeFinalizer</span>(), nativeSize);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> native <span class="type">long</span> <span class="title">nativeGetNativeFinalizer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 层</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// native 层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">Bitmap_getNativeFinalizer</span><span class="params">(JNIEnv*, jobject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转为long</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;jlong&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;Bitmap_destruct));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bitmap_destruct</span><span class="params">(BitmapWrapper* bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>nativeGetNativeFinalizer()</code>是一个<code>native</code>函数，返回值是一个<code>long</code>，这个值其实相当于<code>Bitmap_destruct()</code>函数的直接地址。很明显，<code>Bitmap_destruct()</code>就是用来回收<code>native</code>层内存的。</p><p>那么，<code>Bitmap_destruct()</code>是在哪里调用的呢？继续往下看！</p><ul><li><strong>分析点 3：加载回收函数的类加载器</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line">Bitmap.<span class="keyword">class</span>.getClassLoader()</span><br></pre></td></tr></table></figure><p>另外，<code>NativeAllocationRegistry</code>还需要<code>ClassLoader</code>参数，文档注释指出：**<code>classloader</code>是加载<code>freeFunction</code>所在<code>native</code>库的类加载器**，但是<code>NativeAllocationRegistry</code>内部并没有使用这个参数。这里笔者也不理解为什么需要传递这个参数，如果有知道答案的小伙伴请告诉我一下~</p><h5 id="注册对象"><a href="#注册对象" class="headerlink" title="注册对象"></a>注册对象</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Java 层对象引用与 native 层对象的地址</span></span><br><span class="line">registry.registerNativeAllocation(<span class="keyword">this</span>, nativeBitmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">registerNativeAllocation</span>(<span class="params">Object referent, <span class="built_in">long</span> nativePtr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (referent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;referent is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nativePtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;nativePtr is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CleanerThunk thunk;</span><br><span class="line">    CleanerRunner result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thunk = <span class="keyword">new</span> CleanerThunk();</span><br><span class="line">        Cleaner cleaner = Cleaner.create(referent, thunk);</span><br><span class="line">        result = <span class="keyword">new</span> CleanerRunner(cleaner);</span><br><span class="line">        registerNativeAllocation(<span class="keyword">this</span>.size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (VirtualMachineError vme <span class="comment">/* probably OutOfMemoryError */</span>) &#123;</span><br><span class="line">        applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">        <span class="keyword">throw</span> vme;</span><br><span class="line">        <span class="comment">// Other exceptions are impossible.</span></span><br><span class="line">        <span class="comment">// Enable the cleaner only after we can no longer throw anything, including OOME.</span></span><br><span class="line">        thunk.setNativePtr(nativePtr);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>registerNativeAllocation (...)</code>方法参数是**<code>Java</code>层对象引用与<code>native</code>层对象的地址**。函数体乍一看是有点绕，笔者在这里也停留了好长一会。我们简化一下代码，<code>try-catch</code>代码先省略，函数返回值<code>Runnable</code>暂时用不到也先省略，瘦身后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （简化）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerNativeAllocation</span><span class="params">(Object referent, <span class="type">long</span> nativePtr)</span> &#123;</span><br><span class="line">    CleanerThunk <span class="type">thunk</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CleanerThunk</span>();</span><br><span class="line">    <span class="comment">// Cleaner 绑定 Java 对象与回收函数</span></span><br><span class="line">    <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create(referent, thunk);</span><br><span class="line">    <span class="comment">// 注册 native 内存</span></span><br><span class="line">    registerNativeAllocation(<span class="built_in">this</span>.size);</span><br><span class="line">    thunk.setNativePtr(nativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CleanerThunk</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 代码省略，下文补充...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，上文提出的第一个疑问就可以解释了，原来<code>NativeAllocationRegistry</code>内部是利用了<code>sun.misc.Cleaner.java</code>机制，简单来说：<strong>使用虚引用得知对象被GC的时机，在GC前执行额外的回收工作</strong>。</p><blockquote><h6 id="举一反三"><a href="#举一反三" class="headerlink" title="# 举一反三"></a># 举一反三</h6><p><code>DirectByteBuffer</code>内部也是利用了<code>Cleaner</code>实现堆外内存的释放的。若不了解，请务必阅读：<a href="https://www.jianshu.com/p/993206508d35">《Java | 堆内存与堆外内存》</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CleanerThunk</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// native 层对象的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nativePtr;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CleanerThunk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nativePtr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【分析点 4：执行内存回收方法】</span></span><br><span class="line">            applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">            <span class="comment">// 【分析点 5：注销 native 内存】</span></span><br><span class="line">            registerNativeFree(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNativePtr</span><span class="params">(<span class="type">long</span> nativePtr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nativePtr = nativePtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，<code>CleanerThunk</code>其实是<code>Runnable</code>的实现类，<code>run()</code>在<code>Java</code>层对象被垃圾回收时触发，主要做了两件事：</p><ul><li><strong>分析点 4：执行内存回收方法</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> native <span class="type">void</span> <span class="title">applyFreeFunction</span><span class="params">(<span class="type">long</span> freeFunction, <span class="type">long</span> nativePtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeAllocationRegistry.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FreeFunction)</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NativeAllocationRegistry_applyFreeFunction</span><span class="params">(JNIEnv*,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       jclass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       jlong freeFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* nativePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr));</span><br><span class="line">    FreeFunction nativeFreeFunction = <span class="built_in">reinterpret_cast</span>&lt;FreeFunction&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(freeFunction));</span><br><span class="line">    <span class="comment">// 调用回收函数</span></span><br><span class="line">    <span class="built_in">nativeFreeFunction</span>(nativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>applyFreeFunction(...)</code>最终就是执行到了前面提到的<strong>内存回收函数</strong>，对于<code>Bitmap</code>就是<code>Bitmap_destruct()</code></p><ul><li><strong>分析点 5：注册 &#x2F; 注销native内存</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeAllocationRegistry.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 native 内存</span></span><br><span class="line"><span class="built_in">registerNativeAllocation</span>(<span class="keyword">this</span>.size);</span><br><span class="line"><span class="comment">// 注销 native 内存</span></span><br><span class="line"><span class="built_in">registerNativeFree</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示：这一层函数其实就是为了将参数转为long</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">registerNativeAllocation</span><span class="params">(<span class="type">long</span> size)</span> </span>&#123;</span><br><span class="line">    VMRuntime.<span class="built_in">getRuntime</span>().<span class="built_in">registerNativeAllocation</span>((<span class="type">int</span>)Math.<span class="built_in">min</span>(size, Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">registerNativeFree</span><span class="params">(<span class="type">long</span> size)</span> </span>&#123;</span><br><span class="line">    VMRuntime.<span class="built_in">getRuntime</span>().<span class="built_in">registerNativeFree</span>((<span class="type">int</span>)Math.<span class="built_in">min</span>(size, Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向<code>VM</code>注册<code>native</code>内存，比便在内存占用达到界限时触发<code>GC</code>，在该<code>native</code>内存回收时，需要向<code>VM</code>注销该内存量</p><hr><h4 id="对比-Android-8-0-之前回收-native-内存的方式"><a href="#对比-Android-8-0-之前回收-native-内存的方式" class="headerlink" title="对比 Android 8.0 之前回收 native 内存的方式"></a>对比 Android 8.0 之前回收 native 内存的方式</h4><p>前面我们已经分析完<code>NativeAllocationRegistry</code>的源码了，我们看一看在<code>Android 8.0</code>之前，<code>Bitmap</code>是用什么方法回收<code>native</code>内存的，涉及文件： <a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.0_r1/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java">&#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java</a></p><ul><li>共同点：<ul><li><strong>分配的<code>native</code>层内存需要向<code>VM</code>注册 &#x2F; 注销</strong></li><li><strong>通过一个<code>native</code>层的内存回收函数来回收内存</strong></li></ul></li><li>不同点：<ul><li><strong><code>NativeAllocationRegistry</code>依赖于<code>sun.misc.Cleaner.java</code></strong></li><li><strong><code>BitmapFinalizer</code>依赖于<code>Object#finalize()</code></strong></li></ul></li></ul><p>我们知道，<code>finalize()</code>在<code>Java</code>对象被垃圾回收时会调用，<code>BitmapFinalizer</code>就是利用了这个机制来回收<code>native</code>层内存的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以下是关于 finalize() 方法的一些要点：</span><br><span class="line"></span><br><span class="line">finalize() 方法的定义： finalize() 是一个在 <span class="selector-tag">Object</span> 类中定义的方法，所有的 Java 类都可以选择覆盖它。它的签名为 protected void finalize() throws Throwable。</span><br><span class="line">垃圾回收触发： 当垃圾回收器决定要回收一个对象时（即对象变得不可达），在回收对象之前，会调用对象的 finalize() 方法。这个方法可能会在对象被回收之前执行一些清理操作，例如释放底层资源或资源的解引用。</span><br><span class="line">finalize() 方法的调用时机不确定： 由于垃圾回收的时机是不确定的，因此 finalize() 方法的调用时机也是不确定的。这意味着不能依赖于它来进行资源的及时释放或其他重要的清理操作。</span><br><span class="line">避免过度依赖 finalize()： 由于 finalize() 方法的调用时机不确定，且可能会影响性能，通常不建议过度依赖它。更好的做法是使用显式的资源管理，例如使用 try-finally 块来确保资源的释放。</span><br><span class="line">不同的垃圾回收方式： Java 使用不同的垃圾回收策略，包括标记-清除、标记-压缩等。在不同的垃圾回收方式中，finalize() 方法的调用时机可能会有所不同。</span><br><span class="line">需要注意的是，自从 Java <span class="number">9</span> 开始，finalize() 方法已经被标记为废弃（deprecated），这意味着在未来的 Java 版本中可能会被移除。推荐的做法是使用更可靠的资源管理和垃圾回收机制，例如使用 AutoCloseable 接口和 try-with-resources 语句来确保资源的正确释放。</span><br></pre></td></tr></table></figure><p>再举几个常用的类在<code>Android 8.0</code>之前的源码为例子，原理都大同小异：<a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.1_r10/xref/frameworks/base/graphics/java/android/graphics/Matrix.java">Matrix.java (before Android 8.0)</a>、<a href="https://links.jianshu.com/go?to=http://androidxref.com/6.0.1_r10/xref/frameworks/base/graphics/java/android/graphics/Canvas.java">Canvas.java (before Android 8.0)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        finalizer(native_instance);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">finalizer</span><span class="params">(<span class="type">long</span> native_instance)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Canvas.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CanvasFinalizer mFinalizer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CanvasFinalizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mNativeCanvasWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CanvasFinalizer</span><span class="params">(<span class="type">long</span> nativeCanvas)</span> &#123;</span><br><span class="line">        mNativeCanvasWrapper = nativeCanvas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeCanvasWrapper != <span class="number">0</span>) &#123;</span><br><span class="line">            finalizer(mNativeCanvasWrapper);</span><br><span class="line">            mNativeCanvasWrapper = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Canvas</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line">    mFinalizer = <span class="keyword">new</span> <span class="title class_">CanvasFinalizer</span>(mNativeCanvasWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题回归"><a href="#问题回归" class="headerlink" title="问题回归"></a>问题回归</h4><ul><li><strong><code>NativeAllocationRegistry</code>利用虚引用感知<code>Java</code>对象被回收的时机，来回收<code>native</code>层内存</strong></li><li><strong>在<code>Android 8.0 (API 27)</code>之前，<code>Android</code>通常使用<code>Object#finalize()</code>调用时机来回收<code>native</code>层内存</strong></li></ul><h3 id="Bitmap-的内存复用"><a href="#Bitmap-的内存复用" class="headerlink" title="Bitmap 的内存复用"></a>Bitmap 的内存复用</h3><p>Bitmap 绝对是我们 Android 开发中最容易引起 OOM 的对象之一，因为其占用的像素数据内存比较大，而加载图片又是很常见的操作。如果不断反复的去开辟和销毁 Bitmap 数据内存，势必可能会引起应用的内存抖动，因此 Google 的开发者也为我们想了一些办法，那就是允许 Bitmap 内存复用，具体如下：</p><ul><li><p>被复用的 Bitmap 必须为 Mutable（通过 BitmapFactory.Options 设置）</p><p>这是因为复用操作涉及对 Bitmap 对象像素数据的修改，而只有 Mutable 的 Bitmap 才允许对其像素数据进行修改。</p></li><li><p>4.4 之前</p><ol><li><strong>图像格式：</strong> 被复用的 Bitmap 和要解码的图像必须具有相同的像素格式，通常是 ARGB_8888 或 RGB_565 格式。这是因为像素格式的不匹配可能导致解码失败或图像显示异常。</li><li><strong>图像尺寸：</strong> 被复用的 Bitmap 和要解码的图像必须具有相同的尺寸。如果尺寸不匹配，复用操作将被忽略。</li><li><strong>图像类型：</strong> 在 Android 4.4 之前，被复用的 Bitmap 和要解码的图像必须是 JPEG 或 PNG 格式。其他格式的图像将无法被复用。</li><li><strong>inSampleSize 设置：</strong> <code>BitmapFactory.Options</code> 的 <code>inSampleSize</code> 字段必须设置为 1，以表示不进行图像的缩放。这是因为在进行图像缩放的情况下，图像的尺寸和复用的 Bitmap 尺寸可能不匹配。</li></ol></li><li><p>4.4 以后</p><p><code>BitmapFactory.Options</code> 的 <code>inBitmap</code> 字段用于指定要复用的 <code>Bitmap</code> 对象。通过设置这个字段，你可以告诉解码器将解码后的图像数据存储在已经存在的 <code>Bitmap</code> 中，以便进行复用。</p><p>同时，要注意以下几点：</p><ol><li>被解码的图像的内存大小不应该超过要复用的 <code>Bitmap</code> 的内存大小。</li><li>被解码的图像和要复用的 <code>Bitmap</code> 的像素格式和尺寸应该匹配。</li><li>解码时需要设置 <code>inSampleSize</code> 为 1，以确保图像不会被缩放。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不复用的写法，消耗内存 32 M</span></span><br><span class="line"><span class="built_in">logMemory</span>();</span><br><span class="line">Bitmap bitmap1 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2);</span><br><span class="line">Bitmap bitmap2 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2);</span><br><span class="line"><span class="built_in">logMemory</span>();</span><br><span class="line"><span class="comment">// 复用的写法，消耗内存 16 M</span></span><br><span class="line"><span class="built_in">logMemory</span>();</span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.<span class="built_in">Options</span>();</span><br><span class="line">options.inMutable = <span class="literal">true</span>;</span><br><span class="line">Bitmap bitmap1 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2, options);</span><br><span class="line">options.inBitmap = bitmap1;</span><br><span class="line">Bitmap bitmap2 = BitmapFactory.<span class="built_in">decodeResource</span>(<span class="built_in">getResources</span>(), R.drawable.test2, options);</span><br><span class="line"><span class="built_in">logMemory</span>();</span><br></pre></td></tr></table></figure><p>在 Glide 中，Bitmap 复用是通过使用 <code>BitmapPool</code> 接口来实现的。<code>BitmapPool</code> 是一个用于管理和复用 Bitmap 对象的接口，它允许 Glide 在加载和显示图像时复用之前分配的 Bitmap 对象，从而减少内存分配和垃圾回收的开销。</p><p>以下是简要的 Glide Bitmap 复用的流程：</p><ol><li>Glide 首先会尝试从 <code>BitmapPool</code> 中获取一个可复用的 Bitmap 对象。如果 <code>BitmapPool</code> 中存在满足条件的 Bitmap，就会使用它。</li><li>如果 <code>BitmapPool</code> 中没有可复用的 Bitmap，Glide 会根据要加载的图像的尺寸和像素格式创建一个新的 Bitmap 对象。</li><li>加载和显示图像时，Glide 会将 Bitmap 对象放入 <code>BitmapPool</code>，以便以后可以复用。</li></ol><p>为了更深入地了解 Glide 中 Bitmap 复用的实现，你可以查阅 Glide 的源代码，并关注以下关键部分：</p><ol><li><code>BitmapPool</code> 接口及其实现类：Glide 使用 <code>BitmapPool</code> 接口来管理 Bitmap 对象的复用。<code>BitmapPool</code> 接口定义了一系列的方法，如 <code>get()</code> 获取可复用的 Bitmap，<code>put()</code> 将 Bitmap 放回池中等。在 Glide 源代码中，你可以查看 <code>LruBitmapPool</code> 和其他的 <code>BitmapPool</code> 实现类。</li><li><code>BitmapImageViewTarget</code>：Glide 使用 <code>BitmapImageViewTarget</code> 来将 Bitmap 显示在 ImageView 中。在这个类中，你可以看到 Glide 如何从 <code>BitmapPool</code> 中获取可复用的 Bitmap 对象。</li><li>图片加载流程：Glide 的图片加载流程涉及到许多类和接口，包括请求管理、数据加载、资源解码等。在这些类中，你可以找到 Glide 如何利用 Bitmap 复用来优化内存使用。</li></ol><h4 id="Glide-Bitmap-复用源代码分析"><a href="#Glide-Bitmap-复用源代码分析" class="headerlink" title="Glide Bitmap 复用源代码分析"></a>Glide Bitmap 复用源代码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bumptech.glide.load.engine.bitmap_recycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.annotation.TargetApi;</span><br><span class="line"><span class="keyword">import</span> android.content.ComponentCallbacks2;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.util.Synthetic;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool&#125; implementation that uses an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.bumptech.glide.load.engine.bitmap_recycle.LruPoolStrategy&#125; to bucket &#123;<span class="doctag">@link</span> Bitmap&#125;s</span></span><br><span class="line"><span class="comment"> * and then uses an LRU eviction policy to evict &#123;<span class="doctag">@link</span> android.graphics.Bitmap&#125;s from the least</span></span><br><span class="line"><span class="comment"> * recently used bucket in order to keep the pool below a given maximum size limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruBitmapPool</span> <span class="keyword">implements</span> <span class="title class_">BitmapPool</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;LruBitmapPool&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bitmap.<span class="type">Config</span> <span class="variable">DEFAULT_CONFIG</span> <span class="operator">=</span> Bitmap.Config.ARGB_8888;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LruPoolStrategy strategy;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Bitmap.Config&gt; allowedConfigs;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> initialMaxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BitmapTracker tracker;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> maxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> currentSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> hits;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> misses;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> puts;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> evictions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exposed for testing only.</span></span><br><span class="line">  LruBitmapPool(<span class="type">long</span> maxSize, LruPoolStrategy strategy, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123;</span><br><span class="line">    <span class="built_in">this</span>.initialMaxSize = maxSize;</span><br><span class="line">    <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    <span class="built_in">this</span>.allowedConfigs = allowedConfigs;</span><br><span class="line">    <span class="built_in">this</span>.tracker = <span class="keyword">new</span> <span class="title class_">NullBitmapTracker</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for LruBitmapPool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxSize The initial maximum size of the pool in bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LruBitmapPool</span><span class="params">(<span class="type">long</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for LruBitmapPool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxSize The initial maximum size of the pool in bytes.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> allowedConfigs A white listed put of &#123;<span class="doctag">@link</span> android.graphics.Bitmap.Config&#125; that are</span></span><br><span class="line"><span class="comment">   *     allowed to be put into the pool. Configs not in the allowed put will be rejected.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LruBitmapPool</span><span class="params">(<span class="type">long</span> maxSize, Set&lt;Bitmap.Config&gt; allowedConfigs)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(maxSize, getDefaultStrategy(), allowedConfigs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of cache hits for bitmaps in the pool. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">hitCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hits;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of cache misses for bitmaps in the pool. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">missCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> misses;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of bitmaps that have been evicted from the pool. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">evictionCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evictions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the current size of the pool in bytes. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCurrentSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMaxSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setSizeMultiplier</span><span class="params">(<span class="type">float</span> sizeMultiplier)</span> &#123;</span><br><span class="line">    maxSize = Math.round(initialMaxSize * sizeMultiplier);</span><br><span class="line">    evict();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Bitmap must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!bitmap.isMutable()</span><br><span class="line">        || strategy.getSize(bitmap) &gt; maxSize</span><br><span class="line">        || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(</span><br><span class="line">            TAG,</span><br><span class="line">            <span class="string">&quot;Reject bitmap from pool&quot;</span></span><br><span class="line">                + <span class="string">&quot;, bitmap: &quot;</span></span><br><span class="line">                + strategy.logBitmap(bitmap)</span><br><span class="line">                + <span class="string">&quot;, is mutable: &quot;</span></span><br><span class="line">                + bitmap.isMutable()</span><br><span class="line">                + <span class="string">&quot;, is allowed config: &quot;</span></span><br><span class="line">                + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class="line">      &#125;</span><br><span class="line">      bitmap.recycle();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> strategy.getSize(bitmap);</span><br><span class="line">    strategy.put(bitmap);</span><br><span class="line">    tracker.add(bitmap);</span><br><span class="line"></span><br><span class="line">    puts++;</span><br><span class="line">    currentSize += size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Put bitmap in pool=&quot;</span> + strategy.logBitmap(bitmap));</span><br><span class="line">    &#125;</span><br><span class="line">    dump();</span><br><span class="line"></span><br><span class="line">    evict();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> Bitmap <span class="title function_">get</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> getDirtyOrNull(width, height, config);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Bitmaps in the pool contain random data that in some cases must be cleared for an image</span></span><br><span class="line">      <span class="comment">// to be rendered correctly. we shouldn&#x27;t force all consumers to independently erase the</span></span><br><span class="line">      <span class="comment">// contents individually, so we do so here. See issue #131.</span></span><br><span class="line">      result.eraseColor(Color.TRANSPARENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = createBitmap(width, height, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Bitmap <span class="title function_">getDirty</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> getDirtyOrNull(width, height, config);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      result = createBitmap(width, height, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title function_">createBitmap</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="meta">@Nullable</span> Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(width, height, config != <span class="literal">null</span> ? config : DEFAULT_CONFIG);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.O)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotHardwareConfig</span><span class="params">(Bitmap.Config config)</span> &#123;</span><br><span class="line">    <span class="comment">// Avoid short circuiting on sdk int since it breaks on some versions of Android.</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config == Bitmap.Config.HARDWARE) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">          <span class="string">&quot;Cannot create a mutable Bitmap with config: &quot;</span></span><br><span class="line">              + config</span><br><span class="line">              + <span class="string">&quot;. Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your&quot;</span></span><br><span class="line">              + <span class="string">&quot; RequestOptions and/or in GlideBuilder.setDefaultRequestOptions&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> Bitmap <span class="title function_">getDirtyOrNull</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> width, <span class="type">int</span> height, <span class="meta">@Nullable</span> Bitmap.Config config)</span> &#123;</span><br><span class="line">    assertNotHardwareConfig(config);</span><br><span class="line">    <span class="comment">// Config will be null for non public config types, which can lead to transformations naively</span></span><br><span class="line">    <span class="comment">// passing in null as the requested config here. See issue #194.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> strategy.get(width, height, config != <span class="literal">null</span> ? config : DEFAULT_CONFIG);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Missing bitmap=&quot;</span> + strategy.logBitmap(width, height, config));</span><br><span class="line">      &#125;</span><br><span class="line">      misses++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hits++;</span><br><span class="line">      currentSize -= strategy.getSize(result);</span><br><span class="line">      tracker.remove(result);</span><br><span class="line">      normalize(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Get bitmap=&quot;</span> + strategy.logBitmap(width, height, config));</span><br><span class="line">    &#125;</span><br><span class="line">    dump();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setting these two values provides Bitmaps that are essentially equivalent to those returned</span></span><br><span class="line">  <span class="comment">// from Bitmap.createBitmap.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normalize</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">    bitmap.setHasAlpha(<span class="literal">true</span>);</span><br><span class="line">    maybeSetPreMultiplied(bitmap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maybeSetPreMultiplied</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      bitmap.setPremultiplied(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;clearMemory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressLint(&quot;InlinedApi&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimMemory</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;trimMemory, level=&quot;</span> + level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND)</span><br><span class="line">        || ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)</span><br><span class="line">            &amp;&amp; (level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN))) &#123;</span><br><span class="line">      clearMemory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN)</span><br><span class="line">        || (level == ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL)) &#123;</span><br><span class="line">      trimToSize(getMaxSize() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">removed</span> <span class="operator">=</span> strategy.removeLast();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> This shouldn&#x27;t ever happen, see #331.</span></span><br><span class="line">      <span class="keyword">if</span> (removed == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">          Log.w(TAG, <span class="string">&quot;Size mismatch, resetting&quot;</span>);</span><br><span class="line">          dumpUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">        currentSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tracker.remove(removed);</span><br><span class="line">      currentSize -= strategy.getSize(removed);</span><br><span class="line">      evictions++;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Evicting bitmap=&quot;</span> + strategy.logBitmap(removed));</span><br><span class="line">      &#125;</span><br><span class="line">      dump();</span><br><span class="line">      removed.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dump</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      dumpUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.v(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;Hits=&quot;</span></span><br><span class="line">            + hits</span><br><span class="line">            + <span class="string">&quot;, misses=&quot;</span></span><br><span class="line">            + misses</span><br><span class="line">            + <span class="string">&quot;, puts=&quot;</span></span><br><span class="line">            + puts</span><br><span class="line">            + <span class="string">&quot;, evictions=&quot;</span></span><br><span class="line">            + evictions</span><br><span class="line">            + <span class="string">&quot;, currentSize=&quot;</span></span><br><span class="line">            + currentSize</span><br><span class="line">            + <span class="string">&quot;, maxSize=&quot;</span></span><br><span class="line">            + maxSize</span><br><span class="line">            + <span class="string">&quot;\nStrategy=&quot;</span></span><br><span class="line">            + strategy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LruPoolStrategy <span class="title function_">getDefaultStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> LruPoolStrategy strategy;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      strategy = <span class="keyword">new</span> <span class="title class_">SizeConfigStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strategy = <span class="keyword">new</span> <span class="title class_">AttributeStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.O)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Bitmap.Config&gt; getDefaultAllowedConfigs() &#123;</span><br><span class="line">    Set&lt;Bitmap.Config&gt; configs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(Bitmap.Config.values()));</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      <span class="comment">// GIFs, among other types, end up with a native Bitmap config that doesn&#x27;t map to a java</span></span><br><span class="line">      <span class="comment">// config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured</span></span><br><span class="line">      <span class="comment">// and are suitable for re-use.</span></span><br><span class="line">      configs.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">      configs.remove(Bitmap.Config.HARDWARE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(configs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">BitmapTracker</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bitmap bitmap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Bitmap bitmap)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">  <span class="comment">// Only used for debugging</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThrowingBitmapTracker</span> <span class="keyword">implements</span> <span class="title class_">BitmapTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Bitmap&gt; bitmaps = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Bitmap&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (bitmaps.contains(bitmap)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t add already added bitmap: &quot;</span></span><br><span class="line">                + bitmap</span><br><span class="line">                + <span class="string">&quot; [&quot;</span></span><br><span class="line">                + bitmap.getWidth()</span><br><span class="line">                + <span class="string">&quot;x&quot;</span></span><br><span class="line">                + bitmap.getHeight()</span><br><span class="line">                + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      bitmaps.add(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!bitmaps.contains(bitmap)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot remove bitmap not in tracker&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      bitmaps.remove(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NullBitmapTracker</span> <span class="keyword">implements</span> <span class="title class_">BitmapTracker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synthetic</span></span><br><span class="line">    NullBitmapTracker() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对代码进行逐段分析：</p><ol><li>导入相关的包和类。</li><li>定义了一个名为 “LruBitmapPool” 的类，实现了 “BitmapPool” 接口，用于管理位图内存池。</li><li>定义了一些常量，如默认的位图配置和日志标签。</li><li>声明了一些成员变量，包括内存池策略、允许的位图配置、最大大小、当前大小、命中次数、未命中次数、添加次数和驱逐次数等。</li><li>构造函数，初始化内存池大小、策略和允许的位图配置等。</li><li>提供了一些公开方法用于获取统计信息，如命中次数、未命中次数、驱逐次数、当前大小等。</li><li>实现了 “BitmapPool” 接口中的一些方法，包括 setSizeMultiplier、put、get、getDirty、clearMemory、trimMemory 等。</li><li>定义了一些辅助方法，如 evict、assertNotHardwareConfig、normalize、maybeSetPreMultiplied、getDirtyOrNull、trimToSize、dump 和 dumpUnchecked 等。</li><li>定义了 “BitmapTracker” 接口，其中包含了添加和移除位图的方法。</li><li>定义了一些实现了 “BitmapTracker” 接口的类，如 “ThrowingBitmapTracker” 和 “NullBitmapTracker”。</li></ol><p>总体来说，这段代码实现了一个基于 LRU（Least Recently Used）算法的位图内存池，用于管理位图对象的内存分配和回收。它可以跟踪位图的使用情况，限制内存池的大小，通过策略进行位图的管理和驱逐，以及提供一些统计信息用于优化和调试。</p><h4 id="Gilde-是如何实现-Bitmap-复用的？"><a href="#Gilde-是如何实现-Bitmap-复用的？" class="headerlink" title="Gilde 是如何实现 Bitmap 复用的？"></a>Gilde 是如何实现 Bitmap 复用的？</h4><p>在这段代码中，实现位图复用的核心思想是通过内存池策略（<code>LruPoolStrategy</code>）来管理位图的存储和获取。下面我将详细解释如何实现位图的复用：</p><ol><li><p><code>put(Bitmap bitmap)</code> 方法：<br>当你想要回收一个位图时，会调用这个方法。它会首先判断位图是否为空、是否已经被回收、是否是可变的位图，位图大小是否超过了内存池的最大大小，以及位图的配置是否允许被放入内存池。如果这些条件都满足，它会将位图放入内存池策略中，并更新当前内存池的大小。</p></li><li><p><code>get(int width, int height, Bitmap.Config config)</code> 和 <code>getDirty(int width, int height, Bitmap.Config config)</code> 方法：<br>当你想要获取一个位图时，会调用这两个方法之一。它首先会尝试从内存池策略中获取满足条件的位图，如果找到则返回该位图，否则会创建一个新的位图并返回。这里的位图创建使用了 <code>Bitmap.createBitmap()</code> 方法，确保了返回的位图是可复用的。</p></li><li><p><code>trimToSize(long size)</code> 方法：<br>当内存池的当前大小超过了最大限制时，会调用这个方法进行驱逐。它会循环地从内存池策略中移除最近未使用的位图，直到当前内存池大小小于等于指定的大小。</p></li><li><p><code>LruPoolStrategy</code> 接口的实现：<br>这个接口定义了位图内存池策略的规范，包括位图的添加、获取、移除等操作。在这段代码中，有两个实现类：<code>SizeConfigStrategy</code> 和 <code>AttributeStrategy</code>，分别在不同的 Android 版本上进行位图的管理。</p></li></ol><p>通过这些机制，当位图被回收时，它会被添加到内存池中，下次需要位图时会优先从内存池中获取，以达到位图复用的效果。这样可以减少内存分配和回收的开销，提高性能和效率。</p><hr><p>BitMap 创建，内存申请与内存模型相关内容整理参考自</p><p>作者：红橙Darren<br>链接：<a href="https://www.jianshu.com/p/8e8ad414237e">https://www.jianshu.com/p/8e8ad414237e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>具体回收细节参考自</p><p>版权声明：本文为CSDN博主「shihongyu12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/shihongyu12345/article/details/89681948">https://blog.csdn.net/shihongyu12345/article/details/89681948</a></p><p>NativeAllocationRegistry 的原理与设计思想 摘录自</p><p>作者：彭旭锐<br>链接：<a href="https://www.jianshu.com/p/6f042f9e47a8">https://www.jianshu.com/p/6f042f9e47a8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>部分相关知识来自于 chat-GPT 3.5</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.0 - 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android-Framework-AMS专项-Activity启动的整体流程与第一个阶段解读参数</title>
      <link href="/2023/08/15/3%20Android/Framework/05-Android-Framework-AMS%E4%B8%93%E9%A1%B9-Activity%E5%90%AF%E5%8A%A8%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%A7%A3%E8%AF%BB%E5%8F%82%E6%95%B0/"/>
      <url>/2023/08/15/3%20Android/Framework/05-Android-Framework-AMS%E4%B8%93%E9%A1%B9-Activity%E5%90%AF%E5%8A%A8%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%A7%A3%E8%AF%BB%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Activity-启动整体流程分析"><a href="#Activity-启动整体流程分析" class="headerlink" title="Activity 启动整体流程分析"></a>Activity 启动整体流程分析</h1><p>我们把 Activity 的启动简单分为几个部分</p><ul><li><p>Intent </p><p>startActivity(intent):<br>ActivityAActivityB </p></li><li><p>解析 Activity 启动参数<br>  ActivityRecord </p></li><li><p>activityStack ActivityRecord，管理和启动 ActivityB</p></li><li><p>AMS:<br>  activityStackSupervisor: 封装 clientTransaction（触发事件）</p></li><li><p>通信的流程：clientTransaction<br>  Application: process Activit</p></li></ul><h1 id="Activity-启动第一阶段解析参数"><a href="#Activity-启动第一阶段解析参数" class="headerlink" title="Activity 启动第一阶段解析参数"></a>Activity 启动第一阶段解析参数</h1><p>ActivityStarter：解析 Activity 启动参数，每一个 Activity 启动都会有一个 Starter 去启动它。<br>ActivityStartController：Controller 回去生产 Starter 对象，控制 Starter 的创建。</p><p>Q：为什么需要 ActivityStartController？</p><h2 id="AMS-和-ATMS"><a href="#AMS-和-ATMS" class="headerlink" title="AMS 和 ATMS"></a>AMS 和 ATMS</h2><p> 在 Android 操作系统中，ATMS（ActivityTaskManagerService）和AMS（ActivityManagerService）是两个关键的系统服务，负责管理应用程序的生命周期和任务栈。它们在 Android 的多任务处理和应用管理方面扮演着重要角色。随着 Android 系统的发展，这两个服务的职责和架构也发生了一些变化。下面是它们之间主要的区别：</p><ol><li><p><strong>职责分工</strong>：</p><ul><li><strong>AMS（ActivityManagerService）</strong>：在 Android 10 及其之前的版本中，AMS 是负责管理系统中的所有活动（Activities）、应用进程和服务的核心服务。它处理应用的启动、切换、生命周期管理等任务。</li><li><strong>ATMS（ActivityTaskManagerService）</strong>：从 Android 10（API 级别 29）开始引入，ATMS 负责管理活动和任务的栈管理（Activity and Task Stack Management）。这意味着 ATMS 处理应用的 UI&#x2F;界面任务，如任务视图、活动栈、分屏模式和最近应用的管理。ATMS 实质上是从 AMS 中拆分出来的，专注于任务和活动栈的管理，而让 AMS 能更专注于后台进程和应用管理。</li></ul></li><li><p><strong>架构变化</strong>：</p><ul><li>随着 Android 系统的发展，其架构也在不断演进。引入 ATMS 是 Android 系统为了更好地模块化和清晰地区分不同服务的职责而做的改变。这种变化有助于简化系统服务的管理，使得系统架构更加清晰，同时也为未来的扩展和维护提供了便利。</li></ul></li><li><p><strong>目的</strong>：</p><ul><li>分拆 AMS 和引入 ATMS 的目的是为了更好地分离和管理 Android 系统中的活动和任务栈管理逻辑，从而提高系统的稳定性和可维护性。ATMS 的引入，让 AMS 能够更加专注于进程管理和服务管理，而不是同时处理与 UI&#x2F;界面相关的复杂逻辑。</li></ul></li></ol><p>总结来说，ATMS 和 AMS 在 Android 10 之后的版本中共同工作，以更高效和清晰的方式管理应用的生命周期和用户界面任务。ATMS 的引入是 Android 系统架构演进的一个例证，显示了 Android 团队在不断追求更好的系统管理和性能优化方面的努力。</p><h2 id="ActivityStartController"><a href="#ActivityStartController" class="headerlink" title="ActivityStartController"></a>ActivityStartController</h2><p>Android 10 之前的版本，ActivityStartController 是在 AMS 的 initialize 时创建<br>Android 10 开始，AMS 分离出了一些职责到 ATMS 中，包含了 initialize</p><h3 id="starter，factory，pool-与-recycle，reset"><a href="#starter，factory，pool-与-recycle，reset" class="headerlink" title="starter，factory，pool 与 recycle，reset"></a>starter，factory，pool 与 recycle，reset</h3><p>在这个 initalize 中初始化了 ActivityStartController<br>ActivityStartController 初始化时去获取 starter</p><p>实际上是由 ActivityStartController 初始化时去 创建了一个 Factory<br>这个  Factory 是定义在 ActivityStartController 内部的 DefaultFactory，通过 DefaultFactory 的 obtain 函数去获取一个 ActivityStarter</p><p>DefaultFactory 中构建了一个 synchronizedPool<ActivityStarter>  复用池子，就和 Hanlder 一样，通过 obtain 去获取 ActivityStarter，设置三个缓存<br>采用享元模式去复用，避免内存抖动，同样的，使用完之后要去 recycle，recycle 的时候要去 reset，之后添加回 pool</ActivityStarter></p><p>所以 本质上是使用工厂模式去建造 ActivityStartController 缓存池，并管控 ActivityStartController 的复用，由 AMS 创建</p><h2 id="Activity-的启动参数到底被谁持有了？"><a href="#Activity-的启动参数到底被谁持有了？" class="headerlink" title="Activity 的启动参数到底被谁持有了？"></a>Activity 的启动参数到底被谁持有了？</h2><p> activity 的启动参数实际上是被添加到了 ActivityStarter 的 Request 中，之后执行 ActivityStarter 的 execute 函数</p><p>Request 是 Activity 的内部类，在这个内部类中包含了 Activity 启动过程中一系列的交互参数<br>比如我们要从 Activity A 启动 Activity B，这个过程中需要记录 Activity A 与 Activity B 的核心参数（ 如果我们对 Activity A 启动 Activity B 之后，Activity A 和 B 生命周期函数的执行顺序有所了解，就非常容易理解这里为什么需要记录 A B 双方的核心参数，启动 B 的过程也是 A B 进行交互的过程） </p><p>ActivityStarter 的 execute 函数会执行 executeRequest， 这时候 ActivityStarter 就会去创建一个 ActivityRecord，这就是我们要启动的 Activity</p><p>在启动之前，会先执行 ActivityStartController 的 doPendingActivityLaunches 函数<br>这个函数是用来启动那些没有来得及启动的 Activity（举个例子，在启动之前按了 Home 键）</p><p>之后再调用 StartActivityUnchecked，其中调用 StartActivityInner<br>这里注意下 StartActivityInner 头两个参数是 final ActivityRecord r，ActivityRecord sourceRecord<br>这个函数里会计算 ActivityRecord （要启动的 Activity 的 task 标志），也就是启动模式，接着计算 sourceRecord（源 Activity）所在的 task，将计算后的启动模式 mLaunchFlags 设置给 Intent （ <code>mIntent.setFlags(mLaunchFlags)</code> ）</p><h2 id="Launcher-启动创建黑白屏"><a href="#Launcher-启动创建黑白屏" class="headerlink" title="Launcher 启动创建黑白屏"></a>Launcher 启动创建黑白屏</h2><p>注意完成上述操作之后我们去调用 Launcher 去启动一个 Activity 的时候，为了让用户知道我们已经进行了响应，会启动一个黑白屏</p><p>Q：这个时候 Activity 有启动吗？</p><p>A：并没有，上述操作只是在构建一个 Activity 的启动流程，并没有真正的去启动一个 Activity，因为 Activity 必须依附于一个进程存在，所以黑白屏是为了表示已经开始响应启动流程，但是进程的创建是一个相对缓慢的过程，之后进程创建之后才会启动 Activity</p><h2 id="Activity的真正启动"><a href="#Activity的真正启动" class="headerlink" title="Activity的真正启动"></a>Activity的真正启动</h2><p>启动完黑白屏之后，通过调用 mRootWindowContainer.resumeFocusedStackTopActivities 启动 Activity</p><p>首先，什么是 RootWindowContainer，注释上写 RootWindowContainer 就是 WindowContainer 的根容器，管理了所有窗口容器，<br>设备上所有的窗口（Window）、显示（Display）都是由它管理的 它通过 <code>RootWindowContainer</code> 来检查当前任务栈顶部的 <code>Activity</code> 是否真的可见。</p><p>在这个过程中，<code>RootWindowContainer</code> 会考虑多个因素来确定一个 <code>Activity</code> 的可见性，包括但不限于：</p><ul><li><strong>屏幕的显示状态</strong>：例如，如果设备处于锁屏状态，则处于前台的 <code>Activity</code> 可能不会被认为是可见的。</li><li><strong>其他应用的窗口</strong>：例如，如果有一个全屏模式的应用或是一个浮动窗口覆盖在当前 <code>Activity</code> 上方，可能会影响当前 <code>Activity</code> 的可见性。</li><li><strong>系统对话框或通知</strong>：这些元素也可能覆盖在活动 <code>Activity</code> 上方，影响其可见性。</li><li><strong>分屏模式</strong>：在分屏模式下，两个 <code>Activity</code> 可以同时处于可见状态，<code>RootWindowContainer</code> 需要管理这些 <code>Activity</code> 的可见性和布局。</li></ul><p>基于上述因素的判断，如果 <code>RootWindowContainer</code> 确定任务栈顶部的 <code>Activity</code> 是可见的，<code>resumeFocusedStackTopActivities</code> 方法就会继续执行，恢复该 <code>Activity</code>。这个过程涉及调用 <code>Activity</code> 的 <code>onResume()</code> 方法，使其成为用户可以与之交互的活动界面。</p><p>这一机制确保了 Android 系统在恢复 <code>Activity</code> 时能够正确地管理用户界面的状态和交互，保持应用的流畅运行和用户体验的一致性。</p><p>当启动一个新的 <code>Activity</code> 时，<code>resumeFocusedStackTopActivities</code> 方法负责将这个新的 <code>Activity</code> 放置到正确的任务栈和位置上。如果判断结果为 !resumeOnDisplay，并且 focusedStack !&#x3D; null，那么就会执行 focusedStack.resumeTopActivityUncheckLocked，进入启动的第二阶段</p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06-Android-Framework-AMS专项-Activity生命周期事物封装</title>
      <link href="/2023/08/15/3%20Android/Framework/06-Android-Framework-AMS%E4%B8%93%E9%A1%B9-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E7%89%A9%E5%B0%81%E8%A3%85/"/>
      <url>/2023/08/15/3%20Android/Framework/06-Android-Framework-AMS%E4%B8%93%E9%A1%B9-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E7%89%A9%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>解读完启动参数之后，就进入到由 Activity 栈去管理和启动 Activity 的这个流程<br>ActivityRcord </p><p>创建 ActivityRcord 之后，利用 RootWindowContainer 去管理 ActivityWindow 的显示状态，（除了启动，恢复显示也会经过这个 RootWindowContainer）</p><p>首先会从 RootWindowContainer 进入 ActivityStack </p>]]></content>
      
      
      <categories>
          
          <category> 3 - Android </category>
          
          <category> 3.1 - Framework </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>协程中的取消和异常 （取消操作详解）</title>
      <link href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/"/>
      <url>/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在开发中，我们要避免不必要的的任务来节约设备的内存和电量的使用，协程也是如此。在使用的过程我们需要控制好它的生命周期，在不需要它的取消它。</p><h3 id="调用cancel方法"><a href="#调用cancel方法" class="headerlink" title="调用cancel方法"></a>调用cancel方法</h3><h4 id="取消作用域会取消它的子协程"><a href="#取消作用域会取消它的子协程" class="headerlink" title="取消作用域会取消它的子协程"></a>取消作用域会取消它的子协程</h4><p>当启动了很多个协程，我们一个个协程的取消比较麻烦，我们可以通过取消整个作用域来解决这个问题，因为取消作用域可以取消该作用域创建的所有协程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ 假设我们已经定义了一个作用域</span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">job1</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">job2</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"></span><br><span class="line">scope.cancel()</span><br></pre></td></tr></table></figure><p>假设我们创建了一个作用域scope,并创建了两个协程job1和job2。我们通过调用scope.cancel()，取消作用域，将会把job1 和job2两个协程都取消。</p><h4 id="单独取消某个协程，不会影响他的兄弟协程"><a href="#单独取消某个协程，不会影响他的兄弟协程" class="headerlink" title="单独取消某个协程，不会影响他的兄弟协程"></a>单独取消某个协程，不会影响他的兄弟协程</h4><p>我们创建了两个协程，job1和job2.我们单独取消job1，不会影响到job2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们已经定义了一个作用域</span></span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">job1</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">job2</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个协程将会被取消，而另一个则不受任何影响</span></span><br><span class="line">job1.cancel()</span><br></pre></td></tr></table></figure><h4 id="协程通过抛出一个特殊的异常-CancellationException-来处理取消操作"><a href="#协程通过抛出一个特殊的异常-CancellationException-来处理取消操作" class="headerlink" title="协程通过抛出一个特殊的异常 CancellationException 来处理取消操作"></a>协程通过抛出一个特殊的异常 CancellationException 来处理取消操作</h4><p>在调用cancel函数的时候，我们需要传入一个CancellationException对象,如果我们没有传入，那就用默认的defaultCancellationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// external cancel with cause, never invoked implicitly from internal machinery</span></span><br><span class="line">   <span class="keyword">public</span> override fun <span class="title function_">cancel</span><span class="params">(cause: CancellationException?)</span> &#123;</span><br><span class="line">       cancelInternal(cause ?: defaultCancellationException())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一旦抛出了CancellationException，我们就可以通过这一机制来处理协程的取消。在底层的实现中，子协程会通过抛出异常的方式将取消的情况通知它的父级，父协程通过传入的取消原因决定是否处理该异常。</p><h4 id="不能在已取消的作用域中再次启动新的协程"><a href="#不能在已取消的作用域中再次启动新的协程" class="headerlink" title="不能在已取消的作用域中再次启动新的协程"></a>不能在已取消的作用域中再次启动新的协程</h4><h4 id="调用了-cancel-方法为什么协程处理的任务没有停止？"><a href="#调用了-cancel-方法为什么协程处理的任务没有停止？" class="headerlink" title="调用了 cancel 方法为什么协程处理的任务没有停止？"></a>调用了 cancel 方法为什么协程处理的任务没有停止？</h4><p>不同的Diapatcher不同的区别，下一篇文章将介绍。<br> 我们以Dispatchers.Default为例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line">suspend fun <span class="title function_">main</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line">    <span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">nextTime</span> <span class="operator">=</span> startTime</span><br><span class="line">        <span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;这是第$&#123;i&#125;次&quot;</span>)</span><br><span class="line">                i++</span><br><span class="line">                <span class="comment">//1000毫秒执行一次</span></span><br><span class="line">                nextTime += <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;取消&quot;</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    println(<span class="string">&quot;取消完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是第<span class="number">0</span>次</span><br><span class="line">这是第<span class="number">1</span>次</span><br><span class="line">取消</span><br><span class="line">取消完毕</span><br><span class="line">这是第<span class="number">2</span>次</span><br><span class="line">这是第<span class="number">3</span>次</span><br><span class="line">这是第<span class="number">4</span>次</span><br></pre></td></tr></table></figure><p>调用cancel方法之后，协程的任务依然在运行。调用cancel方法的时候，此时协程处于cancelling正在取消的状态，接着我们打印了2，3，4，处理任务结束之后，协程变成cancelled已经取消的状态，这是以Default举例，Default调度会等待协程任务处理完毕才取消。</p><h4 id="让协程可以被取消"><a href="#让协程可以被取消" class="headerlink" title="让协程可以被取消"></a>让协程可以被取消</h4><p>协程处理任务都是协作式的，协作的意思就是我们的处理任务要配合协程取消做处理。因此在执行任务期间我们要定时检查协程的状态是否已经取消，例如我们从磁盘读取文件之前我们先检查协程是否被取消了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">    <span class="keyword">for</span>(file in files) &#123;</span><br><span class="line">        <span class="comment">// TODO 检查协程是否被取消</span></span><br><span class="line">        readFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程中的挂起函数都是可取消的，使用他们的时候，我们不需要检查协程是否已取消。例如withContext，delay 。如果没有这些挂起函数，为了让我们的代码配合协程取消，可以使用一下两种方法：</p><ul><li>检查 job.isActive 或者使用 ensureActive()</li><li>使用 yield() 来让其他任务进行</li></ul><h4 id="检查-job-的活跃状态"><a href="#检查-job-的活跃状态" class="headerlink" title="检查 job 的活跃状态"></a>检查 job 的活跃状态</h4><p>先看一下第一种方法，在我们的 while(i&lt;5) 循环中添加对于协程状态的检查:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为处于 launch 的代码块中，可以访问到 job.isActive 属性</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive)</span><br></pre></td></tr></table></figure><h4 id="使用-yield-函数运行其他任务"><a href="#使用-yield-函数运行其他任务" class="headerlink" title="使用 yield() 函数运行其他任务"></a>使用 yield() 函数运行其他任务</h4><h4 id="Job-join-和-Deferred-await-cancellation"><a href="#Job-join-和-Deferred-await-cancellation" class="headerlink" title="Job.join 和 Deferred.await cancellation"></a>Job.join 和 Deferred.await cancellation</h4><p>等待协程处理结果有两种方法，launch启动的job可以调用join，async 返回的Deferred 可以调用await方法</p><ul><li>job.join会让协程挂起，直到等待协程处理任务完毕，我们可以配合cancel使用</li><li>deferred.await()如果我们关心协程的处理结果，我们可以使用deferred。结果由deferred.await返回。也是job类型，也可以被取消。</li></ul><h4 id="处理协程取消的副作用"><a href="#处理协程取消的副作用" class="headerlink" title="处理协程取消的副作用"></a>处理协程取消的副作用</h4><p>当我们需要在协程取消 后处理一些清理的工作，或者做一些打印日志。我们有几种办法：</p><ul><li>通过检查协程的状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (…) &#123;</span><br><span class="line">        println(“Hello $&#123;i++&#125;”)</span><br><span class="line">        nextPrintTime += <span class="number">500L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 协程所处理的任务已经完成，因此我们可以做一些清理工作</span></span><br><span class="line">println(“Clean up!”</span><br></pre></td></tr></table></figure><p>当判断协程不是isActive状态的时候，我们可以做一些清理</p><ul><li>try catch finally<br> 我们知道协程的取消会抛出CancellationException 异常，我们可以在协程提中使用try catch finally，在finally中做我们的一些清理的工作，或者打印日志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      work()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: CancellationException)&#123;</span><br><span class="line">      println(“Work cancelled!”)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(“Clean up!”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000L</span>)</span><br><span class="line">println(“Cancel!”)</span><br><span class="line">job.cancel()</span><br><span class="line">println(“Done!</span><br></pre></td></tr></table></figure><h4 id="已经取消的协程，不能再被挂起"><a href="#已经取消的协程，不能再被挂起" class="headerlink" title="已经取消的协程，不能再被挂起"></a>已经取消的协程，不能再被挂起</h4><p>已经取消的协程，不能再被挂起，但是当我们需要在取消的协程中调用挂起函数，那么我们可以在finally中使用NonCancellable ，意思是让协程挂起，直到处理挂起函数中的代码完毕，协程才会取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      work()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: CancellationException)&#123;</span><br><span class="line">      println(“Work cancelled!”)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      withContext(NonCancellable)&#123;</span><br><span class="line">         delay(<span class="number">1000L</span>) <span class="comment">// 或一些其他的挂起函数</span></span><br><span class="line">         println(“Cleanup done!”)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000L</span>)</span><br><span class="line">println(“Cancel!”)</span><br><span class="line">job.cancel()</span><br><span class="line">println(“Done!</span><br></pre></td></tr></table></figure><p>在jetpack中使用viewModelScope 或者lifecycleScope 中定义的作用域，他们在scope完成后取消他们的处理任务。如果我们手动创建自己的作用域CoroutineScope，我们需要协作协程，将我们的作用域和job绑定，在需要的时候取消。</p>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.1 - Kotlin 协程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 的协程本质到底什么</title>
      <link href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/"/>
      <url>/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>几乎就是用阻塞的写法来完成非阻塞的任务。<br>Kotlin-JVM中所谓的协程是假协程<br>Kotlin-JVM中所谓的 协程挂起 ，就是开启了一个子线程去执行任务</p><p>对于Java来说，不管你用什么方法，只要你没有魔改JVM，那么最终你代码里start几个线程，操作系统就会创建几个线程，是1比1的关系。<br>Kotlin官网中那个创建10w个Kotlin协程没有oom的例子其实有误导性，本质上那10w个Kotlin协程就是10w个并发任务仅此而已，他下面运行的就是一个单线程的线程池。你往一个线程池里面丢多少个任务都不会OOM的（前提是你的线程池创建的时候设定了对应的拒绝策略，否则无界队列下，任务过多一定会OOM），因为在运行的始终是那几个线程。</p><p>创建协程的方式有五种：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope<span class="selector-class">.launch</span>&#123;&#125;</span><br><span class="line">launch&#123;&#125;</span><br><span class="line">runBlocking&#123;&#125;</span><br><span class="line">coroutineScope&#123;&#125;</span><br><span class="line">async&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.1 - Kotlin 协程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>协程核心概念的理解与应用(一)--翻译翻译什么是 CoroutineScope</title>
      <link href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/"/>
      <url>/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s21.ax1x.com/2024/03/09/pFymrC9.jpg" alt="图片描述"></p><p>作者：朕小猫与GPT4</p><h1 id="Android-如何在一个非-LifecycleOwner-的类中使用协程"><a href="#Android-如何在一个非-LifecycleOwner-的类中使用协程" class="headerlink" title="Android 如何在一个非 LifecycleOwner 的类中使用协程"></a>Android 如何在一个非 LifecycleOwner 的类中使用协程</h1><p>在非<code>LifecycleOwner</code>的类中使用协程，你不能直接使用与生命周期相关的作用域，如<code>lifecycleScope</code>或<code>viewModelScope</code>。不过，你可以使用<code>CoroutineScope</code>来创建自己的作用域。使用<code>CoroutineScope</code>，你可以定义一个作用域，并指定一个<code>Dispatcher</code>来控制协程的执行线程。此外，你还需要手动管理协程的生命周期，以避免内存泄漏。</p><p>以下是如何在非<code>LifecycleOwner</code>类中使用协程的一个基本示例：</p><ol><li><p><strong>定义协程作用域</strong>：首先，定义一个协程作用域，通常是类的成员变量。这个作用域应当与你希望协程执行的生命周期绑定。例如，如果你在一个普通类中工作，你可能需要在类被销毁时取消所有协程。</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.CoroutineScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Job</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> job = Job()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutineScope = CoroutineScope(Dispatchers.Main + job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在协程作用域内启动协程</strong>：使用定义的协程作用域启动协程，执行异步操作。</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ...前面的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineScope.launch &#123;</span><br><span class="line">            <span class="comment">// 在这里执行协程代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>管理协程生命周期</strong>：为避免内存泄漏，确保在不需要协程运行时取消它们。如果你的类有一个明确的生命周期结束点（如自定义视图的<code>onDetachedFromWindow</code>或者一个对象的<code>close</code>方法），你应当在那里取消作用域中的所有协程。</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    job.cancel() <span class="comment">// 取消与这个作用域相关的所有协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以在不依赖于<code>LifecycleOwner</code>的情况下，安全地在任何类中使用协程。记住，手动管理协程的生命周期是避免内存泄漏的关键。</p><h1 id="如何理解-CoroutineContext"><a href="#如何理解-CoroutineContext" class="headerlink" title="如何理解 CoroutineContext"></a>如何理解 CoroutineContext</h1><p><code>CoroutineContext</code>是Kotlin协程中用于持有协程相关配置的接口。它由一组元素组成，每个元素都实现了<code>CoroutineContext.Element</code>接口，并且通过一个唯一的<code>Key</code>进行标识。<code>CoroutineContext</code>的实现并不限于某些固定的子类，而是通过组合不同的<code>Element</code>实例来扩展其功能。这意味着<code>CoroutineContext</code>的“子类”实际上是指一系列标准库或自定义库中定义的实现了<code>CoroutineContext.Element</code>接口的类，这些类代表了不同的协程配置和特性。以下是一些常见的<code>CoroutineContext.Element</code>实现，它们在Kotlin协程的使用中扮演着关键角色：</p><ol><li><p><strong><code>Job</code></strong>: 控制协程的生命周期，允许启动、取消、和查询协程的状态。<code>Job</code>是协程工作的基本单位，可以被用来取消协程。</p></li><li><p><strong><code>CoroutineDispatcher</code></strong>: 决定协程在哪个线程或线程池上执行。<code>Dispatchers.Main</code>、<code>Dispatchers.IO</code>、和<code>Dispatchers.Default</code>是最常用的几种调度器。</p></li><li><p><strong><code>CoroutineName</code></strong>: 提供协程的名称，有助于调试。</p></li><li><p><strong><code>CoroutineExceptionHandler</code></strong>: 定义了协程如何处理未捕获的异常。可以用来全局或局部地处理异常。</p></li></ol><p>除了上述提到的标准元素外，开发者还可以实现自定义的<code>CoroutineContext.Element</code>来扩展协程的功能。每个元素都可以通过其<code>Key</code>加入到<code>CoroutineContext</code>中，同时保证<code>CoroutineContext</code>中的每个<code>Key</code>都是唯一的。</p><p>在实际应用中，这些元素可以通过<code>+</code>操作符组合在一起，形成一个包含多个配置的<code>CoroutineContext</code>，用于启动和管理协程。这种设计允许协程上下文在保持灵活性的同时，能够非常精确地控制协程的行为和环境。</p><h1 id="协程的-号代表什么"><a href="#协程的-号代表什么" class="headerlink" title="协程的 + 号代表什么"></a>协程的 + 号代表什么</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a context containing elements from this context and elements from  other [context].</span></span><br><span class="line"><span class="comment"> * The elements from this context with the same key as in the other one are dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> operator fun <span class="title function_">plus</span><span class="params">(context: CoroutineContext)</span>: CoroutineContext =</span><br><span class="line">    <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="built_in">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">        context.fold(<span class="built_in">this</span>) &#123; acc, element -&gt;</span><br><span class="line">            <span class="type">val</span> <span class="variable">removed</span> <span class="operator">=</span> acc.minusKey(element.key)</span><br><span class="line">            <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">interceptor</span> <span class="operator">=</span> removed[ContinuationInterceptor]</span><br><span class="line">                <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">val</span> <span class="variable">left</span> <span class="operator">=</span> removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                    <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                        CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个<code>plus</code>函数是<code>CoroutineContext</code>的一个操作符函数，用于合并两个协程上下文（<code>CoroutineContext</code>），返回一个包含两者元素的新上下文。如果两个上下文中有相同键（<code>key</code>）的元素，那么原上下文（<code>this</code>）中的元素会被丢弃。这个函数的主要逻辑可以分解为几个关键步骤：</p><ol><li><p><strong>快速路径检查</strong>：如果要添加的上下文（<code>context</code>）是一个空的协程上下文（<code>EmptyCoroutineContext</code>），则直接返回当前上下文（<code>this</code>），因为没有新元素需要添加。</p></li><li><p><strong>遍历合并</strong>：使用<code>fold</code>方法遍历<code>context</code>中的每个元素。<code>fold</code>接收一个初始累加值（这里是<code>this</code>，即当前上下文）和一个操作函数。操作函数定义了如何将<code>context</code>中的元素合并到累加值中。</p></li><li><p><strong>去除相同键的元素</strong>：对于<code>context</code>中的每个元素，先从累加值（即目前合并的结果）中移除具有相同键的元素。这一步确保了如果有相同键的元素，那么<code>this</code>中的元素会被<code>context</code>中的元素替换。</p></li><li><p><strong>合并上下文</strong>：如果移除相同键元素后的上下文是空的（<code>EmptyCoroutineContext</code>），则只添加当前遍历到的元素。否则，检查是否存在<code>ContinuationInterceptor</code>元素（协程拦截器），因为拦截器应当始终位于上下文中的最后，以便快速获取。</p></li><li><p><strong>调整拦截器位置</strong>：如果存在<code>ContinuationInterceptor</code>，将其移动到合并后的上下文的最后。这涉及到在没有拦截器的剩余上下文中添加当前元素，然后再添加拦截器。</p></li><li><p><strong>返回新的合并上下文</strong>：最终返回包含了<code>this</code>和<code>context</code>元素（且<code>context</code>中的元素优先）的新上下文。如果存在<code>ContinuationInterceptor</code>，确保它位于最后。</p></li></ol><p>简而言之，这个函数通过合并两个协程上下文并调整元素顺序，确保了新上下文中不会有重复的键，且<code>ContinuationInterceptor</code>（如果存在）总是位于最后，以优化性能。</p><h1 id="如何理解其中的-CoroutineContext-与-key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。"><a href="#如何理解其中的-CoroutineContext-与-key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。" class="headerlink" title="如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。"></a>如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。</h1><p><code>CoroutineContext</code>在Kotlin协程中是一个关键概念，它是一组各种元素的集合，这些元素定义了协程的行为。每个元素都有一个<code>Key</code>，用于唯一标识该元素的类型，这样<code>CoroutineContext</code>就可以通过键值对的方式存储和检索协程的配置和状态信息。这里的“相同键（key）的元素”意味着两个元素属于同一类型，或者说执行相同的功能或角色。</p><h3 id="CoroutineContext和-key"><a href="#CoroutineContext和-key" class="headerlink" title="CoroutineContext和 key"></a><code>CoroutineContext</code>和 key</h3><ul><li><p>**<code>CoroutineContext</code><strong>：是一个集合，包含了控制协程行为的各种元素，例如调度器（<code>Dispatcher</code>）、协程名称、协程的异常处理器等。每个元素通过一个唯一的键（</strong><code>Key</code>**）来识别，键通常由元素类型本身提供。</p></li><li><p><strong>相同键的元素</strong>：如果两个<code>CoroutineContext</code>元素具有相同的键，它们被视为同一类型的配置或状态信息。在合并上下文时，不能有重复键的元素，否则会产生冲突。</p></li></ul><h3 id="为什么context中的元素优先"><a href="#为什么context中的元素优先" class="headerlink" title="为什么context中的元素优先"></a>为什么<code>context</code>中的元素优先</h3><p>在合并两个<code>CoroutineContext</code>时，如果存在相同键的元素，<code>context</code>参数中的元素会替换当前上下文（<code>this</code>）中的元素。这个设计选择是基于函数式编程中常见的不可变性原则，以及配置更新的需求：新提供的配置（即<code>context</code>参数中的）被认为是最新的，应优先于旧的配置。这样，开发者可以灵活更新协程的行为，而无需担心旧上下文的状态。</p><h3 id="为什么ContinuationInterceptor位于最后"><a href="#为什么ContinuationInterceptor位于最后" class="headerlink" title="为什么ContinuationInterceptor位于最后"></a>为什么<code>ContinuationInterceptor</code>位于最后</h3><p><code>ContinuationInterceptor</code>是<code>CoroutineContext</code>中的一个特殊元素，用于拦截协程的执行。它是协程调度器（如<code>Dispatchers.Main</code>）的基础，控制着协程的执行线程。将<code>ContinuationInterceptor</code>放在合并后的<code>CoroutineContext</code>的最后，是出于性能考虑：</p><ul><li><p><strong>快速访问</strong>：协程在执行时频繁查询<code>ContinuationInterceptor</code>以确定执行线程。将其置于上下文的末尾可以优化这一查询过程，因为在<code>CoroutineContext</code>的实现中，较后的元素可以更快地被访问到。</p></li><li><p><strong>避免冲突</strong>：确保<code>ContinuationInterceptor</code>总是最后一个被添加，意味着即使合并多个上下文，也能保证只有一个有效的调度器在最终的上下文中生效，这避免了多个调度器可能导致的潜在冲突。</p></li></ul><p>综上所述，<code>CoroutineContext</code>及其键的概念允许协程行为的灵活配置和更新，而在合并上下文时优先考虑新的元素以及保持<code>ContinuationInterceptor</code>在最后，是出于更新优先级和性能优化的考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.1 - Kotlin 协程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android aar 文件到底是什么</title>
      <link href="/2023/08/11/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/Android%20aar%20%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2023/08/11/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/Android%20aar%20%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>作者: 朕小猫与GPT4</p><h1 id="问题起源：怎么打包发布一个含有-C-文件的-Library"><a href="#问题起源：怎么打包发布一个含有-C-文件的-Library" class="headerlink" title="问题起源：怎么打包发布一个含有 C++ 文件的 Library"></a>问题起源：怎么打包发布一个含有 C++ 文件的 Library</h1><p>起因是 KOOM 2.2.1 Release 存在后台分析进程在部分机型失效，想自己发布一个适合自己项目的版本。</p><h1 id="so文件可以被打包到最终的AAR文件中吗"><a href="#so文件可以被打包到最终的AAR文件中吗" class="headerlink" title=".so文件可以被打包到最终的AAR文件中吗"></a>.so文件可以被打包到最终的AAR文件中吗</h1><p>是的，<code>.so</code>文件可以并且通常被打包到最终的AAR（Android Archive）文件中。AAR文件是Android开发中用于分发Android库的标准格式，它包含了库所需的所有资源、编译后的代码以及其他文件，比如<code>.so</code>文件（本地库文件）。</p><h3 id="打包-so文件到AAR中的步骤"><a href="#打包-so文件到AAR中的步骤" class="headerlink" title="打包.so文件到AAR中的步骤"></a>打包<code>.so</code>文件到AAR中的步骤</h3><ol><li><p><strong>放置<code>.so</code>文件</strong>: 将你的<code>.so</code>文件放置在项目的<code>src/main/jniLibs/</code>目录下。按照不同的CPU架构，你可能需要创建相应的子目录，例如<code>armeabi-v7a</code>、<code>arm64-v8a</code>、<code>x86</code>等，然后将相应架构的<code>.so</code>文件放置在这些目录下。</p></li><li><p><strong>配置Gradle构建脚本</strong>: 确保你的<code>build.gradle</code>文件正确配置，这样Gradle在构建过程中就会自动将<code>jniLibs</code>目录下的<code>.so</code>文件包括到AAR包中。大多数情况下，这个过程是自动完成的，无需额外配置。</p></li></ol><h3 id="示例目录结构"><a href="#示例目录结构" class="headerlink" title="示例目录结构"></a>示例目录结构</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">YourLibraryProject/</span><br><span class="line">├── src/</span><br><span class="line">│   └── main/</span><br><span class="line">│       ├── java/</span><br><span class="line">│       │   └── ... (your Java or Kotlin source files)</span><br><span class="line">│       ├── res/</span><br><span class="line">│       │   └── ... (your resources)</span><br><span class="line">│       └── jniLibs/</span><br><span class="line">│           ├── armeabi-v7a/</span><br><span class="line">│           │   └── libyourlibrary.so</span><br><span class="line">│           ├── arm64-v8a/</span><br><span class="line">│           │   └── libyourlibrary.so</span><br><span class="line">│           ├── x86/</span><br><span class="line">│           │   └── libyourlibrary.so</span><br><span class="line">│           └── x86_64/</span><br><span class="line">│               └── libyourlibrary.so</span><br></pre></td></tr></table></figure><h3 id="构建AAR包"><a href="#构建AAR包" class="headerlink" title="构建AAR包"></a>构建AAR包</h3><p>当你构建你的库时（例如，通过运行<code>./gradlew assembleRelease</code>），Gradle会自动将<code>jniLibs</code>目录下的所有<code>.so</code>文件包括到生成的AAR文件中。这样，当其他开发者将你的AAR文件作为依赖项添加到他们的项目中时，这些<code>.so</code>文件就会被自动解压到正确的位置，供他们的应用使用。</p><p>确保在发布你的库之前测试它，以确保<code>.so</code>文件被正确包含且可以按预期工作。这通常涉及到在包含不同CPU架构设备的模拟器或真实设备上运行和测试你的库。</p><h1 id="aar-里可以有哪些文件"><a href="#aar-里可以有哪些文件" class="headerlink" title=".aar 里可以有哪些文件"></a>.aar 里可以有哪些文件</h1><p>一个AAR（Android Archive）文件是Android库项目的发布包格式，用于在开发者之间共享Android库。AAR文件包含了库所需要的所有内容，使其可以被其他的Android应用项目引用。以下是AAR文件通常包含的文件和目录：</p><h3 id="必需的内容"><a href="#必需的内容" class="headerlink" title="必需的内容"></a>必需的内容</h3><ul><li><code>classes.jar</code>：包含库的所有编译后的Java类（.class文件）。</li><li><code>res/</code>：包含库所使用的所有资源文件，如布局（layouts）、字符串（strings）、图片（drawables）等。</li><li><code>AndroidManifest.xml</code>：库的Android清单文件，描述了库的包名、所需权限、活动（activities）、服务（services）等。</li></ul><h3 id="可选的内容"><a href="#可选的内容" class="headerlink" title="可选的内容"></a>可选的内容</h3><ul><li><code>R.txt</code>：包含库中所有资源的ID名称和类型的列表，这是为了在库被引用时帮助生成最终应用的R类。</li><li><code>aidl/</code>：包含库所使用的所有AIDL（Android Interface Definition Language）文件，用于定义跨进程通信接口。</li><li><code>assets/</code>：包含可以被库访问的原始文件，如文本、音频或视频文件。</li><li><code>libs/*.jar</code>：包含库依赖的任何Java库的JAR文件。</li><li><code>jni/</code> 或 <code>jniLibs/</code>：包含库依赖的本地库（如<code>.so</code>文件），这些文件根据不同的CPU架构可能存放在不同的子目录下，如<code>armeabi-v7a/</code>、<code>arm64-v8a/</code>等。</li><li><code>proguard.txt</code>：包含用于代码混淆的ProGuard规则。</li><li><code>lint.jar</code>：包含自定义lint检查规则的JAR，这些规则可以在使用库的项目中被lint程序使用。</li><li><code>public.txt</code>：列出了库公开的资源ID，这些资源ID在库的使用者中是可见的。</li><li><code>annotations.zip</code>：包含用于工具支持的注解，比如nullability注解等。</li></ul><h3 id="如何查看AAR文件内容"><a href="#如何查看AAR文件内容" class="headerlink" title="如何查看AAR文件内容"></a>如何查看AAR文件内容</h3><p>你可以通过解压AAR文件（它本质上是一个ZIP文件）来查看里面的内容。使用任何标准的压缩文件管理器，如WinRAR、7-Zip等，都可以打开AAR文件并浏览其中的内容。</p><h3 id="使用AAR文件"><a href="#使用AAR文件" class="headerlink" title="使用AAR文件"></a>使用AAR文件</h3><p>当你将AAR文件作为依赖项添加到Android项目中时，项目构建系统（如Gradle）会自动处理并引入这些内容，包括解析资源、合并清单文件等，从而使库中的功能可用于应用程序。<br><a href="https://imgse.com/i/pFy2w6J"><img src="https://s21.ax1x.com/2024/03/10/pFy2w6J.png" alt="aar文件分析.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 6 - Android 打包编译 </category>
          
          <category> 6.1 - 文件分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android aar 文件到底是什么</title>
      <link href="/2023/08/11/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/Android%20%E4%BA%91%E7%BC%96%E8%AF%91%20gradle%20%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/08/11/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/Android%20%E4%BA%91%E7%BC%96%E8%AF%91%20gradle%20%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>作者: 朕小猫与GPT4</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">task downloadApk &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> remoteApkPath = <span class="string">&quot;/home/jason/AndroidStudioProjects/ncmusic/app/build/outputs/apk/debug/app-debug.apk&quot;</span></span><br><span class="line">        <span class="keyword">def</span> localApkDir = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/Downloads/&quot;</span></span><br><span class="line">        <span class="keyword">def</span> localApkPath = localApkDir + <span class="string">&quot;app-debug.apk&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建本地目录</span></span><br><span class="line">        <span class="keyword">new</span> File(localApkDir).mkdirs()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 scp 下载远程 APK 文件到本地</span></span><br><span class="line">        <span class="keyword">def</span> command = <span class="string">&quot;sshpass -p &#x27;password&#x27; scp jason@192.168.1.100:$&#123;remoteApkPath&#125; $&#123;localApkPath&#125;&quot;</span></span><br><span class="line">        println <span class="string">&quot;Executing command: $&#123;command&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">        exec &#123;</span><br><span class="line">            commandLine <span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, command</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task installAndStart &#123;</span><br><span class="line">    dependsOn downloadApk</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> localApkPath = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/Downloads/app-debug.apk&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保 adb 可用</span></span><br><span class="line">        <span class="keyword">def</span> adbPath = <span class="string">&#x27;/Users/jason/Library/Android/sdk/platform-tools/adb&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">new</span> File(adbPath).exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;adb command not found at $&#123;adbPath&#125;! Please ensure Android SDK is properly installed.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安装 APK</span></span><br><span class="line">        <span class="keyword">def</span> installCommand = <span class="string">&quot;$&#123;adbPath&#125; install -r $&#123;localApkPath&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                commandLine <span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, installCommand</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;Failed to install APK: $&#123;e.message&#125;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取包名</span></span><br><span class="line">        <span class="keyword">def</span> manifestFile = file(<span class="string">&quot;$&#123;rootProject.projectDir&#125;/app/src/main/AndroidManifest.xml&quot;</span>)</span><br><span class="line">        <span class="keyword">def</span> packageName = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (manifestFile.exists()) &#123;</span><br><span class="line">            manifestFile.eachLine &#123; line -&gt;</span><br><span class="line">                <span class="keyword">if</span> (line.contains(<span class="string">&quot;package=&quot;</span>)) &#123;</span><br><span class="line">                    packageName = line.split(<span class="string">&#x27;package=&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;&quot;&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (packageName == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;Failed to extract package name from AndroidManifest.xml&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;AndroidManifest.xml file not found!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动应用</span></span><br><span class="line">        <span class="keyword">def</span> launchCommand = <span class="string">&quot;$&#123;adbPath&#125; shell monkey -p $&#123;packageName&#125; -c android.intent.category.LAUNCHER 1&quot;</span></span><br><span class="line">        println <span class="string">&quot;Executing command: $&#123;launchCommand&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                commandLine <span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, launchCommand</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;Failed to launch application: $&#123;e.message&#125;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task downloadBuild &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        subprojects.each &#123; subproject -&gt;</span><br><span class="line">            <span class="keyword">def</span> remoteRootPath = <span class="string">&quot;/home/jason/AndroidStudioProjects/&quot;</span></span><br><span class="line">            <span class="keyword">def</span> remoteDirPath = remoteRootPath + <span class="string">&quot;$&#123;rootProject.name&#125;/$&#123;subproject.name&#125;/build&quot;</span></span><br><span class="line">            <span class="keyword">def</span> localDirPath = <span class="string">&quot;$&#123;subproject.projectDir&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建本地目录</span></span><br><span class="line">            <span class="keyword">new</span> File(localDirPath).mkdirs()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 rsync 同步远程文件到本地</span></span><br><span class="line">            <span class="keyword">def</span> command = <span class="string">&quot;sshpass -p &#x27;password&#x27; rsync -avz --delete jason@192.168.1.100:$&#123;remoteDirPath&#125; $&#123;localDirPath&#125;&quot;</span></span><br><span class="line">            println <span class="string">&quot;Executing command: $&#123;command&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">            exec &#123;</span><br><span class="line">                commandLine <span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, command</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task remoteBuild &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="comment">// 远程构建命令</span></span><br><span class="line">        <span class="keyword">def</span> command = <span class="string">&quot;sshpass -p &#x27;password&#x27; ssh jason@192.168.1.100 &#x27;cd /home/jason/AndroidStudioProjects/ncmusic/ &amp;&amp; ./gradlew assembleDebug&#x27;&quot;</span></span><br><span class="line">        exec &#123;</span><br><span class="line">            commandLine <span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, command</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个任务来执行远程构建、下载 APK、安装并启动应用，然后同步构建产物</span></span><br><span class="line">task buildDownloadInstallAndStart &#123;</span><br><span class="line">    dependsOn remoteBuild</span><br><span class="line">    finalizedBy installAndStart, downloadBuild</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 6 - Android 打包编译 </category>
          
          <category> 6.2 - 简单好用的 gradle 云编译设置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的惰性操作容器——Sequence</title>
      <link href="/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/"/>
      <url>/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="Sequence序列"><a href="#Sequence序列" class="headerlink" title="Sequence序列"></a>Sequence序列</h3><p>Sequence 是Kotlin标准库提供的一种容器类型。它和Iterable一样具备对集合进行多步骤操作能力，但是却是采用了一种完全不同于Iterable的实现方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val map = (0..3).filter &#123;</span><br><span class="line">    println(&quot;filter:$it&quot;)</span><br><span class="line">    it % 2 == 0</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    println(&quot;map:$it&quot;)</span><br><span class="line">    it + 1</span><br><span class="line">&#125;</span><br><span class="line">println(map)</span><br></pre></td></tr></table></figure><p>上面的代码用来演示Iterable进行连续操作的情况。它的输出如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter:0</span><br><span class="line">filter:1</span><br><span class="line">filter:2</span><br><span class="line">filter:3</span><br><span class="line">map:0</span><br><span class="line">map:2</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure><p>像<code>map</code>和<code>filter</code>这些链式集合函数它们都会立即执行并创建中间临时集用来保存数据。当原始数据不多时，这并不会有什么影响。但是，当原始数据量非常大的时候。这就会变的非常低效。而此时，就可以借助<code>Sequence</code>提高效率。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val sequence = (0..3).asSequence().filter &#123;</span><br><span class="line">    println(&quot;filter:$it&quot;)</span><br><span class="line">    it % 2 == 0</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    println(&quot;map:$it&quot;)</span><br><span class="line">    it + 1</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;准备开始执行&quot;)</span><br><span class="line">println(sequence.toList())</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">准备开始执行</span><br><span class="line">filter:0</span><br><span class="line">map:0</span><br><span class="line">filter:1</span><br><span class="line">filter:2</span><br><span class="line">map:2</span><br><span class="line">filter:3</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure><p>对比Iterable和Sequence：</p><p>Iterable是即时的、Sequence是惰性的：前者会要求尽早的计算结果，因此在多步骤处理链的每一环都会有中间产物也就是新的集合产生；<strong>后者会尽可能的延迟计算结果，Sequence处理的中间函数不进行任何计算。相反，他们返回一个新Sequence的，用新的操作装饰前一个，所有的这些计算都只是在类似toList的终端操作期间进行。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-f3db64c81524b0df40edf073b68f1ac9_1440w.webp" alt="img"></p><p>区分中间操作符和末端操作符的方式也很简单：<strong>如果操作符返回的是一个Sequence类型的数据，它就是中间操作符。</strong></p><p>在操作的执行方式上也有所不同：Iterable每次都是在整个集合执行完操作后再进行下一步操作——采用第一个操作并将其应用于整个集合，然后移动到下一个操作，官方将其称呼为急切式或者按步骤执行（Eager&#x2F;step-by-step）；<strong>而Sequence则是逐个对每个元素执行所有操作。是一种惰性顺序——取第一个元素并应用所有操作，然后取下一个元素，依此类推。</strong>官方将其称呼为惰性式或者按元素执行（Lazy&#x2F;element-by-element)</p><p>序列的惰性会带来一下几个优点：</p><ul><li>它们的操作按照元素的自然顺序进行；</li><li>只做最少的操作；</li><li>元素可以是无限多个；</li><li>不需要在每一步都创建集合</li></ul><p><strong>Sequence可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。但是，惰性性质也会带来一些运行开销。所以在使用时要权衡惰性开销和中间步骤开销，在Sequence和Iterable中选择更加合适的实现方式。</strong></p><h3 id="执行的顺序"><a href="#执行的顺序" class="headerlink" title="执行的顺序"></a>执行的顺序</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceOf(1,2,3)</span><br><span class="line">    .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125;</span><br><span class="line">    .map &#123; print(&quot;M$it, &quot;); it * 2 &#125;</span><br><span class="line">    .forEach &#123; print(&quot;E$it, &quot;) &#125; </span><br><span class="line">// Prints: F1, M1, E2, F2, F3, M3, E6,</span><br><span class="line"></span><br><span class="line">listOf(1,2,3)</span><br><span class="line">    .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125;</span><br><span class="line">    .map &#123; print(&quot;M$it, &quot;); it * 2 &#125;</span><br><span class="line">    .forEach &#123; print(&quot;E$it, &quot;) &#125;</span><br><span class="line">// Prints: F1, F2, F3, M1, M3, E2, E6,</span><br></pre></td></tr></table></figure><p>sequence的执行时按照元素进行的，依次对元素执行所有的操作，对一个元素而言，所有操作时依次全部执行的。而普通集合操作则是以操作步骤进行的，当所有的元素执行完当前操作后才会进入下一个操作。</p><p><img src="https://pic1.zhimg.com/80/v2-27021cdfe12cadb333ac2f9c5991f8ec_1440w.webp" alt="img"></p><h3 id="只做最少的操作"><a href="#只做最少的操作" class="headerlink" title="只做最少的操作"></a>只做最少的操作</h3><p>试想一下我们有一千万个数字，我们要经过几次变换取出20个，使用下面的代码对比一下序列和不同集合操作的性能：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val fFlow = FFlow()</span><br><span class="line">    fFlow.demoList()</span><br><span class="line">    fFlow.demoSequence()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demoSequence() &#123;</span><br><span class="line">    val currentTimeMillis = System.currentTimeMillis()</span><br><span class="line">    val list =</span><br><span class="line">    (0..10000000).asSequence().map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList()</span><br><span class="line">    println(&quot;demoSequence:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demoList() &#123;</span><br><span class="line">    val currentTimeMillis = System.currentTimeMillis()</span><br><span class="line">    val list =</span><br><span class="line">    (0..10000000).map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList()</span><br><span class="line">    println(&quot;demoList:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demoSequence:20ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]</span><br><span class="line">demoList:4106ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]</span><br></pre></td></tr></table></figure><p>这就是只执行最少操作的意思，序列按照元素顺序执行，当取够29个元素之后便会立即停止计算。而不同的集合则不同，没有中间操作的概念。它的每次操作都会对整个数组中的所有元素执行完才会进行下一个——也就是前两个map都要执行一千万次。</p><p><img src="https://pic2.zhimg.com/80/v2-76965bb77961ce0d47ccef581ac2c2e9_1440w.webp" alt="img"></p><h3 id="序列可以是无限的"><a href="#序列可以是无限的" class="headerlink" title="序列可以是无限的"></a>序列可以是无限的</h3><p>看如下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var list = emptyArray&lt;Int&gt;()</span><br><span class="line">var  i = 0</span><br><span class="line">while(true)&#123;</span><br><span class="line">    list[i] = i++</span><br><span class="line">&#125;</span><br><span class="line">list.take(10)</span><br></pre></td></tr></table></figure><p>很明显，这段代码是没法正常运行的，因为这里有一个死循环。我们也无法创建一个无限长度的集合。但是：因为序列式按步骤依照需求进行处理的，所哟我们可以创建无限序列：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val noEnd = sequence &#123;</span><br><span class="line">    var i = 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        yield(i)</span><br><span class="line">        i *= 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">noEnd.take(4).toList()</span><br><span class="line">//输出:[1, 2, 4, 8]</span><br></pre></td></tr></table></figure><p>但是一定要注意，我们虽然可以这么写，但是务必不能真的让while一直循环。我们不能直接使用toList。必须提供一个能结束循环的操作符，也就是不能取出所有元素（无限个）——要么使用类似take的操作来限制它们的数量，要么使用不需要所有元素的终端操作，例如first, find, any, all, indexOf等。</p><h3 id="序列不会在每个步骤创建集合"><a href="#序列不会在每个步骤创建集合" class="headerlink" title="序列不会在每个步骤创建集合"></a>序列不会在每个步骤创建集合</h3><p>普通的集合会在每次变换之后都会创建新的集合取存储所有变换后的元素。而每次创建集合和填入数据都会带来不小的性能开销。尤其是当我们处理大量或大量的集合时，性能问题会愈发凸显。而序列的按元素操作，则不会有这个问题。除非手动调用了终端操作符，否则不会生成新的集合。</p><h3 id="Sequence的基本使用"><a href="#Sequence的基本使用" class="headerlink" title="Sequence的基本使用"></a>Sequence的基本使用</h3><p>Sequence序列的使用和普通的Iterable极其相似，实际上其内部也还是借助Iterable实现的。在研究它的内部实现原理之前，想从Sequence的创建和基本的序列操作来演示Sequence的基本用法。</p><h3 id="序列的创建"><a href="#序列的创建" class="headerlink" title="序列的创建"></a>序列的创建</h3><p>创建Sequence的方式大概可以分为。分别是由元素创建、通过Iterable、借助函数以及由代码块创建。</p><p>由元素创建：通过调用顶级函数<code>sequenceOf</code>实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequenceOf(1, 2, 3, 4, 5, 6, 7)</span><br><span class="line">val strings = sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</span><br></pre></td></tr></table></figure><p>通过Iterable转化：借助Iterable的扩展函数<code>asSequence</code>实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ints = listOf(1, 2, 3, 4, 5, 6, 7).asSequence()</span><br><span class="line">val strings = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</span><br></pre></td></tr></table></figure><p>通过generateSequence实现：该方法有三个：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; </span><br><span class="line">generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;</span><br><span class="line">generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt;</span><br></pre></td></tr></table></figure><p>最终都是通过<code>GeneratorSequence</code>实现的，这里先不进行源码分析。只讨论使用方式：</p><ul><li>其中三个函数都有的形参nextFunction可以理解为元素生成器，序列里的元素都通过调用该函数生成，当它返回为null是，序列停止生成（所以，nextFunction必须要在某个情况下返回null，否则会因为序列元素是无限多个触发java.lang.OutOfMemoryError: Java heap space异常）。</li><li>而另外两个的seedFunction和seed形参都是为了确定数据初始值的。区别在于一个直接指明，一个通过调用函数获取。</li></ul><p>分别用这三个函数生成0~100的序列，代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val generateSequenceOne = generateSequence &#123;</span><br><span class="line">    if (i &lt; 100) &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val generateSequenceTwo = generateSequence(0) &#123;</span><br><span class="line">    if (it &lt; 100) &#123;</span><br><span class="line">        it+1//此处的it是上一个元素</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val generateSequenceThree = generateSequence(&#123; 0 &#125;) &#123;</span><br><span class="line">    if (it &lt; 100) &#123;</span><br><span class="line">        it+1//此处的it是上一个元素</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码块生成：借助sequence(block: suspend SequenceScope.() -&gt; Unit)函数。改函数接受一个挂起函数，该函数会接受一个<code>SequenceScope</code>实例，这个实例无需我们创建（后面源码分析会讲到）。SequenceScope提供了<code>yield</code>和<code>yieldAll</code>方法复杂返回序列元素给调用者，并暂停序列的执行，直到使用者请求下一个元素。</p><p>用该函数生成0~100的序列，代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequence &#123;</span><br><span class="line">    repeat(100) &#123;</span><br><span class="line">        yield(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列的操作"><a href="#序列的操作" class="headerlink" title="序列的操作"></a>序列的操作</h3><p>对序列的操作可以分为中间操作和末端操作两种。它们只要有一下另种区别：</p><ul><li>中间操作返回惰性生成的一个新的序列，而末端序列则为其他普通的数据类型；</li><li>中间操作不会立刻执行代码，仅当执行了末端操作序列才会开始执行。</li></ul><p>常见的中间操作包括：map、fliter、first、last、take等；它们会序列提供数据变化过滤等增强功能基本上和kotlin提供的集合操作符有着相同的功能。</p><p>常见的末端操作有：toList、toMutableList、sum、count等。它们在提供序列操作功能的同时，还会触发序列的运行。</p><h3 id="Sequence源码分析"><a href="#Sequence源码分析" class="headerlink" title="Sequence源码分析"></a>Sequence源码分析</h3><p>上文对序列做了简单的入门介绍。接下来深入源码去了解一下Sequence的实现方式。</p><h3 id="Sequence是什么？"><a href="#Sequence是什么？" class="headerlink" title="Sequence是什么？"></a>Sequence是什么？</h3><p>Kotlin对的定义Sequence很简单：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Sequence &lt;out T&gt; &#123;</span><br><span class="line">    public operator fun iterator(): Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个接口，定义了一个返回Iterator的方法。接口本身只定义了Sequence具有返回一个迭代器的能力。具体的功能实现还是靠它的实现类完成。</p><p>可以概括一些：<strong>序列就是一个具备提供了迭代器能力的类。</strong></p><h3 id="序列的创建方式分析"><a href="#序列的创建方式分析" class="headerlink" title="序列的创建方式分析"></a>序列的创建方式分析</h3><p>结合上文中提到的序列的四种创建方式，我们依次分析一下它的创建流程。</p><p>我们首先以比较常用的通过Iterable转化获取序列，它需要借助<code>asSequence</code>方法分析一下，使用<code>listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</code>生成一个序列。调用链如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123;</span><br><span class="line">    return Sequence &#123; this.iterator() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程很简单，一个扩展函数加一个内联函数。最终通过匿名内部类的方式创建一个Sequence并返回。代码很好理解，实际上它的实现逻辑等同于下面的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val sequence = MySequence(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).iterator())</span><br><span class="line"></span><br><span class="line">class MySequence&lt;T&gt;(private val iterator:Iterator&lt;T&gt;):Sequence&lt;T&gt;&#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; &#123;</span><br><span class="line">        return iterator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看一下通过调用顶级函数<code>sequenceOf</code>实现，以<code>sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</code>为例，它的调用逻辑如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; sequenceOf(vararg elements: T): Sequence&lt;T&gt; = if (elements.isEmpty()) emptySequence() else elements.asSequence()</span><br></pre></td></tr></table></figure><p>可以看到依旧是借助asSequence实现的。</p><p>接下来看一下代码块和generateSequence的实现方式，这两个方式会比较复杂一点，毕竟前面两个都是借助List进行转换，而List本身就能提供迭代器Iterator。后面两个明显需要提供新的迭代器。 首先看一下代码看的实现方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequence &#123;</span><br><span class="line">        repeat(100) &#123;</span><br><span class="line">            yield(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中sequence的调用逻辑如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; iterator(block) &#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T&gt; iterator(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123;</span><br><span class="line">    //创建迭代器</span><br><span class="line">    val iterator = SequenceBuilderIterator&lt;T&gt;()</span><br><span class="line">    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)</span><br><span class="line">    return iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现：该方法和asSequence一样最终也是通过匿名内部类的方式创建了一个Sequence。不过区别在于，该方法需要创建一个新的迭代器，也就是<code>SequenceBuilderIterator</code> 。同样以MySequence为例，它的创建流程等同于一下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun mian()&#123;</span><br><span class="line">    create&lt;Int&gt; &#123; myblock() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun  SequenceScope&lt;Int&gt;.myblock()&#123;</span><br><span class="line">    repeat(100) &#123;</span><br><span class="line">        yield(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;Int&gt; create(block: suspend SequenceScope&lt;Int&gt;.() -&gt; Unit):Sequence&lt;Int&gt;&#123;</span><br><span class="line">    val iterator = SequenceBuilderIterator&lt;Int&gt;()</span><br><span class="line">    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)</span><br><span class="line">    return MySequence(iterator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这是不可能实现的，因为SequenceBuilderIterator是被private修饰了，我们是无法直接访问的。这里强制写出来演示一下它的流程。</p><p>最后看一下通过generateSequence方法创建序列的源码，一共有三个：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T : Any&gt; generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; =</span><br><span class="line">    GeneratorSequence(seedFunction, nextFunction)</span><br><span class="line"></span><br><span class="line">public fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; =</span><br><span class="line">    if (seed == null)</span><br><span class="line">        EmptySequence</span><br><span class="line">    else</span><br><span class="line">        GeneratorSequence(&#123; seed &#125;, nextFunction)</span><br><span class="line"></span><br><span class="line">public fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; &#123;</span><br><span class="line">    return GeneratorSequence(nextFunction, &#123; nextFunction() &#125;).constrainOnce()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是创建了<code>GeneratorSequence</code>的一个实例并返回，而<code>GeneratorSequence</code>实现了<code>Sequence</code>接口并重写了<code>iterator()</code>方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class GeneratorSequence&lt;T : Any&gt;(private val getInitialValue: () -&gt; T?, private val getNextValue: (T) -&gt; T?) : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123;</span><br><span class="line">        var nextItem: T? = null</span><br><span class="line">        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue</span><br><span class="line"></span><br><span class="line">        private fun calcNext() &#123;</span><br><span class="line">            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)</span><br><span class="line">            nextState = if (nextItem == null) 0 else 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun next(): T &#123;</span><br><span class="line">            if (nextState &lt; 0)</span><br><span class="line">                calcNext()</span><br><span class="line"></span><br><span class="line">            if (nextState == 0)</span><br><span class="line">                throw NoSuchElementException()</span><br><span class="line">            val result = nextItem as T</span><br><span class="line">            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue</span><br><span class="line">            nextState = -1</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun hasNext(): Boolean &#123;</span><br><span class="line">            if (nextState &lt; 0)</span><br><span class="line">                calcNext()</span><br><span class="line">            return nextState == 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下Sequence的创建大致可以分为三类：</p><ul><li>使用List自带的迭代器通过匿名的方式创建Sequence实例，<code>sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</code>和<code>listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</code>就是这种方式；</li><li>创建新的<code>SequenceBuilderIterator</code>迭代器，并通过匿名的方式创建Sequence实例。例如使用代码块的创建方式。</li><li>创建<code>GeneratorSequence</code>，通过重写iterator()方法，使用匿名的方式创建Iterator。GeneratorSequence方法就是采用的这种方式。</li></ul><p>看完创建方式，也没什么奇特的，就是一个提供迭代器的普通类。还是看不出是如何惰性执行操作的。接下来就分析一下惰性操作的原理。</p><h3 id="序列的惰性原理"><a href="#序列的惰性原理" class="headerlink" title="序列的惰性原理"></a>序列的惰性原理</h3><p>以最常用的map操作符为例：普通的集合操作源码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;</span><br><span class="line">    //出啊年一个新的ArrayList，并调用mapTo方法</span><br><span class="line">    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123;</span><br><span class="line">    //遍历原始的集合，进行变换操作，然后将变换后的数据依次加入到新创建的集合</span><br><span class="line">    for (item in this)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    //返回新集合    </span><br><span class="line">    return destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：当List.map被调用后，便会立即创建新的集合，然后遍历老数据并进行变换操作。最后返回一个新的数据。这印证了上面提到的普通集合的操作时按照步骤且会立刻执行的理论。</p><p>接下来看一下序列的map方法，它的源码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123;</span><br><span class="line">    return TransformingSequence(this, transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal class TransformingSequence&lt;T, R&gt;</span><br><span class="line">constructor(private val sequence: Sequence&lt;T&gt;, private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123;</span><br><span class="line">          //注释一：TransformingSequence的iterator持有上一个序列的迭代器</span><br><span class="line">        val iterator = sequence.iterator()</span><br><span class="line">        override fun next(): R &#123;</span><br><span class="line">            //注释二：在开始执行迭代时，向上调用前一个序列的迭代器。</span><br><span class="line">            return transformer(iterator.next())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun hasNext(): Boolean &#123;</span><br><span class="line">            return iterator.hasNext()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123;</span><br><span class="line">        return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码并不复杂，它接收用户提供的变换函数和序列，然后创建了一个TransformingSequence并返回。TransformingSequence本身和上文中提到的序列没什么区别，唯一的区别在于它的迭代器：在通过next依次取数据的时候，并不是直接返回元素。而是先调用调用者提供的函数进行变换。返回变换后的数据——这也没什么新鲜的，和普通集合的map操作符和RxJava的Map都是同样的原理。</p><p>但是，这里却又有点不一样。<strong>操作符里没有任何开启迭代的代码，它只是对序列以及迭代进行了嵌套处理，并不会开启迭代.如果用户不手动调用（后者间接调用）迭代器的next函数，序列就不会被执行</strong>——这就是惰性执行的机制的原理所在。</p><p>而且，由于操作符返回的是一个Sequence类型的值，当你重复不断调用map时，例如下面的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(0..10).asSequence().map&#123;add(it)&#125;.map&#123;add(it)&#125;.map&#123;add(it)&#125;.toList()</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line"></span><br><span class="line">val sequence1 = (0..10).asSequence()</span><br><span class="line">val sequence2 = sequence1.map &#123; it+1 &#125;</span><br><span class="line">val sequence3 = sequence2.map &#123; it+1 &#125;</span><br><span class="line">sequence3.toList()</span><br></pre></td></tr></table></figure><p>最终，序列sequence3的结构持有如下：sequence3-&gt; sequence2 -&gt; sequence1。而它们都有各自的迭代器。迭代器里都重写了各自的变换逻辑:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun next(): R &#123;</span><br><span class="line">    return transformer(iterator.next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//由于这里都是执行的+1操作，所以变换逻辑transformer可以认为等同于如下操作:</span><br><span class="line"></span><br><span class="line">override fun next(): R &#123;</span><br><span class="line">    return iterator.next()+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当我们通过<code>sequence3.toList</code>执行代码时，它的流程如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123;</span><br><span class="line">    return this.toMutableList().optimizeReadOnlyList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T&gt; Sequence&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123;</span><br><span class="line">    //末端操作符，此处才会开始创建新的集合</span><br><span class="line">    return toCollection(ArrayList&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123;</span><br><span class="line">    //执行迭代器next操作</span><br><span class="line">    //当调用（末端操作符）走到这里时，便会和普通结合的操作符一样</span><br><span class="line">    //此时为新创建的集合赋值</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        destination.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">    return destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过几次扩展函数调用，最终在toCollection里开始执行迭代(Iterator的典型的操作)，也就是获取了sequence3的iterator实例，并不断通过next取出数据。而在上文中的TransformingSequence源码里可以看到，TransformingSequence会持有上一个迭代器的实例（代码注释一）。</p><p>并且在迭代开始后，在进行transformer操作（也就是执行+1操作）前，会调用上一个迭代器的next方法进行迭代（代码注释二）。这样不断的迭代，最终，最终会调用到sequence1的next方法。再结合上文中的序列创建里的分析——sequence1里所持有的迭代器就是就是原始数据里的迭代器。</p><p>那么当最终执行toList方法时，它会循环<code>sequence3.iterator</code>方法。而在每次循环内，都会首先执行sequence3所持有的sequence2.iterator的next方法。sequence2依次类推执行到sequence1的sequence1.iterator&#96;方法，最终执行到我们原始数组的迭代器next方法：</p><p>整个流程如下：</p><p><img src="https://pic2.zhimg.com/80/v2-d8485553b786d4cb8def81a27cffd361_1440w.webp" alt="img"></p><p>原理就是这么简单：中间操作符通过序列嵌套，实现对迭代器iterator的嵌套。这样在进行迭代的时候，会依次调用各个iterator迭代器直到调用到原始集合数据里的迭代器开始并返回元素。而当元素返回时，会依次执行各个迭代器持有变换操作方法实现对数据的变换。</p><p><img src="https://pic4.zhimg.com/80/v2-e34ba780f0b283f6fc8b6a9fb52f5243_1440w.webp" alt="img"></p><p>而其他操作符，也是遵循这个基本的规则。无非就是增加一些其他的操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>序列通过中间操作符对迭代器进行嵌套和复写，以此实现按元素操作执行变换；</li><li>中间操作符只负责根据需求创建并嵌套迭代器，并不负责开启迭代器。以此实现惰性操作且不产生临时集合；</li><li>末端操作符负责开启迭代，按照嵌套顺序执行迭代操作。依次获取操作后的数据，并且会创建新的集合用来存储最终数据；</li><li>序列不是万能的，因为要引入新的对象。在带来惰性和顺序执行的优势时，这些对象必然会带来性能开销。所以要依需求在集合和序列之间进行选择，使用合适的方式进行迭代。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.0 - Kotlin 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中有哪些类</title>
      <link href="/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB/"/>
      <url>/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在 Kotlin 中，类的概念是非常广泛的，包括各种类型的类设计用于不同的目的和场景。Kotlin 提供了丰富的类类型以支持现代软件开发的需要。下面是一些在 Kotlin 中常见的类类型：</p><h3 id="1-数据类（Data-Class）"><a href="#1-数据类（Data-Class）" class="headerlink" title="1. 数据类（Data Class）"></a>1. <strong>数据类（Data Class）</strong></h3><p>数据类是专门用于存储数据的类。Kotlin 的数据类通过 <code>data</code> 关键字定义，它自动从所声明的属性中派生出 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 等方法，以及 <code>copy()</code> 函数和 <code>componentN()</code> 函数（按声明顺序对应于所有属性）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><h3 id="2-枚举类（Enum-Class）"><a href="#2-枚举类（Enum-Class）" class="headerlink" title="2. 枚举类（Enum Class）"></a>2. <strong>枚举类（Enum Class）</strong></h3><p>枚举类用于定义一组命名常量。Kotlin 中的枚举不仅可以有属性，还可以有自己的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH, SOUTH, EAST, WEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-密封类（Sealed-Class）"><a href="#3-密封类（Sealed-Class）" class="headerlink" title="3. 密封类（Sealed Class）"></a>3. <strong>密封类（Sealed Class）</strong></h3><p>密封类用于表示受限的类层次结构，即一个值只能是有限集合中的某个类型，而不能是任何其他类型。这对于当你在使用 <code>when</code> 表达式时，想要确保覆盖所有可能的类型非常有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br></pre></td></tr></table></figure><h3 id="4-抽象类（Abstract-Class）"><a href="#4-抽象类（Abstract-Class）" class="headerlink" title="4. 抽象类（Abstract Class）"></a>4. <strong>抽象类（Abstract Class）</strong></h3><p>抽象类是不能被实例化的类，通常用作其他类的基类。抽象类可以包含抽象方法（没有实现的方法）和非抽象方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">park</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Parked&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-内部类（Inner-Class）"><a href="#5-内部类（Inner-Class）" class="headerlink" title="5. 内部类（Inner Class）"></a>5. <strong>内部类（Inner Class）</strong></h3><p>内部类是定义在另一个类内部的类。内部类持有其外部类的一个引用，因此可以访问其成员。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-嵌套类（Nested-Class）"><a href="#6-嵌套类（Nested-Class）" class="headerlink" title="6. 嵌套类（Nested Class）"></a>6. <strong>嵌套类（Nested Class）</strong></h3><p>与内部类相比，嵌套类没有对外部类的隐式引用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-对象声明（Object-Declaration）"><a href="#7-对象声明（Object-Declaration）" class="headerlink" title="7. 对象声明（Object Declaration）"></a>7. <strong>对象声明（Object Declaration）</strong></h3><p>Kotlin 支持对象声明，这是实现单例模式的一种方式。对象声明的实例自动成为一个单例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Provider registered: <span class="variable">$provider</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-伴生对象（Companion-Object）"><a href="#8-伴生对象（Companion-Object）" class="headerlink" title="8. 伴生对象（Companion Object）"></a>8. <strong>伴生对象（Companion Object）</strong></h3><p>在 Kotlin 中，没有静态方法，但可以用伴生对象来模拟静态方法的效果。伴生对象的成员可以通过类名直接访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-接口（Interface）"><a href="#9-接口（Interface）" class="headerlink" title="9. 接口（Interface）"></a>9. <strong>接口（Interface）</strong></h3><p>虽然不是类，但接口在 Kotlin 中用于定义可以由类实现或继承的协定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drivable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Driving&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些类类型展示了 Kotlin 语言的灵活性和现代特性，旨在提供简洁而强大的语法来支持各种编程范式和设计模式。</p><h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><p>在 Kotlin 中，密封类（sealed class）是一种特殊的类，它用于表示严格的类层次结构。使用密封类，你可以定义一个类的可能的子类集合，而且这些子类只能在与密封类相同的文件中定义。这种限制确保了除文件内定义的子类之外，无法有其他子类存在，从而使得使用时更加安全和维护更加方便。</p><h3 id="密封类的主要特点和优势："><a href="#密封类的主要特点和优势：" class="headerlink" title="密封类的主要特点和优势："></a>密封类的主要特点和优势：</h3><ol><li><p><strong>受限的继承</strong>：</p><ul><li>密封类本身是抽象的，不能直接实例化，只能通过其子类进行实例化。</li><li>所有的子类必须与密封类在同一个文件中声明，这提高了可维护性，因为所有扩展都在一个集中的位置。</li></ul></li><li><p><strong>类型安全</strong>：</p><ul><li>密封类非常适合用在 <code>when</code> 表达式中，因为它们可以确保覆盖所有可能的情况，不需要再添加一个 <code>else</code> 子句。这是因为编译器能够检测到所有定义的子类。</li></ul></li><li><p><strong>更精确的控制</strong>：</p><ul><li>使用密封类可以精确控制类的继承结构，这对于构建不可变数据类型和状态管理非常有用。</li></ul></li></ol><h3 id="密封类的用法示例："><a href="#密封类的用法示例：" class="headerlink" title="密封类的用法示例："></a>密封类的用法示例：</h3><p>首先，定义一个密封类，然后在同一个文件中定义其所有子类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line">    <span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    Expr.NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Expr</code> 是一个密封类，有三个子类：<code>Const</code>、<code>Sum</code> 和 <code>NotANumber</code>。这使得 <code>eval</code> 函数可以安全地使用 <code>when</code> 表达式来处理所有可能的 <code>Expr</code> 类型，而不需要 <code>else</code> 分支，因为编译器知道所有可能的子类。</p><h3 id="使用密封类的场景："><a href="#使用密封类的场景：" class="headerlink" title="使用密封类的场景："></a>使用密封类的场景：</h3><ul><li><strong>状态管理</strong>：在应用程序状态管理或者在处理有限状态机（FSM）时，密封类提供了一种清晰的方式来表示所有可能的状态。</li><li><strong>返回类型的多样性</strong>：在函数需要返回多种类型的结果时，可以使用密封类来封装这些不同类型的返回值。</li><li><strong>在模式匹配中增强类型安全</strong>：如上面示例中的 <code>eval</code> 函数，使用密封类可以确保 <code>when</code> 表达式已经处理了所有可能的情况，这在处理复杂的逻辑分支时非常有帮助。</li></ul><p>通过这种方式，Kotlin 的密封类增加了代码的安全性和清晰度，特别是在需要表达一个有限的类层次结构时。</p><h1 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h1><p>Kotlin 1.3 引入了内联类，主要目的是提供一种无开销的抽象方式。内联类允许你创建一个包含单个属性的类，当这个类被使用时，它会在编译时被内联，即直接替换为它包含的那个值，从而避免了额外的内存分配和间接访问。</p><h3 id="内联类的定义和使用"><a href="#内联类的定义和使用" class="headerlink" title="内联类的定义和使用"></a>内联类的定义和使用</h3><p>内联类定义时需要使用 <code>inline</code> 关键字，且必须有一个主构造函数，该构造函数恰好接收一个参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">val</span> value: String)</span><br></pre></td></tr></table></figure><p>这里的 <code>Password</code> 类包裹了一个字符串，但在编译后，Kotlin 编译器会尽可能将 <code>Password</code> 类的实例替换为简单的 <code>String</code> 类型，从而减少对象创建的开销。当你在代码中使用 <code>Password</code> 类型时，例如将它作为函数参数或从函数中返回时，实际上传递的将是一个 <code>String</code> 类型。</p><h3 id="内联类的特点和优势"><a href="#内联类的特点和优势" class="headerlink" title="内联类的特点和优势"></a>内联类的特点和优势</h3><ol><li><strong>性能优化</strong>：内联类主要用于性能优化，可以避免对象分配，并减少方法调用的层次。</li><li><strong>类型安全</strong>：虽然内联类在运行时表现为它们包装的类型（例如 <code>String</code> 或 <code>Int</code>），但在编译时，它们是不同的类型。这意味着你可以用它们来实现类型安全的操作，例如防止将普通字符串与经过验证的密码字符串混淆。</li><li><strong>限制</strong>：内联类不能有初始化块 (<code>init</code> 块)，它们也不能包含其他属性或构造函数。此外，内联类可以实现接口，但不能从其他类继承。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">takePassword</span><span class="params">(password: <span class="type">Password</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Password is <span class="subst">$&#123;password.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> password = Password(<span class="string">&quot;my_secret_password&quot;</span>)</span><br><span class="line">    takePassword(password)  <span class="comment">// 在这里，password 被内联，实际传递的是一个 String 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管我们定义了一个名为 <code>Password</code> 的内联类，并在函数 <code>takePassword</code> 中使用它，实际上，在编译后，这些函数调用会直接使用 <code>String</code> 类型，而不会有任何包装和解包的性能开销。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>内联类是 Kotlin 提供的一种非常有用的特性，特别适合那些需要通过类型来提供更丰富语义但又不想引入运行时开销的场景。通过内联类，Kotlin 开发者可以在享受类型安全的同时，保持代码的高性能。</p>]]></content>
      
      
      <categories>
          
          <category> 1 - Kotlin </category>
          
          <category> 1.0 - Kotlin 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized 关键字为什么会引入锁的竞争</title>
      <link href="/2023/08/11/2%20Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/"/>
      <url>/2023/08/11/2%20Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>synchronized</code> 关键字用于实现线程同步，它可以保证在同一时间只有一个线程能够执行被 <code>synchronized</code> 修饰的代码块或方法。当一个线程获取了对象的锁，其他线程需要等待该线程释放锁才能继续执行。</p><p>当多个线程同时竞争同一个锁时，就会发生锁的竞争。这种竞争会导致多个线程按顺序排队等待锁的释放，从而引入性能问题。具体来说，锁的竞争可能导致以下情况：</p><ol><li>线程争用：多个线程同时竞争同一个锁，会导致线程进行上下文切换，从而增加了线程切换的开销。</li><li>阻塞等待：当一个线程获取了锁，其他线程需要等待，直到该线程释放锁。这会导致其他线程阻塞，降低了并发性能。</li><li>锁饥饿：如果某个线程频繁地获取锁，其他线程无法获得执行的机会，会导致其他线程长时间等待锁，造成锁饥饿的情况。</li></ol><p>因此，当多个线程同时竞争同一个锁时，就会引入锁的竞争问题，进而影响程序的性能。在高并发场景中，合理设计并发控制机制，避免不必要的锁竞争，可以提高程序的并发性能。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java.util.Stack 类为什么是线程安全的</title>
      <link href="/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/"/>
      <url>/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在Java中，<code>java.util.Stack</code> 类是线程安全的，这是因为它是通过在每个方法上添加<code>synchronized</code>关键字来实现同步的。<br><code>synchronized</code>关键字可以确保在同一时间只有一个线程可以访问被标记为<code>synchronized</code>的方法或代码块。<br>当一个线程执行一个被<code>synchronized</code>关键字修饰的方法时，它将获得一个锁，其他线程必须等待该锁释放才能访问相同的方法。<br>这样可以确保在任何给定的时刻只有一个线程可以修改<code>Stack</code>的状态，从而防止并发访问导致的数据不一致或竞态条件。<br>然而，需要注意的是，虽然<code>Stack</code>类本身是线程安全的，但在某些情况下，使用<code>synchronized</code>关键字可能会降低性能，特别是在高并发环境下。<br>因此，在Java中，推荐使用<code>java.util.concurrent</code>包提供的并发集合类，如<code>java.util.concurrent.ArrayDeque</code>或<code>java.util.concurrent.LinkedBlockingDeque</code>，它们提供了更高效和灵活的线程安全操作。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Stack 过时了吗</title>
      <link href="/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/"/>
      <url>/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在 Java 中，<code>Stack</code> 类并没有过时，仍然可以使用。然而，根据 Java 官方文档的建议，推荐使用 <code>Deque</code> 接口的实现类 <code>ArrayDeque</code> 来代替 <code>Stack</code>。</p><p><code>Stack</code> 类是基于向量（<code>Vector</code>）实现的，而 <code>Vector</code> 是线程安全的、同步的，因此在性能上可能会有一些开销。而 <code>ArrayDeque</code> 是基于数组实现的双端队列，性能更高，并且在大多数情况下能够提供与 <code>Stack</code> 类相同的功能。</p><p>此外，<code>Deque</code> 接口提供了更丰富的操作方法，例如在队首或队尾插入、删除元素等，使得其更灵活且更符合现代编程的需求。</p><p>因此，尽管 <code>Stack</code> 类仍然可用，但在新的代码中，推荐使用 <code>ArrayDeque</code> 或其他实现了 <code>Deque</code> 接口的类来代替 <code>Stack</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略</title>
      <link href="/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/"/>
      <url>/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayDeque-和-java-util-Stack-和-MutableList-的区别是什么"><a href="#ArrayDeque-和-java-util-Stack-和-MutableList-的区别是什么" class="headerlink" title="ArrayDeque 和 java.util.Stack 和 MutableList 的区别是什么"></a><code>ArrayDeque</code> 和 <code>java.util.Stack</code> 和 <code>MutableList</code> 的区别是什么</h3><p><code>ArrayDeque</code>、<code>java.util.Stack</code> 和 <code>MutableList</code>（如 <code>ArrayList</code>）是实现栈的不同方式，它们有一些区别：</p><ol><li>实现接口：<code>ArrayDeque</code> 实现了 <code>Deque</code> 接口，而 <code>java.util.Stack</code> 继承自 <code>Vector</code> 类，<code>MutableList</code> 则是 Kotlin 标准库中的可变列表接口。</li><li>内部数据结构：<code>ArrayDeque</code> 使用循环数组（circular array）作为内部数据结构，而 <code>java.util.Stack</code> 内部使用数组（Array），<code>MutableList</code> 则可以使用数组、链表或其他数据结构。</li><li>动态扩容：<code>ArrayDeque</code> 和 <code>MutableList</code> 都支持动态扩容，可以根据需要自动调整容量，而 <code>java.util.Stack</code> 不支持动态扩容，需要手动调整容量。</li><li>性能：<code>ArrayDeque</code> 在大多数操作上具有更好的性能，因为它使用了循环数组和更优化的实现。而 <code>java.util.Stack</code> 是一个遗留类，性能可能相对较差。<code>MutableList</code> 的性能取决于具体实现。</li></ol><p>综上所述，如果你想要使用性能较好且功能丰富的栈实现，推荐使用 <code>ArrayDeque</code>。如果你需要与现有的代码兼容或使用特定的接口，可以选择 <code>java.util.Stack</code> 或 <code>MutableList</code>。</p><h1 id="ArrayDeque-怎么用循环数组实现的"><a href="#ArrayDeque-怎么用循环数组实现的" class="headerlink" title="ArrayDeque 怎么用循环数组实现的"></a>ArrayDeque 怎么用循环数组实现的</h1><p><code>ArrayDeque</code> 使用循环数组（circular array）实现，它在内部维护了一个固定大小的数组来存储元素。下面是简单介绍 <code>ArrayDeque</code> 如何使用循环数组实现的一些关键点：</p><ol><li>内部数组：<code>ArrayDeque</code> 内部有一个对象数组来存储元素，通常使用 <code>elements</code> 或 <code>array</code> 字段表示。</li><li>头部和尾部指针：<code>ArrayDeque</code> 有两个指针，分别指向头部和尾部。通常使用 <code>head</code> 和 <code>tail</code> 字段表示。</li><li>循环数组特性：<code>ArrayDeque</code> 的关键之处在于利用循环数组的性质。当头部或尾部指针到达数组的边界时，它们会回绕到数组的另一侧，形成循环效果。</li><li>扩容和缩容：当元素数量达到数组容量时，<code>ArrayDeque</code> 会自动扩容。在扩容时，会创建一个更大的数组，并将原始数组中的元素按照循环顺序复制到新数组中。类似地，当元素数量较少时，<code>ArrayDeque</code> 也会自动缩容。</li><li>添加和移除元素：添加元素时，头部指针向前移动一个位置，并将元素放入头部位置。移除元素时，头部指针向后移动一个位置，并返回头部位置的元素。</li></ol><p>通过这种方式，<code>ArrayDeque</code> 可以在不断添加和移除元素的过程中高效地利用数组空间，并保持循环数组的特性。这使得 <code>ArrayDeque</code> 在栈和队列等数据结构的实现中具有较高的性能和灵活性。</p><h3 id="ArrayList-和-ArrayDeque-的区别"><a href="#ArrayList-和-ArrayDeque-的区别" class="headerlink" title="ArrayList 和 ArrayDeque 的区别"></a>ArrayList 和 ArrayDeque 的区别</h3><p>两种实现之间的主要区别在于调整大小的策略。</p><p>ArrayList 的调整大小策略是将其调整为 oldCapacity + (oldCapacity &gt;&gt; 1) 的新大小，增加了约 50%。默认容量为 10，在调整大小后的容量为 15、22、33、49、73、109、163、244、366…</p><p>ArrayDeque 总是调整为 2 的幂次方。在调整大小时，容量会加倍。从默认值 16 开始，调整大小后的容量为 32、64、128、256…</p><p>因此，ArrayDeque 达到了更高的容量，而调整大小的操作更少，这是因为数组的复制操作很耗费资源。例如，要在默认大小的 ArrayList 中存储 256，需要进行 9 次调整大小操作，而 ArrayDeque 只需要 4 次。数组的复制操作可能很快，但也可能需要 GC 来释放一些空间用于新的数据集，此外还需要进行内存复制操作（ArrayDeque 可能在这方面表现更好，因为它对齐到 2 的幂次方）。</p><p>这两种数据结构的最佳情况复杂度为 O(1)。ArrayList 的 push 和 pop 操作通过直接访问头部和尾部（ArrayDeque）来实现，而 add 和 removeLast 操作（ArrayList）则是通过直接访问大小来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque 的接口</title>
      <link href="/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>ArrayDeque</code> 实现了 <code>Deque</code> 接口，该接口继承自 <code>Queue</code> 接口。下面是 <code>Deque</code> 接口中定义的一些主要方法：</p><ol><li><p>添加元素操作：</p><ul><li><code>addFirst(element: E)</code>：将元素添加到双端队列的开头。</li><li><code>addLast(element: E)</code>：将元素添加到双端队列的末尾。</li><li><code>offerFirst(element: E)</code>：将元素添加到双端队列的开头，并返回是否成功。</li><li><code>offerLast(element: E)</code>：将元素添加到双端队列的末尾，并返回是否成功。</li></ul></li><li><p>获取元素操作：</p><ul><li><code>getFirst(): E</code>：获取双端队列的第一个元素，但不删除它。</li><li><code>getLast(): E</code>：获取双端队列的最后一个元素，但不删除它。</li><li><code>peekFirst(): E</code>：获取双端队列的第一个元素，如果队列为空则返回 null。</li><li><code>peekLast(): E</code>：获取双端队列的最后一个元素，如果队列为空则返回 null。</li></ul></li><li><p>移除元素操作：</p><ul><li><code>removeFirst(): E</code>：移除并返回双端队列的第一个元素。</li><li><code>removeLast(): E</code>：移除并返回双端队列的最后一个元素。</li><li><code>pollFirst(): E</code>：移除并返回双端队列的第一个元素，如果队列为空则返回 null。</li><li><code>pollLast(): E</code>：移除并返回双端队列的最后一个元素，如果队列为空则返回 null。</li></ul></li></ol><p>此外，<code>ArrayDeque</code> 还实现了 <code>Queue</code> 接口中定义的方法，如 <code>offer(element: E)</code>、<code>remove(): E</code>、<code>poll(): E</code> 等。</p><p>需要注意的是，<code>ArrayDeque</code> 是一个可变大小的数组双端队列，可以在队列的两端进行高效的插入和删除操作，同时也支持随机访问。</p>]]></content>
      
      
      <categories>
          
          <category> 2 - Java </category>
          
          <category> 2.0 - Java 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6. N 字形变换</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li><li><code>1 &lt;= numRows &lt;= 1000</code></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">重点不在字形，重点在变换是什么变换</span><br><span class="line">关键词：</span><br><span class="line">一维函数变二维函数</span><br><span class="line">往复变化函数</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>我们思考，为什么这个算法难写<br>分析 <code>N字形</code> 的离散函数，我们面临着一个唯一的 <code>x</code> 对应着 1- N 个 <code>y</code><br>在 <code>x</code> 变化的时候，我们首先要算该 <code>x</code> 对应了几个 <code>y</code><br>这根本不符合函数的定义<br><code>函数是指一个集合中的每个元素都有且仅有一个映射到另一个集合中的元素，这种关系被称为函数映射</code></p><p>推出我们需要把一个一维度线性离线函数 s &#x3D; f(n) 变成二维离散函数 s &#x3D; g(x, y)<br>注意，这里好玩的是 y 和 x 其实是数列<br>即 s &#x3D; g(x(n), y(n))<br>我们开始推导</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x(n) = x(n-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">函数 x(n) 很简单，我们怎么表达 y(n) 呢</span><br><span class="line">我们发现 y(n) 是一个往复的等差数列</span><br><span class="line">对于本题有</span><br><span class="line">y(n) = y(n - <span class="number">1</span>) + step(n)</span><br><span class="line">step 是一个往复函数</span><br><span class="line">用 flag 代表往复函数的方向</span><br><span class="line"> |-<span class="number">1</span>  当 y(n - <span class="number">1</span>) 到达最大值或者最小值时</span><br><span class="line">flag = | <span class="number">1</span>  其他</span><br><span class="line">step(n) = flag * step(n-<span class="number">1</span>)当 y(n - <span class="number">1</span>) 到达最大值或者最小值时</span><br><span class="line"> |-step(n-<span class="number">1</span>)其他</span><br><span class="line">step(n) = |step(n)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">convert</span><span class="params">(s: <span class="type">String</span>, numRows: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        推出 (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">val</span> rows: MutableList&lt;StringBuilder&gt; = ArrayList()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until numRows) rows.add(StringBuilder())</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> step = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> s.toCharArray()) &#123;</span><br><span class="line">            rows[i].append(c)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) step = -step</span><br><span class="line">            i += step</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> res = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (row <span class="keyword">in</span> rows) res.append(row)</span><br><span class="line">        <span class="keyword">return</span> res.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.2 - 算法题目 </category>
          
          <category> 0.2.1 - 中等 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. 最长回文子串</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">介绍 Manacher 算法</span><br><span class="line">理解回文串的对称性，减少与回文串相交的字符串的计算量</span><br><span class="line">关键词</span><br><span class="line">情况一：完全包含，直接赋值</span><br><span class="line">情况二：部分相交。直接从后一位接续计算</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>数据预处理： 首先回文子串有两种形式 奇数 与 偶数 也就有两种对应的指针操作方式</p><p>假定有字符数组 ababaabc 改成 # a # b # a # b # a # a # b # c # 将偶数数组变成奇数统一处理 索性改成 ^ # a # b # a # b # a # a # b # c # $，头尾清晰<br>这样就可以通过把每个字符作为回文子串的中心向两边扩展，找出最长回文子串 时间复杂度是 O(n^2)</p><p>现在需要我们观察回文子串的规律，简化计算</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">      ^ # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # c # $</span><br><span class="line"><span class="number">0</span>     ^                                      <span class="selector-tag">P</span><span class="selector-attr">[0]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">1</span>       ^                                    <span class="selector-tag">P</span><span class="selector-attr">[1]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>       --^--                                <span class="selector-tag">p</span><span class="selector-attr">[2]</span>  = <span class="number">1</span></span><br><span class="line"><span class="number">3</span>           ^                                <span class="selector-tag">P</span><span class="selector-attr">[3]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">5</span>               ^                            <span class="selector-tag">P</span><span class="selector-attr">[5]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span></span><br><span class="line"><span class="number">7</span>                   ^                        <span class="selector-tag">P</span><span class="selector-attr">[7]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">9</span>                       ^                    <span class="selector-tag">P</span><span class="selector-attr">[9]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">11</span>                  --------^--------        <span class="selector-tag">P</span><span class="selector-attr">[11]</span> = <span class="number">2</span></span><br><span class="line"><span class="number">12</span>                          --^--            <span class="selector-tag">P</span><span class="selector-attr">[12]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">13</span>                              ^            <span class="selector-tag">P</span><span class="selector-attr">[13]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">14</span>                              --^--        <span class="selector-tag">P</span><span class="selector-attr">[14]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">15</span>                                  ^        <span class="selector-tag">P</span><span class="selector-attr">[15]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">16</span>                                  --^--    <span class="selector-tag">P</span><span class="selector-attr">[16]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">17</span>                                      ^    <span class="selector-tag">P</span><span class="selector-attr">[17]</span> = <span class="number">0</span></span><br><span class="line"><span class="number">18</span>                                        ^  <span class="selector-tag">P</span><span class="selector-attr">[18]</span> = <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>情况一：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span></span><br><span class="line"><span class="number">11</span>                  --------^--------        <span class="selector-tag">P</span><span class="selector-attr">[11]</span> = <span class="number">2</span></span><br><span class="line"><span class="number">12</span>                          --^--            <span class="selector-tag">P</span><span class="selector-attr">[12]</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>第 10 行，第 12 行 都是 第 11 行 的子串，完全包含在 第 11 行 之中，由于回文串的对称性 此时直接有 P[10] &#x3D; P[12]</p><p>情况二：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span></span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>第 4 行，第 8 行 都是 第 6 行 的子串，分别位于字符串的两端，当我们知道 第 4 行 的信息之后，我们知道 第 8 行 至少有 第 4 行 那么长，至于会不会更长，继续试着向两边扩展即可 此时需要干两件事 1. 将 P[8] &#x3D; P[4]; 2. 继续向外扩展</p><p>情况三： 8 ——^—— P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 第 8 行 部分与 第 11 行 重叠，第 14 行 是 第 11 行 的子串，非常简单，舍弃超出部分 8 –^– P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 当成这样处理即可 定义遍历指针 i ，指向回文的中心的指针 center 和 指向回文串右边界的指针 r 此时需要干两件事 1. 将 P[8] &#x3D; r - i ; 2. 继续向外扩展</p><p>好，我们现在已经理解了 Manacher 算法的精髓了 我们思考一下算法该怎么写</p><p>P[i] 计算过程</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">      ^ # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # <span class="selector-tag">a</span> # <span class="selector-tag">a</span> # <span class="selector-tag">b</span> # c # $</span><br><span class="line"><span class="number">0</span>     ^                                      <span class="selector-tag">P</span><span class="selector-attr">[0]</span>  = <span class="number">0</span>  -- 起始，不必计算，更新 r</span><br><span class="line"><span class="number">1</span>       ^                                    <span class="selector-tag">P</span><span class="selector-attr">[1]</span>  = <span class="number">0</span>  -- 暴力计算，一次计算，更新 r</span><br><span class="line"><span class="number">2</span>       --^--                                <span class="selector-tag">p</span><span class="selector-attr">[2]</span>  = <span class="number">1</span>  -- 暴力计算，二次计算，更新 r</span><br><span class="line"><span class="number">3</span>           ^                                <span class="selector-tag">P</span><span class="selector-attr">[3]</span>  = <span class="number">0</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span>  -- 暴力计算，四次计算，更新 r</span><br><span class="line"><span class="number">5</span>               ^                            <span class="selector-tag">P</span><span class="selector-attr">[5]</span>  = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span>  -- 情况二，六次计算，更新 r</span><br><span class="line"><span class="number">7</span>                   ^                        <span class="selector-tag">P</span><span class="selector-attr">[7]</span>  = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">9</span>                       ^                    <span class="selector-tag">P</span><span class="selector-attr">[9]</span>  = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">11</span>                  --------^--------        <span class="selector-tag">P</span><span class="selector-attr">[11]</span> = <span class="number">2</span>  -- 情况二，五次计算，更新 r</span><br><span class="line"><span class="number">12</span>                          --^--            <span class="selector-tag">P</span><span class="selector-attr">[12]</span> = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">13</span>                              ^            <span class="selector-tag">P</span><span class="selector-attr">[13]</span> = <span class="number">0</span>  -- 情况一，零次计算</span><br><span class="line"><span class="number">14</span>                              --^--        <span class="selector-tag">P</span><span class="selector-attr">[14]</span> = <span class="number">1</span>  -- 情况三，一次计算</span><br><span class="line"><span class="number">15</span>                                  ^        <span class="selector-tag">P</span><span class="selector-attr">[15]</span> = <span class="number">0</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">16</span>                                  --^--    <span class="selector-tag">P</span><span class="selector-attr">[16]</span> = <span class="number">1</span>  -- 暴力计算，两次计算，更新 r</span><br><span class="line"><span class="number">17</span>                                      ^    <span class="selector-tag">P</span><span class="selector-attr">[17]</span> = <span class="number">0</span>  -- 情况二，一次计算</span><br><span class="line"><span class="number">18</span>                                        ^  <span class="selector-tag">P</span><span class="selector-attr">[18]</span> = <span class="number">0</span>  -- 终止</span><br></pre></td></tr></table></figure><p>我列出了每次计算面对的情况，计算的次数以及是否需要 r 我希望大家思考 当新计算出的 r 与旧的 r 相等时，是否应该更新 center ？ 当然不应该，我们肯定更倾向于选择更长的回文串</p><p>是这样吗？ 我们思考一种情况</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>       --^--                                <span class="selector-tag">p</span><span class="selector-attr">[2]</span>  = <span class="number">1</span></span><br><span class="line"><span class="number">3</span>           ^                                <span class="selector-tag">P</span><span class="selector-attr">[3]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">4</span>       ------^------                        <span class="selector-tag">P</span><span class="selector-attr">[4]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">5</span>               ^                            <span class="selector-tag">P</span><span class="selector-attr">[5]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">6</span>       ----------^----------                <span class="selector-tag">P</span><span class="selector-attr">[6]</span>  = <span class="number">5</span></span><br><span class="line"><span class="number">7</span>                   ^                        <span class="selector-tag">P</span><span class="selector-attr">[7]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">8</span>               ------^------                <span class="selector-tag">P</span><span class="selector-attr">[8]</span>  = <span class="number">3</span></span><br><span class="line"><span class="number">9</span>                       ^                    <span class="selector-tag">P</span><span class="selector-attr">[9]</span>  = <span class="number">0</span></span><br><span class="line"><span class="number">10</span>                      --^--                <span class="selector-tag">P</span><span class="selector-attr">[10]</span> = <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>第 6 行 较长有什么用呢，有用的只是 i 到 r 这一小截而已，不更新是因为都一样，没必要更新，所以只有当我们发现了更右边的 r 更新即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private fun formatString(s: String): String&#123;</span><br><span class="line">        val tString : StringBuffer = <span class="built_in">StringBuffer</span>(<span class="string">&quot;^#&quot;</span>)</span><br><span class="line">        for ( i in s.indices )&#123;</span><br><span class="line">            tString<span class="selector-class">.append</span>(s<span class="selector-attr">[i]</span>)</span><br><span class="line">            tString<span class="selector-class">.append</span>(&#x27;#&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        return tString<span class="selector-class">.append</span>(&#x27;$&#x27;)<span class="selector-class">.toString</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun extend(s: String, leftIndex: Int, rightIndex: Int): Int &#123;</span><br><span class="line">        <span class="selector-tag">var</span> r = <span class="number">0</span></span><br><span class="line">        <span class="selector-tag">var</span> <span class="attribute">left</span> = leftIndex</span><br><span class="line">        <span class="selector-tag">var</span> <span class="attribute">right</span> = rightIndex</span><br><span class="line">        while (<span class="attribute">left</span> &gt; <span class="number">0</span> &amp;&amp; <span class="attribute">right</span> &lt; s<span class="selector-class">.length</span> &amp;&amp; s<span class="selector-attr">[left]</span> == s<span class="selector-attr">[right]</span>)&#123;</span><br><span class="line">           r ++</span><br><span class="line">           <span class="attribute">left</span> --</span><br><span class="line">           <span class="attribute">right</span> ++</span><br><span class="line">        &#125;</span><br><span class="line">        return r</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun longestPalindrome(s: String): String &#123;</span><br><span class="line">        val tString = formatString(s)</span><br><span class="line">        <span class="selector-tag">var</span> maxR = <span class="number">0</span></span><br><span class="line">        <span class="selector-tag">var</span> maxCenter = <span class="number">0</span></span><br><span class="line">        <span class="selector-tag">var</span> center = -<span class="number">1</span></span><br><span class="line">        <span class="selector-tag">var</span> R = <span class="number">0</span></span><br><span class="line">        val <span class="selector-tag">p</span> = Array&lt;Int&gt;(tString<span class="selector-class">.length</span>) &#123; <span class="number">0</span> &#125;</span><br><span class="line">    </span><br><span class="line">        for ( <span class="selector-tag">i</span> in tString<span class="selector-class">.indices</span> )&#123;</span><br><span class="line">            val iMirror = center - (<span class="selector-tag">i</span> - center)</span><br><span class="line">            <span class="selector-tag">var</span> rightIndex = <span class="selector-tag">i</span></span><br><span class="line">            <span class="selector-tag">var</span> leftIndex = <span class="selector-tag">i</span></span><br><span class="line">            val maxLength = R - <span class="selector-tag">i</span></span><br><span class="line">    </span><br><span class="line">            val hasMirrorIndex = <span class="selector-tag">i</span> &lt; R &amp;&amp; center - maxLength &gt; <span class="number">0</span></span><br><span class="line">            val case1CompletelyIncluded = hasMirrorIndex &amp;&amp; <span class="selector-tag">i</span> &gt; center &amp;&amp; <span class="selector-tag">p</span><span class="selector-attr">[iMirror]</span> &lt; R - <span class="selector-tag">i</span></span><br><span class="line">            val case2NotCompletelyInclude = hasMirrorIndex &amp;&amp; !case1CompletelyIncluded</span><br><span class="line">            </span><br><span class="line">            if(!hasMirrorIndex)&#123;</span><br><span class="line">                <span class="selector-tag">p</span><span class="selector-attr">[i]</span> = <span class="number">0</span></span><br><span class="line">                rightIndex = <span class="selector-tag">i</span> + <span class="number">1</span></span><br><span class="line">                leftIndex = <span class="selector-tag">i</span> - <span class="number">1</span></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(case1CompletelyIncluded) &#123;</span><br><span class="line">                    <span class="selector-tag">p</span><span class="selector-attr">[i]</span> = <span class="selector-tag">p</span><span class="selector-attr">[iMirror]</span></span><br><span class="line">                    continue</span><br><span class="line">                &#125; else if (case2NotCompletelyInclude) &#123;</span><br><span class="line">                    <span class="selector-tag">p</span><span class="selector-attr">[i]</span> = maxLength</span><br><span class="line">                    rightIndex = R + <span class="number">1</span></span><br><span class="line">                    leftIndex = <span class="selector-tag">i</span> - (rightIndex - <span class="selector-tag">i</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">p</span><span class="selector-attr">[i]</span> += extend(tString, leftIndex, rightIndex)</span><br><span class="line">            </span><br><span class="line">            // 更新最右边的 R 和 center</span><br><span class="line">            if(<span class="selector-tag">i</span> + <span class="selector-tag">p</span><span class="selector-attr">[i]</span> &gt; R)&#123;</span><br><span class="line">                R = <span class="selector-tag">i</span> + <span class="selector-tag">p</span><span class="selector-attr">[i]</span></span><br><span class="line">                center = <span class="selector-tag">i</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 判断是不是最长的回文串</span><br><span class="line">            if(<span class="selector-tag">p</span><span class="selector-attr">[i]</span> &gt; maxR)&#123;</span><br><span class="line">                maxR = <span class="selector-tag">p</span><span class="selector-attr">[i]</span></span><br><span class="line">                maxCenter = <span class="selector-tag">i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if(maxR == <span class="number">0</span>) return &quot;&quot;</span><br><span class="line">    </span><br><span class="line">        val start = maxCenter - maxR</span><br><span class="line">        val end = maxCenter + maxR</span><br><span class="line">        return tString<span class="selector-class">.substring</span>(start.<span class="selector-class">.end</span>)<span class="selector-class">.replace</span>(&quot;#&quot;, &quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.2 - 算法题目 </category>
          
          <category> 0.2.1 - 中等 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 寻找两个正序数组的中位数</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">讨论在两个有序数组中寻找中位数的问题</span><br><span class="line"></span><br><span class="line">观察单个有序数组，通过比较元素大小找到舍弃的元素，确定中位数。</span><br><span class="line"></span><br><span class="line">类推两个有序数组，准备两个区间来存放偏小值和偏大值。</span><br><span class="line">根据区间需要满足必要条件，使得偏小区间的元素都小于偏大区间。</span><br><span class="line">问题转化为在单个有序数组中查找满足条件的关键元素位置，可以使用二分查找。</span><br><span class="line"></span><br><span class="line">关键词:</span><br><span class="line">偏小区间</span><br><span class="line">偏大区间</span><br><span class="line">二分查找</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先思考我们是否可以避免全排序找到中位数</p><p>我们有一种想法就是通过比较元素的大小找到需要舍弃的元素</p><p>我们观察一个有序数组，我们准备两个区间 RSmall, RBig 分别存放这个数组的偏小值与偏大值（相对中位数而言）</p><p>分别用 left，right 指针从两头操作偏小值与偏大值，将他们依次放入对应的数组</p><p>直到 「偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1」，中位数显然易得</p><p>好，现在我们来看两个有序数组的复杂情况</p><p>我们同样准备两个区间 RSmall, RBig，同样我们需要将数组偏小值放进 RSmall，偏大值放进 RBig</p><p>与一个有序数组不同的是，现在我们必须综合考虑两个有序数组的情况</p><p>所以 RSmall 区间里可能既包含 num1 数组的偏小元素也包含 num2 数组的偏小元素，对于RBig也是一样</p><p>这就让我们的思考变得复杂了，这使得 RSmall，RBig 变得无序</p><p>现在将这个 RSmall 再细分为 RSmallN1 区间，以及 RSmallN2 区间，同样有 RBigN1，RBigN2 区间</p><p>想要得到中位数，那么偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1</p><p>也就有</p><p>「 必要条件一： 偶数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size 奇数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size +1 」</p><p>同时 RSmall 区间内任何一个元素都必须小于 RBig 区间</p><p>自然有 Small 区间的子区间的任何一个元素都小于 Big 区间的子区间的任何一个元素</p><p>所以得到</p><p>「 必要条件二： RSmallN1 的最大值 &lt; RBigN1 的最小值 ( 因为数组有序，这是不用判断的 ) RSmallN1 的最大值 &lt; RBigN2 的最小值 RSmallN2 的最大值 &lt; RBigN1 的最小值 RSmallN2 的最大值 &lt; RBigN2 的最小值 ( 因为数组有序，这是不用判断的 )」</p><p>简化一下</p><p>「 必要条件二： maxOf( RSmallN1 ) &lt; minOf ( RBigN2 ) maxOf( RSmallN2 ) &lt; minOf ( RBigN1 ) 」</p><p>显然必要条件一加上必要条件二就是充分必要条件</p><p>现在我们要得到这四个区间，或者说要在两个有序数组分别划分出这四个区间</p><p>我们要在这两个数组中分别找到关键的那个分隔元素</p><p>因为必要条件一的原因，我们找到了 num1 数组的分割元素，我们也就找到了 num2 数组的分割元素</p><p>这非常好理解，因为 Small 区间和 Big 区间的数量是固定的，RSmallN1 多了一个元素，RSmallN2 就要对应减少一个元素</p><p>所以我们只要找到 num1 数组的分隔元素即可</p><p>至此，问题成功转化成了</p><p>在 num1 数组中查找出一个关键元素位置，这个关键元素满足上述两条必要条件</p><p>这是一个典型的有判断条件的查找问题，我们就可以使用二分查找，测试每个元素是否符合上述两个条件</p><p>关于二分查找这里不再赘述。</p><p>以下是基于二分查找的 Kotlin 代码实现，用于找出两个有序数组的中位数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数用于在两个已排序整数数组中找到它们的中位数，返回类型为 Double。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 nums1 和 nums2 的长度。</span></span><br><span class="line">    <span class="keyword">val</span> n1 = nums1.size</span><br><span class="line">    <span class="keyword">val</span> n2 = nums2.size</span><br><span class="line">    <span class="comment">// 如果 nums1 的长度大于 nums2，则交换它们，确保 nums1 的长度小于等于 nums2。</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 设置左右指针的初始值。</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span> <span class="comment">// 如果把 num1 和 num2 合并元素重新排序，最左边</span></span><br><span class="line">    <span class="keyword">var</span> right = n1 <span class="comment">// 如果把 num1 和 num2 合并元素重新排序，相当于 num2 最左边</span></span><br><span class="line">    <span class="comment">// 当左指针小于等于右指针时，执行二分查找。</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 因为 n1 &lt; n2</span></span><br><span class="line">        <span class="comment">// 计算 nums1 中间的索引 i 和 nums2 中间的索引 j。</span></span><br><span class="line">        <span class="keyword">val</span> num1HalfIndex = (left + right) / <span class="number">2</span> </span><br><span class="line">        <span class="keyword">val</span> num2HalfIndex = ((n1 + n2 + <span class="number">1</span>) / <span class="number">2</span>) - num1HalfIndex  </span><br><span class="line">        <span class="comment">// 计算 nums1 和 nums2 的左侧和右侧的最大值和最小值。</span></span><br><span class="line">        <span class="keyword">val</span> maxOfNum1SmallRange = <span class="keyword">if</span> (num1HalfIndex == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[num1HalfIndex - <span class="number">1</span>] <span class="comment">// nums1 小区间的最大值</span></span><br><span class="line">        <span class="keyword">val</span> minOfNum1BigRange = <span class="keyword">if</span> (num1HalfIndex == n1) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[num1HalfIndex] <span class="comment">// nums1 大区间的最小值</span></span><br><span class="line">        <span class="keyword">val</span> maxOfNum2SmallRange = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>] <span class="comment">// nums2 小区间的最大值</span></span><br><span class="line">        <span class="keyword">val</span> minOfNum2BigRange = <span class="keyword">if</span> (j == n2) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j] <span class="comment">// nums2 大区间的最小值</span></span><br><span class="line">        <span class="comment">// 如果满足条件，则返回中位数。</span></span><br><span class="line">        <span class="keyword">if</span> (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; <span class="comment">// num1小 &lt; num2大 &amp;&amp; num2小 &lt; num1大, 也就是说“小区间都小于大区间”</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">if</span> ((n1 + n2) % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果 nums1 和 nums2 的长度之和为偶数</span></span><br><span class="line">                <span class="comment">// 则返回左右两侧最大值和最小值的平均值。</span></span><br><span class="line">                (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / <span class="number">2.0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1 和 nums2 的长度之和为奇数，则返回左侧最大值。</span></span><br><span class="line">                maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; <span class="comment">// num1大 &lt; num2小</span></span><br><span class="line">            <span class="comment">// 如果 nums1 的左侧最大值大于 nums2 的右侧最小值，则需要将 num1HalfIndex 向左移动。</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   left   num1HalfIndex   right</span></span><br><span class="line"><span class="comment">                    |           |           |</span></span><br><span class="line"><span class="comment">                    1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">          1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                          |</span></span><br><span class="line"><span class="comment">                     num2HalfIndex</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            right = num1HalfIndex - <span class="number">1</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    num1HalfIndex </span></span><br><span class="line"><span class="comment">                   left   |   right</span></span><br><span class="line"><span class="comment">                    |     |     |</span></span><br><span class="line"><span class="comment">                    1 1 1 1 1 1 1 1 1 1 1 1 </span></span><br><span class="line"><span class="comment">          1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                                |</span></span><br><span class="line"><span class="comment">                           num2HalfIndex </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 nums2 的左侧最大值大于 nums1 的右侧最小值，则需要将 num1HalfIndex 向右移动。</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         left   num1HalfIndex   right</span></span><br><span class="line"><span class="comment">          |           |           |</span></span><br><span class="line"><span class="comment">          1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                  1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E</span></span><br><span class="line"><span class="comment">                                  |</span></span><br><span class="line"><span class="comment">                            num2HalfIndex</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            left = num1HalfIndex + <span class="number">1</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            留给大家画</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到中位数，则返回 0.0。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n1 = nums1.size</span><br><span class="line">    <span class="keyword">val</span> n2 = nums2.size</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = n1</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 因为 n1 &lt; n2</span></span><br><span class="line">        <span class="keyword">val</span> num1HalfIndex = (left + right) / <span class="number">2</span> </span><br><span class="line">        <span class="keyword">val</span> num2HalfIndex = ((n1 + n2 + <span class="number">1</span>) / <span class="number">2</span>) - num1HalfIndex  </span><br><span class="line">        <span class="keyword">val</span> maxOfNum1SmallRange = <span class="keyword">if</span> (num1HalfIndex == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums1[num1HalfIndex - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> minOfNum1BigRange = <span class="keyword">if</span> (num1HalfIndex == n1) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums1[num1HalfIndex]</span><br><span class="line">        <span class="keyword">val</span> maxOfNum2SmallRange = <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">Int</span>.MIN_VALUE <span class="keyword">else</span> nums2[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> minOfNum2BigRange = <span class="keyword">if</span> (j == n2) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> nums2[j]</span><br><span class="line">        <span class="keyword">if</span> (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">if</span> ((n1 + n2) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / <span class="number">2.0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123;</span><br><span class="line">            right = num1HalfIndex - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = num1HalfIndex + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留给大家一个问题，问 N 个有序数组的中位数怎么求？</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.2 - 算法题目 </category>
          
          <category> 0.2.2 - 困难 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">巧妙的使用 HashMap&lt;Char, Int&gt; 记录每个字符的最新的位置</span><br><span class="line">巧妙的确定了每个元素对应的滑动窗口的左边界</span><br><span class="line">关键词：</span><br><span class="line">HashMap &lt;Char, Int&gt;用以查找位置</span><br><span class="line">窗口长度不固定，遍历指针作为左边界</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>本题的巧妙在于使用 HashMap 和 遍历指针构建了一个滑动窗口</p><p>在寻找滑动窗口的时候，我们总是固定住一端位置去寻找另一端的位置，通常需要我们找到两个端点之间的关系</p><p>来分析滑动窗口的性质：左边届位置，右边界的位置，滑动窗口的长度<br>三者有以下这些关系：<code>滑动窗口的长度 = 滑动窗口右边届 - 滑动窗口左边界</code><br>无论算法如何变化，我们知二求一</p><p>我们分析，遍历指针和左右边界的关系有三<br>情况一：遍历指针是滑动窗口的左边界<br>情况二：遍历指针是滑动窗口的右边界<br>情况三：遍历指针在滑动窗口的中间</p><p>结合滑动窗口的性质<br>情况一：知道窗口的长度，以遍历指针为左边界<br>情况二：窗口长度不固定，新增的元素决定窗口的长度，也就是左边界的位置<br>情况三：对于滑动窗口算法，通常情况下遍历指针要么位于窗口的左边界，要么位于右边界，用于控制窗口的扩展和收缩。在常规的滑动窗口算法中，遍历指针并不位于窗口的中间位置。</p><p>显然这种是情况二</p><p>当滑动窗口的位置和长度变化受制于新增的元素时，我们将遍历指针设置为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">0</span> <span class="comment">// 最长不含重复字符子串的长度</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span> <span class="comment">// 窗口左边界</span></span><br><span class="line">        <span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;() <span class="comment">// 哈希表记录字符最后出现的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right <span class="keyword">in</span> s.indices)&#123;</span><br><span class="line">            <span class="keyword">val</span> char = s[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(char) &amp;&amp; map[char]!! &gt;= left)&#123;</span><br><span class="line">                left = (map[char]?: <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map[char] = right</span><br><span class="line">            maxLen = maxOf(maxLen, right - left + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.2 - 算法题目 </category>
          
          <category> 0.2.1 - 中等 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2. 两数相加</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">遍历两个链表，元素相加生成新列表。</span><br><span class="line">关键词：</span><br><span class="line">哨兵节点 val dummy = ListNode(0)</span><br><span class="line">关键返回值 dummy?.next</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="comment">// 定义两个指针 p1 和 p2，分别指向两个链表的头节点</span></span><br><span class="line">        <span class="keyword">var</span> p1 = l1</span><br><span class="line">        <span class="keyword">var</span> p2 = l2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个哨兵节点 dummy，作为结果链表的头节点</span></span><br><span class="line">        <span class="keyword">val</span> dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 定义一个节点 cur, 作为结果链表的尾节点</span></span><br><span class="line">        <span class="keyword">var</span> cur = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> x = p1?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> y = p2?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> sum = x + y + carry</span><br><span class="line">            carry = sum / <span class="number">10</span></span><br><span class="line">            sum = sum % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            cur?.next = ListNode(sum)</span><br><span class="line"></span><br><span class="line">            p1 = p1?.next</span><br><span class="line">            p2 = p2?.next</span><br><span class="line">            cur = cur?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cur?.next = ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy?.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.2 - 算法题目 </category>
          
          <category> 0.2.0 - 简单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1. 两数之和</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10^4</code></li><li><code>-109 &lt;= nums[i] &lt;= 10^9</code></li><li><code>-109 &lt;= target &lt;= 10^9</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键在于对 hashmap 查找时间复杂度 O(1) 的应用</span><br><span class="line">关键词：</span><br><span class="line">HashMap&lt;Key, Value&gt;</span><br><span class="line">hashmap.containsKey(Value)</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> hashmap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> nums.indices)&#123;</span><br><span class="line">            <span class="keyword">val</span> complement = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(complement))&#123;</span><br><span class="line">                <span class="keyword">return</span> intArrayOf(hashmap[complement]!!, i)</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i        </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> intArrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.2 - 算法题目 </category>
          
          <category> 0.2.0 - 简单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23. 构建前缀树（字典树）</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/23%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/23%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> children = HashMap&lt;<span class="built_in">Char</span>, TrieNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> isWord = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(char)) &#123;</span><br><span class="line">                node.children[char] = TrieNode()</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[char]!!</span><br><span class="line">        &#125;</span><br><span class="line">        node.isWord = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(word: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(char)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[char]!!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isWord</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startsWith</span><span class="params">(prefix: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(char)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[char]!!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22. 动态规划-自顶向下法</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/22%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B3%95/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/22%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dp</span><span class="params">(n: <span class="type">Int</span>, memo: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否已经计算过该值</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        memo[n] = n</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归计算并保存结果</span></span><br><span class="line">    memo[n] = dp(n - <span class="number">1</span>, memo) + dp(n - <span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21. 回溯</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/21%20%E5%9B%9E%E6%BA%AF/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/21%20%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">backtrack</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否达到结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (满足结束条件) &#123;</span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">        处理结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可能的选择</span></span><br><span class="line">    <span class="keyword">for</span> (选择 <span class="keyword">in</span> 可选列表) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        做选择</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(...)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20. 二分查找-贪心问题</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            nums[mid] == target -&gt; <span class="keyword">return</span> mid</span><br><span class="line">            nums[mid] &lt; target -&gt; left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. 二分查找-重复元素，最右边的插入点</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/19%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/19%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchInsert</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> result = nums.size <span class="comment">// 默认插入到最右边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 找到目标元素，更新结果为当前索引</span></span><br><span class="line">                result = mid</span><br><span class="line">            &#125;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18. 二分查找-重复元素，最左边的插入点</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/18%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/18%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchInsert</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到了目标元素，返回索引</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 目标元素在右半部分，更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 目标元素在左半部分，更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标元素不存在，返回插入位置</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17. 二分查找</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/17%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/17%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16. 找到堆的前 k 个元素</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/16%20%E6%89%BE%E5%88%B0%E5%A0%86%E7%9A%84%E5%89%8D%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/16%20%E6%89%BE%E5%88%B0%E5%A0%86%E7%9A%84%E5%89%8D%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findKthLargest</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建最小堆</span></span><br><span class="line">    <span class="keyword">val</span> minHeap = PriorityQueue&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组中的元素依次加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        minHeap.offer(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最小堆的大小超过 k，移除堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size &gt; k) &#123;</span><br><span class="line">            minHeap.poll()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆顶元素，即第 k 大的元素</span></span><br><span class="line">    <span class="keyword">return</span> minHeap.peek()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15. 图-BFS</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/15%20%E5%9B%BE-BFS/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/15%20%E5%9B%BE-BFS/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adjacencyList: MutableMap&lt;<span class="built_in">Int</span>, MutableList&lt;<span class="built_in">Int</span>&gt;&gt; = HashMap()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addEdge</span><span class="params">(src: <span class="type">Int</span>, dest: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        adjacencyList.computeIfAbsent(src) &#123; mutableListOf() &#125;.add(dest)</span><br><span class="line">        adjacencyList.computeIfAbsent(dest) &#123; mutableListOf() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">(startVertex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> visited = BooleanArray(adjacencyList.size)</span><br><span class="line">        <span class="keyword">val</span> queue: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">        visited[startVertex] = <span class="literal">true</span></span><br><span class="line">        queue.offer(startVertex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> currentVertex = queue.poll()</span><br><span class="line">            print(<span class="string">&quot;<span class="variable">$currentVertex</span> &quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> neighbors = adjacencyList[currentVertex]</span><br><span class="line">            <span class="keyword">if</span> (neighbors != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (neighbor <span class="keyword">in</span> neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                        visited[neighbor] = <span class="literal">true</span></span><br><span class="line">                        queue.offer(neighbor)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> graph = Graph()</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    graph.addEdge(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;BFS traversal starting from vertex 2:&quot;</span>)</span><br><span class="line">    graph.bfs(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. 图-DFS (迭代)</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/14%20%E5%9B%BE-DFS-(%E8%BF%AD%E4%BB%A3)/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/14%20%E5%9B%BE-DFS-(%E8%BF%AD%E4%BB%A3)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adjacencyList: MutableMap&lt;<span class="built_in">Int</span>, MutableList&lt;<span class="built_in">Int</span>&gt;&gt; = mutableMapOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addEdge</span><span class="params">(u: <span class="type">Int</span>, v: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        adjacencyList.computeIfAbsent(u) &#123; mutableListOf() &#125;.add(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(start: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> stack = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        stack.add(start)</span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> vertex = stack.removeAt(stack.size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(vertex)) &#123;</span><br><span class="line">                visited.add(vertex)</span><br><span class="line">                println(<span class="string">&quot;Visited vertex: <span class="variable">$vertex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                adjacencyList[vertex]?.reversed()?.forEach &#123; neighbor -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                        stack.add(neighbor)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> graph = Graph()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加图的边</span></span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点0开始进行DFS</span></span><br><span class="line">    graph.dfs(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. 图-DFS (递归)</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/13%20%E5%9B%BE-DFS%20(%E9%80%92%E5%BD%92)/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/13%20%E5%9B%BE-DFS%20(%E9%80%92%E5%BD%92)/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adjList: MutableMap&lt;<span class="built_in">Int</span>, MutableList&lt;<span class="built_in">Int</span>&gt;&gt; = mutableMapOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addEdge</span><span class="params">(u: <span class="type">Int</span>, v: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        adjList.getOrPut(u) &#123; mutableListOf() &#125;.add(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(vertex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> visited = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        dfsHelper(vertex, visited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsHelper</span><span class="params">(vertex: <span class="type">Int</span>, visited: <span class="type">MutableSet</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        visited.add(vertex)</span><br><span class="line">        println(vertex) <span class="comment">// 在这里可以对当前节点进行相关操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> neighbors = adjList[vertex]</span><br><span class="line">        <span class="keyword">if</span> (neighbors != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (neighbor <span class="keyword">in</span> neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                    dfsHelper(neighbor, visited)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> graph = Graph()</span><br><span class="line">    <span class="comment">// 添加图的边</span></span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    graph.addEdge(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 0 开始进行深度优先搜索</span></span><br><span class="line">    graph.dfs(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09. 单调递增栈</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/09%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/09%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotonicStack</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> result = IntArray(nums.size) &#123; -<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; stack.last() &lt; nums[i]) &#123;</span><br><span class="line">            stack.removeAt(stack.size - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以根据题目需求进行处理</span></span><br><span class="line">        <span class="comment">// 例如：找到栈中元素的下一个更大元素</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">            result[i] = stack.last()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack.add(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08. 找到符合确切条件的子数组数</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/08%20%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E7%A1%AE%E5%88%87%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/08%20%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E7%A1%AE%E5%88%87%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numSubarraysWithSum</span><span class="params">(nums: <span class="type">IntArray</span>, goal: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (right <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        total += nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; total &gt; goal) &#123;</span><br><span class="line">            total -= nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total == goal) &#123;</span><br><span class="line">            count++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计连续的0</span></span><br><span class="line">            <span class="keyword">var</span> temp = left</span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= right &amp;&amp; nums[temp] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++</span><br><span class="line">                temp++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07. 反转链表</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/07%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/07%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> next: ListNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reverseList</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">var</span> prev: ListNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> current = head</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> nextNode = current.next</span><br><span class="line">    current.next = prev</span><br><span class="line">    prev = current</span><br><span class="line">    current = nextNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06. 链表-快慢指针</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/06%20%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/06%20%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在模板中，我们使用两个指针，一个指针每次向后移动一个节点，另一个指针每次向后移动两个节点。如果链表中存在循环，快指针最终会追上慢指针，这样我们就可以判断出链表有循环。如果链表没有循环，快指针会先到达链表的末尾，此时我们就可以判断链表没有循环。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasCycle</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slow = head</span><br><span class="line">    <span class="keyword">var</span> fast = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast?.next != <span class="literal">null</span> &amp;&amp; fast.next?.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow?.next</span><br><span class="line">        fast = fast.next?.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05. 高效的字符串构建</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/05%20%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/05%20%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>以下是一个高效的字符串构建算法模板：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildString</span><span class="params">(chars: <span class="type">List</span>&lt;<span class="type">Char</span>&gt;)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ch <span class="keyword">in</span> chars) &#123;</span><br><span class="line">        sb.append(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个模板中，我们使用 StringBuilder 来构建字符串。StringBuilder 是可变的字符串类，可以高效地进行字符串的拼接操作。</p><p>我们通过遍历字符列表 chars，逐个将字符添加到 StringBuilder 中。最后，通过调用 toString() 方法，将 StringBuilder 转换为最终的字符串结果并返回。</p><p>使用 StringBuilder 的好处是它避免了在每次拼接字符串时创建新的字符串对象，从而提高了性能和效率。特别是在需要频繁拼接大量字符串的情况下，使用 StringBuilder 可以避免不必要的性能损耗。</p><p>使用这个模板，你可以根据具体需求构建字符串。可以根据问题的要求在遍历过程中进行一些字符处理、条件判断等操作。</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04. 构建前缀和</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/04%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/04%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>以下是一个前缀和算法的常见模板：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">prefixSum</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> prefixSum = IntArray(nums.size + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.nums.size) &#123;</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prefixSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个模板中，我们使用一个额外的数组 prefixSum 来存储原始数组 nums 的前缀和。通过遍历原始数组，我们可以计算每个位置的前缀和并存储在 prefixSum 中。</p><p>使用前缀和数组 prefixSum，我们可以高效地回答多个查询，例如计算某个区间的和。假设我们需要计算区间 [left, right] 的和，我们可以使用如下方式获取结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = prefixSum[right + <span class="number">1</span>] - prefixSum[left</span><br></pre></td></tr></table></figure><p>这个计算结果即为原始数组中从位置 left 到位置 right 的元素之和。<br>请注意，在模板中，前缀和数组 prefixSum 的长度比原始数组 nums 的长度多了一个元素。这是为了方便计算区间和时的边界情况。</p>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03. 滑动窗口</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/03%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/03%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">slidingWindow</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nums.size</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算第一个窗口的和</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxSum = sum</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> k until n) &#123;</span><br><span class="line">        <span class="comment">// 新窗口的和等于之前窗口的和加上新进入窗口的元素，减去滑出窗口的元素</span></span><br><span class="line">        sum += nums[i] - nums[i - k]</span><br><span class="line">        <span class="comment">// 更新最大和</span></span><br><span class="line">        maxSum = maxOf(maxSum, sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02. 双指针-有两个输入, 两个都需要遍历完</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/02%20%E5%8F%8C%E6%8C%87%E9%92%88-%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%E5%AE%8C/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/02%20%E5%8F%8C%E6%8C%87%E9%92%88-%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%E5%AE%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoPointers</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pointer1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> pointer2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt; nums1.size &amp;&amp; pointer2 &lt; nums2.size) &#123;</span><br><span class="line">        <span class="comment">// 处理指针1和指针2对应位置的元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        pointer1++</span><br><span class="line">        pointer2++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余未遍历完的元素</span></span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt; nums1.size) &#123;</span><br><span class="line">        <span class="comment">// 处理指针1对应位置的元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pointer1++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointer2 &lt; nums2.size) &#123;</span><br><span class="line">        <span class="comment">// 处理指针2对应位置的元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pointer2++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶心法</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/00%20%E5%BF%83%E6%B3%95/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/00%20%E5%BF%83%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法高手养成体系"><a href="#算法高手养成体系" class="headerlink" title="算法高手养成体系"></a>算法高手养成体系</h1><h2 id="一、筑基阶段（1-3个月）"><a href="#一、筑基阶段（1-3个月）" class="headerlink" title="一、筑基阶段（1-3个月）"></a>一、筑基阶段（1-3个月）</h2><h3 id="武器库建设"><a href="#武器库建设" class="headerlink" title="武器库建设"></a>武器库建设</h3><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li>​<strong>数组</strong>​<br>前缀和、差分数组、双指针技巧（快慢指针&#x2F;对撞指针）</li><li>​<strong>链表</strong>​<br>环形检测（Floyd龟兔算法）、LRU缓存实现</li><li>​<strong>树</strong>​<br>红黑树旋转规则、B+树在数据库索引的应用</li><li>​<strong>图</strong>​<br>邻接表与邻接矩阵的存储差异，Dijkstra堆优化版时间复杂度推导</li></ul><h4 id="算法范式："><a href="#算法范式：" class="headerlink" title="算法范式："></a>算法范式：</h4><ul><li>​<strong>分治</strong>​<br>Karatsuba大数乘法（时间复杂度$O(n^{\log 3})$）</li><li>​<strong>贪心</strong>​<br>Huffman编码的熵最优性证明</li><li>​<strong>DP</strong>​<br>背包问题状态压缩技巧（滚动数组）</li></ul><h3 id="每日训练"><a href="#每日训练" class="headerlink" title="每日训练"></a>每日训练</h3><ol><li>完成《算法导论》第1-15章课后习题（重点：递归式求解主方法）</li><li>在LeetCode按类型刷题，每日3道（Easy 1, Medium 2）</li></ol><hr><h2 id="二、思维强化阶段（3-6个月）"><a href="#二、思维强化阶段（3-6个月）" class="headerlink" title="二、思维强化阶段（3-6个月）"></a>二、思维强化阶段（3-6个月）</h2><h3 id="高阶算法模式"><a href="#高阶算法模式" class="headerlink" title="高阶算法模式"></a>高阶算法模式</h3><h4 id="位运算魔法："><a href="#位运算魔法：" class="headerlink" title="位运算魔法："></a>位运算魔法：</h4><ul><li>用XOR找缺失数（LC268）</li><li>快速幂算法（矩阵快速幂解斐波那契）</li></ul><h4 id="空间换时间："><a href="#空间换时间：" class="headerlink" title="空间换时间："></a>空间换时间：</h4><ul><li>单调栈解决Next Greater Element（LC496）</li><li>跳表(SkipList)实现$O(\log N)$查询</li></ul><h4 id="数学建模："><a href="#数学建模：" class="headerlink" title="数学建模："></a>数学建模：</h4><ul><li>约瑟夫环递推公式推导</li><li>用中国剩余定理解决周期问题（LC1250）</li></ul><h3 id="实战突破："><a href="#实战突破：" class="headerlink" title="实战突破："></a>实战突破：</h3><ol><li>参加每周LeetCode周赛，目标进入前10%</li><li>实现《算法竞赛入门经典》中的STL轮子（手写红黑树）</li></ol><hr><h2 id="三、领域专精阶段（6-12个月）"><a href="#三、领域专精阶段（6-12个月）" class="headerlink" title="三、领域专精阶段（6-12个月）"></a>三、领域专精阶段（6-12个月）</h2><h3 id="分支选择与深化"><a href="#分支选择与深化" class="headerlink" title="分支选择与深化"></a>分支选择与深化</h3><h4 id="机器学习算法："><a href="#机器学习算法：" class="headerlink" title="机器学习算法："></a>机器学习算法：</h4><ul><li>推导XGBoost损失函数泰勒展开过程</li><li>手写SVM对偶问题求解器（SMO算法）</li></ul><h4 id="分布式算法："><a href="#分布式算法：" class="headerlink" title="分布式算法："></a>分布式算法：</h4><ul><li>Raft协议Leader选举的随机超时机制</li><li>Gossip协议在Cassandra中的应用</li></ul><h4 id="几何计算："><a href="#几何计算：" class="headerlink" title="几何计算："></a>几何计算：</h4><ul><li>凸包Graham扫描法实现</li><li>使用扫描线算法求矩形并集面积（LC850）</li></ul><h3 id="专项训练："><a href="#专项训练：" class="headerlink" title="专项训练："></a>专项训练：</h3><ol><li>在Codeforces刷2200+分的计算几何题目</li><li>复现Google Spanner的TrueTime API设计</li></ol><hr><h2 id="四、思维跃迁训练法"><a href="#四、思维跃迁训练法" class="headerlink" title="四、思维跃迁训练法"></a>四、思维跃迁训练法</h2><h3 id="降维打击法"><a href="#降维打击法" class="headerlink" title="降维打击法"></a>降维打击法</h3><ul><li>将字符串匹配问题转化为自动机（AC自动机实现）</li><li>用FFT加速多项式乘法（大数乘法优化）</li></ul><h3 id="极限压榨法"><a href="#极限压榨法" class="headerlink" title="极限压榨法"></a>极限压榨法</h3><ul><li>在内存限制1MB下实现外排序（多路归并）</li><li>用位图处理40亿整数去重（LC原题变形）</li></ul><hr><h2 id="五、工具链配置"><a href="#五、工具链配置" class="headerlink" title="五、工具链配置"></a>五、工具链配置</h2><h3 id="调试神器"><a href="#调试神器" class="headerlink" title="调试神器"></a>调试神器</h3><pre><code class="python"># 重定向调试工具import pdbpdb.set_trace()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.0 - 学习规划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01. 双指针-只有一个输入, 从两端开始遍历</title>
      <link href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/01%20%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%BB%8E%E4%B8%A4%E7%AB%AF%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86/"/>
      <url>/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/01%20%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%BB%8E%E4%B8%A4%E7%AB%AF%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doublePointer</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = arr.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 根据 left 和 right 相关的条件进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (CONDITION) &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 返回需要的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0 - 算法 </category>
          
          <category> 0.1 - 算法模版 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
