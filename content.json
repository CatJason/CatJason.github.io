{"meta":{"title":"喵星科技报","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"About Author","date":"2023-08-09T03:40:47.000Z","updated":"2023-08-09T17:43:34.000Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-08-08T22:26:40.000Z","updated":"2023-08-08T23:16:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-09T03:39:01.000Z","updated":"2023-08-09T03:39:56.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何理解 Vulkan MAX_CONCURRENT_FRAMES","slug":"8渲染引擎/03 Vulkan/01 如何理解 Vulkan MAX_CONCURRENT_FRAMES","date":"2025-05-30T17:40:12.612Z","updated":"2025-05-30T18:50:29.835Z","comments":true,"path":"2025/05/31/8渲染引擎/03 Vulkan/01 如何理解 Vulkan MAX_CONCURRENT_FRAMES/","link":"","permalink":"http://example.com/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/01%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20Vulkan%20MAX_CONCURRENT_FRAMES/","excerpt":"","text":"MAX_CONCURRENT_FRAMES 参数是Vulkan多帧并行处理的核心设计，理解它需要从硬件工作原理和性能调优两个维度来分析： 底层硬件机制GPU流水线特性：现代GPU采用深度流水线设计，类似CPU的指令级并行。 当设置为2时： 1CPU帧1记录 → GPU执行帧1 → CPU帧2记录 → GPU执行帧2 内存带宽影响：每增加一帧需要额外存储： 命令缓冲区副本 Uniform缓冲区(本例中每帧144字节mat4×3) 同步对象(约32字节&#x2F;帧) 性能权衡公式理论上吞吐量提升遵循： 1理论最大帧率 = 1 / max(CPU帧处理时间, GPU帧渲染时间) 当MAX_CONCURRENT_FRAMES&#x3D;N时，可掩盖的延迟为： 1可隐藏延迟 = (N-1) × min(CPU_time, GPU_time) 理论最大帧率公式1理论最大帧率 = \\frac&#123;1&#125;&#123;\\max(T_&#123;CPU&#125;, T_&#123;GPU&#125;)&#125; 核心含义： 系统瓶颈决定论：渲染管线的吞吐量由CPU和GPU中较慢的一方决定，符合木桶原理 时间维度：T_CPU包含命令记录+资源更新，T_GPU包含所有渲染阶段耗时 实例分析：假设某场景： CPU每帧处理时间：3ms GPU每帧渲染时间：5ms 则最大理论帧率 &#x3D; 1&#x2F;5ms &#x3D; ​​200 FPS​​ 可隐藏延迟公式1可隐藏延迟 = (N-1) \\times \\min(T_&#123;CPU&#125;, T_&#123;GPU&#125;) 关键洞察： 并行窗口：当有N帧资源时，系统可以构建深度为N的流水线 补偿机制：每增加一帧资源，就能多掩盖一个较慢者的处理周期 动态演示（N&#x3D;3时）：123456时间轴 CPU活动 GPU活动t0 记录帧1命令 空闲t1 记录帧2命令 执行帧1 t2 记录帧3命令 执行帧2t3 等待GPU 执行帧3 ↑ 这里CPU必须等待，因为N=3的窗口已满 此时可隐藏的延迟 &#x3D; (3-1)*min(3ms,5ms) &#x3D; 6ms 意味着系统能容忍6ms的突发延迟而不掉帧 工程实践意义参数选择策略： 瓶颈方 优化建议 数学原理 CPU受限 增加MAX_CONCURRENT_FRAMES 增大N使T_GPU×N &gt; T_CPU GPU受限 降低画质&#x2F;分辨率 减小分母max(T_CPU,T_GPU) 均衡状态 保持N&#x3D;2~3 达到1&#x2F;max(T,T)的理论极限 性能诊断方法：12345auto calc_optimal_N = [](float cpu_time, float gpu_time) &#123; float bottleneck = std::max(cpu_time, gpu_time); float hidden_latency = (target_latency - vsync_interval); return std::ceil(hidden_latency / std::min(cpu_time,gpu_time)) + 1;&#125;; 现代GPU架构的影响在RDNA3&#x2F;Turing等架构中，由于： 异步计算引擎的引入 硬件指令级并行(ILP)增强 显存压缩技术 实际观测到公式需要修正为： 1有效帧率 = \\frac&#123;1&#125;&#123;\\max(T_&#123;CPU&#125;, \\alpha \\cdot T_&#123;GPU&#125;)&#125; 其中α是GPU并行化系数（通常0.7~0.9） 高级应用场景在VR系统中，通常需要： 1N = \\left\\lceil \\frac&#123;motion-to-photon&#125;&#123;\\min(T_&#123;CPU&#125;,T_&#123;GPU&#125;)&#125; \\right\\rceil + 1 例如Oculus Rift要求的20ms延迟： 如果min(T_CPU,T_GPU)&#x3D;5ms → N&#x3D;20&#x2F;5+1&#x3D;5 这种场景下就需要更复杂的帧交错(Frame Interleaving)技术。 C++具体实现分析在代码中体现为三重资源组： 123456789// 每组资源包含：struct FrameResources &#123; VkCommandBuffer commandBuffer; // 命令缓冲区 VkSemaphore presentCompleteSem; // 图像可用信号量 VkSemaphore renderCompleteSem; // 渲染完成信号量 VkFence queueSubmitFence; // 队列提交栅栏 UniformBuffer uniformBuffer; // 每帧UBO&#125;;std::array&lt;FrameResources, MAX_CONCURRENT_FRAMES&gt; frames; 参数选择建议根据硬件特性调整： 硬件配置 推荐值 理论收益 集成显卡(移动设备) 2 避免内存带宽饱和 独立显卡(桌面级) 3 利用高显存带宽 多GPU交火系统 4 掩盖跨GPU通信延迟 延迟分析增加该值会引入： 1总延迟 = 呈现延迟 + (N-1)×帧间隔 例如60FPS下： N&#x3D;2 → 最大延迟16.7ms + 16.7ms &#x3D; 33.4ms N&#x3D;3 → 最大延迟增加到50.1ms 调试技巧可通过Vulkan调试扩展验证实际利用率： 123456void checkPipelineState() &#123; VkPipelineStageFlags stage; vkGetFenceStatus(device, frames[currentFrame].queueSubmitFence, &amp;stage); // 如果stage长期处于VK_PIPELINE_STAGE_ALL_COMMANDS_BIT // 说明GPU资源饱和，可考虑增大MAX_CONCURRENT_FRAMES&#125; 高级用法配合VK_KHR_timeline_semaphore扩展可实现动态帧数： 12uint32_t dynamicFrameCount = calculate_optimal_frame_count();resizeFrameResources(dynamicFrameCount); // 运行时调整资源组大小 最佳实践：从2开始逐步增加，使用VK_LAYER_KHRONOS_performance层监测GPU空闲率，当达到95%以上GPU利用率时停止增加。","categories":[{"name":"8 - 渲染引擎","slug":"8-渲染引擎","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"8.3 - Vulkan","slug":"8-渲染引擎/8-3-Vulkan","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-3-Vulkan/"}],"tags":[]},{"title":"如何理解 Vulkan","slug":"8渲染引擎/03 Vulkan/02 如何理解 Vulkan UBO 与帧重叠","date":"2025-05-30T17:40:12.612Z","updated":"2025-05-31T08:34:30.044Z","comments":true,"path":"2025/05/31/8渲染引擎/03 Vulkan/02 如何理解 Vulkan UBO 与帧重叠/","link":"","permalink":"http://example.com/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/02%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20Vulkan%20UBO%20%E4%B8%8E%E5%B8%A7%E9%87%8D%E5%8F%A0/","excerpt":"","text":"这段代码定义了一个名为 uniformBuffers 的数组，它包含 MAX_CONCURRENT_FRAMES 个 UniformBuffer 对象。这种设计通常用于图形渲染中的多缓冲技术（如双缓冲或三缓冲），目的是实现帧重叠（frame overlapping）并避免资源冲突。 关键点解释： 帧重叠（Frame Overlapping）： 现代图形 API（如 Vulkan&#x2F;DirectX 12）允许 CPU 准备下一帧的数据，同时 GPU 仍在渲染当前帧。 这需要为每一帧使用独立的资源，防止 CPU 覆盖 GPU 正在使用的数据。 **MAX_CONCURRENT_FRAMES**： 表示系统支持的最大并行处理帧数（通常是 2 或 3）。 例如：Vulkan 中常设为 VK_MAX_FRAMES_IN_FLIGHT。 **UniformBuffer**： 存储每帧需要的统一&#x2F;常量数据（如 MVP 矩阵、光照参数等）。 每个活跃帧都有自己独立的 UBO，防止写入冲突。 工作流程示例： 12345// 帧N使用它的UBOdrawFrameN(uniformBuffers[currentFrame]);// 同时，CPU可以更新帧N+1的UBOupdateUniformBuffer(uniformBuffers[(currentFrame + 1) % MAX_CONCURRENT_FRAMES]); 为什么需要这样设计？ 安全性：避免 GPU 读取 UBO 时被 CPU 写入破坏数据。 性能：允许 CPU 和 GPU 并行工作，提高吞吐量。 同步：配合栅栏（Fence）&#x2F;信号量（Semaphore）实现正确的帧调度。 这是现代图形编程中实现高效资源管理的典型模式。","categories":[{"name":"8 - 渲染引擎","slug":"8-渲染引擎","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"8.3 - Vulkan","slug":"8-渲染引擎/8-3-Vulkan","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-3-Vulkan/"}],"tags":[]},{"title":"如何理解 Vulkan","slug":"8渲染引擎/03 Vulkan/03 ","date":"2025-05-30T17:40:12.612Z","updated":"2025-05-31T08:34:30.044Z","comments":true,"path":"2025/05/31/8渲染引擎/03 Vulkan/03 /","link":"","permalink":"http://example.com/2025/05/31/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/03%20Vulkan/03%20/","excerpt":"","text":"这段代码定义了一个名为 uniformBuffers 的数组，它包含 MAX_CONCURRENT_FRAMES 个 UniformBuffer 对象。这种设计通常用于图形渲染中的多缓冲技术（如双缓冲或三缓冲），目的是实现帧重叠（frame overlapping）并避免资源冲突。 关键点解释： 帧重叠（Frame Overlapping）： 现代图形 API（如 Vulkan&#x2F;DirectX 12）允许 CPU 准备下一帧的数据，同时 GPU 仍在渲染当前帧。 这需要为每一帧使用独立的资源，防止 CPU 覆盖 GPU 正在使用的数据。 **MAX_CONCURRENT_FRAMES**： 表示系统支持的最大并行处理帧数（通常是 2 或 3）。 例如：Vulkan 中常设为 VK_MAX_FRAMES_IN_FLIGHT。 **UniformBuffer**： 存储每帧需要的统一&#x2F;常量数据（如 MVP 矩阵、光照参数等）。 每个活跃帧都有自己独立的 UBO，防止写入冲突。 工作流程示例： 12345// 帧N使用它的UBOdrawFrameN(uniformBuffers[currentFrame]);// 同时，CPU可以更新帧N+1的UBOupdateUniformBuffer(uniformBuffers[(currentFrame + 1) % MAX_CONCURRENT_FRAMES]); 为什么需要这样设计？ 安全性：避免 GPU 读取 UBO 时被 CPU 写入破坏数据。 性能：允许 CPU 和 GPU 并行工作，提高吞吐量。 同步：配合栅栏（Fence）&#x2F;信号量（Semaphore）实现正确的帧调度。 这是现代图形编程中实现高效资源管理的典型模式。","categories":[{"name":"8 - 渲染引擎","slug":"8-渲染引擎","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"8.3 - Vulkan","slug":"8-渲染引擎/8-3-Vulkan","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-3-Vulkan/"}],"tags":[]},{"title":"Android 边框阴影绘制方案","slug":"7复杂代码模版/2 阴影绘制/Android-边框阴影绘制方案","date":"2025-04-14T10:28:08.388Z","updated":"2025-04-14T14:06:39.473Z","comments":true,"path":"2025/04/14/7复杂代码模版/2 阴影绘制/Android-边框阴影绘制方案/","link":"","permalink":"http://example.com/2025/04/14/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/2%20%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6/Android-%E8%BE%B9%E6%A1%86%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6%E6%96%B9%E6%A1%88/","excerpt":"","text":"在说解决方案之前，我们需要先明确两个问题 到底什么是阴影 为什么在 Android 端上绘制阴影效果这么麻烦 每当我向 Android 同学提出第一问时，通常他们会回答我：阴影是个10-25%透明度的线性减淡的黑色图层 但是当你尝试在移动端去绘制这样一个黑色图层去代表阴影，其视觉效果肉眼可见的差强人意 于是绝大多数 Android 同学会提议你去找设计出个带阴影的图，或者使用诸如 ShadowLayout 这样复杂的控件https://github.com/lihangleo2/ShadowLayout ShadowLayout 使用了 1600 行代码只为实现边框阴影 再看看 github 上其他绘制阴影的方案，不是采用 RenderScript 这种即将被谷歌废弃的图像处理库，就是使用 Android 12 以上才有的还要依赖硬件加速的 RenderEffect，更有甚者者干脆用 Canvas 硬画，不仅效果不好，性能更是很差，稍有复杂的情况，甚至可能导致卡顿发热 我们不经要发问：Android 10多年了，难道就没有一个不需要和设计掰扯，能兼容所有机型，对开发简单友好的阴影解决方案吗？ 到底什么是阴影先来看下阴影的组成部分 我们可以将阴影大致分成两个部分，全影&#x2F;umbra 和 半影&#x2F;penumbra 。 半影区域就是阴影的过渡区， 也就是软阴影，有半影的阴影过渡时，视觉效果会好很多。 通俗点说：全影就是大家常说的 10 - 25% 透明度的黑色图层，通常我们需要绘制的边框阴影是半影。 为什么在 Android 端上绘制阴影效果这么麻烦半影的绘制实际上是一个多次采样模糊的过程 1234567891011float PCF(float2 uv, float currentDepth) &#123; float shadow = 0.0; float2 texelSize = 1.0 / _ShadowMap_TexelSize; for (int x = -1; x &lt;= 1; x++) &#123; for (int y = -1; y &lt;= 1; y++) &#123; float depth = tex2D(_ShadowMap, uv + float2(x, y) * texelSize).r; shadow += (currentDepth &gt; depth) ? 1.0 : 0.0; &#125; &#125; return shadow / 9.0;&#125; 在上述代码中，对 3* 3 的区域进行了模糊采样，也就是说每个像素点的颜色依赖其周围相邻的一圈像素点的颜色的计算结果，实现逐步衰减 切图和代码实现究竟哪个更好？首先明确一点：切图和代码实现的本质区别是什么？ 是预渲染和实时渲染的区别 如果我们当前卡片所在的背景是可枚举且数量较少的，我们应该倾向使用预渲染 举个例子： 如果一个页面只有日夜间两种阴影我们倾向于切图 如果需要七彩渐变非中心光源产生的（上下左右阴影不一致的）阴影，我们倾向于代码实现 使用 .9 图来规避切图的弊端切图虽然方便，却有以下几种弊端 设计会想打你，尤其当你需要反复调试效果的时候 切图会增加包体积 解决方案 自己学会使用 figma 调试阴影切图 使用 .9 图 当我们想要绘制一个带阴影的圆角矩形的时候，我们会发现除了矩形的四个角外，整个矩形绝大部份都是重复可拉伸的 如果我切出一个这样的圆角矩形最小图，并设置其非圆角的区域为拉伸区域 那我们就可以用一个只有几 kb 大小的 .9 图实现固定圆角的带边框阴影的矩形 考虑到实际情况，我们可以切出 0 - 12度的圆角图共13张图，圆角越小的图片越小，易得总共大约 (1kb + 5kb ) &#x2F; 2 * 13 &#x3D; 39kb 再算上深色模式，未打包压缩前总共只需要 80kb 而 1600 行的 ShadowLayout.java 未压缩前有 55kb，引入 Androidx 的 CardView 就更大了，还需要考虑机型的兼容性和硬件加速开关 而使用 .9 图，开发同学只需要选择对应圆角的 .9 图设置为背景即可 使用轻松使用 12345&lt;View android:layout_width=&quot;400dp&quot; android:layout_height=&quot;200dp&quot; android:backgroud=&quot;@drawable/rounded_corner_12dp_shadow&quot; /&gt; 展望我们可以进一步，将圆角和矩形分离，使用原子化的图片素材 + 微量代码，组合各种圆角与阴影效果 总结以下是 预渲染（.9图） 和 代码实现（如ShadowLayout &#x2F; CardView） 的优劣势对比表格，结合性能、开发效率、灵活性等维度分析： 对比维度 预渲染（.9图） 代码实现（动态绘制） 性能 ✅ 极低开销（仅纹理采样） ⚠️ 较高开销（实时计算阴影、图层叠加） 内存占用 ✅ 小 ⚠️ 动态（取决于具体代码） 开发效率 ✅ 直接设置背景，无需编码 ⚠️ 需编写&#x2F;维护复杂逻辑（如阴影算法） 灵活性 ❌ 仅支持预定义的圆角&#x2F;阴影样式 ✅ 动态调整参数（颜色、圆角、模糊度等） 适配性 ✅ 无兼容性问题（Android&#x2F;iOS通用） ⚠️ 需处理机型兼容（如硬件加速、API差异） 扩展性 ❌ 修改样式需重新切图 ✅ 可通过代码快速迭代新效果 文件体积 ✅ 极小（如80KB未压缩） ⚠️ 较大（代码+依赖库，如CardView） 动态效果支持 ❌ 无法实现动画或实时变化 ✅ 支持动态阴影（如跟随光源移动） 多分辨率适配 ✅ 自动拉伸（.9图特性） ⚠️ 需额外处理多分辨率下的绘制精度 维护成本 ✅ 低（替换图片即可） ⚠️ 高（需测试不同机型&#x2F;系统版本） 适用场景总结 优先使用.9图：• 样式固定（如标准化设计语言中的卡片阴影）。• 性能敏感场景（如列表项、高频刷新界面）。• 需要快速开发且无动态效果需求。 优先代码实现：• 需要动态效果（如阴影动画、交互反馈）。• 样式高度自定义（如设计师要求的特殊渐变阴影）。 补充建议• 混合方案：对静态部分使用.9图，动态部分叠加代码绘制（如悬浮按钮的阴影）。• 工具化：将.9图生成和代码阴影封装成工具，供团队按需选择 通过明确场景需求，可以高效选择最优方案。","categories":[{"name":"7 - 复杂代码模版","slug":"7-复杂代码模版","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/"},{"name":"7.3 - 复杂 UI 效果","slug":"7-复杂代码模版/7-3-复杂-UI-效果","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-3-%E5%A4%8D%E6%9D%82-UI-%E6%95%88%E6%9E%9C/"}],"tags":[]},{"title":"从零开始写一个 Android 播放器（一）","slug":"9 音视频/01 播放器/media3exoplayer专项解析（一）","date":"2025-01-22T16:07:23.000Z","updated":"2025-05-31T10:16:11.252Z","comments":true,"path":"2025/01/23/9 音视频/01 播放器/media3exoplayer专项解析（一）/","link":"","permalink":"http://example.com/2025/01/23/9%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/media3exoplayer%E4%B8%93%E9%A1%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Mp4Extractor 解析 mp4 数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import androidx.media3.extractor.ExtractorInput;import androidx.media3.extractor.Mp4Extractor;import androidx.media3.extractor.TrackOutput;import androidx.media3.common.util.Util;import java.io.IOException;import java.io.InputStream;public class MediaExtractorExample &#123; /** * 解析 MP4 文件 * * @param inputStream 输入流 * @throws IOException 如果读取文件时发生错误 */ public void extractMp4(InputStream inputStream) throws IOException &#123; // 创建一个 ExtractorInput 实现，用于从输入流中读取数据 ExtractorInput extractorInput = new ExtractorInput() &#123; private InputStream input = inputStream; @Override public long getLength() throws IOException &#123; return input.available(); // 获取文件长度 &#125; @Override public long getPosition() throws IOException &#123; return 0; // 返回当前读取的位置，假设从头开始读取 &#125; @Override public void advancePeekPosition(int length) throws IOException &#123; input.skip(length); // 跳过指定长度的字节 &#125; @Override public void resetPeekPosition() throws IOException &#123; // 重置读取位置，这里未实现 &#125; @Override public int read(byte[] target, int offset, int length) throws IOException &#123; return input.read(target, offset, length); // 从输入流中读取数据到目标字节数组 &#125; @Override public void close() throws IOException &#123; input.close(); // 关闭输入流 &#125; &#125;; // 创建 MP4 提取器 Mp4Extractor mp4Extractor = new Mp4Extractor(); // 提供输出轨道的处理器，简单打印数据 TrackOutput trackOutput = new TrackOutput() &#123; @Override public void format(Format format) &#123; // 处理格式信息 System.out.println(&quot;Format: &quot; + format); &#125; @Override public void sampleData(ExtractorInput input, int length) throws IOException &#123; // 处理样本数据 byte[] buffer = new byte[length]; input.readFully(buffer, 0, length); // 读取样本数据 System.out.println(&quot;Sample Data: &quot; + new String(buffer)); &#125; @Override public void sampleMetadata(long timeUs, int flags, int size, int offset, CryptoData cryptoData) &#123; // 处理样本元数据 System.out.println(&quot;Sample Metadata: timeUs=&quot; + timeUs + &quot;, flags=&quot; + flags); &#125; &#125;; // 使用提取器初始化 ExtractorOutput mp4Extractor.init(new ExtractorOutput() &#123; @Override public void seekMap(SeekMap seekMap) &#123; // 处理 SeekMap long duration = seekMap.getDurationUs(); System.out.println(&quot;Media Duration: &quot; + duration); &#125; @Override public void track(int id, TrackOutput trackOutput) &#123; // 添加轨道 System.out.println(&quot;Track: &quot; + id); &#125; &#125;); // 解析文件数据 mp4Extractor.read(extractorInput, new PositionHolder(), 0); &#125;&#125; Mp4Extractor 需要的 API 名称以及对应的功能 构造方法 Mp4Extractor() 功能： 默认构造函数，初始化 Mp4Extractor 对象。 Mp4Extractor(Factory factory) 功能： 通过工厂方法创建 Mp4Extractor 实例，用于支持动态依赖注入。 Mp4Extractor(int flags) 功能： 通过标志（flags）初始化解析器，例如控制是否解析特定类型的 Atom。 工厂方法 newFactory(Factory factory): ExtractorsFactory 功能： 提供用于创建 Mp4Extractor 实例的工厂方法。 格式验证 sniff(ExtractorInput input): boolean 功能： 检测输入流是否是支持的 MP4 文件格式。 getSniffFailureDetails(): ImmutableList&lt;SniffFailure&gt; 功能： 如果 sniff 方法失败，返回失败的详细信息。 初始化与资源管理 init(ExtractorOutput output): void 功能： 初始化解析器，设置音视频数据的输出接口。 release(): void 功能： 释放资源，清理解析器的内部状态。 文件解析 read(ExtractorInput input, PositionHolder seekPosition): int 功能： 读取输入流，逐步解析 MP4 文件的音视频数据或元数据。 seek(long position, long timeUs): void 功能： 跳转到指定的文件位置和时间戳。 getDurationUs(): long 功能： 返回 MP4 文件的总时长（单位：微秒）。 跳转与定位 getSeekPoints(long timeUs): SeekPoints 功能： 根据时间戳获取跳转点，帮助实现精确跳转。 isSeekable(): boolean 功能： 判断当前 MP4 文件是否支持跳转功能。 Atom 解析 shouldParseLeafAtom(int atomType): boolean 功能： 判断是否需要解析叶子 Atom（无子元素的 Atom）。 shouldParseContainerAtom(int atomType): boolean 功能： 判断是否需要解析容器 Atom（包含子元素的 Atom）。 readAtomHeader(ExtractorInput input): boolean 功能： 读取当前 Atom 的头部信息（类型和大小）。 readAtomPayload(ExtractorInput input, PositionHolder positionHolder): boolean 功能： 读取 Atom 的有效负载部分。 processMoovAtom(ContainerAtom moov): void 功能： 处理 MP4 文件中的 moov Atom，它包含元数据和轨道信息。 processUnparsedAtom(long atomSize): void 功能： 跳过未解析的 Atom，通常用于忽略无关数据。 brandToFileType(int brand): int 功能： 将 ftyp Atom 中的 Major Brand 转换为文件类型标识。 processAtomEnded(long atomSize): void 功能： 在解析完整个 Atom 后执行收尾处理。 音视频样本处理 readSample(ExtractorInput input, PositionHolder positionHolder): int 功能： 读取音视频样本数据（如一帧音频或视频）。 getTrackIndexOfNextReadSample(long timeUs): int 功能： 获取下一帧需要读取的轨道索引。 updateSampleIndex(Mp4Track track, long timeUs): void 功能： 更新轨道的样本索引，用于定位到特定的时间点。 calculateAccumulatedSampleSizes(Mp4Track[] tracks): long[][] 功能： 计算所有轨道中样本的累积大小，用于样本偏移计算。 getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs): long 功能： 获取同步样本索引（关键帧），用于跳转或快速预览。 maybeAdjustSeekOffset(TrackSampleTable sampleTable, long timeUs, long seekPosition): long 功能： 根据当前轨道信息调整跳转偏移。 processEndOfStreamReadingAtomHeader(): void 功能： 在文件流结束时，处理 Atom 头部的读取操作。 辅助方法 maybeSkipRemainingMetaAtomHeaderBytes(ExtractorInput input): void 功能： 跳过当前 Atom 的剩余头部字节，通常用于优化解析流程。","categories":[{"name":"9 - 音视频","slug":"9-音视频","permalink":"http://example.com/categories/9-%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"9.1 - 播放器实战","slug":"9-音视频/9-1-播放器实战","permalink":"http://example.com/categories/9-%E9%9F%B3%E8%A7%86%E9%A2%91/9-1-%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98/"}],"tags":[]},{"title":"从零开始写一个 Android 播放器（一）","slug":"9 音视频/01 播放器/从零开始写一个-Android-播放器","date":"2025-01-22T16:07:23.000Z","updated":"2025-05-31T10:15:48.086Z","comments":true,"path":"2025/01/23/9 音视频/01 播放器/从零开始写一个-Android-播放器/","link":"","permalink":"http://example.com/2025/01/23/9%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%80%E4%B8%AA-Android-%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"Mp4Extractor 解析 mp4 数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import androidx.media3.extractor.ExtractorInput;import androidx.media3.extractor.Mp4Extractor;import androidx.media3.extractor.TrackOutput;import androidx.media3.common.util.Util;import java.io.IOException;import java.io.InputStream;public class MediaExtractorExample &#123; /** * 解析 MP4 文件 * * @param inputStream 输入流 * @throws IOException 如果读取文件时发生错误 */ public void extractMp4(InputStream inputStream) throws IOException &#123; // 创建一个 ExtractorInput 实现，用于从输入流中读取数据 ExtractorInput extractorInput = new ExtractorInput() &#123; private InputStream input = inputStream; @Override public long getLength() throws IOException &#123; return input.available(); // 获取文件长度 &#125; @Override public long getPosition() throws IOException &#123; return 0; // 返回当前读取的位置，假设从头开始读取 &#125; @Override public void advancePeekPosition(int length) throws IOException &#123; input.skip(length); // 跳过指定长度的字节 &#125; @Override public void resetPeekPosition() throws IOException &#123; // 重置读取位置，这里未实现 &#125; @Override public int read(byte[] target, int offset, int length) throws IOException &#123; return input.read(target, offset, length); // 从输入流中读取数据到目标字节数组 &#125; @Override public void close() throws IOException &#123; input.close(); // 关闭输入流 &#125; &#125;; // 创建 MP4 提取器 Mp4Extractor mp4Extractor = new Mp4Extractor(); // 提供输出轨道的处理器，简单打印数据 TrackOutput trackOutput = new TrackOutput() &#123; @Override public void format(Format format) &#123; // 处理格式信息 System.out.println(&quot;Format: &quot; + format); &#125; @Override public void sampleData(ExtractorInput input, int length) throws IOException &#123; // 处理样本数据 byte[] buffer = new byte[length]; input.readFully(buffer, 0, length); // 读取样本数据 System.out.println(&quot;Sample Data: &quot; + new String(buffer)); &#125; @Override public void sampleMetadata(long timeUs, int flags, int size, int offset, CryptoData cryptoData) &#123; // 处理样本元数据 System.out.println(&quot;Sample Metadata: timeUs=&quot; + timeUs + &quot;, flags=&quot; + flags); &#125; &#125;; // 使用提取器初始化 ExtractorOutput mp4Extractor.init(new ExtractorOutput() &#123; @Override public void seekMap(SeekMap seekMap) &#123; // 处理 SeekMap long duration = seekMap.getDurationUs(); System.out.println(&quot;Media Duration: &quot; + duration); &#125; @Override public void track(int id, TrackOutput trackOutput) &#123; // 添加轨道 System.out.println(&quot;Track: &quot; + id); &#125; &#125;); // 解析文件数据 mp4Extractor.read(extractorInput, new PositionHolder(), 0); &#125;&#125; Mp4Extractor 需要的 API 名称以及对应的功能 构造方法 Mp4Extractor() 功能： 默认构造函数，初始化 Mp4Extractor 对象。 Mp4Extractor(Factory factory) 功能： 通过工厂方法创建 Mp4Extractor 实例，用于支持动态依赖注入。 Mp4Extractor(int flags) 功能： 通过标志（flags）初始化解析器，例如控制是否解析特定类型的 Atom。 工厂方法 newFactory(Factory factory): ExtractorsFactory 功能： 提供用于创建 Mp4Extractor 实例的工厂方法。 格式验证 sniff(ExtractorInput input): boolean 功能： 检测输入流是否是支持的 MP4 文件格式。 getSniffFailureDetails(): ImmutableList&lt;SniffFailure&gt; 功能： 如果 sniff 方法失败，返回失败的详细信息。 初始化与资源管理 init(ExtractorOutput output): void 功能： 初始化解析器，设置音视频数据的输出接口。 release(): void 功能： 释放资源，清理解析器的内部状态。 文件解析 read(ExtractorInput input, PositionHolder seekPosition): int 功能： 读取输入流，逐步解析 MP4 文件的音视频数据或元数据。 seek(long position, long timeUs): void 功能： 跳转到指定的文件位置和时间戳。 getDurationUs(): long 功能： 返回 MP4 文件的总时长（单位：微秒）。 跳转与定位 getSeekPoints(long timeUs): SeekPoints 功能： 根据时间戳获取跳转点，帮助实现精确跳转。 isSeekable(): boolean 功能： 判断当前 MP4 文件是否支持跳转功能。 Atom 解析 shouldParseLeafAtom(int atomType): boolean 功能： 判断是否需要解析叶子 Atom（无子元素的 Atom）。 shouldParseContainerAtom(int atomType): boolean 功能： 判断是否需要解析容器 Atom（包含子元素的 Atom）。 readAtomHeader(ExtractorInput input): boolean 功能： 读取当前 Atom 的头部信息（类型和大小）。 readAtomPayload(ExtractorInput input, PositionHolder positionHolder): boolean 功能： 读取 Atom 的有效负载部分。 processMoovAtom(ContainerAtom moov): void 功能： 处理 MP4 文件中的 moov Atom，它包含元数据和轨道信息。 processUnparsedAtom(long atomSize): void 功能： 跳过未解析的 Atom，通常用于忽略无关数据。 brandToFileType(int brand): int 功能： 将 ftyp Atom 中的 Major Brand 转换为文件类型标识。 processAtomEnded(long atomSize): void 功能： 在解析完整个 Atom 后执行收尾处理。 音视频样本处理 readSample(ExtractorInput input, PositionHolder positionHolder): int 功能： 读取音视频样本数据（如一帧音频或视频）。 getTrackIndexOfNextReadSample(long timeUs): int 功能： 获取下一帧需要读取的轨道索引。 updateSampleIndex(Mp4Track track, long timeUs): void 功能： 更新轨道的样本索引，用于定位到特定的时间点。 calculateAccumulatedSampleSizes(Mp4Track[] tracks): long[][] 功能： 计算所有轨道中样本的累积大小，用于样本偏移计算。 getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs): long 功能： 获取同步样本索引（关键帧），用于跳转或快速预览。 maybeAdjustSeekOffset(TrackSampleTable sampleTable, long timeUs, long seekPosition): long 功能： 根据当前轨道信息调整跳转偏移。 processEndOfStreamReadingAtomHeader(): void 功能： 在文件流结束时，处理 Atom 头部的读取操作。 辅助方法 maybeSkipRemainingMetaAtomHeaderBytes(ExtractorInput input): void 功能： 跳过当前 Atom 的剩余头部字节，通常用于优化解析流程。","categories":[{"name":"9 - 音视频","slug":"9-音视频","permalink":"http://example.com/categories/9-%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"9.1 - 播放器实战","slug":"9-音视频/9-1-播放器实战","permalink":"http://example.com/categories/9-%E9%9F%B3%E8%A7%86%E9%A2%91/9-1-%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98/"}],"tags":[]},{"title":"CMake 中的静态连接和动态链接","slug":"6 Android编译打包/CMake-中的静态连接和动态链接","date":"2024-11-02T10:59:31.865Z","updated":"2024-11-02T11:00:29.072Z","comments":true,"path":"2024/11/02/6 Android编译打包/CMake-中的静态连接和动态链接/","link":"","permalink":"http://example.com/2024/11/02/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/CMake-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/","excerpt":"","text":"作者: 朕小猫与GPT4 12345678910111213141516171819202122232425262728293031cmake_minimum_required(VERSION 3.4.1)project(DualVectorFoil)# 先设置 Assimp 配置项，禁用测试、样例和文档生成set(ASSIMP_BUILD_TESTS OFF CACHE BOOL &quot;&quot; FORCE)set(ASSIMP_BUILD_SAMPLES OFF CACHE BOOL &quot;&quot; FORCE)set(ASSIMP_BUILD_DOCS OFF CACHE BOOL &quot;&quot; FORCE)# 添加 Assimp 目录和包含目录add_subdirectory($&#123;CMAKE_SOURCE_DIR&#125;/Assimp)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/Assimp/include)# 定义库文件 DualVectorFoilLibadd_library( DualVectorFoilLib # 库名称 SHARED # 库类型 # 你的源文件列表，示例：src/main/cpp/你的文件.cpp)# 链接必要的库target_link_libraries( DualVectorFoilLib assimp # Assimp 库 android # Android 系统库 EGL # OpenGL 库 GLESv2 # OpenGL ES 2.0 m # 数学库 z # 压缩库 atomic # 原子操作库) Q: 这样写完之后，apk 安装包中有两个so文件 libDualVectorFoilLib 和 libassimp，都占用 14m，但其实，libDualVectorFoilLib 中包含的就是libassimp，不应该再占用这么大体积 A: 为了减少 APK 中的体积，你可以将 libassimp 静态链接到 DualVectorFoilLib 中，这样只会生成一个包含 assimp 的 libDualVectorFoilLib.so 文件，而不会包含独立的 libassimp.so 文件。这种方式可以避免重复打包和减小 APK 的体积。具体修改如下： 修改 CMakeLists.txt 配置，将 assimp 静态链接12345678910111213141516171819202122232425262728293031cmake_minimum_required(VERSION 3.4.1)project(DualVectorFoil)# 先设置 Assimp 配置项，禁用测试、样例和文档生成set(ASSIMP_BUILD_TESTS OFF CACHE BOOL &quot;&quot; FORCE)set(ASSIMP_BUILD_SAMPLES OFF CACHE BOOL &quot;&quot; FORCE)set(ASSIMP_BUILD_DOCS OFF CACHE BOOL &quot;&quot; FORCE)set(BUILD_SHARED_LIBS OFF) # 禁用 Assimp 的动态库生成，改为静态库# 添加 Assimp 目录和包含目录add_subdirectory($&#123;CMAKE_SOURCE_DIR&#125;/Assimp)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/Assimp/include)# 定义库文件 DualVectorFoilLibadd_library( DualVectorFoilLib # 库名称 SHARED # 库类型 # 你的源文件列表，示例：src/main/cpp/你的文件.cpp)# 链接必要的库target_link_libraries( DualVectorFoilLib assimp # 静态链接 Assimp 库 android # Android 系统库 EGL # OpenGL 库 GLESv2 # OpenGL ES 2.0 m # 数学库 z # 压缩库 atomic # 原子操作库) 解释 **禁用 BUILD_SHARED_LIBS**：将 BUILD_SHARED_LIBS 设置为 OFF，使 Assimp 以静态库（.a 文件）形式生成，这样 Assimp 将不会生成独立的 .so 文件，而是将代码直接打包到 libDualVectorFoilLib.so 中。 **静态链接 assimp**：在 target_link_libraries 中链接 assimp，这会将 Assimp 的代码直接合并进 libDualVectorFoilLib.so，避免生成和打包独立的 libassimp.so。 结果：这样可以减小 APK 体积，因为不再包含重复的库文件。 之后重新构建项目，确保 APK 中只包含 libDualVectorFoilLib.so 文件，不再包含 libassimp.so 文件。 Q: 为什么改成静态连接之后小了好多 A: 改成静态链接之后 APK 大小减少，主要原因在于静态链接和动态链接的工作原理不同，以及 Android 应用打包时如何处理库文件： 避免重复加载的冗余文件：动态链接时，libassimp.so 作为独立的动态库被单独打包，并在运行时加载。而静态链接则将 libassimp 的代码直接整合到 libDualVectorFoilLib.so 中，避免了多余的 .so 文件。因此，只生成一个完整的 .so 文件，而不是两个重复的文件，节省了空间。 优化与裁剪：静态链接时，链接器会自动去除 Assimp 库中未使用的代码，只保留 DualVectorFoilLib 需要的部分。这意味着生成的 libDualVectorFoilLib.so 体积更小，因为一些多余的功能不会被包含进去。而动态链接时，通常整个库都被打包，即使项目不使用 Assimp 的所有功能，APK 也会包含整个库的内容。 减少符号表与动态加载信息：动态库需要额外的符号表和动态加载信息，以便在运行时进行地址解析和符号加载。静态链接的 .so 文件则不需要这些额外的信息，因此最终生成的文件会更小。 加载性能提升：除了体积减小，静态链接也会带来性能上的提升，因为它省去了动态加载库时的解析步骤，在某些场景下可以略微缩短应用启动时间。 通过静态链接，代码体积优化和去重工作会更加有效，因此可以显著减小 APK 大小。 Q: 如果我只想引入 assimp 不想引入 libDualVectorFoilLib.so 怎么处理 A: 如果只想引入 assimp 库，不需要 libDualVectorFoilLib.so，可以直接在 CMake 中只构建 assimp，而不创建其他自定义的 .so 库文件。这样可以实现只生成 libassimp.so，并确保它在你的 APK 中被正确引用。以下是可以实现的步骤： 直接构建 Assimp 并禁用其他库的生成：只需要 assimp，无需自定义的库文件，可以移除自定义库的定义，只保留对 assimp 的配置与编译。 修改 CMakeLists.txt： 12345678910111213cmake_minimum_required(VERSION 3.4.1)project(DualVectorFoil)# 配置 Assimp：禁用测试、样例和文档生成set(ASSIMP_BUILD_TESTS OFF CACHE BOOL &quot;&quot; FORCE)set(ASSIMP_BUILD_SAMPLES OFF CACHE BOOL &quot;&quot; FORCE)set(ASSIMP_BUILD_DOCS OFF CACHE BOOL &quot;&quot; FORCE)# 添加 Assimp 目录并包含头文件add_subdirectory($&#123;CMAKE_SOURCE_DIR&#125;/Assimp)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/Assimp/include)# Assimp 将自动生成 libassimp.so，无需自定义其他库 **在 build.gradle 中指定加载 libassimp.so**：在你的 Android 项目中确保在 Java 或 Kotlin 代码中正确加载 libassimp.so，例如： 1System.loadLibrary(&quot;assimp&quot;) **检查并确保只有 libassimp.so**：构建 APK 后，检查生成的 APK 文件，确认只有 libassimp.so 被打包，而没有 libDualVectorFoilLib.so。 这样配置后，APK 中只会包含 libassimp.so，并且该库可以直接使用，不再生成不必要的库文件。 Q: So 文件的 Raw File Size 和 Download Size 分别是什么? A: 在 APK 文件的打包和发布过程中，文件会经历压缩处理，这使得 APK 下载包的体积通常小于安装后在设备上实际占用的空间。在 Android Studio 中，APK Analyzer 工具展示了两个关键指标来帮助我们理解这些差异： Raw File Size（原始文件大小）：这是文件在 APK 解压后，在设备上占用的实际存储空间大小。在您提供的截图中，libassimpd.so 的原始文件大小为 14.4 MB，表示安装到设备后它会占用 14.4 MB 的空间。 Download Size（下载大小）：这是 APK 包含的文件在压缩后的大小。由于 APK 打包时会对文件进行压缩，libassimpd.so 的压缩后下载大小仅为 3.4 MB。这个值表示用户在下载 APK 包时实际需要传输的数据量。 总结来说： Raw File Size 是文件在设备上解压后的实际存储空间需求。 Download Size 是文件在 APK 压缩包中的大小，直接影响 APK 的下载体积。 因此，虽然下载 APK 时 libassimpd.so 只占 3.4 MB，但安装后在设备上会占用 14.4 MB 的存储空间。 Q: So 文件是怎么实现从14M压缩到3.4M的 A: so 文件（共享库文件）的大小可以大幅度缩小，主要是因为 Android APK 打包过程中应用了压缩算法。以下是一些关键原因和过程： 1. ZIP 压缩APK 文件本质上是一个 ZIP 文件，打包时会对资源文件和库文件应用 ZIP 压缩。共享库文件（so 文件）通常包含大量重复数据和空白区域，这些内容在 ZIP 压缩时能够被有效地缩减。因此，像 libassimpd.so 这种大型的二进制文件，通过 ZIP 压缩可以大幅度减小体积。 2. 二进制格式的高压缩率so 文件是二进制格式，包含大量的结构化数据和代码段。这些二进制数据在结构上非常紧密，包含许多重复的模式和数据块，非常适合被压缩算法处理。常用的压缩算法（例如 DEFLATE）能够识别这些模式，减少冗余，从而将文件压缩到较小的尺寸。 3. 去除无用数据一些调试信息和符号信息在生成 so 文件时可能会被包含在内，但是在发布 APK 时通常会将这些调试符号信息剥离。这会进一步减少 so 文件的体积，尤其在压缩之后，对这些无用数据的移除效果显著。 4. 压缩前未使用的代码和数据区域so 文件可能包含一些预留的数据段或对齐填充，这些部分在压缩后也会被进一步缩小。比如对齐填充区域在压缩时几乎不会占用空间，从而进一步减小了整体体积。 示例总结在您的示例中，libassimpd.so 原始文件大小为 14.4 MB，而在 APK 中压缩后的下载大小是 3.4 MB。这种大幅缩小主要得益于 ZIP 压缩的高效性，以及 so 文件的二进制结构带来的高压缩比。 总结APK 中的 so 文件能够实现从 14 MB 压缩到 3.4 MB，主要是由于以下原因： ZIP 压缩算法的高效性 二进制文件的结构适合压缩 发布时剥离调试符号信息 未使用的数据和对齐填充在压缩后基本不占空间 这些因素共同作用，使得 so 文件在安装包中的大小远小于其解压后的原始大小。","categories":[{"name":"6 - Android 打包编译","slug":"6-Android-打包编译","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/"},{"name":"6.1 - 文件分析","slug":"6-Android-打包编译/6-1-文件分析","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-1-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[]},{"title":"Kotlin中的自动拆装箱","slug":"1 Kotlin/02 Kotlin 基础/Kotlin中的自动拆装箱","date":"2024-04-14T04:47:49.083Z","updated":"2024-04-14T04:47:53.517Z","comments":true,"path":"2024/04/14/1 Kotlin/02 Kotlin 基础/Kotlin中的自动拆装箱/","link":"","permalink":"http://example.com/2024/04/14/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/","excerpt":"","text":"在 Kotlin 中，对于基本数据类型的包装类，比如 Integer、Boolean 等，Kotlin 设计了一套特殊的类，被称为原生类型的包装类或者叫做原生类型的对象，例如 Int、Boolean 等。这些类的行为表现得如同 Java 的基本类型，同时它们具备了对象的一些特性。在编译阶段，Kotlin 会尽量使用 JVM 的原生类型来提高性能，但在需要时（例如作为泛型参数时），这些原生类型会自动装箱。 自动装箱与拆箱Kotlin 处理原生类型和装箱类型的自动转换，以保证性能同时提供丰富的类库支持。这个过程包括两个部分：自动装箱（boxing）和自动拆箱（unboxing）。 装箱（Boxing）：当一个原生类型的值需要作为对象处理时，它会自动被装入对应的包装类。例如，当你将一个 int 值放入一个泛型集合如 List&lt;Int&gt; 时，这个值会自动被装箱成 Integer。 拆箱（Unboxing）：当从对象中需要一个原生类型的值时，这个包装对象会自动被拆箱。例如，从 List&lt;Int&gt; 中取出一个元素时，它会自动从 Integer 转换为 int。 示例12val list: List&lt;Int&gt; = listOf(1, 2, 3) // 装箱val x: Int = list[0] // 拆箱 在上面的例子中，整数列表中的数字自动被装箱成 Integer 类型的对象以存入 List&lt;Int&gt;。当从列表中检索一个整数时，它自动拆箱回 Int 类型。 注意事项虽然 Kotlin 试图隐藏装箱和拆箱的复杂性，但在某些情况下，装箱对象的身份不会保留。例如，两个独立装箱的整数可能不会在内存中具有相同的引用： 1234val a: Int = 1000val boxedA: Int? = aval anotherBoxedA: Int? = aprintln(boxedA === anotherBoxedA) // 可能输出 false 在上面的代码中，boxedA 和 anotherBoxedA 是相同原始值的两个独立的装箱实例。使用 === 比较它们的引用时可能得到 false，因为它们可能指向不同的对象。 总结Kotlin 在编写代码时提供了类似于基本数据类型的简洁性和效率，同时也保留了对象的灵活性。通过自动装箱和拆箱，Kotlin 旨在提供无缝的集合操作和泛型支持，同时减少需要程序员关注的底层细节。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ViewModel 源代码分析 (一)","slug":"3 Android/Jetpacket/VideoModel/0 ViewModel 源代码分析 (一)","date":"2024-03-31T17:32:52.573Z","updated":"2024-04-03T11:40:25.760Z","comments":true,"path":"2024/04/01/3 Android/Jetpacket/VideoModel/0 ViewModel 源代码分析 (一)/","link":"","permalink":"http://example.com/2024/04/01/3%20Android/Jetpacket/VideoModel/0%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%80)/","excerpt":"","text":"viewmodel CreationExtrasViewModel创建过程中传递额外参数的容器。 InitializerViewModelFactory ViewModelProvider.Factory接口实现类，使用ViewModelInitializer来创建ViewModel实例。 InitializerViewModelFactoryBuilder 用于构建InitializerViewModelFactory的工具，通常以DSL形式提供。 MutableCreationExtras 可变版本的CreationExtras，允许添加或修改额外参数。 ViewModelFactoryDsl 一个DSL（领域特定语言），用于更声明式地定义如何创建ViewModel。 ViewModelInitializer 用于初始化ViewModel的类，通常与ViewModelFactoryDsl一起使用。 InitializerViewModelFactory 提供了使用InitializerViewModelFactory的Kotlin扩展。 AndroidViewModel AndroidViewModel是ViewModel的一个子类，它接受应用程序的Application作为上下文，这对于需要访问Application资源的ViewModel特别有用。 HasDefaultViewModelProviderFactory 一个接口，标识一个类拥有默认的ViewModelProvider.Factory，用于创建ViewModel。 ViewModel ViewModelLazy 一个提供懒加载ViewModel实例的工具类。 ViewModelProvider 用于获取ViewModel实例，确保配置更改时ViewModel可以持续使用。 ViewModelStore 用于保存ViewModel实例的类，以便它们可以跨配置更改持续存在。 ViewModelStoreOwner 一个接口，标识一个类可以拥有ViewModelStore。 ViewTreeViewModelStoreOwner 用于从视图树中查找ViewModelStoreOwner的工具类。 ViewTreeViewModelKt 提供了操作和查询视图树中ViewModel的Kotlin扩展 CreationExtras 与 MutableCreationExtra123456789101112131415161718192021222324252627282930313233343536package androidx.lifecycle.viewmodelpublic abstract class CreationExtras internal constructor() &#123; internal val map: MutableMap&lt;Key&lt;*&gt;, Any?&gt; = mutableMapOf() public interface Key&lt;T&gt; public abstract operator fun &lt;T&gt; get(key: Key&lt;T&gt;): T? object Empty : CreationExtras() &#123; override fun &lt;T&gt; get(key: Key&lt;T&gt;): T? = null &#125;&#125;/** * [CreationExtras]的可变实现 * * @param initialExtras 将被填充到结果MutableCreationExtras中的额外信息 */public class MutableCreationExtras(initialExtras: CreationExtras = Empty) : CreationExtras() &#123; init &#123; map.putAll(initialExtras.map) &#125; /** * 将给定的[key]与[t]关联 */ public operator fun &lt;T&gt; set(key: Key&lt;T&gt;, t: T) &#123; map[key] = t &#125; public override fun &lt;T&gt; get(key: Key&lt;T&gt;): T? &#123; @Suppress(&quot;UNCHECKED_CAST&quot;) return map[key] as T? &#125;&#125; fun viewModelFactory 和 InitializerViewModelFactoryBuilder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package androidx.lifecycle.viewmodelimport androidx.lifecycle.ViewModelimport androidx.lifecycle.ViewModelProviderimport kotlin.reflect.KClass@DslMarkerpublic annotation class ViewModelFactoryDslpublic inline fun viewModelFactory( builder: InitializerViewModelFactoryBuilder.() -&gt; Unit): ViewModelProvider.Factory = InitializerViewModelFactoryBuilder().apply(builder).build()/** * 用于构建新的[ViewModelProvider.Factory]的DSL。 */@ViewModelFactoryDslpublic class InitializerViewModelFactoryBuilder &#123; private val initializers = mutableListOf&lt;ViewModelInitializer&lt;*&gt;&gt;() /** * 为给定的ViewModel类添加初始化器。 * * @param clazz 与初始化器关联的类。 * @param initializer 用于创建ViewModel类实例的lambda表达式 */ fun &lt;T : ViewModel&gt; addInitializer(clazz: KClass&lt;T&gt;, initializer: CreationExtras.() -&gt; T) &#123; initializers.add(ViewModelInitializer(clazz.java, initializer)) &#125; fun build(): ViewModelProvider.Factory = InitializerViewModelFactory(*initializers.toTypedArray())&#125;inline fun &lt;reified VM : ViewModel&gt; InitializerViewModelFactoryBuilder.initializer( noinline initializer: CreationExtras.() -&gt; VM) &#123; addInitializer(VM::class, initializer)&#125;class ViewModelInitializer&lt;T : ViewModel&gt;( internal val clazz: Class&lt;T&gt;, internal val initializer: CreationExtras.() -&gt; T,)internal class InitializerViewModelFactory( private vararg val initializers: ViewModelInitializer&lt;*&gt;) : ViewModelProvider.Factory &#123; override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T &#123; var viewModel: T? = null @Suppress(&quot;UNCHECKED_CAST&quot;) initializers.forEach &#123; if (it.clazz == modelClass) &#123; viewModel = it.initializer.invoke(extras) as? T &#125; &#125; return viewModel ?: throw IllegalArgumentException( &quot;No initializer set for given class $&#123;modelClass.name&#125;&quot; ) &#125;&#125; AndroidViewModel123456789101112131415161718192021package androidx.lifecycle;import android.annotation.SuppressLint;import android.app.Application;import androidx.annotation.NonNull;public class AndroidViewModel extends ViewModel &#123; @SuppressLint(&quot;StaticFieldLeak&quot;) private Application mApplication; public AndroidViewModel(@NonNull Application application) &#123; mApplication = application; &#125; @SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;) @NonNull public &lt;T extends Application&gt; T getApplication() &#123; return (T) mApplication; &#125;&#125; AndroidViewModel 是一个扩展了标准 ViewModel 功能的类，通过提供对 Application 上下文的访问，它允许 ViewModel 执行需要这种上下文的操作。使用 AndroidViewModel 可以帮助你编写更清晰、更健壮的应用程序代码，尤其是在处理配置更改和应用程序范围的资源访问时 HasDefaultViewModelProviderFactory1234567891011121314package androidx.lifecycle;import androidx.annotation.NonNull;import androidx.lifecycle.viewmodel.CreationExtras;public interface HasDefaultViewModelProviderFactory &#123; @NonNull ViewModelProvider.Factory getDefaultViewModelProviderFactory(); @NonNull default CreationExtras getDefaultViewModelCreationExtras() &#123; return CreationExtras.Empty.INSTANCE; &#125;&#125; ViewModel12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package androidx.lifecycle;import androidx.annotation.MainThread;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.Closeable;import java.io.IOException;import java.util.Arrays;import java.util.HashMap;import java.util.LinkedHashSet;import java.util.Map;import java.util.Set;public abstract class ViewModel &#123; // Can&#x27;t use ConcurrentHashMap, because it can lose values on old apis (see b/37042460) @Nullable private final Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;(); @Nullable private final Set&lt;Closeable&gt; mCloseables = new LinkedHashSet&lt;&gt;(); private volatile boolean mCleared = false; public ViewModel() &#123; &#125; public ViewModel(@NonNull Closeable... closeables) &#123; mCloseables.addAll(Arrays.asList(closeables)); &#125; public void addCloseable(@NonNull Closeable closeable) &#123; if (mCloseables != null) &#123; synchronized (mCloseables) &#123; mCloseables.add(closeable); &#125; &#125; &#125; @SuppressWarnings(&quot;WeakerAccess&quot;) protected void onCleared() &#123; &#125; @MainThread final void clear() &#123; mCleared = true; if (mBagOfTags != null) &#123; synchronized (mBagOfTags) &#123; for (Object value : mBagOfTags.values()) &#123; closeWithRuntimeException(value); &#125; &#125; &#125; if (mCloseables != null) &#123; synchronized (mCloseables) &#123; for (Closeable closeable : mCloseables) &#123; closeWithRuntimeException(closeable); &#125; &#125; &#125; onCleared(); &#125; @SuppressWarnings(&quot;unchecked&quot;) &lt;T&gt; T setTagIfAbsent(String key, T newValue) &#123; T previous; synchronized (mBagOfTags) &#123; previous = (T) mBagOfTags.get(key); if (previous == null) &#123; mBagOfTags.put(key, newValue); &#125; &#125; T result = previous == null ? newValue : previous; if (mCleared) &#123; closeWithRuntimeException(result); &#125; return result; &#125; @SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;) &lt;T&gt; T getTag(String key) &#123; if (mBagOfTags == null) &#123; return null; &#125; synchronized (mBagOfTags) &#123; return (T) mBagOfTags.get(key); &#125; &#125; private static void closeWithRuntimeException(Object obj) &#123; if (obj instanceof Closeable) &#123; try &#123; ((Closeable) obj).close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 举例子说明哪些特殊数据是需要 ViewModel 特别管理的在 ViewModel 的使用场景中，有几种特殊数据需要通过 ViewModel 来特别管理，主要是因为这些数据的生命周期需要与 ViewModel 保持一致，或者这些数据在 ViewModel 被销毁时需要进行特殊处理。以下是一些示例： 网络请求的取消标识（Cancellation Tokens）：当使用 ViewModel 进行网络请求时，可以在 mBagOfTags 中保存请求的取消标识（如 Call 对象或其他取消机制）。如果用户离开了关联的界面（例如，Activity 或 Fragment 被销毁），则可以在 ViewModel 的 onCleared() 方法中取消所有挂起的网络请求，以避免不必要的网络流量消耗或潜在的内存泄漏。 数据库监听器（Database Listeners）：如果 ViewModel 监听数据库变化（例如，使用 SQLite 数据库或 Room 持久库），可以将监听器对象存储在 mBagOfTags 中。当 ViewModel 被清理时，这些监听器可以被适当地移除，防止因为监听器持续激活而导致的内存泄漏。 文件资源（File Resources）：应用可能会打开文件进行读写操作，这些文件的句柄或相关的流对象（如 FileInputStream、FileOutputStream）可以放在 mBagOfTags 中。在 ViewModel 生命周期结束时，确保这些资源被正确关闭，避免文件资源泄漏。 自定义资源的清理（Custom Resource Cleanup）：如果有一些自定义的资源或对象需要在 ViewModel 生命周期结束时进行清理（比如自定义的缓存机制、临时文件的删除等），也可以利用 mBagOfTags 来管理这些资源。通过实现 Closeable 接口，可以确保这些资源在 ViewModel 的 clear() 方法被调用时得到正确的处理。 订阅服务（Subscriptions）：当 ViewModel 订阅了某些事件通知或数据流（例如，使用 RxJava 的 Observable 或 LiveData 订阅），可以将这些订阅的取消引用（比如 Disposable）存储在 mBagOfTags 中。这样，可以在不需要这些订阅时或 ViewModel 销毁时，统一取消订阅，防止内存泄漏。 通过以上示例，可以看出 ViewModel 中的 mBagOfTags 提供了一种便捷的方式来管理与 ViewModel 生命周期紧密相关的特殊数据和资源，帮助开发者维护应用的健壮性和性能。 ViewModelLazy123456789101112131415161718192021222324252627282930313233package androidx.lifecycleimport androidx.lifecycle.viewmodel.CreationExtrasimport kotlin.reflect.KClasspublic class ViewModelLazy&lt;VM : ViewModel&gt; @JvmOverloads constructor( private val viewModelClass: KClass&lt;VM&gt;, private val storeProducer: () -&gt; ViewModelStore, private val factoryProducer: () -&gt; ViewModelProvider.Factory, private val extrasProducer: () -&gt; CreationExtras = &#123; CreationExtras.Empty &#125;) : Lazy&lt;VM&gt; &#123; private var cached: VM? = null override val value: VM get() &#123; val viewModel = cached return if (viewModel == null) &#123; val factory = factoryProducer() val store = storeProducer() ViewModelProvider( store, factory, extrasProducer() ).get(viewModelClass.java).also &#123; cached = it &#125; &#125; else &#123; viewModel &#125; &#125; override fun isInitialized(): Boolean = cached != null&#125; ViewModelProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224@file:JvmName(&quot;ViewModelProviderGetKt&quot;)package androidx.lifecycleimport android.app.Applicationimport androidx.annotation.MainThreadimport androidx.annotation.RestrictToimport androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.DEFAULT_KEYimport androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.defaultFactoryimport androidx.lifecycle.viewmodel.CreationExtras.Keyimport androidx.lifecycle.ViewModelProvider.NewInstanceFactory.Companion.VIEW_MODEL_KEYimport androidx.lifecycle.viewmodel.CreationExtrasimport androidx.lifecycle.viewmodel.InitializerViewModelFactoryimport androidx.lifecycle.viewmodel.MutableCreationExtrasimport androidx.lifecycle.viewmodel.ViewModelInitializerimport java.lang.IllegalArgumentExceptionimport java.lang.RuntimeExceptionimport java.lang.reflect.InvocationTargetExceptionimport kotlin.UnsupportedOperationExceptionpublic open class ViewModelProvider@JvmOverloadsconstructor( private val store: ViewModelStore, private val factory: Factory, private val defaultCreationExtras: CreationExtras = CreationExtras.Empty,) &#123; public interface Factory &#123; public fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123; throw UnsupportedOperationException( &quot;Factory.create(String) is unsupported. This Factory requires &quot; + &quot;`CreationExtras` to be passed into `create` method.&quot; ) &#125; public fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T = create(modelClass) companion object &#123; @JvmStatic fun from(vararg initializers: ViewModelInitializer&lt;*&gt;): Factory = InitializerViewModelFactory(*initializers) &#125; &#125; @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public open class OnRequeryFactory &#123; public open fun onRequery(viewModel: ViewModel) &#123;&#125; &#125; public constructor( owner: ViewModelStoreOwner ) : this(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner)) public constructor(owner: ViewModelStoreOwner, factory: Factory) : this( owner.viewModelStore, factory, defaultCreationExtras(owner) ) @MainThread public open operator fun &lt;T : ViewModel&gt; get(modelClass: Class&lt;T&gt;): T &#123; val canonicalName = modelClass.canonicalName ?: throw IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;) return get(&quot;$DEFAULT_KEY:$canonicalName&quot;, modelClass) &#125; @Suppress(&quot;UNCHECKED_CAST&quot;) @MainThread public open operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: Class&lt;T&gt;): T &#123; val viewModel = store[key] if (modelClass.isInstance(viewModel)) &#123; (factory as? OnRequeryFactory)?.onRequery(viewModel) return viewModel as T &#125; else &#123; @Suppress(&quot;ControlFlowWithEmptyBody&quot;) if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; val extras = MutableCreationExtras(defaultCreationExtras) extras[VIEW_MODEL_KEY] = key // AGP has some desugaring issues associated with compileOnly dependencies so we need to // fall back to the other create method to keep from crashing. return try &#123; factory.create(modelClass, extras) &#125; catch (e: AbstractMethodError) &#123; factory.create(modelClass) &#125;.also &#123; store.put(key, it) &#125; &#125; // actually there is getInstance() @Suppress(&quot;SingletonConstructor&quot;) public open class NewInstanceFactory : Factory &#123; @Suppress(&quot;DocumentExceptions&quot;) override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123; return try &#123; modelClass.newInstance() &#125; catch (e: InstantiationException) &#123; throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e) &#125; catch (e: IllegalAccessException) &#123; throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e) &#125; &#125; public companion object &#123; private var sInstance: NewInstanceFactory? = null @JvmStatic public val instance: NewInstanceFactory @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) get() &#123; if (sInstance == null) &#123; sInstance = NewInstanceFactory() &#125; return sInstance!! &#125; private object ViewModelKeyImpl : Key&lt;String&gt; @JvmField val VIEW_MODEL_KEY: Key&lt;String&gt; = ViewModelKeyImpl &#125; &#125; public open class AndroidViewModelFactory private constructor( private val application: Application?, @Suppress(&quot;UNUSED_PARAMETER&quot;) unused: Int, ) : NewInstanceFactory() &#123; @Suppress(&quot;SingletonConstructor&quot;) public constructor() : this(null, 0) @Suppress(&quot;SingletonConstructor&quot;) public constructor(application: Application) : this(application, 0) @Suppress(&quot;DocumentExceptions&quot;) override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T &#123; return if (application != null) &#123; create(modelClass) &#125; else &#123; val application = extras[APPLICATION_KEY] if (application != null) &#123; create(modelClass, application) &#125; else &#123; // For AndroidViewModels, CreationExtras must have an application set if (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123; throw IllegalArgumentException( &quot;CreationExtras must have an application by `APPLICATION_KEY`&quot; ) &#125; super.create(modelClass) &#125; &#125; &#125; @Suppress(&quot;DocumentExceptions&quot;) override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123; return if (application == null) &#123; throw UnsupportedOperationException( &quot;AndroidViewModelFactory constructed &quot; + &quot;with empty constructor works only with &quot; + &quot;create(modelClass: Class&lt;T&gt;, extras: CreationExtras).&quot; ) &#125; else &#123; create(modelClass, application) &#125; &#125; @Suppress(&quot;DocumentExceptions&quot;) private fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, app: Application): T &#123; return if (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123; try &#123; modelClass.getConstructor(Application::class.java).newInstance(app) &#125; catch (e: NoSuchMethodException) &#123; throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e) &#125; catch (e: IllegalAccessException) &#123; throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e) &#125; catch (e: InstantiationException) &#123; throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e) &#125; catch (e: InvocationTargetException) &#123; throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e) &#125; &#125; else super.create(modelClass) &#125; public companion object &#123; internal fun defaultFactory(owner: ViewModelStoreOwner): Factory = if (owner is HasDefaultViewModelProviderFactory) owner.defaultViewModelProviderFactory else instance internal const val DEFAULT_KEY = &quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot; private var sInstance: AndroidViewModelFactory? = null @JvmStatic public fun getInstance(application: Application): AndroidViewModelFactory &#123; if (sInstance == null) &#123; sInstance = AndroidViewModelFactory(application) &#125; return sInstance!! &#125; private object ApplicationKeyImpl : Key&lt;Application&gt; @JvmField val APPLICATION_KEY: Key&lt;Application&gt; = ApplicationKeyImpl &#125; &#125;&#125;internal fun defaultCreationExtras(owner: ViewModelStoreOwner): CreationExtras &#123; return if (owner is HasDefaultViewModelProviderFactory) &#123; owner.defaultViewModelCreationExtras &#125; else CreationExtras.Empty&#125;@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; ViewModelProvider.get(): VM = get(VM::class.java) 简单解析一下 ViewModelProvider在这段代码中，定义了一个ViewModelProvider类，其作用是提供ViewModel实例。在MVVM架构中，ViewModel是负责准备和管理UI相关数据的组件，它使数据和命令可以轻松地绑定到UI控件，同时保持UI控件和应用逻辑的分离。ViewModelProvider负责创建和管理这些ViewModel对象。以下是该代码段中定义的主要函数及其作用的分析： 构造函数 ViewModelProvider构造函数: 接收一个ViewModelStore和一个Factory作为参数，以及一个可选的CreationExtras。这些构造函数允许你在创建ViewModelProvider实例时指定ViewModel的存储和创建方式。 内部接口和类 Factory接口: 定义了创建ViewModel实例的方法。这个接口允许自定义ViewModel的创建过程，包括通过CreationExtras传递额外的创建参数。 OnRequeryFactory类: 这是一个可选的回调，当ViewModel被重新查询时调用。 NewInstanceFactory类: 一个默认的Factory实现，它使用反射来创建ViewModel的新实例。 AndroidViewModelFactory类: 专门为AndroidViewModel定制的Factory实现，它需要Application实例来创建ViewModel。 主要方法 get方法: 重载的方法，用于获取指定类的ViewModel实例。如果ViewModel已经存在于ViewModelStore中，则返回这个实例；如果不存在，则通过Factory创建新的实例并存储起来。这些方法确保ViewModel的生命周期被正确管理，即使在配置更改（如屏幕旋转）后也能保持状态。 defaultCreationExtras函数: 为ViewModel创建提供默认的CreationExtras。这是用于传递额外参数给ViewModel构造函数的一种机制。 其他重要组件 ViewModelStore: 一个容器，用于存储和管理ViewModel实例。这确保了ViewModel能够跨配置更改存活。 ViewModelStoreOwner: 一个接口，表示拥有ViewModelStore的对象，通常是UI控制器，如Activity或Fragment。 CreationExtras: 一个容器，用于在创建ViewModel时传递额外的参数。它支持通过键值对形式传递任意数据。 整体而言，这段代码提供了一个灵活的机制来创建和管理ViewModel实例，支持自定义创建过程，并确保ViewModel能够有效地与UI组件的生命周期同步。 这段代码体现了Android架构组件中ViewModel的灵活创建和管理机制，包括支持自定义工厂、传递额外参数以及通过工厂模式解耦ViewModel的创建过程。这套机制不仅提高了ViewModel使用的灵活性，还增强了组件之间的解耦，使得应用架构更加清晰和易于维护。 参数 defaultCreationExtras 的作用defaultCreationExtras函数在ViewModelProvider的上下文中扮演着重要的角色。它提供了一种机制，用于在创建ViewModel实例时传递额外的参数，这些参数被封装在CreationExtras对象中。这允许ViewModel的构造过程中接收来自ViewModelProvider以外的信息，进而使得ViewModel的创建更加灵活和动态。 CreationExtras的作用CreationExtras是一种键值对集合，它允许开发者在创建ViewModel时传递任意类型的数据。这些数据可以是应用上下文（如Application实例）、配置参数，或者任何对于ViewModel初始化过程中可能需要的信息。 defaultCreationExtras 使用场景defaultCreationExtras的使用场景通常涉及到需要向ViewModel传递额外信息的情况。例如，如果某个ViewModel需要访问全局的应用状态，或者依赖于特定的服务实例，这些依赖项可以通过CreationExtras在创建时传递给ViewModel，而defaultCreationExtras函数就是为了方便地提供这类默认参数的。 总之，defaultCreationExtras函数和CreationExtras机制为ViewModel的创建提供了额外的灵活性和动态配置能力，使得ViewModel能够更好地适应不同的应用场景和需求。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.4 - Jetpacket","slug":"3-Android/3-4-Jetpacket","permalink":"http://example.com/categories/3-Android/3-4-Jetpacket/"}],"tags":[]},{"title":"ViewModel 源代码分析 (二)","slug":"3 Android/Jetpacket/VideoModel/1 ViewModel 源代码分析 (二)","date":"2024-03-31T17:32:52.573Z","updated":"2024-04-03T11:53:20.200Z","comments":true,"path":"2024/04/01/3 Android/Jetpacket/VideoModel/1 ViewModel 源代码分析 (二)/","link":"","permalink":"http://example.com/2024/04/01/3%20Android/Jetpacket/VideoModel/1%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%BA%8C)/","excerpt":"","text":"viewmodel CreationExtrasViewModel创建过程中传递额外参数的容器。 InitializerViewModelFactory ViewModelProvider.Factory接口实现类，使用ViewModelInitializer来创建ViewModel实例。 InitializerViewModelFactoryBuilder 用于构建InitializerViewModelFactory的工具，通常以DSL形式提供。 MutableCreationExtras 可变版本的CreationExtras，允许添加或修改额外参数。 ViewModelFactoryDsl 一个DSL（领域特定语言），用于更声明式地定义如何创建ViewModel。 ViewModelInitializer 用于初始化ViewModel的类，通常与ViewModelFactoryDsl一起使用。 InitializerViewModelFactory 提供了使用InitializerViewModelFactory的Kotlin扩展。 AndroidViewModel AndroidViewModel是ViewModel的一个子类，它接受应用程序的Application作为上下文，这对于需要访问Application资源的ViewModel特别有用。 HasDefaultViewModelProviderFactory 一个接口，标识一个类拥有默认的ViewModelProvider.Factory，用于创建ViewModel。 ViewModel ViewModelLazy 一个提供懒加载ViewModel实例的工具类。 ViewModelProvider 用于获取ViewModel实例，确保配置更改时ViewModel可以持续使用。 ViewModelStore 用于保存ViewModel实例的类，以便它们可以跨配置更改持续存在。 ViewModelStoreOwner 一个接口，标识一个类可以拥有ViewModelStore。 ViewTreeViewModelStoreOwner 用于从视图树中查找ViewModelStoreOwner的工具类。 ViewTreeViewModelKt 提供了操作和查询视图树中ViewModel的Kotlin扩展 ViewModelStore1234567891011121314151617181920212223242526272829303132333435package androidx.lifecycle;import java.util.HashMap;import java.util.HashSet;import java.util.Set;public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; Set&lt;String&gt; keys() &#123; return new HashSet&lt;&gt;(mMap.keySet()); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.clear(); &#125; mMap.clear(); &#125;&#125; 如果有不想保存的数据可以在存储前调用 ViewModelStore clear 函数 使用场景Activity或Fragment销毁时在Activity或Fragment的onDestroy方法中调用ViewModelStore的clear方法，可以确保所有关联的ViewModel能够及时清理资源。这是因为，在某些情况下（如用户明确退出Activity或Fragment），保留ViewModel不再有意义，应该清除所有资源以避免内存泄漏。 示例代码：12345678javaCopy code@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (isFinishing()) &#123; viewModelStore.clear(); &#125;&#125; 这里，isFinishing()用于检查Activity是否正在结束（用户退出或因其他原因被销毁），如果是，则清理ViewModelStore中的所有ViewModel。 在使用ViewModel时实现资源管理如果你的应用程序具有复杂的业务逻辑，可能会创建多个ViewModel用于不同的数据处理和业务逻辑。在这种情况下，当确定某些ViewModel不再需要时，可以通过调用clear方法释放这些ViewModel占用的资源。 3. 单元测试在进行单元测试时，特别是在测试涉及ViewModel生命周期的逻辑时，clear方法可以在测试完成后被调用来清理测试环境，保证每个测试运行的隔离性。 注意事项：虽然clear方法的使用可以帮助管理资源，但需要谨慎使用，以避免在不适当的时机释放资源导致的应用崩溃或不稳定。通常，Android框架会自动处理ViewModel的生命周期，只有在特定情况下，如Activity或Fragment被销毁时，才需要手动调用clear方法。 ViewModelStoreOwner12345678910package androidx.lifecycle;import androidx.annotation.NonNull;@SuppressWarnings(&quot;WeakerAccess&quot;)public interface ViewModelStoreOwner &#123; @NonNull ViewModelStore getViewModelStore();&#125; 我们来看一下到底谁是 ViewModelStoreOwner ViewModelStoreOwner - ComponentActivity12345678910@NonNull@Overridepublic ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;); &#125; ensureViewModelStore(); return mViewModelStore;&#125; ViewModelStoreOwner - Fragment12345678910111213@NonNull@Overridepublic ViewModelStore getViewModelStore() &#123; if (mFragmentManager == null) &#123; throw new IllegalStateException(&quot;Can&#x27;t access ViewModels from detached fragment&quot;); &#125; if (getMinimumMaxLifecycleState() == Lifecycle.State.INITIALIZED.ordinal()) &#123; throw new IllegalStateException(&quot;Calling getViewModelStore() before a Fragment &quot; + &quot;reaches onCreate() when using setMaxLifecycle(INITIALIZED) is not &quot; + &quot;supported&quot;); &#125; return mFragmentManager.getViewModelStore(this);&#125; ViewTreeViewModelStoreOwner12345678910111213141516171819202122232425262728293031323334package androidx.lifecycle;import android.view.View;import android.view.ViewParent;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.lifecycle.viewmodel.R;public class ViewTreeViewModelStoreOwner &#123; private ViewTreeViewModelStoreOwner() &#123; // No instances &#125; public static void set(@NonNull View view, @Nullable ViewModelStoreOwner viewModelStoreOwner) &#123; view.setTag(R.id.view_tree_view_model_store_owner, viewModelStoreOwner); &#125; @Nullable public static ViewModelStoreOwner get(@NonNull View view) &#123; ViewModelStoreOwner found = (ViewModelStoreOwner) view.getTag( R.id.view_tree_view_model_store_owner); if (found != null) return found; ViewParent parent = view.getParent(); while (found == null &amp;&amp; parent instanceof View) &#123; final View parentView = (View) parent; found = (ViewModelStoreOwner) parentView.getTag(R.id.view_tree_view_model_store_owner); parent = parentView.getParent(); &#125; return found; &#125;&#125; ViewTreeViewModelStoreOwner 与 ViewModelStoreOwner 有什么区别ViewModelStoreOwner 定义：ViewModelStoreOwner是一个接口，定义了可以拥有并管理ViewModelStore的类。ViewModelStore是一个容器，用于存储和管理ViewModel实例，确保它们能够跨配置更改（如屏幕旋转）生存下来。 用途：这个接口通常由Activity和Fragment实现，使它们能够持有ViewModel实例。通过这种方式，Activity或Fragment可以在内部管理其ViewModels的生命周期，确保在发生配置更改时，ViewModels不会被销毁并重新创建。 实现方式：在使用ViewModel时，开发者通常不需要直接实现ViewModelStoreOwner接口。例如，AppCompatActivity和Fragment已经实现了这个接口，提供了对ViewModelStore的访问。 ViewTreeViewModelStoreOwner 定义：ViewTreeViewModelStoreOwner是与Android视图树（View Tree）相关的工具类。它提供了静态方法来从视图树中查找ViewModelStoreOwner。这是通过在视图的Tag中设置和获取ViewModelStoreOwner实现的。 用途：ViewTreeViewModelStoreOwner的主要用途是在视图层级中找到最近的ViewModelStoreOwner。这对于自定义视图或视图组件特别有用，这些组件需要访问ViewModel但不直接与Activity或Fragment关联。 使用场景：当你有一个嵌套在深层视图层次结构中的自定义视图，并且这个视图需要访问ViewModel时，可以使用ViewTreeViewModelStoreOwner.get(view)来找到最近的ViewModelStoreOwner实例。这使得即使在复杂的视图结构中，自定义视图也能正确地管理和访问ViewModel实例。 区别 作用范围：ViewModelStoreOwner直接关联于可以持有ViewModelStore的实体（如Activity或Fragment），而ViewTreeViewModelStoreOwner是一个工具类，用于在视图树中查找这些实体。 使用上下文：ViewModelStoreOwner通常用于直接管理ViewModels的生命周期，特别是在Activity和Fragment中。ViewTreeViewModelStoreOwner则用于在视图层级中寻找ViewModelStoreOwner，便于自定义视图或组件访问ViewModels。 实现与调用：Activity和Fragment通常自动实现ViewModelStoreOwner接口。相反，ViewTreeViewModelStoreOwner提供了一种机制，允许在视图树中任意位置将视图与最近的ViewModelStoreOwner关联起来，而无需直接实现或管理ViewModelStoreOwner接口。 简而言之，ViewModelStoreOwner关注于拥有和管理ViewModelStore的能力，而ViewTreeViewModelStoreOwner提供了一种查找视图树中最近的ViewModelStoreOwner的方法，使得在复杂的视图结构中的组件也能访问和使用ViewModels。 ViewModelStoreOwner 的 set 方法ViewModelStoreOwner 的 set 方法是什么时候被调用的，被添加到哪个 View 的 Tag 中？ androidx.activity.ComponentActivity 中的调用时机androidx.activity.ComponentActivity#setContentView(android.view.View) 12345678910111213141516171819@Overridepublic void setContentView(@LayoutRes int layoutResID) &#123; initViewTreeOwners(); super.setContentView(layoutResID);&#125;@Overridepublic void setContentView(@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;) View view) &#123; initViewTreeOwners(); super.setContentView(view);&#125;@Overridepublic void setContentView(@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;) View view, @SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;) ViewGroup.LayoutParams params) &#123; initViewTreeOwners(); super.setContentView(view, params);&#125; androidx.activity.ComponentActivity#addContentView 1234567@Overridepublic void addContentView(@SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;) View view, @SuppressLint(&#123;&quot;UnknownNullness&quot;, &quot;MissingNullability&quot;&#125;) ViewGroup.LayoutParams params) &#123; initViewTreeOwners(); super.addContentView(view, params);&#125;) 在 initViewTreeOwners 中调用 ViewModelStoreOwner 的 setandroidx.activity.ComponentActivity#initViewTreeOwners 12345678private void initViewTreeOwners() &#123; // Set the view tree owners before setting the content view so that the inflation process // and attach listeners will see them already present ViewTreeLifecycleOwner.set(getWindow().getDecorView(), this); ViewTreeViewModelStoreOwner.set(getWindow().getDecorView(), this); ViewTreeSavedStateRegistryOwner.set(getWindow().getDecorView(), this); ViewTreeOnBackPressedDispatcherOwner.set(getWindow().getDecorView(), this);&#125; 这里顺便提一下 ViewTreeLifecycleOwner，ViewTreeSavedStateRegistryOwner，ViewTreeOnBackPressedDispatcherOwner 在Android Jetpack架构组件中，ViewTreeLifecycleOwner、ViewTreeSavedStateRegistryOwner和ViewTreeOnBackPressedDispatcherOwner是用于在视图树中传递和存储与生命周期、状态保存和返回按钮事件处理相关的对象的工具类。它们允许开发者在任何视图层级中访问与这些功能相关的对象，增强了组件化和模块化开发的灵活性。 ViewTreeLifecycleOwnerViewTreeLifecycleOwner与LifecycleOwner接口相关，后者是一个类可以实现的接口，表示这个类有一个生命周期，比如Activity或Fragment。ViewTreeLifecycleOwner提供了静态方法来在视图树中设置和获取LifecycleOwner。这使得在视图树中的任何位置，都可以访问到与之相关联的LifecycleOwner，进而可以根据生命周期事件来管理资源，比如开始&#x2F;停止数据加载、绑定&#x2F;解绑资源等。 ViewTreeSavedStateRegistryOwnerViewTreeSavedStateRegistryOwner与SavedStateRegistryOwner接口相关，后者管理和存储状态，以便在进程被杀后恢复状态。通过ViewTreeSavedStateRegistryOwner，开发者可以为视图树中的任何视图设置和获取与状态保存相关的SavedStateRegistryOwner。这使得即使是自定义视图也能够利用Android的状态保存机制，无需依赖于Activity或Fragment来保存和恢复状态。 ViewTreeOnBackPressedDispatcherOwnerViewTreeOnBackPressedDispatcherOwner与OnBackPressedDispatcherOwner接口相关，后者提供了一个组件化的方式来处理返回按钮事件。ViewTreeOnBackPressedDispatcherOwner允许开发者为视图树中的任何视图设置和获取OnBackPressedDispatcherOwner。这意味着在任何视图中，都可以独立处理返回按钮的点击事件，而不是仅限于在Activity中处理。这对于构建复杂的用户界面和处理嵌套的用户交互特别有用。 使用场景和好处 组件化开发：这些工具类支持更加组件化的开发方式，视图或组件可以独立于Activity或Fragment使用这些架构组件。 灵活性和可重用性：使得自定义视图和组件更加灵活，易于重用，因为它们可以在不依赖特定Activity或Fragment的情况下，管理自己的生命周期、状态保存和返回按钮处理。 简化代码：简化了在自定义视图或深层嵌套的视图结构中访问这些功能的方式，避免了复杂的回调结构或过度依赖于上下文。 综上所述，ViewTreeLifecycleOwner、ViewTreeSavedStateRegistryOwner和ViewTreeOnBackPressedDispatcherOwner为Android开发者提供了强大的工具，以更加灵活和模块化的方式处理生命周期管理、状态保存和返回按钮事件处理。 ViewTreeViewModelKtGoogle 也准备了一个 Kotlin 使用的扩展函数配合 ViewModelStoreOwner 123456package androidx.lifecycleimport android.view.Viewpublic fun View.findViewTreeViewModelStoreOwner(): ViewModelStoreOwner? = ViewTreeViewModelStoreOwner.get(this)","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.4 - Jetpacket","slug":"3-Android/3-4-Jetpacket","permalink":"http://example.com/categories/3-Android/3-4-Jetpacket/"}],"tags":[]},{"title":"ViewModel 源代码分析 (三)","slug":"3 Android/Jetpacket/VideoModel/2 ViewModel 源代码分析 (三) ","date":"2024-03-31T17:32:52.573Z","updated":"2024-04-03T12:07:54.691Z","comments":true,"path":"2024/04/01/3 Android/Jetpacket/VideoModel/2 ViewModel 源代码分析 (三) /","link":"","permalink":"http://example.com/2024/04/01/3%20Android/Jetpacket/VideoModel/2%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%89)%20/","excerpt":"","text":"viewmodel CreationExtrasViewModel创建过程中传递额外参数的容器。 InitializerViewModelFactory ViewModelProvider.Factory接口实现类，使用ViewModelInitializer来创建ViewModel实例。 InitializerViewModelFactoryBuilder 用于构建InitializerViewModelFactory的工具，通常以DSL形式提供。 MutableCreationExtras 可变版本的CreationExtras，允许添加或修改额外参数。 ViewModelFactoryDsl 一个DSL（领域特定语言），用于更声明式地定义如何创建ViewModel。 ViewModelInitializer 用于初始化ViewModel的类，通常与ViewModelFactoryDsl一起使用。 InitializerViewModelFactory 提供了使用InitializerViewModelFactory的Kotlin扩展。 AndroidViewModel AndroidViewModel是ViewModel的一个子类，它接受应用程序的Application作为上下文，这对于需要访问Application资源的ViewModel特别有用。 HasDefaultViewModelProviderFactory 一个接口，标识一个类拥有默认的ViewModelProvider.Factory，用于创建ViewModel。 ViewModel ViewModelLazy 一个提供懒加载ViewModel实例的工具类。 ViewModelProvider 用于获取ViewModel实例，确保配置更改时ViewModel可以持续使用。 ViewModelStore 用于保存ViewModel实例的类，以便它们可以跨配置更改持续存在。 ViewModelStoreOwner 一个接口，标识一个类可以拥有ViewModelStore。 ViewTreeViewModelStoreOwner 用于从视图树中查找ViewModelStoreOwner的工具类。 ViewTreeViewModelKt 提供了操作和查询视图树中ViewModel的Kotlin扩展 页面旋转的时候 ViewModelStore 到底被谁持有了ViewModelStoreActivity 的销毁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** Core implementation of activity destroy call. */void performDestroyActivity(ActivityClientRecord r, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; Class&lt;? extends Activity&gt; activityClass = null; if (localLOGV) Slog.v(TAG, &quot;Performing finish of &quot; + r); activityClass = r.activity.getClass(); r.activity.mConfigChangeFlags |= configChanges; if (finishing) &#123; r.activity.mFinished = true; &#125; performPauseActivityIfNeeded(r, &quot;destroy&quot;); if (!r.stopped) &#123; callActivityOnStop(r, false /* saveState */, &quot;destroy&quot;); &#125; if (getNonConfigInstance) &#123; try &#123; r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException(&quot;Unable to retain activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125; try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnDestroy(r.activity); if (!r.activity.mCalled) &#123; throw new SuperNotCalledException(&quot;Activity &quot; + safeToComponentShortString(r.intent) + &quot; did not call through to super.onDestroy()&quot;); &#125; if (r.window != null) &#123; r.window.closeAllPanels(); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException(&quot;Unable to destroy activity &quot; + safeToComponentShortString(r.intent) + &quot;: &quot; + e.toString(), e); &#125; &#125; r.setState(ON_DESTROY); mLastReportedWindowingMode.remove(r.activity.getActivityToken()); schedulePurgeIdler(); synchronized (this) &#123; if (mSplashScreenGlobal != null) &#123; mSplashScreenGlobal.tokenDestroyed(r.token); &#125; &#125; // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. synchronized (mResourcesManager) &#123; mActivities.remove(r.token); &#125; StrictMode.decrementExpectedActivityCount(activityClass);&#125; 关键代码12345678910if (getNonConfigInstance) &#123; try &#123; r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException(&quot;Unable to retain activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125; android.app.ActivityretainNonConfigurationInstances123456789101112131415161718192021222324252627282930NonConfigurationInstances retainNonConfigurationInstances() &#123; Object activity = onRetainNonConfigurationInstance(); HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); // We&#x27;re already stopped but we&#x27;ve been asked to retain. // Our fragments are taken care of but we need to mark the loaders for retention. // In order to do this correctly we need to restart the loaders first before // handing them off to the next activity. mFragments.doLoaderStart(); mFragments.doLoaderStop(true); ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig(); if (activity == null &amp;&amp; children == null &amp;&amp; fragments == null &amp;&amp; loaders == null &amp;&amp; mVoiceInteractor == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity; nci.children = children; nci.fragments = fragments; nci.loaders = loaders; if (mVoiceInteractor != null) &#123; mVoiceInteractor.retainInstance(); nci.voiceInteractor = mVoiceInteractor; &#125; return nci;&#125; onRetainNonConfigurationInstance123public Object onRetainNonConfigurationInstance() &#123; return null;&#125; onRetainNonConfigurationChildInstances1234@NullableHashMap&lt;String,Object&gt; onRetainNonConfigurationChildInstances() &#123; return null;&#125; androidx.activity.ComponentActivityonRetainNonConfigurationInstance1234567891011121314151617181920212223242526272829303132/** * Retain all appropriate non-config state. You can NOT * override this yourself! Use a &#123;@link androidx.lifecycle.ViewModel&#125; if you want to * retain your own non config state. */@Override@Nullable@SuppressWarnings(&quot;deprecation&quot;)public final Object onRetainNonConfigurationInstance() &#123; // Maintain backward compatibility. Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) &#123; // No one called getViewModelStore(), so see if there was an existing // ViewModelStore from our last NonConfigurationInstance NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; viewModelStore = nc.viewModelStore; &#125; &#125; if (viewModelStore == null &amp;&amp; custom == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci;&#125; 关键代码123NonConfigurationInstances nci = new NonConfigurationInstances();nci.custom = custom;nci.viewModelStore = viewModelStore; androidx.activity.ComponentActivity 中实现了 onRetainNonConfigurationInstance ViewModelStore 被保存到了 NonConfigurationInstances.viewModelStore 中 NonConfigurationInstances 又被 ActivityClientRecord 持有 android.app.ActivityThread.ActivityClientRecord 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236public static final class ActivityClientRecord &#123; @UnsupportedAppUsage public IBinder token; public IBinder assistToken; // A reusable token for other purposes, e.g. content capture, translation. It shouldn&#x27;t be // used without security checks public IBinder shareableActivityToken; // The token of the initial TaskFragment that embedded this activity. Do not rely on it // after creation because the activity could be reparented. @Nullable public IBinder mInitialTaskFragmentToken; int ident; @UnsupportedAppUsage Intent intent; String referrer; IVoiceInteractor voiceInteractor; Bundle state; PersistableBundle persistentState; @UnsupportedAppUsage Activity activity; Window window; Activity parent; String embeddedID; Activity.NonConfigurationInstances lastNonConfigurationInstances; // TODO(lifecycler): Use mLifecycleState instead. @UnsupportedAppUsage boolean paused; @UnsupportedAppUsage boolean stopped; boolean hideForNow; Configuration createdConfig; Configuration overrideConfig; // Used for consolidating configs before sending on to Activity. private Configuration tmpConfig = new Configuration(); // Callback used for updating activity override config and camera compat control state. ViewRootImpl.ActivityConfigCallback activityConfigCallback; ActivityClientRecord nextIdle; // Indicates whether this activity is currently the topmost resumed one in the system. // This holds the last reported value from server. boolean isTopResumedActivity; // This holds the value last sent to the activity. This is needed, because an update from // server may come at random time, but we always need to report changes between ON_RESUME // and ON_PAUSE to the app. boolean lastReportedTopResumedState; ProfilerInfo profilerInfo; @UnsupportedAppUsage ActivityInfo activityInfo; @UnsupportedAppUsage CompatibilityInfo compatInfo; @UnsupportedAppUsage public LoadedApk packageInfo; List&lt;ResultInfo&gt; pendingResults; List&lt;ReferrerIntent&gt; pendingIntents; boolean startsNotResumed; public final boolean isForward; int pendingConfigChanges; // Whether we are in the process of performing on user leaving. boolean mIsUserLeaving; Window mPendingRemoveWindow; WindowManager mPendingRemoveWindowManager; @UnsupportedAppUsage boolean mPreserveWindow; /** The options for scene transition. */ ActivityOptions mActivityOptions; /** Whether this activiy was launched from a bubble. */ boolean mLaunchedFromBubble; @LifecycleState private int mLifecycleState = PRE_ON_CREATE; private SizeConfigurationBuckets mSizeConfigurations; @VisibleForTesting @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) public ActivityClientRecord() &#123; this.isForward = false; init(); &#125; public ActivityClientRecord(IBinder token, Intent intent, int ident, ActivityInfo info, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, ActivityOptions activityOptions, boolean isForward, ProfilerInfo profilerInfo, ClientTransactionHandler client, IBinder assistToken, IBinder shareableActivityToken, boolean launchedFromBubble, IBinder initialTaskFragmentToken) &#123; this.token = token; this.assistToken = assistToken; this.shareableActivityToken = shareableActivityToken; this.ident = ident; this.intent = intent; this.referrer = referrer; this.voiceInteractor = voiceInteractor; this.activityInfo = info; this.compatInfo = compatInfo; this.state = state; this.persistentState = persistentState; this.pendingResults = pendingResults; this.pendingIntents = pendingNewIntents; this.isForward = isForward; this.profilerInfo = profilerInfo; this.overrideConfig = overrideConfig; this.packageInfo = client.getPackageInfoNoCheck(activityInfo.applicationInfo, compatInfo); mActivityOptions = activityOptions; mLaunchedFromBubble = launchedFromBubble; mInitialTaskFragmentToken = initialTaskFragmentToken; init(); &#125; /** Common initializer for all constructors. */ private void init() &#123; parent = null; embeddedID = null; paused = false; stopped = false; hideForNow = false; nextIdle = null; activityConfigCallback = new ViewRootImpl.ActivityConfigCallback() &#123; @Override public void onConfigurationChanged(Configuration overrideConfig, int newDisplayId) &#123; if (activity == null) &#123; throw new IllegalStateException( &quot;Received config update for non-existing activity&quot;); &#125; activity.mMainThread.handleActivityConfigurationChanged( ActivityClientRecord.this, overrideConfig, newDisplayId); &#125; @Override public void requestCompatCameraControl(boolean showControl, boolean transformationApplied, ICompatCameraControlCallback callback) &#123; if (activity == null) &#123; throw new IllegalStateException( &quot;Received camera compat control update for non-existing activity&quot;); &#125; ActivityClient.getInstance().requestCompatCameraControl( activity.getResources(), token, showControl, transformationApplied, callback); &#125; &#125;; &#125; /** Get the current lifecycle state. */ public int getLifecycleState() &#123; return mLifecycleState; &#125; /** Update the current lifecycle state for internal bookkeeping. */ public void setState(@LifecycleState int newLifecycleState) &#123; mLifecycleState = newLifecycleState; switch (mLifecycleState) &#123; case ON_CREATE: paused = true; stopped = true; break; case ON_START: paused = true; stopped = false; break; case ON_RESUME: paused = false; stopped = false; break; case ON_PAUSE: paused = true; stopped = false; break; case ON_STOP: paused = true; stopped = true; break; &#125; &#125; private boolean isPreHoneycomb() &#123; return activity != null &amp;&amp; activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB; &#125; private boolean isPreP() &#123; return activity != null &amp;&amp; activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.P; &#125; public boolean isPersistable() &#123; return activityInfo.persistableMode == ActivityInfo.PERSIST_ACROSS_REBOOTS; &#125; public boolean isVisibleFromServer() &#123; return activity != null &amp;&amp; activity.mVisibleFromServer; &#125; public String toString() &#123; ComponentName componentName = intent != null ? intent.getComponent() : null; return &quot;ActivityRecord&#123;&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; token=&quot; + token + &quot; &quot; + (componentName == null ? &quot;no component name&quot; : componentName.toShortString()) + &quot;&#125;&quot;; &#125; public String getStateString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;ActivityClientRecord&#123;&quot;); sb.append(&quot;paused=&quot;).append(paused); sb.append(&quot;, stopped=&quot;).append(stopped); sb.append(&quot;, hideForNow=&quot;).append(hideForNow); sb.append(&quot;, startsNotResumed=&quot;).append(startsNotResumed); sb.append(&quot;, isForward=&quot;).append(isForward); sb.append(&quot;, pendingConfigChanges=&quot;).append(pendingConfigChanges); sb.append(&quot;, preserveWindow=&quot;).append(mPreserveWindow); if (activity != null) &#123; sb.append(&quot;, Activity&#123;&quot;); sb.append(&quot;resumed=&quot;).append(activity.mResumed); sb.append(&quot;, stopped=&quot;).append(activity.mStopped); sb.append(&quot;, finished=&quot;).append(activity.isFinishing()); sb.append(&quot;, destroyed=&quot;).append(activity.isDestroyed()); sb.append(&quot;, startedActivity=&quot;).append(activity.mStartedActivity); sb.append(&quot;, changingConfigurations=&quot;).append(activity.mChangingConfigurations); sb.append(&quot;&#125;&quot;); &#125; sb.append(&quot;&#125;&quot;); return sb.toString(); &#125;&#125; ActivityClientRecord是Android系统内部使用的一个类，主要存在于ActivityThread中，用于管理和跟踪Activity的状态信息。这个类作为Activity实例状态的容器，承载了Activity的生命周期状态、Intent信息、窗口和其他与Activity实例相关的配置信息。ActivityClientRecord是ActivityThread处理Activity生命周期事件时的关键数据结构，它帮助ActivityThread高效地管理Activity的创建、启动、恢复、暂停、停止以及销毁过程。 主要职责 生命周期管理：ActivityClientRecord存储了Activity的生命周期状态，例如是否处于暂停状态、是否已经创建等，这对于ActivityThread正确处理Activity生命周期事件至关重要。 配置管理：它还包含了与Activity实例相关的配置信息，如屏幕方向、主题等，这些信息对于Activity在不同配置下正确表现自己非常重要。 Intent处理：ActivityClientRecord包含了启动Activity所用的Intent，这个Intent携带了从其他组件传递给Activity的数据。 窗口管理：它还管理着Activity的窗口信息，包括用于描绘Activity UI的窗口。这对于在屏幕上正确渲染Activity视图非常关键。 工作原理当一个新的Activity被启动时，ActivityThread会接收到一个来自AMS（Activity Manager Service）的请求，此请求包含了创建或启动Activity所需的所有信息，包括Intent和Activity的配置信息。ActivityThread随后会创建一个新的ActivityClientRecord实例，用来存储这些信息，并根据这些信息处理Activity的创建和启动过程。 在Activity的生命周期中，ActivityThread会根据接收到的来自AMS的指令，更新ActivityClientRecord的状态，并据此调用Activity的相应生命周期方法，如onCreate、onStart、onResume、onPause、onStop和onDestroy。 重要性虽然ActivityClientRecord是一个内部类，不面向普通开发者，但了解它的存在和作用有助于深入理解Android的Activity管理机制。它是ActivityThread和AMS协同工作、高效管理Activity生命周期的关键数据结构，确保了Activity可以在正确的时间执行正确的操作，从而为用户提供流畅的应用体验。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.4 - Jetpacket","slug":"3-Android/3-4-Jetpacket","permalink":"http://example.com/categories/3-Android/3-4-Jetpacket/"}],"tags":[]},{"title":"04/80 寻找数组的中心下标","slug":"0 算法/03 基础算法80道/04 寻找数组的中心下标","date":"2024-03-27T17:15:30.000Z","updated":"2025-02-27T14:48:34.659Z","comments":true,"path":"2024/03/28/0 算法/03 基础算法80道/04 寻找数组的中心下标/","link":"","permalink":"http://example.com/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/04%20%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/","excerpt":"","text":"要在Kotlin中实现寻找数组的中心下标的算法，你可以遵循这个基本思路：遍历数组，对于每个下标，计算其左侧所有元素的和与右侧所有元素的和。如果在某个下标位置，这两个和相等，那么这个下标就是数组的中心下标。 下面是一个具体的实现示例： 123456789101112fun findPivotIndex(nums: IntArray): Int &#123; val totalSum = nums.sum() var leftSum = 0 for ((index, value) in nums.withIndex()) &#123; // 如果左侧和的两倍加上当前值等于总和，则当前索引是中心索引 if (2 * leftSum + value == totalSum) &#123; return index &#125; leftSum += value &#125; return -1 // 如果没有找到，返回-1&#125; 这个函数findPivotIndex接受一个整数数组nums作为参数，并返回中心下标。它首先计算数组的总和，然后遍历数组。在遍历过程中，它更新一个名为leftSum的变量，该变量存储当前索引左侧所有元素的和。对于每个元素，它检查2 * leftSum + value是否等于totalSum。如果等于，这意味着左侧所有元素的和等于右侧所有元素的和，因此当前索引是中心下标，函数返回该索引。如果遍历完整个数组都没有找到这样的索引，函数返回-1。 要使用这个函数，你可以像这样调用它： 12345fun main() &#123; val nums = intArrayOf(1, 7, 3, 6, 5, 6) val pivotIndex = findPivotIndex(nums) println(pivotIndex) // 输出中心下标&#125; 这个示例会输出数组[1, 7, 3, 6, 5, 6]的中心下标。","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.3 - 80 道基础算法","slug":"0-算法/0-3-80-道基础算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-3-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"02/80 统计素数个数-埃氏筛选法","slug":"0 算法/03 基础算法80道/02 统计素数个数 埃氏筛选法","date":"2024-03-27T17:12:10.000Z","updated":"2025-02-27T14:48:23.241Z","comments":true,"path":"2024/03/28/0 算法/03 基础算法80道/02 统计素数个数 埃氏筛选法/","link":"","permalink":"http://example.com/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/02%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E5%9F%83%E6%B0%8F%E7%AD%9B%E9%80%89%E6%B3%95/","excerpt":"","text":"埃拉托斯特尼筛法（简称埃氏筛）是一种高效的查找素数的算法，它通过排除从2开始到给定数n的所有非素数来找出所有小于或等于n的素数。使用埃氏筛选法改进统计数组中素数元素的个数的算法，我们可以先通过筛法找出数组中所有可能的素数，然后再统计数组中这些素数的个数。 这里是如何用Kotlin实现基于埃氏筛选法来统计一个数组中素数元素的个数： 构建埃氏筛: 根据数组中的最大值构建埃氏筛，以找到所有可能的素数。 统计素数: 遍历数组，利用构建的埃氏筛判断每个元素是否为素数，并计算素数的总数。 12345678910111213141516171819202122232425262728293031323334fun countPrimesInArrayWithSieve(arr: IntArray): Int &#123; if (arr.isEmpty()) return 0 // 找出数组中的最大值，以便构建足够大的筛 val max = arr.maxOrNull() ?: 0 // 构建埃氏筛 val isPrime = BooleanArray(max + 1) &#123; true &#125; isPrime[0] = false if (isPrime.size &gt; 1) isPrime[1] = false for (i in 2..Math.sqrt(max.toDouble()).toInt()) &#123; if (isPrime[i]) &#123; for (j in i * i..max step i) &#123; isPrime[j] = false &#125; &#125; &#125; // 统计数组中的素数个数 var count = 0 for (num in arr) &#123; if (num &gt;= 2 &amp;&amp; isPrime[num]) &#123; count++ &#125; &#125; return count&#125;fun main() &#123; val arr = intArrayOf(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15) println(&quot;Count of prime numbers in the array with sieve: $&#123;countPrimesInArrayWithSieve(arr)&#125;&quot;)&#125; 在这个实现中，countPrimesInArrayWithSieve 函数首先找出数组中的最大值，以此来确定筛的大小。接着，它通过遍历2到sqrt(max)的数来构建筛，标记所有这些数的倍数为非素数。最后，它遍历数组，统计那些标记为素数的元素个数。 埃氏筛选法的时间复杂度通常为 O(n log log n)，相比暴力法的 O(n^2)，它在处理大量数据时更加高效。","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.3 - 80 道基础算法","slug":"0-算法/0-3-80-道基础算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-3-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"03/80 删除排序数组中的重复项","slug":"0 算法/03 基础算法80道/03 删除排序数组中的重复项","date":"2024-03-27T17:11:48.000Z","updated":"2025-02-27T14:48:27.584Z","comments":true,"path":"2024/03/28/0 算法/03 基础算法80道/03 删除排序数组中的重复项/","link":"","permalink":"http://example.com/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/03%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"123456789101112131415161718192021fun removeDuplicates(nums: IntArray): Int &#123; if (nums.isEmpty()) return 0 var i = 0 for (j in 1 until nums.size) &#123; if (nums[j] != nums[i]) &#123; i++ nums[i] = nums[j] &#125; &#125; return i + 1 // 返回不重复数组的长度&#125;// 使用例子fun main() &#123; val nums = intArrayOf(1, 1, 2, 2, 3) val length = removeDuplicates(nums) println(&quot;新的数组长度: $length&quot;) for (i in 0 until length) &#123; print(&quot;$&#123;nums[i]&#125; &quot;) &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.3 - 80 道基础算法","slug":"0-算法/0-3-80-道基础算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-3-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"01/80 统计素数个数-暴力算法","slug":"0 算法/03 基础算法80道/01 统计素数个数 暴力算法","date":"2024-03-27T16:59:59.000Z","updated":"2025-02-27T14:48:17.809Z","comments":true,"path":"2024/03/28/0 算法/03 基础算法80道/01 统计素数个数 暴力算法/","link":"","permalink":"http://example.com/2024/03/28/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/01%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324fun isPrime(n: Int): Boolean &#123; if (n &lt;= 1) return false for (i in 2 until n) &#123; if (n % i == 0) &#123; return false &#125; &#125; return true&#125;fun countPrimesInArray(arr: IntArray): Int &#123; var count = 0 for (num in arr) &#123; if (isPrime(num)) &#123; count++ &#125; &#125; return count&#125;fun main() &#123; val arr = intArrayOf(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15) println(&quot;Count of prime numbers in the array: $&#123;countPrimesInArray(arr)&#125;&quot;)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.3 - 80 道基础算法","slug":"0-算法/0-3-80-道基础算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-3-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"TextView layout_constrainedWidth 属性","slug":"7复杂代码模版/0 UI绘制模版/TextView-layout_constrainedWidth-属性","date":"2024-03-22T13:47:30.611Z","updated":"2024-03-22T13:58:57.827Z","comments":true,"path":"2024/03/22/7复杂代码模版/0 UI绘制模版/TextView-layout_constrainedWidth-属性/","link":"","permalink":"http://example.com/2024/03/22/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/0%20UI%E7%BB%98%E5%88%B6%E6%A8%A1%E7%89%88/TextView-layout_constrainedWidth-%E5%B1%9E%E6%80%A7/","excerpt":"","text":"layout_constrainedWidth是ConstraintLayout中的一个属性，用于在处理宽度约束时提供更多的灵活性和控制。当你使用ConstraintLayout构建复杂的布局时，可能会遇到某些视图在其内容过长时需要被约束宽度的情况，以避免它们超出屏幕边界或影响其他视图的布局。layout_constrainedWidth属性就是为了解决这类问题而设计的。 1234567891011121314151617181920212223242526272829&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/buttonView&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintHorizontal_bias=&quot;0&quot; android:text=&quot;长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例长文本示例&quot; /&gt; &lt;Button android:id=&quot;@+id/buttonView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintStart_toEndOf=&quot;@id/textView&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintHorizontal_bias=&quot;0&quot; android:text=&quot;按钮&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;","categories":[{"name":"7 - 复杂代码模版","slug":"7-复杂代码模版","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/"},{"name":"7.1 - UI 绘制模版","slug":"7-复杂代码模版/7-1-UI-绘制模版","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-1-UI-%E7%BB%98%E5%88%B6%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"拦截 View 触摸事件，判断滑动方向","slug":"7复杂代码模版/1 手势分发/拦截 View 触摸事件，判断滑动方向","date":"2024-03-22T13:47:30.611Z","updated":"2024-06-25T04:46:07.880Z","comments":true,"path":"2024/03/22/7复杂代码模版/1 手势分发/拦截 View 触摸事件，判断滑动方向/","link":"","permalink":"http://example.com/2024/03/22/7%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/1%20%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/%E6%8B%A6%E6%88%AA%20View%20%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%88%A4%E6%96%AD%E6%BB%91%E5%8A%A8%E6%96%B9%E5%90%91/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657anyView.setOnTouchListener(object : View.OnTouchListener &#123; private var initialX = 0f private var initialY = 0f private var hasScrolled = false override fun onTouch(v: View?, event: MotionEvent?): Boolean &#123; event ?: return false when (event.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; // 记录初始触摸位置 initialX = event.x initialY = event.y hasScrolled = false &#125; MotionEvent.ACTION_MOVE -&gt; &#123; if (!hasScrolled) &#123; val diffX = event.x - initialX val diffY = event.y - initialY // 判断滑动方向，确保是水平滑动 if (abs(diffX) &gt; abs(diffY)) &#123; val direction = if (diffX &lt; 0) Direction.LEFT else Direction.RIGHT handleHorizontalScroll(direction) hasScrolled = true &#125; &#125; &#125; MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; &#123; hasScrolled = false &#125; &#125; return false &#125; private fun handleHorizontalScroll(direction: Direction) &#123; when (direction) &#123; Direction.LEFT -&gt; &#123; // 向左滑动 showToast(&quot;发生向左滑动&quot;) // 在这里处理向左滑动的逻辑 &#125; Direction.RIGHT -&gt; &#123; // 向右滑动 showToast(&quot;发生向右滑动&quot;) // 在这里处理向右滑动的逻辑 &#125; &#125; &#125; private fun showToast(message: String) &#123; Toast.makeText(context, message, Toast.LENGTH_SHORT).show() &#125; enum class Direction &#123; LEFT, RIGHT &#125;&#125;","categories":[{"name":"7 - 复杂代码模版","slug":"7-复杂代码模版","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/"},{"name":"7.2 - 手势分发","slug":"7-复杂代码模版/7-2-手势分发","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-2-%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/"}],"tags":[]},{"title":"Android 性能专题 - 插件化预热-拼多多为什么只有26M-GPT4快问快答","slug":"3 Android/性能优化/Android-性能专题-插件化预热-拼多多为什么只有26M-GPT4快问快答","date":"2024-02-20T17:52:23.080Z","updated":"2024-02-23T14:53:33.370Z","comments":true,"path":"2024/02/21/3 Android/性能优化/Android-性能专题-插件化预热-拼多多为什么只有26M-GPT4快问快答/","link":"","permalink":"http://example.com/2024/02/21/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E6%8F%92%E4%BB%B6%E5%8C%96%E9%A2%84%E7%83%AD-%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%8926M-GPT4%E5%BF%AB%E9%97%AE%E5%BF%AB%E7%AD%94/","excerpt":"","text":"什么是双亲委派机制双亲委派机制（Parent Delegation Model）是Java类加载器（ClassLoader）使用的一种特定模型，在这个模型中，类加载器在尝试加载类或资源时，会首先委托给其父类加载器进行加载，这个过程会一直递归下去，直到达到最顶层的启动类加载器（Bootstrap ClassLoader）。如果父类加载器可以完成类加载工作，就使用父类加载器的定义，如果父类加载器无法完成加载工作（即它搜索的路径中没有找到所需的类），子类加载器才会尝试自己去加载这个类。 双亲委派机制的优点包括： 避免类的重复加载：由于在顶层开始尝试加载类，因此类在JVM中只会被加载一次，这样就保证了Java虚拟机中存在的类，都是由唯一的类加载器加载的，从而避免了类的多次加载。 保护程序安全：通过给予Java核心库的加载工作委托给顶层的启动类加载器，保证了Java核心库的类型安全，防止核心API库被随意替换。用户自定义的类加载器不会去尝试加载这些Java核心类库，这样可以防止一些恶意代码替代了这些核心API，从而破坏JVM的安全性。 促进正向的类加载工作流：这种委派模式促进了类加载器之间的协作，遵循了一种从顶层到底层的工作流，使得类加载过程更加清晰。 尽管双亲委派模型带来了上述好处，但在某些情况下，比如在一个Java程序中需要加载一些运行时生成的类，或者是从网络上下载的类，这时可能需要自定义类加载器，并打破双亲委派模型。在Java中，可以通过重写ClassLoader的loadClass方法来实现自定义的类加载逻辑，从而在必要时绕过双亲委派模型。 为什么可以避免类的重复加载双亲委派模型可以避免类的重复加载主要是因为它采用了一种层次化的类加载方式，确保了每个类由一个确定的类加载器负责加载。具体来说，这种机制避免类重复加载的原理和机制包括以下几点： 层次化的类加载器结构：在Java中，类加载器通常有三层结构（启动类加载器、扩展类加载器、应用程序类加载器），加上可能的自定义类加载器。每个类加载器都有可能有自己的父加载器（除了启动类加载器，它是最顶层的加载器，没有父加载器）。当一个类加载器接收到类加载的请求时，它首先不会尝试自己去加载这个类，而是把这个请求委托给它的父加载器去执行，这样一层层向上直到启动类加载器。 委托机制确保类的唯一性：因为加载请求最终会传递到启动类加载器，如果这个类能被启动类加载器加载，那么它就会由启动类加载器完成加载。如果启动类加载器加载不了，它会返回到下一级加载器尝试，依此类推，直到找到合适的加载器加载这个类。这样一来，无论是哪个类加载器加载的类，都确保了在JVM中的唯一性，因为同一个类在JVM中只会被加载一次。 缓存机制：类加载器在加载类的过程中，会将加载过的类缓存起来。当再次请求加载这个类时，类加载器会首先检查这个类是否已经加载过了，如果已经加载，就直接从缓存中返回这个类的Class对象，而不会再次加载。这个缓存机制进一步保证了类的唯一性和避免重复加载。 安全性考虑：双亲委派模型还有一个重要的安全考量。通过让启动类加载器（负责加载Java核心库的加载器）在加载类的最前线，可以避免核心API被恶意替换。因为用户自定义的类加载器无法直接加载核心API类，所以即使有类的全限定名相同，也不会影响到JVM内部的类实现，这样就避免了核心类库的污染和重复加载。 通过上述机制，双亲委派模型不仅避免了类的重复加载，而且还提升了Java程序的运行时安全性和稳定性。 向我解释启动类加载器、扩展类加载器、应用程序类加载器Java虚拟机（JVM）使用类加载器（ClassLoader）来动态加载类文件到内存中。在JVM中，类加载器遵循双亲委派模型，并且主要分为三种类型：启动（Bootstrap）类加载器、扩展（Extension）类加载器、应用程序（Application）类加载器。它们的作用和层次结构如下： 启动类加载器（Bootstrap ClassLoader） 作用：这是Java类加载器层次结构中的最顶层加载器。它负责加载JVM基础核心类库，如rt.jar、resources.jar、charsets.jar以及类路径中指定的类。这些库位于JDK的jre/lib目录或者是JAVA_HOME/lib目录下。 实现：启动类加载器并不是Java实现的，而是由JVM自身的底层代码（如C&#x2F;C++）实现的。这意味着它不继承自java.lang.ClassLoader，不能被Java代码直接引用。 特点：由于其加载的是Java的核心类库，因此它不会被Java程序直接控制。它提供了Java运行时环境的基础类，保证了JVM的稳定性和安全性。 扩展类加载器（Extension ClassLoader） 作用：扩展类加载器负责加载Java的扩展库，即位于JDK的jre/lib/ext目录或者由系统属性java.ext.dirs指定位置的类库。这些库提供了标准Java类库之外的扩展功能。 实现：扩展类加载器是用Java实现的，并且它是java.lang.ClassLoader类的一个实例。在类加载器的层次结构中，它是启动类加载器的子加载器。 特点：扩展类加载器使得用户可以通过放置jar文件到ext目录来扩展JVM的功能，而不需要放到JVM核心类库目录中去。 应用程序类加载器（Application ClassLoader） 作用：应用程序类加载器负责加载用户类路径（Classpath）上的类库，这包括来自于CLASSPATH环境变量、-classpath或-cp命令行选项指定的所有类库。它是程序中默认的类加载器，通常用来加载我们自己写的类和第三方库。 实现：这个加载器也是用Java实现的，并且是ClassLoader的一个直接子类。在类加载器的层次结构中，它是扩展类加载器的子加载器。 特点：大部分应用程序中的类都是由这个加载器加载的。它保证了应用程序类是由用户定义的路径加载，而不是由JVM的内部路径决定。 这三个类加载器共同协作，确保了Java应用程序在运行时可以动态加载类，同时保障了系统的安全性和类加载机制的高效性。 向我介绍什么是Android的插件化Android的插件化是一种在Android开发中实现模块化、动态加载和运行时集成第三方组件或模块的技术手段。它允许应用在不需要重新安装或更新整个应用的情况下，动态加载和卸载功能模块。这种技术为应用提供了极高的灵活性和扩展性，使得应用能够根据需要加载新功能或更新现有功能，同时减少了应用的初始下载大小。 Android插件化的关键特点 动态性：插件可以在应用运行时被动态加载和替换，无需重新安装或更新整个应用。 模块化：应用的不同功能可以被封装成独立的模块（插件），便于单独开发和管理。 减小体积：通过插件化，可以减少应用的初始下载大小，用户可以根据需要下载额外的功能模块。 更新灵活：可以单独更新某个功能模块而不影响整个应用，提高了更新的灵活性和效率。 实现机制Android插件化的实现通常涉及到以下几个关键技术点： 类加载器（ClassLoader）：利用Android的ClassLoader机制动态加载插件中的类。通过自定义ClassLoader实现类的加载，避免了插件和宿主应用之间的类冲突。 资源管理：动态加载插件中的资源（如布局、图片、字符串等），并确保宿主应用和插件能够正常使用这些资源。 四大组件激活：动态注册和管理插件中的四大组件（Activity、Service、BroadcastReceiver、ContentProvider），由于这些组件需要在AndroidManifest.xml中静态声明，插件化技术需要绕过这一限制，通过宿主代理或其他机制实现组件的动态激活。 上下文隔离：保证插件运行时的上下文（Context）环境与宿主应用隔离，避免相互干扰。 应用场景 功能模块化：将应用的不同功能模块化，按需加载，减轻应用初始体积。 热更新：修复bug或更新应用的某部分功能而无需更新整个应用。 组件共享：实现跨应用的组件共享和复用。 挑战尽管插件化为Android应用开发带来了诸多好处，但它也引入了一些挑战，包括复杂的实现机制、性能优化、资源管理、安全性问题等。因此，实现一个稳定、高效的插件化框架需要深入理解Android的底层机制和高级特性。 双亲委派机制在Android插件化中的作用在Android插件化中，双亲委派机制扮演着至关重要的角色，主要体现在插件的加载和运行时隔离方面。由于Android基于Java开发，而Java的类加载器采用双亲委派模型，这对Android插件化的实现产生了直接影响。以下是双亲委派机制在Android插件化中作用的几个关键点： 确保类的唯一性双亲委派机制通过优先委托父加载器加载类的方式，确保了JVM中每个类的唯一性。在Android插件化框架中，这一点尤为重要，因为它可以防止插件中的类与宿主应用或其他插件中的类发生冲突。例如，如果插件和宿主应用都使用了同一个库的不同版本，双亲委派机制可以确保在同一个类加载器上下文中，这个库的类只被加载一次，从而避免版本冲突。 提高安全性双亲委派机制通过限制类的加载来源，提高了应用的安全性。在插件化环境中，通过自定义类加载器加载插件，可以控制插件的权限，防止插件访问或修改宿主应用的私有数据。同时，由于双亲委派模型优先使用父加载器加载类，它还可以防止恶意代码通过插件覆盖或篡改系统类库。 实现运行时隔离在Android插件化中，通常需要实现插件之间以及插件与宿主之间的运行时隔离。双亲委派机制允许插件化框架通过自定义类加载器为每个插件创建独立的命名空间，从而实现隔离。这种隔离机制确保了插件可以独立运行，互不干扰，同时也方便了插件的管理和更新。 动态加载插件插件化框架通常需要动态加载和卸载插件，双亲委派机制使得这种动态性成为可能。通过使用自定义的类加载器加载插件，可以在运行时根据需要加载或替换插件，而不需要重新启动应用。这种机制不仅提高了应用的灵活性，也支持了热更新和模块化部署。 绕过双亲委派模型的挑战虽然双亲委派机制有诸多优点，但在实现Android插件化时，有时也需要绕过这种机制。例如，当插件需要使用不同版本的共享库时，可能需要设计复杂的类加载策略来加载正确的类版本，而不是由双亲委派机制自动选择。这就需要插件化框架能够灵活控制类加载过程，可能通过反射或者使用自定义类加载器来实现。 总的来说，双亲委派机制为Android插件化提供了一个强大的基础，使得插件化框架能够高效、安全地管理和加载插件。但同时，它也带来了一定的挑战，需要开发者深入理解其工作原理，才能有效地利用这一机制实现高质量的插件化方案。 双亲委派机制如何使得这种动态性成为可能双亲委派机制本身是一种类加载机制，确保了类加载的有序性和安全性。在讨论它如何使得动态性成为可能时，我们主要关注的是这种机制如何被用于实现和优化Android插件化中的动态加载和动态更新功能。 实现动态加载在Android插件化中，动态加载指的是应用运行时按需加载外部或者附加的代码和资源，而不是在应用安装时就固定下来。双亲委派机制通过以下方式促进这种动态加载： 自定义类加载器：开发者可以通过创建自定义的类加载器来绕过双亲委派机制的一些限制，使得在应用运行时可以加载或替换插件。这些自定义类加载器可以直接或间接继承自ClassLoader类，通过重写findClass方法来实现对插件类的加载。 隔离和独立：自定义类加载器可以为每个插件创建独立的命名空间，这意味着即使多个插件包含相同的类名，它们也能够被独立加载和运行，互不干扰。这种隔离保证了插件之间的动态性和独立性。 支持动态更新动态更新是指在不重启应用的情况下更新应用的部分内容或功能。双亲委派机制在这方面的作用体现在： 类版本的控制：通过自定义类加载器，应用可以动态地卸载旧的插件类和加载新的插件类。这是因为Java虚拟机(JVM)允许同一个类可以被不同的类加载器加载，只要这些类加载器是不同的实例。因此，通过更新类加载器或者使用不同的类加载器实例，可以实现插件的动态更新。 资源的动态加载：除了代码之外，插件化还涉及到资源的动态加载，如图片、布局文件等。自定义类加载器也可以被用来加载这些资源，使得应用能够在运行时不仅更新代码，还可以更新资源。 如何绕过双亲委派机制虽然双亲委派机制的初衷是为了保证安全和一致性，但在插件化场景下，有时需要绕过这一机制以实现更高级的动态性。这通常通过以下方式实现： 反射和Hook技术：通过反射调用或修改Android内部的API行为，或者使用Hook技术，可以在不违背双亲委派原则的前提下，实现对类加载过程的控制和干预。 自定义类加载策略：通过实现自定义的类加载器，并在其中实现特定的加载策略，可以有选择性地加载或替换特定的类或资源，从而实现对双亲委派机制的有效绕过。 总的来说，双亲委派机制在Android插件化中的作用并不直接关联到动态性的实现，而是通过自定义类加载器和策略，以及对这一机制的细致控制和适当绕过，使得动态加载和更新成为可能。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"Android 性能专题 - 启动优化（一）启动耗时","slug":"3 Android/性能优化/Android-性能专题-启动优化","date":"2024-02-20T17:52:23.080Z","updated":"2024-09-03T13:09:48.335Z","comments":true,"path":"2024/02/21/3 Android/性能优化/Android-性能专题-启动优化/","link":"","permalink":"http://example.com/2024/02/21/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"声明：本文是《Android 性能优化入门与实战》——张世欣著 的笔记 为什么要做启动优化App 启动耗时每减少 1s，用户流失率降低 6.9% 启动监控123456789补充知识**App 冷温热启动分辨**：根据进程、Activity 是否已经存在**冷启动**: 进程初始化 -&gt; Activity.onCreate -&gt; Activity.onStart**温启动**: Activity.onCreate -&gt; Activity.onStart**热启动**：Activity.onStart 监控数据设计 需要比较的对照组： 旧版本-新版本 冷启动-温启动-热启动 数据与目的： 获取总耗时，判断新版本更快还是更慢 获取各区间耗时，具体分析耗时到具体区间 App 启动代码顺序1234567891011121314151617181920212223242526272829303132Application 构造函数Application#attachBaseContextContentProvider#onCreateApplication#onCreateActivity#onStartActivity#onResumeView#onDrawActivity#onWindowFocusChanged起点：Application 构造函数终点：方案一：MainActivity 的某个 View 的第一次 onDraw(绘制函数)- 优点：可以拿到第一帧绘制的耗时- 缺点： 1. 执行时第一帧还没绘制完成 2. 需要选择某个核心布局，业务改造的时候容易影响到启动监控逻辑方案二：MainActivity 的 onWindowFocusChanged- 优点：不受业务逻辑的影响- 缺点：被调用的时可能已经不是首帧，会将非首帧的时间算入 获取启动各阶段耗时方法： 手动埋点 编译时 AOP 获取启动性能数据123456分析 App 启动慢的几个重要指标 -&gt; 代码耗时 (判断标准：App 运行的 CPU 时间充足) -&gt; 获取的 CPU 时间不足 (判断标准：App 运行的 CPU 时间不足) -&gt; 线程优先级不够 (判断标准：主线程优先级) -&gt; 被其他线程抢占过多 (判断标准：主线程被抢占次数) -&gt; 内存不足 (判断标准：启动期间 GC 执行次数和耗时) 线下分析Logcat 或者 adb logcat 中查看关键字 Displayed 相关日志 自动执行 App的启动并获取启动耗时：通过 adb shell am start 实现多次自动启动 App 并获取第一次的启动耗时： 1adb shell am start -S -W -R -3 com.antfortune.wealth/com.alipay.mobile.quinox.LauncherActivity am start 是 ActivityManagerService 提供的命令，用来启动 Activity。 - S 即 Stop，表示在每次启动前，先强制停止 App 运行，以实现冷启动。 - W 即 Wait，表示执行后等待启动完成再退出，以统计整个启动的耗时。 - R 即 Repeat， 表示重复执行启动的次数，-R 3 表示重复启动 3 次。 会得到以下信息 12345678Stopping: com.antfortune.wealthStarting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.antfortune.wealth/com.alipay.mobile.quinox.LauncherActivity &#125;Status: okLaunchState: COLDActivity: com.antfortune.wealth/com.alipay.mobile.quinox.LauncherActivityTotalTime: 463WaitTime: 467Complete 上述 TotalTime 就是整个冷启动的耗时，与 Locat 过滤 Displayed 得到的时间基本是一致的。 这两种方式，统计的都是 App 启动到 Activity 首次调用的时间 onWindowFocusChanged 的时间。 如果想统计从 App 启动到数据请求成功后某个布局完全展示出来的耗时，可以在启动终点调用 Activity#reportFullyDrawn 来通知当前 已经完全绘制完成，然后在 Logcat 里过滤 Fully drawn 就可以看到整个流程的耗时。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"Android Glide 三种池子","slug":"3 Android/性能优化/Android-Glide-三种池子","date":"2024-02-10T14:09:52.000Z","updated":"2024-02-11T02:55:18.104Z","comments":true,"path":"2024/02/10/3 Android/性能优化/Android-Glide-三种池子/","link":"","permalink":"http://example.com/2024/02/10/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Glide-%E4%B8%89%E7%A7%8D%E6%B1%A0%E5%AD%90/","excerpt":"","text":"问题1234567Glide 中 LruPoolStrategy 是如何设计的三个子类 SizeConfigStrategy AttributeStrategy SizeStrategy 的区别从精细度管理的角度，对三种池子进行排序如果图片都使用 `ARGB_8888` 应该使用哪个池子 LruPoolStrategy 接口设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 定义了在LRU（最近最少使用）缓存中管理可重用位图池的策略接口。 * 该接口的实现负责定义位图的存储、检索和根据缓存策略及位图的属性（如大小和配置）的逐出机制。 */internal interface LruPoolStrategy &#123; /** * 将位图放入池中。实现应根据其大小、配置或其他属性决定如何将位图添加到池中。 * * @param bitmap 要添加到池中的位图。 */ fun put(bitmap: Bitmap) /** * 尝试从池中检索并返回与指定宽度、高度和配置匹配的位图。如果没有找到合适的位图，此方法返回null。 * * @param width 请求的位图宽度。 * @param height 请求的位图高度。 * @param config 所需位图的Bitmap.Config配置。可以为null。 * @return 匹配请求属性的位图，如果没有合适的位图可用则返回null。 */ operator fun get(width: Int, height: Int, config: Bitmap.Config?): Bitmap? /** * 从池中移除并返回最近最少使用的位图。如果池为空，此方法返回null。 * * @return 最近最少使用的位图，如果池为空则返回null。 */ fun removeLast(): Bitmap? /** * 生成并返回指定位图属性的日志友好型字符串表示，如其大小和配置。 * * @param bitmap 要为其生成日志字符串的位图。 * @return 位图属性的字符串表示，用于日志记录目的。 */ fun logBitmap(bitmap: Bitmap): String? /** * 根据指定的宽度、高度和配置生成并返回一个位图属性的日志友好型字符串表示。 * * @param width 位图的宽度。 * @param height 位图的高度。 * @param config 位图的Bitmap.Config配置。可以为null。 * @return 指定属性的字符串表示，用于日志记录目的。 */ fun logBitmap(width: Int, height: Int, config: Bitmap.Config?): String? /** * 返回指定位图的大小（以字节为单位）。实现应根据位图的尺寸和配置计算大小。 * * @param bitmap 要计算大小的位图。 * @return 位图的字节大小。 */ fun getSize(bitmap: Bitmap): Int&#125; SizeConfigStrategySizeConfigStrategy 是一个实现了 LruPoolStrategy 接口的类，用于管理和重用 Bitmap 对象，其核心目标是通过控制 Bitmap 对象的尺寸和配置来优化内存使用。 这个策略通过将 Bitmap 对象分类存储在一个组织良好的结构中，并在需要时提供快速访问，以减少内存分配和回收的开销。下面是对这个类的关键部分的详细解析： 核心数据结构和方法 ARGB_8888_IN_CONFIGS RGA_F16_IN_CONFIGS RGB_565_IN_CONFIGS ARGB_4444_IN_CONFIGS ALPHA_8_IN_CONFIGS这些数组定义了在不同 Android 版本下，根据请求的 Bitmap.Config 所能接受的配置类型。例如，如果请求的是 ARGB_8888，那么可能接受的配置就包括了 ARGB_8888 和 RGBA_F16（在支持的 Android 版本上）。 keyPool:KeyPool 实例，用于重用 Key 对象。每个 Key 对象代表一个 Bitmap 的尺寸和配置，这样可以减少内存分配。 groupedMap:GroupedLinkedMap&lt;Key?, Bitmap&gt; 实例，用于根据 Key 存储和检索 Bitmap 对象。这种结构支持快速查找、插入和删除操作。 sortedSizes:NavigableMap&lt;Int, Int&gt; 的映射，用于跟踪每种配置下不同大小的 Bitmap 数量。这对于找到最匹配的 Bitmap 尺寸非常有用。 方法 put(bitmap: Bitmap):将 Bitmap 添加到池中。这个方法计算 Bitmap 的字节大小，创建或获取一个对应的 Key，并更新 groupedMap 和 sortedSizes。 get(width: Int, height: Int, config: Bitmap.Config?):尝试根据提供的宽度、高度和配置从池中获取一个最匹配的 Bitmap。这涉及到查找一个尺寸合适、配置兼容的 Bitmap，如果找到，就对其进行重新配置并返回。 removeLast():移除并返回池中最后一个 Bitmap，这通常是最近最少使用的一个。这个方法还会更新 sortedSizes 以反映 变化。 logBitmap(bitmap: Bitmap) 和 logBitmap(width: Int, height: Int, config: Bitmap.Config?):生成表示 Bitmap 尺寸和配置的字符串，用于日志记录和调试。 内部类 KeyPool 和 Key:这些类支持 Bitmap 尺寸和配置的高效存储和检索。KeyPool 用于管理 Key 对象的池，以减少创建新对象的需要。Key 对象表示一个 Bitmap 的尺寸和配置，用作 groupedMap 中的键。 整体设计思路SizeConfigStrategy 的设计旨在通过细致管理 Bitmap 对象的存储和重用来优化内存使用。它通过精确匹配请求的 Bitmap 尺寸和配置，尽量减少创建新 Bitmap 对象的需要，从而降低了内存压力和提高了性能。这个策略特别适用于图片密集型的应用，比如图片浏览器或社交媒体应用，其中频繁地加载和显示图片。 AttributeStrategy这段代码定义了一个名为 AttributeStrategy 的内部类，实现了 LruPoolStrategy 接口，用于管理位图（Bitmap）的缓存策略。这个策略通过位图的宽度、高度和配置（Bitmap.Config）来唯一标识和管理位图。下面是对这个类的主要组成部分和逻辑的解析： 类的主要组成部分 KeyPool 类：一个用于管理 Key 对象池的内部类。它通过重写 create() 方法来创建新的 Key 对象，并提供了一个获取 Key 的方法，该方法接受位图的宽度、高度和配置作为参数，用于初始化 Key。 Key 类：一个内部类，实现了 Poolable 接口。每个 Key 对象包含位图的宽度、高度和配置属性。Key 类提供了 init 方法来设置这些属性，equals 和 hashCode 方法被重写以确保 Key 对象可以根据其宽度、高度和配置被唯一地标识和比较。 groupedMap：一个 GroupedLinkedMap 对象，用于根据 Key（位图的宽度、高度和配置）分组存储和管理位图。 类的主要方法 put(bitmap: Bitmap)：将位图添加到缓存中。首先通过 keyPool 获取与位图尺寸和配置对应的 Key，然后将位图和 Key 添加到 groupedMap 中。 get(width: Int, height: Int, config: Bitmap.Config?)：尝试获取一个符合指定尺寸和配置的位图。首先通过 keyPool 获取与指定尺寸和配置对应的 Key，然后从 groupedMap 中查找和返回相应的位图。 removeLast()：移除并返回最近最少使用的位图。这是通过从 groupedMap 中移除最后一个位图来实现的。 logBitmap(bitmap: Bitmap) 和 logBitmap(width: Int, height: Int, config: Bitmap.Config?)：用于生成表示位图尺寸和配置的日志字符串。 getSize(bitmap: Bitmap)：返回位图占用的字节大小。 特点和用途AttributeStrategy 通过精确地考虑位图的尺寸和配置来管理位图缓存，使其能够更有效地利用内存并提高缓存的效率。通过使用对象池来管理 Key 对象，还可以减少内存分配和垃圾回收的压力。这种策略特别适用于需要存储和管理多种尺寸和配置位图的应用场景。 SizeStrategy这段代码是一个用于管理位图（Bitmap）缓存策略的内部类 SizeStrategy，它实现了 LruPoolStrategy 接口。这个策略的核心是通过位图大小来管理和回收位图资源，以优化内存使用。下面是对这个类和它的主要组成部分的分析： 成员变量介绍： keyPool: 一个 KeyPool 对象，用于管理 Key 对象的池。每个 Key 对象都与一个特定大小的位图相关联。 groupedMap: 一个 GroupedLinkedMap&lt;Key, Bitmap&gt; 对象，用于根据 Key 分组存储 Bitmap 对象。这允许快速查找和回收特定大小的位图。 sortedSizes: 一个 NavigableMap&lt;Int?, Int&gt; 对象，存储每个大小的位图数量。这是一个 PrettyPrintTreeMap，可能是为了便于调试和打印。 方法解析： put(bitmap: Bitmap): 将一个位图添加到缓存中。它计算位图的大小，获取或创建相应大小的 Key，将位图和 Key 添加到 groupedMap 中，并更新 sortedSizes 中对应大小的计数。 get(width: Int, height: Int, config: Bitmap.Config?): 尝试获取一个符合指定宽度、高度和配置的位图。它计算所需位图的大小，查找是否有足够大的可用位图，如果有，则从 groupedMap 中取出并返回该位图。 removeLast(): 移除并返回最近最少使用（LRU）的位图。这是通过从 groupedMap 中移除最后一个位图来实现的，并更新 sortedSizes 中的计数。 decrementBitmapOfSize(size: Int?): 减少特定大小的位图数量。如果该大小的位图只有一个，则从 sortedSizes 中移除该大小；否则，减少其计数。 辅助类： KeyPool: 用于管理 Key 对象池的类。它重写了 create() 方法来生成新的 Key 对象，并提供了一个重载的 get(size: Int) 方法来获取或创建一个初始化了特定大小的 Key。 Key: 实现了 Poolable 接口的类，表示与位图大小相关联的键。包含一个 size 属性和 init(size: Int) 方法来设置键的大小。重写了 equals() 和 hashCode() 方法以支持正确的键比较和哈希操作。 常量和辅助方法： MAX_SIZE_MULTIPLE: 一个常量，定义了在查找时可以接受的最大位图大小倍数。 getBitmapString(bitmap: Bitmap) 和 getBitmapString(size: Int): 辅助方法，用于生成表示位图大小的字符串。 这个类的设计目的是提高位图缓存的效率和灵活性，通过精细地管理不同大小的位图来优化内存使用。通过维护一个有序的大小映射和一个根据大小分组的位图映射，它可以快速地存取和回收位图资源。 SizeConfigStrategy、AttributeStrategy、和SizeStrategy是Glide图像加载库用于位图缓存管理的三种不同策略，它们在位图的存储、查找和回收方式上各有特点。这些策略优化了内存使用，并改善了图像加载的性能。以下是它们的区别和各自适用的场景： 适用场景SizeConfigStrategy特点：SizeConfigStrategy使用位图的大小（以字节为单位）和Bitmap.Config配置作为键来管理缓存。这种方法允许区分具有相同像素大小但不同像素配置的位图，如ARGB_8888和RGB_565。 适用场景：这种策略适用于需要根据位图的内存大小和配置精细管理缓存的应用。例如，如果应用中同时使用了不同配置的位图（以优化显示质量和内存使用），SizeConfigStrategy能有效地区分和管理这些位图。 AttributeStrategy特点：AttributeStrategy基于位图的宽度、高度和配置（Bitmap.Config）来识别和管理位图。这种方法提供了对缓存的精确控制，允许缓存系统区分尺寸相同但配置不同的位图。 适用场景：当应用需要在相同的尺寸下缓存不同配置的位图，且这些配置对位图的使用和性能有明显影响时，AttributeStrategy非常适用。它确保了即使是细微的配置差异也能被正确管理，适合对图像质量和性能有高要求的应用。 SizeStrategy特点：SizeStrategy仅基于位图占用的内存大小来管理缓存，不考虑位图的配置或尺寸。这种策略通过一种更简单的方式来回收和重用位图内存，忽略了位图的其他属性。 适用场景：对于那些不需要考虑位图配置差异，主要关注于减少内存占用和简化缓存管理的应用，SizeStrategy是一个理想的选择。它适合内存使用更为紧张，或者位图配置较为统一的场景。 总结SizeConfigStrategy 和 AttributeStrategy 提供了更细粒度的缓存管理，能够根据位图的具体特征（如配置和尺寸）进行优化，适合需要高度优化内存使用和图像质量的场景。 SizeStrategy 通过一个更简单的方法来管理缓存，适用于对缓存管理的要求相对简单，更关注于减少内存占用的应用。 选择哪种策略取决于应用的具体需求，包括对内存管理的敏感度、图像的多样性以及性能的要求。 三种池子的特点SizeConfigStrategy 内存大小：使用位图的内存大小作为缓存的关键因素之一。 配置敏感：考虑了Bitmap.Config，区分了相同大小但配置不同的位图。 精细管理：允许对缓存的位图进行更精细的管理，适用于内存和显示质量都很重要的场景。 AttributeStrategy 尺寸配置：基于位图的宽度、高度和Bitmap.Config来管理位图。 高度区分：能够精确区分尺寸相同但配置不同的位图。 细节控制：提供对位图缓存的细节控制，适用于对图像显示细节有高要求的应用。 SizeStrategy 简化内存：仅基于位图占用的内存大小来管理缓存，简化了缓存管理。 统一处理：不区分位图的尺寸或配置，统一处理所有位图。 内存优化：优先考虑内存使用效率，适用于内存敏感且配置统一的应用场景。 这些关键字概括了每种策略的核心特点和适用场景，有助于在实际开发中根据应用的需求选择最合适的位图缓存管理策略。 附件SizeConfigStrategy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197class SizeConfigStrategy : LruPoolStrategy &#123; companion object &#123; private const val MAX_SIZE_MULTIPLE = 8 private val ARGB_8888_IN_CONFIGS: Array&lt;Bitmap.Config?&gt; init &#123; var result = arrayOf( Bitmap.Config.ARGB_8888, // The value returned by Bitmaps with the hidden Bitmap config. null ) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; result = result.copyOf(result.size + 1) result[result.size - 1] = Bitmap.Config.RGBA_F16 &#125; ARGB_8888_IN_CONFIGS = result &#125; private val RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS private val RGB_565_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.RGB_565) private val ARGB_4444_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.ARGB_4444) private val ALPHA_8_IN_CONFIGS = arrayOf&lt;Bitmap.Config?&gt;(Bitmap.Config.ALPHA_8) fun getBitmapString(size: Int, config: Bitmap.Config?): String &#123; return &quot;[$size]($config)&quot; &#125; private fun getInConfigs(requested: Bitmap.Config?): Array&lt;Bitmap.Config?&gt; &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; if (Bitmap.Config.RGBA_F16 == requested) &#123; // NOPMD - Avoid short circuiting sdk checks. return RGBA_F16_IN_CONFIGS &#125; &#125; return when (requested) &#123; Bitmap.Config.ARGB_8888 -&gt; ARGB_8888_IN_CONFIGS Bitmap.Config.RGB_565 -&gt; RGB_565_IN_CONFIGS Bitmap.Config.ARGB_4444 -&gt; ARGB_4444_IN_CONFIGS Bitmap.Config.ALPHA_8 -&gt; ALPHA_8_IN_CONFIGS else -&gt; arrayOf(requested) &#125; &#125; &#125; private val keyPool = KeyPool() private val groupedMap = GroupedLinkedMap&lt;Key?, Bitmap&gt;() private val sortedSizes: MutableMap&lt;Bitmap.Config?, NavigableMap&lt;Int, Int&gt;&gt; = EnumMap(Bitmap.Config::class.java) override fun put(bitmap: Bitmap) &#123; val size = getBitmapByteSize(bitmap) val key = keyPool[size, bitmap.config] groupedMap.put(key, bitmap) val sizes = getSizesForConfig(bitmap.config) val current = sizes[key!!.size] sizes[key.size] = if (current == null) 1 else current + 1 &#125; override fun get(width: Int, height: Int, config: Bitmap.Config?): Bitmap? &#123; val size = getBitmapByteSize(width, height, config) val bestKey = findBestKey(size, config) val result = groupedMap[bestKey] if (result != null) &#123; decrementBitmapOfSize(bestKey!!.size, result) result.reconfigure(width, height, config) &#125; return result &#125; private fun findBestKey(size: Int, config: Bitmap.Config?): Key? &#123; var result = keyPool[size, config] for (possibleConfig in getInConfigs(config)) &#123; val sizesForPossibleConfig = getSizesForConfig(possibleConfig) val possibleSize = sizesForPossibleConfig.ceilingKey(size) if (possibleSize != null &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123; if (possibleSize != size || if (possibleConfig == null) config != null else possibleConfig != config ) &#123; keyPool.offer(result) result = keyPool[possibleSize, possibleConfig] &#125; break &#125; &#125; return result &#125; override fun removeLast(): Bitmap? &#123; val removed = groupedMap.removeLast() if (removed != null) &#123; val removedSize = getBitmapByteSize(removed) decrementBitmapOfSize(removedSize, removed) &#125; return removed &#125; private fun decrementBitmapOfSize(size: Int, removed: Bitmap) &#123; val config = removed.config val sizes = getSizesForConfig(config) val current = sizes[size]?: throw NullPointerException( &quot;Tried to decrement empty size&quot; + &quot;, size: &quot; + size + &quot;, removed: &quot; + logBitmap(removed) + &quot;, this: &quot; + this ) if (current == 1) &#123; sizes.remove(size) &#125; else &#123; sizes[size] = current - 1 &#125; &#125; private fun getSizesForConfig(config: Bitmap.Config?): NavigableMap&lt;Int, Int&gt; &#123; var sizes = sortedSizes[config] if (sizes == null) &#123; sizes = TreeMap() sortedSizes[config] = sizes &#125; return sizes &#125; override fun logBitmap(bitmap: Bitmap): String &#123; val size = getBitmapByteSize(bitmap) return getBitmapString(size, bitmap.config) &#125; override fun logBitmap(width: Int, height: Int, config: Bitmap.Config?): String &#123; val size = getBitmapByteSize(width, height, config) return getBitmapString(size, config) &#125; override fun getSize(bitmap: Bitmap): Int &#123; return getBitmapByteSize(bitmap) &#125; override fun toString(): String &#123; val sb = StringBuilder() .append(&quot;SizeConfigStrategy&#123;groupedMap=&quot;) .append(groupedMap) .append(&quot;, sortedSizes=(&quot;) for ((key, value) in sortedSizes) &#123; sb.append(key).append(&#x27;[&#x27;).append(value).append(&quot;], &quot;) &#125; if (sortedSizes.isNotEmpty()) &#123; sb.replace(sb.length - 2, sb.length, &quot;&quot;) &#125; return sb.append(&quot;)&#125;&quot;).toString() &#125; @VisibleForTesting internal class KeyPool : BaseKeyPool&lt;Key?&gt;() &#123; operator fun get(size: Int, config: Bitmap.Config?): Key? &#123; val result = get() result!!.init(size, config) return result &#125; override fun create(): Key &#123; return Key(this) &#125; &#125; @VisibleForTesting internal class Key(private val pool: KeyPool) : Poolable &#123; var size = 0 private var config: Bitmap.Config? = null @VisibleForTesting constructor(pool: KeyPool, size: Int, config: Bitmap.Config?) : this(pool) &#123; init(size, config) &#125; fun init(size: Int, config: Bitmap.Config?) &#123; this.size = size this.config = config &#125; override fun offer() &#123; pool.offer(this) &#125; override fun toString(): String &#123; return getBitmapString(size, config) &#125; override fun equals(other: Any?): Boolean &#123; if (other is Key) &#123; return if (size == other.size &amp;&amp; config == null) other.config == null else config == other.config &#125; return false &#125; override fun hashCode(): Int &#123; var result = size result = 31 * result + if (config != null) config.hashCode() else 0 return result &#125; &#125;&#125; AttributeStategy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.max.hbbitmappool.pool.implimport android.graphics.Bitmapimport androidx.annotation.VisibleForTestingimport com.max.hbbitmappool.utils.getBitmapByteSizeinternal class AttributeStrategy : LruPoolStrategy &#123; private val keyPool = KeyPool() private val groupedMap = GroupedLinkedMap&lt;Key?, Bitmap&gt;() override fun put(bitmap: Bitmap) &#123; val key = keyPool[bitmap.width, bitmap.height, bitmap.config] groupedMap.put(key, bitmap) &#125; override fun get(width: Int, height: Int, config: Bitmap.Config?): Bitmap? &#123; val key = keyPool[width, height, config] return groupedMap[key] &#125; override fun removeLast(): Bitmap? &#123; return groupedMap.removeLast() &#125; override fun logBitmap(bitmap: Bitmap): String &#123; return getBitmapString(bitmap) &#125; override fun logBitmap(width: Int, height: Int, config: Bitmap.Config?): String &#123; return getBitmapString(width, height, config) &#125; override fun getSize(bitmap: Bitmap): Int &#123; return getBitmapByteSize(bitmap) &#125; override fun toString(): String &#123; return &quot;AttributeStrategy:\\n $groupedMap&quot; &#125; @VisibleForTesting internal class KeyPool : BaseKeyPool&lt;Key?&gt;() &#123; operator fun get(width: Int, height: Int, config: Bitmap.Config?): Key? &#123; val result = get() result?.init(width, height, config) return result &#125; override fun create(): Key &#123; return Key(this) &#125; &#125; @VisibleForTesting internal class Key(private val pool: KeyPool) : Poolable &#123; private var width = 0 private var height = 0 private var config: Bitmap.Config? = null fun init(width: Int, height: Int, config: Bitmap.Config?) &#123; this.width = width this.height = height this.config = config &#125; override fun equals(other: Any?): Boolean &#123; if (other is Key) &#123; return width == other.width &amp;&amp; height == other.height &amp;&amp; config == other.config &#125; return false &#125; override fun hashCode(): Int &#123; var result = width result = 31 * result + height result = 31 * result + if (config != null) config.hashCode() else 0 return result &#125; override fun toString(): String &#123; return getBitmapString(width, height, config) &#125; override fun offer() &#123; pool.offer(this) &#125; &#125; companion object &#123; private fun getBitmapString(bitmap: Bitmap): String &#123; return getBitmapString(bitmap.width, bitmap.height, bitmap.config) &#125; fun getBitmapString(width: Int, height: Int, config: Bitmap.Config?): String &#123; return &quot;[&quot; + width + &quot;x&quot; + height + &quot;], &quot; + config &#125; &#125;&#125; SizeStrategy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118internal class SizeStrategy : LruPoolStrategy &#123; private val keyPool = KeyPool() private val groupedMap = GroupedLinkedMap&lt;Key, Bitmap&gt;() private val sortedSizes: NavigableMap&lt;Int?, Int&gt; = PrettyPrintTreeMap() override fun put(bitmap: Bitmap) &#123; val size = getBitmapByteSize(bitmap) val key = keyPool[size] groupedMap.put(key, bitmap) val current = sortedSizes[key.size] sortedSizes[key.size] = if (current == null) 1 else current + 1 &#125; override fun get(width: Int, height: Int, config: Bitmap.Config?): Bitmap? &#123; val size = getBitmapByteSize(width, height, config) var key = keyPool[size] val possibleSize = sortedSizes.ceilingKey(size) if (possibleSize != null &amp;&amp; possibleSize != size &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123; keyPool.offer(key) key = keyPool[possibleSize] &#125; val result = groupedMap[key] if (result != null) &#123; result.reconfigure(width, height, config) decrementBitmapOfSize(possibleSize) &#125; return result &#125; override fun removeLast(): Bitmap? &#123; val removed = groupedMap.removeLast() if (removed != null) &#123; val removedSize = getBitmapByteSize(removed) decrementBitmapOfSize(removedSize) &#125; return removed &#125; private fun decrementBitmapOfSize(size: Int?) &#123; val current = sortedSizes[size] if (current == 1) &#123; sortedSizes.remove(size) &#125; else &#123; sortedSizes[size] = current!! - 1 &#125; &#125; override fun logBitmap(bitmap: Bitmap): String &#123; return getBitmapString(bitmap) &#125; override fun logBitmap(width: Int, height: Int, config: Bitmap.Config?): String &#123; val size = getBitmapByteSize(width, height, config) return getBitmapString(size) &#125; override fun getSize(bitmap: Bitmap): Int &#123; return getBitmapByteSize(bitmap) &#125; override fun toString(): String &#123; return &quot;SizeStrategy:\\n $groupedMap\\n SortedSizes$sortedSizes&quot; &#125; // Non-final for mocking. @VisibleForTesting internal class KeyPool : BaseKeyPool&lt;Key?&gt;() &#123; operator fun get(size: Int): Key &#123; val result = super.get()!! result.init(size) return result &#125; override fun create(): Key &#123; return Key(this) &#125; &#125; @VisibleForTesting internal class Key(private val pool: KeyPool) : Poolable &#123; var size = 0 fun init(size: Int) &#123; this.size = size &#125; override fun equals(o: Any?): Boolean &#123; if (o is Key) &#123; return size == o.size &#125; return false &#125; override fun hashCode(): Int &#123; return size &#125; // PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807 override fun toString(): String &#123; return getBitmapString(size) &#125; override fun offer() &#123; pool.offer(this) &#125; &#125; companion object &#123; private const val MAX_SIZE_MULTIPLE = 8 private fun getBitmapString(bitmap: Bitmap): String &#123; val size = getBitmapByteSize(bitmap) return getBitmapString(size) &#125; fun getBitmapString(size: Int): String &#123; return &quot;[$size]&quot; &#125; &#125;&#125; 三种池子精细化管理排序 AttributeStrategy SizeConfigStrategy SizeStrategy 1. AttributeStrategy 精细化等级：最高 原因：AttributeStrategy基于位图的宽度、高度和Bitmap.Config配置来管理位图，提供了最细致的控制。这允许它区分具有相同像素数量但不同尺寸或配置的位图，实现了对位图缓存的高度精细化管理。 2. SizeConfigStrategy 精细化等级：中等 原因：SizeConfigStrategy结合了位图的内存大小和配置（如ARGB_8888、RGB_565等）来管理位图。虽然它不如AttributeStrategy能够精确到位图的具体尺寸，但通过考虑配置信息，它在位图的管理上提供了比仅基于大小更精细的控制。 3. SizeStrategy 精细化等级：最低 原因：SizeStrategy仅基于位图占用的内存大小来管理位图，完全忽略了位图的尺寸和配置信息。这种策略提供了最简单的管理方式，适合于那些内存使用效率是主要关注点、对位图的具体属性（如尺寸和配置）关注较少的场景。 总结来说，如果需要对缓存中的位图进行非常精细化的管理，优先选择AttributeStrategy；如果希望在精细化管理和简化逻辑之间取得平衡，SizeConfigStrategy是一个好的选择；而如果主要关注简化缓存管理和优化内存使用，SizeStrategy将是最合适的策略。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"从零开始写一个 ARouter - router-annotation 路由注解模块","slug":"3 Android/ARouter/01-ARouter","date":"2023-09-09T17:05:06.000Z","updated":"2024-03-22T13:21:39.286Z","comments":true,"path":"2023/09/10/3 Android/ARouter/01-ARouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/01-ARouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类 router-annotation 路由注解模块annotation 存放各种注解类的包Autowired自动注入的注解 123456789101112131415161718192021package com.alibaba.android.arouter.facade.annotation/** * Annotation for field, which need autowired. * 用于需要自动注入的字段的注解。 * * @author zhilong [Contact me.](mailto:zhilong.lzl@alibaba-inc.com) * @version 1.0 * @since 2017/2/20 下午4:26 */@Target(AnnotationTarget.FIELD) // 表示该注解只能用于字段上@kotlin.annotation.Retention(AnnotationRetention.BINARY) // 表示该注解的生命周期为编译期annotation class Autowired( // Mark param&#x27;s name or service name. // 标记参数的名称或服务名称 val name: String = &quot;&quot;, // If required, app will be crash when value is null. // Primitive type wont be check! // 如果设置为true，在数值为null时应用程序将崩溃。不会检查原始类型！ val required: Boolean = false, // Description of the field // 字段的描述信息 val desc: String = &quot;&quot;) 标记需要注入的字段：在你的类中，标记需要进行自动注入的字段。使用 @Autowired 注解，例如： 12345678910import com.alibaba.android.arouter.facade.annotation.Autowired;// ...public class MyClass &#123; @Autowired private MyDependency myDependency; // ...&#125; 在这个示例中，myDependency 字段被标记为需要自动注入的依赖对象。 假设你有两个相同类型的依赖对象 MyDependency，但它们在功能上略有不同，你需要指定要注入哪一个。 123456789101112javaCopy codeimport com.alibaba.android.arouter.facade.annotation.Autowired;public class MyClass &#123; @Autowired(name = &quot;dependencyA&quot;) private MyDependency dependencyA; @Autowired(name = &quot;dependencyB&quot;) private MyDependency dependencyB; // ...&#125; Interceptor12345678910111213141516171819202122package com.alibaba.android.arouter.facade.annotation/** * 标记拦截器以拦截路由。 * 注意：此注解仅可用于标记#&#123;IInterceptor&#125;的实现！！！ * * @author Alex [联系我。](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 16/8/23 14:03 */@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS) // 表示该注解只能用于类上@kotlin.annotation.Retention(AnnotationRetention.BINARY) // 表示该注解的生命周期为编译期annotation class Interceptor( /** * 拦截器的优先级，ARouter将按优先级执行它们。 */ val priority: Int, /** * 拦截器的名称，可能用于生成javadoc。 */ val name: String = &quot;Default&quot;) 要使用 @Interceptor 注解，你需要将其标记在实现了 IInterceptor 接口的类上，以定义一个拦截器。然后，你可以使用这个拦截器来拦截路由操作。下面是使用 @Interceptor 注解的一般步骤： 创建一个实现了 IInterceptor 接口的类，该类将用作拦截器。确保类实现了接口中的 process 方法，该方法定义了拦截器的逻辑。 123456789101112131415kotlinCopy codeimport com.alibaba.android.arouter.facade.annotation.Interceptorimport com.alibaba.android.arouter.facade.template.IInterceptorimport com.alibaba.android.arouter.facade.callback.InterceptorCallback@Interceptor(priority = 1, name = &quot;ExampleInterceptor&quot;)class ExampleInterceptor : IInterceptor &#123; override fun process(postcard: Postcard?, callback: InterceptorCallback?) &#123; // 在这里编写拦截器的逻辑 // 可以在进入路由之前或之后执行一些操作 // 最后，调用 callback.onContinue(postcard) 继续路由操作，或者 callback.onInterrupt(exception) 中断路由操作 callback?.onContinue(postcard) &#125;&#125; Param(废弃)1234567891011121314151617181920212223package com.alibaba.android.arouter.facade.annotation/** * 用于标记页面参数的注解。 * 此注解已被弃用，请使用 &#x27;Autowired&#x27; 代替！ * * @author Alex [联系我。](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 2016/11/22 18:01 */@Target(AnnotationTarget.FIELD) // 表示该注解只能用于字段上@kotlin.annotation.Retention(AnnotationRetention.BINARY) // 表示该注解的生命周期为编译期@Deprecated(&quot;&quot;) // 表示该注解已被弃用annotation class Param( /** * 字段名称 */ val name: String = &quot;&quot;, /** * 字段的描述信息 */ val desc: String = &quot;No desc.&quot;) 既已废弃，不浪费时间 Route12345678910111213141516171819202122232425262728293031323334package com.alibaba.android.arouter.facade.annotation/** * 标记页面可由路由器路由。 * * @author Alex [联系我。](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 16/8/15 下午9:29 */@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS) // 表示该注解只能用于类上@kotlin.annotation.Retention(AnnotationRetention.BINARY) // 表示该注解的生命周期为编译期annotation class Route( /** * 路由的路径 */ val path: String, /** * 用于合并路由，组名必须使用常见单词!!! */ val group: String = &quot;&quot;, /** * 路由的名称，用于生成javadoc。 */ val name: String = &quot;&quot;, /** * 额外的数据，可以由用户设置。 * 注意：您应该使用整数数值表示开关，通过位进行标记。例如：10001010101010 */ val extras: Int = Int.MIN_VALUE, /** * 路由的优先级。 */ val priority: Int = -1) 这个类定义了一个用于标记页面可由路由器路由的注解 @Route。该注解包含了五个元素，分别表示路由的路径、组名、名称、额外数据和优先级。 创建一个页面类，并在该类上添加 @Route 注解，以标记这个页面可以被路由器路由。 1234567import com.alibaba.android.arouter.facade.annotation.Route// 使用 @Route 注解标记这个页面@Route(path = &quot;/example/activity&quot;)class ExampleActivity : AppCompatActivity() &#123; // 页面的代码...&#125; 在上面的示例中，我们创建了一个名为 ExampleActivity 的页面类，并使用 @Route 注解标记了这个页面的路由路径为 &quot;/example/activity&quot;。 enums 包含各种枚举类型的包RouteType123456789101112131415161718192021222324252627282930313233343536373839404142package com.alibaba.android.arouter.facade.enums/** * 路由类型的枚举。 * * @author Alex [联系我。](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 16/8/23 22:33 */enum class RouteType(// 未知类型的路由 var id: Int, var className: String) &#123; ACTIVITY(0, &quot;android.app.Activity&quot;), // Activity类型的路由 SERVICE(1, &quot;android.app.Service&quot;), // Service类型的路由 PROVIDER(2, &quot;com.alibaba.android.arouter.facade.template.IProvider&quot;), // Provider类型的路由 CONTENT_PROVIDER(-1, &quot;android.app.ContentProvider&quot;), // ContentProvider类型的路由 BOARDCAST(-1, &quot;&quot;), // Broadcast类型的路由 METHOD(-1, &quot;&quot;), // Method类型的路由 FRAGMENT(-1, &quot;android.app.Fragment&quot;), // Fragment类型的路由 UNKNOWN(-1, &quot;Unknown route type&quot;); fun setId(id: Int): RouteType &#123; this.id = id return this &#125; fun setClassName(className: String): RouteType &#123; this.className = className return this &#125; companion object &#123; fun parse(name: String): RouteType &#123; for (routeType in values()) &#123; if (routeType.className == name) &#123; return routeType &#125; &#125; return UNKNOWN &#125; &#125;&#125; TypeKind1234567891011121314151617181920212223242526package com.alibaba.android.arouter.facade.enums/** * 字段类型的种类枚举。 * * @author Alex [联系我。](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 2017-03-16 19:13:38 */enum class TypeKind &#123; // 基本类型 BOOLEAN, // 布尔类型 BYTE, // 字节类型 SHORT, // 短整型 INT, // 整型 LONG, // 长整型 CHAR, // 字符类型 FLOAT, // 单精度浮点型 DOUBLE, // 双精度浮点型 // 其他类型 STRING, // 字符串类型 SERIALIZABLE, // 可序列化类型 PARCELABLE, // Parcelable类型 OBJECT // 对象类型&#125; model 包含模型类的包RouteMeta123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243package com.alibaba.android.arouter.facade.modelimport com.alibaba.android.arouter.facade.annotation.Autowiredimport com.alibaba.android.arouter.facade.annotation.Routeimport com.miao.router.RouteType/** * 包含基本路由信息的类。 * * @author Alex [联系我。](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 16/8/24 09:45 */class RouteMeta &#123; var type: RouteType? = null // 路由类型 private set private var rawType: javax.lang.model.element.Element? = null // 路由的原始类型 var destination : Class&lt;*&gt;? = null // 目标类 private set var path : String? = null // 路由路径 private set var group: String? = null // 路由分组 private set var priority = -1 // 优先级，数值越小优先级越高 private set var extra = 0// 额外数据 private set var paramsType: Map&lt;String?, Int?&gt;? = null // 参数类型 private set var name: String? = null var injectConfig: Map&lt;String, Autowired&gt;? = null // 缓存注入配置信息 constructor() &#123;&#125; /** * Type * * @param route 路由 * @param destination 目标类 * @param type 类型 */ constructor( route: Route, destination: Class&lt;*&gt;?, type: RouteType? ) : this( type, null, destination, route.name(), route.path(), route.group(), null, route.priority(), route.extras() ) &#123; &#125; /** * Type * * @param route 路由 * @param rawType 原始类型 * @param type 类型 * @param paramsType 参数类型 */ constructor( route: Route, rawType: javax.lang.model.element.Element?, type: RouteType?, paramsType: Map&lt;String?, Int?&gt;? ) : this( type, rawType, null, route.name(), route.path(), route.group(), paramsType, route.priority(), route.extras() ) &#123; &#125; /** * Type * * @param type 类型 * @param rawType 原始类型 * @param destination 目标类 * @param path 路径 * @param group 分组 * @param paramsType 参数类型 * @param priority 优先级 * @param extra 额外数据 */ constructor( type: RouteType?, rawType: javax.lang.model.element.Element?, destination: Class&lt;*&gt;?, name: String?, path: String?, group: String?, paramsType: Map&lt;String?, Int?&gt;?, priority: Int, extra: Int ) &#123; this.type = type this.name = name this.destination = destination this.rawType = rawType this.path = path this.group = group this.paramsType = paramsType this.priority = priority this.extra = extra &#125; fun setParamsType(paramsType: Map&lt;String?, Int?&gt;?): RouteMeta &#123; this.paramsType = paramsType return this &#125; fun getRawType(): javax.lang.model.element.Element? &#123; return rawType &#125; fun setRawType(rawType: javax.lang.model.element.Element?): RouteMeta &#123; this.rawType = rawType return this &#125; fun setType(type: RouteType?): RouteMeta &#123; this.type = type return this &#125; fun setDestination(destination: Class&lt;*&gt;?): RouteMeta &#123; this.destination = destination return this &#125; fun setPath(path: String?): RouteMeta &#123; this.path = path return this &#125; fun setGroup(group: String?): RouteMeta &#123; this.group = group return this &#125; fun setPriority(priority: Int): RouteMeta &#123; this.priority = priority return this &#125; fun setExtra(extra: Int): RouteMeta &#123; this.extra = extra return this &#125; override fun toString(): String &#123; return &quot;RouteMeta&#123;&quot; + &quot;type=&quot; + type + &quot;, rawType=&quot; + rawType + &quot;, destination=&quot; + destination + &quot;, path=&#x27;&quot; + path + &#x27;\\&#x27;&#x27; + &quot;, group=&#x27;&quot; + group + &#x27;\\&#x27;&#x27; + &quot;, priority=&quot; + priority + &quot;, extra=&quot; + extra + &quot;, paramsType=&quot; + paramsType + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27; &#125; companion object &#123; /** * For versions of &#x27;compiler&#x27; less than 1.0.7, contain 1.0.7 * * @param type 类型 * @param destination 目标类 * @param path 路径 * @param group 分组 * @param priority 优先级 * @param extra 额外数据 * @return this */ fun build( type: RouteType?, destination: Class&lt;*&gt;?, path: String?, group: String?, priority: Int, extra: Int ): RouteMeta &#123; return RouteMeta(type, null, destination, null, path, group, null, priority, extra) &#125; /** * For versions of &#x27;compiler&#x27; greater than 1.0.7 * * @param type 类型 * @param destination 目标类 * @param path 路径 * @param group 分组 * @param paramsType 参数类型 * @param priority 优先级 * @param extra 额外数据 * @return this */ fun build( type: RouteType?, destination: Class&lt;*&gt;?, path: String?, group: String?, paramsType: Map&lt;String?, Int?&gt;?, priority: Int, extra: Int ): RouteMeta &#123; return RouteMeta( type, null, destination, null, path, group, paramsType, priority, extra ) &#125; &#125;&#125; private RouteType type：表示路由的类型，可能是普通路由、自动注入、或者其他类型。private Element rawType：表示路由的原始类型的元素。private Class&lt;?&gt; destination：表示目标类，即路由到哪个页面。private String path：表示路由的路径，用于唯一标识一个路由。private String group：表示路由的分组，通常用于组织路由。private int priority：表示路由的优先级，数值越小表示优先级越高。private int extra：表示额外的数据，可以用于传递一些标记或开关。private Map&lt;String, Integer&gt; paramsType：表示参数类型的映射。private String name：表示路由的名称。 RouteMeta 是 Route 原子信息与其构建类 TypeWrapper12345678910111213141516171819202122232425package com.alibaba.android.arouter.facade.modelimport java.lang.reflect.ParameterizedTypeimport java.lang.reflect.Type/** * 用于获取目标对象的类型。 * * @param &lt;T&gt; 泛型类型 * @since 17/10/26 11:56:22&lt;/T&gt; */class TypeWrapper&lt;T&gt; protected constructor() &#123; /** * 获取目标对象的类型。 * * @return 目标对象的类型 */ val type: Type // 存储目标对象的类型信息 init &#123; val superClass = javaClass.genericSuperclass type = (superClass as ParameterizedType).actualTypeArguments[0] // 获取泛型类型参数 &#125;&#125; 通过 Java 反射获取当前类的父类，然后从父类中获取泛型参数的类型信息，并将其赋值给 type 字段。这样，这个类就能够存储目标对象的泛型类型信息。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - base 基础功能 与 core 核心功能","slug":"3 Android/ARouter/02-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/02-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/02-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类 arouter-api ARouter框架的API模块base 基础功能相关的包UniqueKeyTreeMap123456789101112131415161718192021package com.alibaba.android.arouter.baseimport java.util.*/** * TreeMap with unique key. * * @author zhilong [Contact me.](mailto:zhilong.lzl@alibaba-inc.com) * @version 1.0 * @since 2017/2/22 下午5:01 */class UniqueKeyTreeMap&lt;K, V&gt;(private val tipText: String) : TreeMap&lt;K, V&gt;() &#123; override fun put(key: K, value: V): V? &#123; return if (containsKey(key)) &#123; throw RuntimeException(String.format(tipText, key)) &#125; else &#123; super.put(key, value) &#125; &#125;&#125; core 核心功能相关的包AutowiredLifecyleCallback(废弃)123456789101112131415161718192021222324252627282930package com.alibaba.android.arouter.coreimport android.annotation.TargetApiimport android.app.Activityimport android.app.Application.ActivityLifecycleCallbacksimport android.os.Buildimport android.os.Bundleimport com.alibaba.android.arouter.launcher.ARouter/** * LifecycleCallback for autowired. * * @author zhilong [Contact me.](mailto:zhilong.lzl@alibaba-inc.com) * @version 1.0 * @since 2017/2/21 上午11:28 */@Deprecated(&quot;&quot;)@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)class AutowiredLifecycleCallback : ActivityLifecycleCallbacks &#123; override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) &#123; ARouter.getInstance().inject(activity) &#125; override fun onActivityStarted(activity: Activity) &#123;&#125; override fun onActivityResumed(activity: Activity) &#123;&#125; override fun onActivityPaused(activity: Activity) &#123;&#125; override fun onActivityStopped(activity: Activity) &#123;&#125; override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) &#123;&#125; override fun onActivityDestroyed(activity: Activity) &#123;&#125;&#125; 已经废弃，不废话 AutowiredServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.alibaba.android.arouter.coreimport android.content.Contextimport android.util.LruCacheimport com.alibaba.android.arouter.facade.annotation.Routeimport com.alibaba.android.arouter.facade.service.AutowiredServiceimport com.alibaba.android.arouter.facade.template.ISyringeimport com.alibaba.android.arouter.utils.Consts.SUFFIX_AUTOWIRED/** * 自动注入服务的实现。 * * 作者: zhilong [联系我](mailto:zhilong.lzl@alibaba-inc.com) * 版本: 1.0 * 创建日期: 2017年2月28日 下午6:08 */@Route(path = &quot;/arouter/service/autowired&quot;)class AutowiredServiceImpl : AutowiredService &#123; private var classCache: LruCache&lt;String, ISyringe&gt;? = null private var blackList: MutableList&lt;String&gt;? = null /** * 初始化方法。 * * @param context 上下文 */ fun init(context: Context?) &#123; classCache = LruCache&lt;String, ISyringe&gt;(50) blackList = ArrayList() &#125; /** * 自动注入方法。 * * @param instance 要进行注入的实例 */ fun autowire(instance: Any) &#123; doInject(instance, null) &#125; /** * 递归注入方法。 * * @param instance 调用该方法的实例 * @param parent 父类的Class */ private fun doInject(instance: Any, parent: Class&lt;*&gt;?) &#123; // 如果提供了父类的 Class 对象，则使用父类的 Class；否则，使用实例的 Class val clazz = parent ?: instance.javaClass // 获取适用于当前类的注入器实例 val syringe: ISyringe? = getSyringe(clazz) // 如果存在适用的注入器实例 if (null != syringe) &#123; // 使用注入器进行注入 syringe.inject(instance) &#125; // 获取当前类的父类的 Class 对象 val superClazz = clazz.superclass // 如果存在父类，并且父类不是 Android 框架类 if (null != superClazz &amp;&amp; !superClazz.name.startsWith(&quot;android&quot;)) &#123; // 递归调用 doInject 方法，继续为父类进行自动注入 doInject(instance, superClazz) &#125; &#125; /** * 获取注入器实例。 * * @param clazz 类的Class * @return 注入器实例 */ private fun getSyringe(clazz: Class&lt;*&gt;): ISyringe? &#123; // 获取类的完整名称 val className = clazz.name try &#123; // 检查类名是否在黑名单中，如果不在，则尝试获取对应的注入器 if (!blackList!!.contains(className)) &#123; // 从缓存中尝试获取注入器实例 var syringeHelper: ISyringe? = classCache!![className] // 如果缓存中没有该注入器实例 if (null == syringeHelper) &#123; // 动态加载并创建注入器实例 syringeHelper = Class.forName( clazz.name + SUFFIX_AUTOWIRED ).getConstructor() .newInstance() as ISyringe // 将创建的注入器实例缓存起来，以便下次使用 classCache!!.put(className, syringeHelper) &#125; // 返回获取到的注入器实例 return syringeHelper &#125; &#125; catch (e: Exception) &#123; // 如果在获取注入器的过程中发生异常，将类名添加到黑名单中，表示该实例无需自动注入 blackList!!.add(className) &#125; // 如果无法获取注入器实例，返回 null return null &#125;&#125; doInject 方法用于自动注入依赖到给定的实例（instance）中。 InstrumentationHook(废弃)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.alibaba.android.arouter.coreimport android.app.Activityimport android.app.Instrumentationimport android.content.Intentimport com.alibaba.android.arouter.launcher.ARouterimport com.alibaba.android.arouter.utils.Constsimport com.alibaba.android.arouter.utils.TextUtils/** * 使用 ARouter.getInstance().inject(this) 来进行注入！ * * Hook Instrumentation，为 Activity 的字段注入值。 * 仅支持普通 Activity，不包括单元测试。 * * 作者：Alex [联系我](mailto:zhilong.liu@aliyun.com) * 版本：1.0 * 创建日期：2016年11月24日 16:42 */@Deprecated(&quot;&quot;)class InstrumentationHook : Instrumentation() &#123; /** * Hook Instrumentation 的 newActivity 方法，进行注入。 * * 执行进程的 [Activity] 对象的实例化。默认实现提供正常的系统行为。 * * @param cl 用于实例化对象的类加载器。 * @param className 实现 Activity 对象的类的名称。 * @param intent 指定要实例化的活动类的 Intent 对象。 * @return 新创建的 Activity 对象。 */ @Throws( InstantiationException::class, IllegalAccessException::class, ClassNotFoundException::class ) override fun newActivity( cl: ClassLoader, className: String, intent: Intent ): Activity &#123;// return (Activity)cl.loadClass(className).newInstance(); // 使用类加载器加载目标 Activity 类的定义 val targetActivity = cl.loadClass(className) // 创建目标 Activity 的实例 val instanceOfTarget = targetActivity.newInstance() // 检查是否可以自动注入 if (ARouter.canAutoInject()) &#123; // 从 Intent 中获取自动注入的参数 val autoInjectParams = intent.getStringArrayExtra(ARouter.AUTO_INJECT) if (null != autoInjectParams &amp;&amp; autoInjectParams.isNotEmpty()) &#123; // 遍历参数列表 for (paramsName in autoInjectParams) &#123; // 从 Intent 的 extras 中获取参数值 val value = intent.extras!![TextUtils.getLeft(paramsName)] if (null != value) &#123; try &#123; // 获取目标 Activity 中的字段 val injectField = targetActivity.getDeclaredField(TextUtils.getLeft(paramsName)) // 设置字段可访问 injectField.isAccessible = true // 将提取的值注入到目标 Activity 的字段中 injectField[instanceOfTarget] = value &#125; catch (e: Exception) &#123; // 记录错误日志，包括异常信息 ARouter.logger.error( Consts.TAG, &quot;为 Activity 注入值时发生错误！[&quot; + e.message + &quot;]&quot; ) &#125; &#125; &#125; &#125; &#125; // 返回已注入值的目标 Activity 实例 return instanceOfTarget as Activity &#125;&#125; 已废弃，不废话 InterceptorServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package com.alibaba.android.arouter.coreimport android.content.Contextimport com.alibaba.android.arouter.exception.HandlerExceptionimport com.alibaba.android.arouter.facade.Postcardimport com.alibaba.android.arouter.facade.annotation.Routeimport com.alibaba.android.arouter.facade.callback.InterceptorCallbackimport com.alibaba.android.arouter.facade.service.InterceptorServiceimport com.alibaba.android.arouter.facade.template.IInterceptorimport com.alibaba.android.arouter.launcher.ARouter.loggerimport com.alibaba.android.arouter.thread.CancelableCountDownLatchimport com.alibaba.android.arouter.utils.Consts.TAGimport com.alibaba.android.arouter.utils.MapUtilsimport java.util.concurrent.TimeUnit/** * 所有拦截器的实现类 * * @author zhilong [联系我](mailto:zhilong.lzl@alibaba-inc.com) * @version 1.0 * @since 2017/2/23 下午2:09 */@Route(path = &quot;/arouter/service/interceptor&quot;)class InterceptorServiceImpl : InterceptorService &#123;/** * 执行拦截操作 * * @param postcard 路由信息，包含了路由的相关信息和配置。 * @param callback 拦截回调，用于在拦截器流程中通知下一步操作。 */fun doInterceptions(postcard: Postcard, callback: InterceptorCallback) &#123; if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123; // 检查拦截器是否已经初始化 checkInterceptorsInitStatus() // 如果拦截器未初始化完成，中断导航并抛出异常 if (!interceptorHasInit) &#123; callback.onInterrupt(HandlerException(&quot;拦截器初始化花费太长时间。&quot;)) return &#125; // 在后台线程中执行拦截器操作 LogisticsCenter.executor.execute(Runnable &#123; val interceptorCounter = CancelableCountDownLatch(Warehouse.interceptors.size()) try &#123; // 依次执行拦截器 _execute(0, interceptorCounter, postcard) // 等待拦截器执行完成，超时时间由路由配置决定 interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS) // 如果有未执行的拦截器，取消导航 if (interceptorCounter.getCount() &gt; 0) &#123; // 如果没有返回任何内容，取消导航。 callback.onInterrupt(HandlerException(&quot;拦截器处理超时。&quot;)) &#125; else if (null != postcard.getTag()) &#123; // 如果标签中有异常信息。 callback.onInterrupt(postcard.getTag() as Throwable) &#125; else &#123; // 所有拦截器执行完毕，继续路由导航 callback.onContinue(postcard) &#125; &#125; catch (e: Exception) &#123; // 拦截器执行过程中出现异常，中断导航并传递异常信息 callback.onInterrupt(e) &#125; &#125;) &#125; else &#123; // 没有注册拦截器，直接继续路由导航 callback.onContinue(postcard) &#125;&#125; /** * 初始化拦截器 * * @param context 上下文对象，用于在拦截器初始化时可能需要的上下文信息。 */fun init(context: Context?) &#123; LogisticsCenter.executor.execute(Runnable &#123; // 检查是否有已注册的拦截器 if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123; for ((_, interceptorClass): Map.Entry&lt;Int?, Class&lt;out IInterceptor?&gt;&gt; in Warehouse.interceptorsIndex.entrySet()) &#123; try &#123; // 实例化拦截器 val iInterceptor: IInterceptor = interceptorClass.getConstructor().newInstance() // 调用拦截器的初始化方法，传入上下文信息 iInterceptor.init(context) // 将拦截器添加到仓库中，以供后续使用 Warehouse.interceptors.add(iInterceptor) &#125; catch (ex: Exception) &#123; // 如果初始化过程中发生异常，抛出自定义的异常 throw HandlerException(TAG.toString() + &quot;ARouter初始化拦截器错误！名称 = [&quot; + interceptorClass.name + &quot;]，原因 = [&quot; + ex.message + &quot;]&quot;) &#125; &#125; // 标记拦截器已经初始化完成 interceptorHasInit = true // 记录日志，表示拦截器初始化已完成 logger.info(TAG, &quot;ARouter拦截器初始化完成。&quot;) // 通知等待的线程，拦截器已经初始化完成 synchronized(interceptorInitLock) &#123; interceptorInitLock.notifyAll() &#125; &#125; &#125;)&#125; companion object &#123; private var interceptorHasInit = false private val interceptorInitLock = Any() /** * 执行拦截器 * * @param index 当前拦截器索引 * @param counter 拦截器计数器 * @param postcard 路由信息 */ private fun _execute(index: Int, counter: CancelableCountDownLatch, postcard: Postcard) &#123; if (index &lt; Warehouse.interceptors.size()) &#123; val iInterceptor: IInterceptor = Warehouse.interceptors.get(index) iInterceptor.process(postcard, object : InterceptorCallback() &#123; fun onContinue(postcard: Postcard) &#123; // 最后一个拦截器执行完成，没有异常。 counter.countDown() _execute( index + 1, counter, postcard ) // 当计数器减少时，继续执行，但是索引大于拦截器的大小，此时不会继续执行。 &#125; fun onInterrupt(exception: Throwable?) &#123; // 最后一个拦截器执行出现严重异常。 postcard.setTag( exception ?: HandlerException(&quot;没有消息。&quot;) ) // 保存异常消息以备份。 counter.cancel() // 注意，可能回调中的线程已经更改， // 然后捕获块（L207）将无效。 // 最糟糕的情况是线程更改为主线程，然后如果抛出此异常，则应用程序将崩溃！// if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123; // 如果线程是主线程，则不应抛出异常。// throw new HandlerException(exception.getMessage());// &#125; &#125; &#125;) &#125; &#125; private fun checkInterceptorsInitStatus() &#123; synchronized(interceptorInitLock) &#123; while (!interceptorHasInit) &#123; try &#123; interceptorInitLock.wait((10 * 1000).toLong()) &#125; catch (e: InterruptedException) &#123; throw HandlerException(TAG.toString() + &quot;拦截器初始化花费太长时间错误！原因 = [&quot; + e.message + &quot;]&quot;) &#125; &#125; &#125; &#125; &#125;&#125; 这个类是ARouter（Android路由框架）的核心拦截器服务实现类，它具有以下作用： 拦截器管理： 该类负责管理ARouter框架中的拦截器。拦截器是在路由导航过程中执行的一系列操作，用于处理路由请求或者对路由进行拦截和修改。 拦截器执行： 通过doInterceptions方法，该类执行了一系列的拦截器操作。在路由导航之前，它会依次调用已注册的拦截器，检查是否需要拦截路由请求或对请求进行修改。如果有拦截器拦截了请求，将触发拦截器的onInterrupt方法，否则，将继续执行下一个拦截器，直到所有拦截器都完成或者发生了异常。 拦截器初始化： 通过init方法，该类还负责初始化所有的拦截器。在ARouter框架初始化的过程中，会注册各种拦截器，这些拦截器需要在合适的时机进行初始化，以便在路由导航时能够正确地执行。 线程控制： 该类使用CancelableCountDownLatch来管理拦截器的执行，确保在所有拦截器执行完成或者超时时能够继续路由导航操作。同时，它还使用锁来控制拦截器的初始化过程，以确保在初始化完成之前不会执行路由导航。 LogisticsCenter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411package com.alibaba.android.arouter.coreimport android.content.Contextimport android.net.Uriimport com.alibaba.android.arouter.exception.HandlerExceptionimport com.alibaba.android.arouter.exception.NoRouteFoundExceptionimport com.alibaba.android.arouter.facade.Postcardimport com.alibaba.android.arouter.facade.enums.TypeKindimport com.alibaba.android.arouter.facade.model.RouteMetaimport com.alibaba.android.arouter.facade.template.IInterceptorGroupimport com.alibaba.android.arouter.facade.template.IProviderimport com.alibaba.android.arouter.facade.template.IProviderGroupimport com.alibaba.android.arouter.facade.template.IRouteGroupimport com.alibaba.android.arouter.facade.template.IRouteRootimport com.alibaba.android.arouter.launcher.ARouterimport com.alibaba.android.arouter.launcher.ARouter.loggerimport com.alibaba.android.arouter.utils.ClassUtilsimport com.alibaba.android.arouter.utils.Constsimport com.alibaba.android.arouter.utils.Consts.AROUTER_SP_CACHE_KEYimport com.alibaba.android.arouter.utils.Consts.AROUTER_SP_KEY_MAPimport com.alibaba.android.arouter.utils.Consts.DOTimport com.alibaba.android.arouter.utils.Consts.ROUTE_ROOT_PAKCAGEimport com.alibaba.android.arouter.utils.Consts.SDK_NAMEimport com.alibaba.android.arouter.utils.Consts.SEPARATORimport com.alibaba.android.arouter.utils.Consts.SUFFIX_INTERCEPTORSimport com.alibaba.android.arouter.utils.Consts.SUFFIX_PROVIDERSimport com.alibaba.android.arouter.utils.Consts.SUFFIX_ROOTimport com.alibaba.android.arouter.utils.Consts.TAGimport com.alibaba.android.arouter.utils.MapUtilsimport com.alibaba.android.arouter.utils.PackageUtilsimport com.alibaba.android.arouter.utils.TextUtilsimport java.lang.Booleanimport java.lang.reflect.InvocationTargetExceptionimport java.util.*import java.util.concurrent.ThreadPoolExecutorimport kotlin.Exceptionimport kotlin.Intimport kotlin.Stringimport kotlin.Throwableimport kotlin.Throwsimport kotlin.arrayOf/** * LogisticsCenter 包含了所有的路由映射信息。 * * 1. 在首次使用时创建实例。 * 2. 处理多模块之间的映射关系(*) * 3. 解决重复组定义的复杂逻辑 * * @author Alex [联系我](mailto:zhilong.liu@aliyun.com) * @version 1.0 * @since 16/8/23 15:02 */object LogisticsCenter &#123; private var mContext: Context? = null var executor: ThreadPoolExecutor? = null private var registerByPlugin = false /** * arouter-auto-register 插件将在这个方法中生成代码 * 调用这个方法来注册所有的路由、拦截器和提供者 */ private fun loadRouterMap() &#123; registerByPlugin = false // 自动生成的注册代码由 Gradle 插件 arouter-auto-register 生成 // 看起来像下面这样： // registerRouteRoot(new ARouter..Root..modulejava()); // registerRouteRoot(new ARouter..Root..modulekotlin()); &#125; /** * 根据类名注册 * 为了解决主 dex 文件过大的问题，牺牲了一些效率 */ private fun register(className: String) &#123; if (!TextUtils.isEmpty(className)) &#123; try &#123; val clazz = Class.forName(className) val obj = clazz.getConstructor().newInstance() if (obj is IRouteRoot) &#123; registerRouteRoot(obj as IRouteRoot) &#125; else if (obj is IProviderGroup) &#123; registerProvider(obj as IProviderGroup) &#125; else if (obj is IInterceptorGroup) &#123; registerInterceptor(obj as IInterceptorGroup) &#125; else &#123; logger.info( TAG, &quot;注册失败，类名：&quot; + className + &quot; 应该实现其中一个接口 IRouteRoot/IProviderGroup/IInterceptorGroup。&quot; ) &#125; &#125; catch (e: Exception) &#123; logger.error(TAG, &quot;注册类错误：$className&quot;, e) &#125; &#125; &#125; /** * 用于 arouter-auto-register 插件注册路由的方法 * @param routeRoot IRouteRoot 实现类，位于包 com.alibaba.android.arouter.core.routers */ private fun registerRouteRoot(routeRoot: IRouteRoot?) &#123; markRegisteredByPlugin() if (routeRoot != null) &#123; routeRoot.loadInto(Warehouse.groupsIndex) &#125; &#125; /** * 用于 arouter-auto-register 插件注册拦截器的方法 * @param interceptorGroup IInterceptorGroup 实现类，位于包 com.alibaba.android.arouter.core.routers */ private fun registerInterceptor(interceptorGroup: IInterceptorGroup?) &#123; markRegisteredByPlugin() if (interceptorGroup != null) &#123; interceptorGroup.loadInto(Warehouse.interceptorsIndex) &#125; &#125; /** * 用于 arouter-auto-register 插件注册提供者的方法 * @param providerGroup IProviderGroup 实现类，位于包 com.alibaba.android.arouter.core.routers */ private fun registerProvider(providerGroup: IProviderGroup?) &#123; markRegisteredByPlugin() if (providerGroup != null) &#123; providerGroup.loadInto(Warehouse.providersIndex) &#125; &#125; /** * 标记已由 arouter-auto-register 插件注册 */ private fun markRegisteredByPlugin() &#123; if (!registerByPlugin) &#123; registerByPlugin = true &#125; &#125; /** * LogisticsCenter 初始化，加载所有路由信息到内存中，需要在首次使用时进行初始化。 */ @Synchronized @Throws(HandlerException::class) fun init(context: Context, tpe: ThreadPoolExecutor?) &#123; mContext = context executor = tpe try &#123; var startInit = System.currentTimeMillis() // 首先通过插件加载路由信息 loadRouterMap() if (registerByPlugin) &#123; logger.info(TAG, &quot;通过 arouter-auto-register 插件加载路由映射信息。&quot;) &#125; else &#123; val routerMap: Set&lt;String&gt; // 在调试模式或安装新版本时，每次都会重建路由映射 if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123; logger.info(TAG, &quot;在调试模式下或安装新版本，重新构建路由映射。&quot;) // 这些类是由 arouter-compiler 自动生成的 routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE) if (!routerMap.isEmpty()) &#123; context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE) .edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply() &#125; PackageUtils.updateVersion(context) // 保存新版本名，当路由映射更新完成时使用 &#125; else &#123; logger.info(TAG, &quot;从缓存中加载路由映射信息。&quot;) routerMap = HashSet( context.getSharedPreferences( AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE ).getStringSet(AROUTER_SP_KEY_MAP, HashSet()) ) &#125; logger.info( TAG, &quot;找到路由映射信息，映射大小 = &quot; + routerMap.size + &quot;，耗时 &quot; + (System.currentTimeMillis() - startInit) + &quot; 毫秒。&quot; ) startInit = System.currentTimeMillis() for (className in routerMap) &#123; if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123; // 这是根元素之一，加载根元素 (Class.forName(className).getConstructor() .newInstance() as IRouteRoot).loadInto(Warehouse.groupsIndex) &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123; // 加载拦截器映射信息 (Class.forName(className).getConstructor() .newInstance() as IInterceptorGroup).loadInto(Warehouse.interceptorsIndex) &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123; // 加载提供者映射信息 (Class.forName(className).getConstructor() .newInstance() as IProviderGroup).loadInto(Warehouse.providersIndex) &#125; &#125; &#125; logger.info( TAG, &quot;加载根元素完成，耗时 &quot; + (System.currentTimeMillis() - startInit) + &quot; 毫秒。&quot; ) if (Warehouse.groupsIndex.size() === 0) &#123; logger.error(TAG, &quot;未找到映射文件，请检查您的配置！&quot;) &#125; if (ARouter.debuggable()) &#123; logger.debug( TAG, java.lang.String.format( Locale.getDefault(), &quot;LogisticsCenter 已经加载，GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]&quot;, Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size() ) ) &#125; &#125; catch (e: Exception) &#123; throw HandlerException(TAG.toString() + &quot;ARouter 初始化物流中心异常！ [&quot; + e.message + &quot;]&quot;) &#125; &#125; /** * 根据服务名构建 Postcard * * @param serviceName 接口名 * @return Postcard */ fun buildProvider(serviceName: String?): Postcard? &#123; val meta: RouteMeta = Warehouse.providersIndex.get(serviceName) return if (null == meta) &#123; null &#125; else &#123; Postcard(meta.getPath(), meta.getGroup()) &#125; &#125; /** * 根据路由元信息完成 Postcard 对象 * * @param postcard 不完整的 Postcard，应由此方法完成。 */ @Synchronized fun completion(postcard: Postcard?) &#123; if (null == postcard) &#123; throw NoRouteFoundException(TAG.toString() + &quot;没有 Postcard！&quot;) &#125; val routeMeta: RouteMeta = Warehouse.routes.get(postcard.getPath()) if (null == routeMeta) &#123; // 可能不存在或尚未加载 if (!Warehouse.groupsIndex.containsKey(postcard.getGroup())) &#123; throw NoRouteFoundException(TAG.toString() + &quot;没有匹配路径 [&quot; + postcard.getPath() + &quot;]，在组 [&quot; + postcard.getGroup() + &quot;] 中。&quot;) &#125; else &#123; // 加载路由信息并缓存到内存中，然后从路由元信息中删除 try &#123; if (ARouter.debuggable()) &#123; logger.debug( TAG, java.lang.String.format( Locale.getDefault(), &quot;开始加载组 [%s]，由 [%s] 触发。&quot;, postcard.getGroup(), postcard.getPath() ) ) &#125; addRouteGroupDynamic(postcard.getGroup(), null) if (ARouter.debuggable()) &#123; logger.debug( TAG, java.lang.String.format( Locale.getDefault(), &quot;组 [%s] 已经加载，由 [%s] 触发。&quot;, postcard.getGroup(), postcard.getPath() ) ) &#125; &#125; catch (e: Exception) &#123; throw HandlerException(TAG.toString() + &quot;加载组元信息时发生致命异常。 [&quot; + e.message + &quot;]&quot;) &#125; completion(postcard) // 重新加载 &#125; &#125; else &#123; postcard.setDestination(routeMeta.getDestination()) postcard.setType(routeMeta.getType()) postcard.setPriority(routeMeta.getPriority()) postcard.setExtra(routeMeta.getExtra()) val rawUri: Uri = postcard.getUri() if (null != rawUri) &#123; // 尝试将参数设置到 Bundle 中 val resultMap: Map&lt;String, String&gt; = TextUtils.splitQueryParameters(rawUri) val paramsType: Map&lt;String, Int?&gt; = routeMeta.getParamsType() if (MapUtils.isNotEmpty(paramsType)) &#123; // 根据参数类型设置值，仅对使用 @Param 注解的参数有效 for ((key, value): Map.Entry&lt;String, Int?&gt; in paramsType) &#123; setValue( postcard, value, key, resultMap[key] ) &#125; // 保存需要自动注入的参数名 postcard.getExtras().putStringArray( ARouter.AUTO_INJECT, paramsType.keys.toArray(arrayOf&lt;String&gt;()) ) &#125; // 保存原始 URI postcard.withString(ARouter.RAW_URI, rawUri.toString()) &#125; when (routeMeta.getType()) &#123; PROVIDER -&gt; &#123; // 这是提供者，所以必须实现 IProvider 接口 val providerMeta: Class&lt;out IProvider?&gt; = routeMeta.getDestination() var instance: IProvider? = Warehouse.providers.get(providerMeta) if (null == instance) &#123; // 没有此提供者的实例 val provider: IProvider try &#123; provider = providerMeta.getConstructor().newInstance() provider.init(mContext) Warehouse.providers.put(providerMeta, provider) instance = provider &#125; catch (e: Exception) &#123; logger.error(TAG, &quot;初始化提供者失败！&quot;, e) throw HandlerException(&quot;初始化提供者失败！&quot;) &#125; &#125; postcard.setProvider(instance) postcard.greenChannel() // 提供者应跳过所有拦截器 &#125; FRAGMENT -&gt; postcard.greenChannel() // Fragment 不需要拦截器 else -&gt; &#123;&#125; &#125; &#125; &#125; /** * 根据已知类型设置值 * * @param postcard postcard * @param typeDef 类型 * @param key 键 * @param value 值 */ private fun setValue(postcard: Postcard, typeDef: Int?, key: String, value: String?) &#123; if (TextUtils.isEmpty(key) || TextUtils.isEmpty(value)) &#123; return &#125; try &#123; if (null != typeDef) &#123; if (typeDef === TypeKind.BOOLEAN.ordinal()) &#123; postcard.withBoolean(key, Boolean.parseBoolean(value)) &#125; else if (typeDef === TypeKind.BYTE.ordinal()) &#123; postcard.withByte(key, value!!.toByte()) &#125; else if (typeDef === TypeKind.SHORT.ordinal()) &#123; postcard.withShort(key, value!!.toShort()) &#125; else if (typeDef === TypeKind.INT.ordinal()) &#123; postcard.withInt(key, value!!.toInt()) &#125; else if (typeDef === TypeKind.LONG.ordinal()) &#123; postcard.withLong(key, value!!.toLong()) &#125; else if (typeDef === TypeKind.FLOAT.ordinal()) &#123; postcard.withFloat(key, value!!.toFloat()) &#125; else if (typeDef === TypeKind.DOUBLE.ordinal()) &#123; postcard.withDouble(key, value!!.toDouble()) &#125; else if (typeDef === TypeKind.STRING.ordinal()) &#123; postcard.withString(key, value) &#125; else if (typeDef === TypeKind.PARCELABLE.ordinal()) &#123; // TODO : 如何使用字符串描述可传递的值？ &#125; else if (typeDef === TypeKind.OBJECT.ordinal()) &#123; postcard.withString(key, value) &#125; else &#123; // 兼容编译器 SDK 1.0.3，在该版本中，字符串类型 = 18 postcard.withString(key, value) &#125; &#125; else &#123; postcard.withString(key, value) &#125; &#125; catch (ex: Throwable) &#123; logger.warning(Consts.TAG, &quot;LogisticsCenter setValue 失败！&quot; + ex.message) &#125; &#125; /** * 挂起业务，清除缓存。 */ fun suspend() &#123; Warehouse.clear() &#125; @Synchronized @Throws( NoSuchMethodException::class, IllegalAccessException::class, InvocationTargetException::class, InstantiationException::class ) fun addRouteGroupDynamic(groupName: String?, group: IRouteGroup?) &#123; if (Warehouse.groupsIndex.containsKey(groupName)) &#123; // 如果已包含此组，但尚未加载 // 先加载此组，因为动态路由具有较高的优先级。 Warehouse.groupsIndex.get(groupName).getConstructor().newInstance() .loadInto(Warehouse.routes) Warehouse.groupsIndex.remove(groupName) &#125; // 覆盖旧组。 if (null != group) &#123; group.loadInto(Warehouse.routes) &#125; &#125;&#125; 这个类是ARouter库的核心组件之一，它的主要作用是负责管理和维护ARouter路由框架中的各种映射关系和配置信息，以便实现路由功能。以下是这个类的主要作用描述： 加载路由映射信息： LogisticsCenter负责加载和管理所有的路由映射信息。这些路由映射信息包括路由路径、路由分组、拦截器、提供者等相关信息，它们在ARouter框架中用于实现路由跳转和服务提供。 支持自动注册： 通过ARouter的插件机制，LogisticsCenter可以支持自动注册路由信息，使得开发者无需手动配置路由信息，提高了开发效率。插件会自动生成代码来调用LogisticsCenter的方法注册路由信息。 初始化和管理线程池： LogisticsCenter负责初始化和管理线程池，用于异步加载路由信息和执行路由任务。线程池的管理有助于提高ARouter框架的性能和并发处理能力。 动态加载路由信息： 当需要跳转到某个路由时，LogisticsCenter会根据路由信息动态加载相关的路由元信息，包括路由组信息和拦截器信息，以便进行路由跳转和拦截器处理。 提供路由跳转和服务提供支持： LogisticsCenter提供了一系列方法，用于构建路由跳转的Postcard对象和获取服务提供者的实例。它还负责处理路由跳转的逻辑，包括路由路径匹配、拦截器处理和服务提供。 支持路由信息的缓存和更新： LogisticsCenter支持路由信息的缓存和更新，以提高ARouter框架的性能。当路由信息有更新时，可以通过插件机制重新生成路由映射信息。 总之，LogisticsCenter是ARouter框架中的核心组件，它通过加载、管理和动态获取路由信息，实现了路由跳转和服务提供的功能，提供了便捷的路由框架和服务化解决方案。 Warehouse1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.alibaba.android.arouter.coreimport com.alibaba.android.arouter.base.UniqueKeyTreeMapimport com.alibaba.android.arouter.facade.model.RouteMetaimport com.alibaba.android.arouter.facade.template.IInterceptorimport com.alibaba.android.arouter.facade.template.IProviderimport com.alibaba.android.arouter.facade.template.IRouteGroup/** * 路由元信息和其他数据的存储仓库。 * * Warehouse（仓库）负责存储路由元信息以及其他相关数据。 * * @author zhilong [Contact me.](mailto:zhilong.lzl@alibaba-inc.com) * @version 1.0 * @since 2017/2/23 下午1:39 */internal object Warehouse &#123; // 缓存路由组和路由元信息 var groupsIndex: MutableMap&lt;String, Class&lt;out IRouteGroup?&gt;&gt; = HashMap&lt;String, Class&lt;out IRouteGroup?&gt;&gt;() var routes: MutableMap&lt;String, RouteMeta&gt; = HashMap&lt;String, RouteMeta&gt;() // 缓存服务提供者 var providers: MutableMap&lt;Class&lt;*&gt;, IProvider&gt; = HashMap&lt;Class&lt;*&gt;, IProvider&gt;() var providersIndex: MutableMap&lt;String, RouteMeta&gt; = HashMap&lt;String, RouteMeta&gt;() // 缓存拦截器 var interceptorsIndex: MutableMap&lt;Int, Class&lt;out IInterceptor?&gt;&gt; = UniqueKeyTreeMap(&quot;多个拦截器使用相同的优先级 [%s]&quot;) var interceptors: MutableList&lt;IInterceptor&gt; = ArrayList&lt;IInterceptor&gt;() /** * 清空仓库中的数据。 */ fun clear() &#123; routes.clear() groupsIndex.clear() providers.clear() providersIndex.clear() interceptors.clear() interceptorsIndex.clear() &#125;&#125; 这个类是ARouter框架内部的一个存储仓库，用于缓存路由元信息、路由组信息、服务提供者信息以及拦截器信息等相关数据。这些数据在ARouter框架中用于实现路由跳转和服务提供功能。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - exception 异常与 callback 回调","slug":"3 Android/ARouter/03-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/03-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/03-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - service 服务","slug":"3 Android/ARouter/04-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/04-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/04-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - template 模板","slug":"3 Android/ARouter/05-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/05-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/05-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - launcher 启动器","slug":"3 Android/ARouter/06-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/06-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/06-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - utils 工具类","slug":"3 Android/ARouter/07-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/07-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/07-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"从零开始写一个 ARouter - compiler 编译模块","slug":"3 Android/ARouter/08-Arouter","date":"2023-09-09T17:05:06.000Z","updated":"2023-09-09T17:05:06.000Z","comments":true,"path":"2023/09/10/3 Android/ARouter/08-Arouter/","link":"","permalink":"http://example.com/2023/09/10/3%20Android/ARouter/08-Arouter/","excerpt":"","text":"ARouter router-annotation 路由注解模块 src.main.java com.alibaba.android.arouter facade 提供注解和枚举的包 annotation 存放各种注解类的包 Autowired.java 自动注入的注解 Interceptor.java 拦截器的注解 Param.java(废弃) 参数注解: 被 Autowired 淘汰 Route.java 路由信息注解 enums 包含各种枚举类型的包 RouteType.java 路由类型的枚举 TypeKind.java 类型种类的枚举 model 包含模型类的包 RouteMeta.java 路由元信息的模型类 TypeWrapper.java 存储目标对象的泛型类型信息的类 arouter-api ARouter框架的API模块 src.main.java com.alibaba.android.arouter base 基础功能相关的包 UniqueKeyTreeMap.java 唯一键树形映射的类 core 核心功能相关的包 AutowiredLifecyleCallback.java(废弃) 自动注入生命周期回调的类 AutowiredServiceImpl.java 自动注入服务的实现类 InstrumentationHook.java(废弃) 仪表钩子的类 InterceptorServiceImpl.java 拦截器服务的实现类 LogisticsCenter.java 物流中心的类 Warehouse.java 仓库的类 exception 异常相关的包 HandlerException.java 处理异常的类 InitException.java 初始化异常的类 NoRouteFoundException.java 未找到路由的异常类 facade 提供各种服务和回调的包 callback 回调相关的包 InterceptorCallback.java 拦截器回调的接口 NavigationCallback.java 导航回调的接口 NoRouteFoundException.java 未找到路由的异常接口 service 服务相关的包 AutowiredService.java 自动注入服务的接口 ClassLoaderService.java 类加载器服务的接口 DegradeService.java 降级服务的接口 InterceptorService.java 拦截器服务的接口 PathReplaceService.java 路径替换服务的接口 PretreatmentService.java 预处理服务的接口 SerializationService.java 序列化服务的接口 template 模板相关的包 IInterceptor.java 拦截器接口 IInterceptorGroup.java 拦截器分组接口 Ilogger.java 日志记录器接口 IPolicy.java 策略接口 IProvider.java 提供者接口 IProviderGroup.java 提供者分组接口 IRouteGroup.java 路由分组接口 IRouteRoot.java 路由根接口 Isyringe.java 注射器接口 Postcard.java 路由信息封装类 launcher 启动器: 包含一些用于启动ARouter框架的类和线程管理相关的类。 _Arouter.java ARouter框架的内部启动类，用于初始化ARouter。 Arouter.java ARouter框架的启动类，用于初始化ARouter。 thread （线程）包含了与线程管理相关的类。 CancelableCountDownLatch.java 可取消的倒计时计数器，用于线程同步。 DefaultPoolExecutor.java 默认的线程池执行器，用于执行异步任务。 DefaultThreadFactory.java 默认线程工厂，用于创建线程。 utils 工具类。 ClassUtils.java 用于操作类的实用工具类。 Consts.java 包含一些常量值的类。 DefaultLogger.java 默认的日志记录器类。 MapUtils.java 用于操作地图数据的实用工具类。 PackageUtils.java 用于操作包信息的实用工具类。 TextUtils.java 用于操作文本数据的实用工具类。 arouter-compiler src.main.java com.alibaba.android.arouter compiler 编译相关的包 entity 实体类相关的包 RouteDoc.java 路由文档实体类 processor 处理器相关的包 AutowiredProcessor.java 自动注入处理器 BaseProcessor.java 基础处理器 InterceptorProcessor.java 拦截器处理器 RouteProcessor.java 路由处理器 utils 工具类相关的包 Consts.java 常量类 Logger.java 日志记录器类 TypeUtils.java 类型工具类","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"}],"tags":[]},{"title":"11. 二叉树-DFS (迭代)","slug":"0 算法/01 算法模板/11 二叉树-DFS (迭代)","date":"2023-09-08T07:57:42.000Z","updated":"2025-02-27T14:45:54.883Z","comments":true,"path":"2023/09/08/0 算法/01 算法模板/11 二叉树-DFS (迭代)/","link":"","permalink":"http://example.com/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/11%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E8%BF%AD%E4%BB%A3)/","excerpt":"","text":"正文先序遍历（写法一）123456789101112131415161718192021222324252627class TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun preorderTraversal(root: TreeNode?) &#123; val stack = LinkedList&lt;TreeNode&gt;() root ?: return stack.addFirst(root) while (!stack.isEmpty()) &#123; val current = stack.removeFirst() visit(current) // 先将右子节点入栈，再将左子节点入栈 if (current.right != null) &#123; stack.addFirst(current.right) &#125; if (current.left != null) &#123; stack.addFirst(current.left) &#125; &#125;&#125;fun visit(root: TreeNode)&#123; println(root.value)&#125; 先序遍历（写法二）123456789101112131415161718192021222324class TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun preorderTraversal(root: TreeNode?) &#123; val stack = LinkedList&lt;TreeNode&gt;(); var cur: TreeNode = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; visit(cur) stack.addFirst(cur); cur = cur.left; &#125; val top: TreeNode = stack.removeFirst((); cur = top.right; &#125;&#125;fun visit(node: TreeNode)&#123; println(node.value)&#125; 中序遍历123456789101112131415161718192021222324class TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun inorderTraversal(root: TreeNode?) &#123; val stack = LinkedList&lt;TreeNode&gt;(); var cur: TreeNode = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.addFirst(cur); cur = cur.left; &#125; visit(cur) val top: TreeNode = stack.removeFirst((); cur = top.right; &#125;&#125;fun visit(node: TreeNode)&#123; println(node.value)&#125; 后序遍历123456789101112131415161718192021222324252627282930class TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun postorder(root: TreeNode?) &#123; val stack: LinkList = LinkedList&lt;TreeNode&gt;() var cur = root var last = null while (cur != null || !stack.isEmpty()) &#123; // 左节点先入栈 while (cur != null) &#123; stack.addFirst(cur) // 第一次访问 cur = cur.left &#125; val top = stack.peekFirst() // 第二次访问 if (top.right == null || top.right == last) &#123; // 第三次访问 visit(top) last = top stack.removeFirst() &#125; else &#123; cur = top.right &#125; &#125;&#125;fun visit(node: TreeNode)&#123; println(node.value)&#125; 非递归后续遍历比较有意思结合注释我们来一语道破天机先序，中序，后序遍历第一次经过结点（从双亲过来）: 先序第二次经过结点（从左孩子过来）: 中序第三次经过结点（右孩子过来）: 后序","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"12. 二叉树-BFS","slug":"0 算法/01 算法模板/12 二叉树-BFS","date":"2023-09-08T02:31:56.000Z","updated":"2025-02-27T14:46:01.138Z","comments":true,"path":"2023/09/08/0 算法/01 算法模板/12 二叉树-BFS/","link":"","permalink":"http://example.com/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/12%20%E4%BA%8C%E5%8F%89%E6%A0%91-BFS/","excerpt":"","text":"正文12345678910111213141516171819202122232425262728import java.util.LinkedListclass TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun bfs(root: TreeNode?) &#123; val queue: LinkedList&lt;TreeNode&gt; = LinkedList() queue.add(root) while (!queue.isEmpty()) &#123; val node: TreeNode = queue.removeFirst() visit(node) if (node.left != null) &#123; queue.add(node.left) &#125; if (node.right != null) &#123; queue.add(node.right) &#125; &#125;&#125;fun visit(root: TreeNode)&#123; println(root.value)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"10. 二叉树-DFS (递归)","slug":"0 算法/01 算法模板/10 二叉树-DFS (递归)","date":"2023-09-08T02:21:10.000Z","updated":"2025-02-27T14:45:50.459Z","comments":true,"path":"2023/09/08/0 算法/01 算法模板/10 二叉树-DFS (递归)/","link":"","permalink":"http://example.com/2023/09/08/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/10%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E9%80%92%E5%BD%92)/","excerpt":"","text":"正文1234567891011121314151617class TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun dfs(root: TreeNode?) &#123; root?: return // visit() // 先序遍历 dfs(root.left) // visit() // 中序遍历 dfs(root.right) // visit() // 后序遍历&#125;fun visit(root: TreeNode)&#123; println(root.value)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"Android MVI GPT4 快问快答","slug":"4 架构方案设计/01 MVI/Android-音视频架构专项","date":"2023-08-28T18:45:14.000Z","updated":"2024-03-31T15:09:41.832Z","comments":true,"path":"2023/08/29/4 架构方案设计/01 MVI/Android-音视频架构专项/","link":"","permalink":"http://example.com/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/01%20MVI/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/","excerpt":"","text":"MVI 层级架构 App 用于依赖注入 —— 可以访问所有层 Data 负责内部和外部存储 —— 可以访问 Domain Domain 负责仓库和用例 —— 不访问任何层 Presentation 负责UI逻辑 —— 可以访问 Domain GPT 4 块问快答：究竟什么是 MVI为什么 Data 和 Presentation 可以访问领域层，举例子怎么访问的在一个典型的分层架构中，每一层都有其独特的职责，而且这种架构通常允许某些层访问其他特定的层。在你提到的结构中，App、Data、Domain和Presentation层各自担负不同的角色，其中Data和Presentation层被允许访问Domain层，主要是因为Domain层包含了应用程序的核心业务逻辑和规则，是其他层依赖的基础。 Data 层访问 Domain 层 职责：Data层负责处理数据的存取，无论是来自内部存储（如SQLite数据库、内存缓存等）还是外部存储（如网络API、远程数据库等）。 访问方式：Data层访问Domain层通常是通过实现Domain层定义的仓库接口（Repository Interfaces）。这些仓库接口定义了应用程序需要的数据操作（如获取用户数据、保存订单等），而Data层实现这些接口，具体处理数据的存取逻辑。 示例：假设在Domain层有一个UserRepository接口，它定义了获取用户信息的方法。Data层将实现这个接口，通过网络API或本地数据库获取用户信息。 Presentation 层访问 Domain 层 职责：Presentation层负责处理所有与用户界面（UI）相关的逻辑，如显示数据、响应用户操作等。 访问方式：Presentation层通过使用Domain层中定义的用例（Use Cases）或服务（Services）来获取所需的数据或执行特定的业务逻辑。用例封装了特定的业务逻辑操作，为Presentation层提供了清晰、简洁的API。 示例：如果有一个显示用户个人信息的界面，Presentation层的一个ViewModel或Presenter可能会调用一个GetUserProfile用例（从Domain层获取），该用例封装了获取用户个人信息的业务逻辑。 总结通过允许Data和Presentation层访问Domain层，可以确保应用程序的核心业务逻辑集中管理，并且易于测试和维护。同时，这种结构还有助于解耦，使得数据源的更改或UI的修改不会直接影响到业务逻辑的实现，从而提高了应用程序的灵活性和可维护性。 给出 GetUserProfile 代码例子为了提供一个GetUserProfile的示例，我们将遵循典型的分层架构中的Domain、Data和Presentation层的交互方式。这个例子将使用Kotlin语言，因为它是在Android开发中常用的语言，同时也适用于Kotlin多平台移动（KMM）项目。 Domain 层在Domain层，我们定义一个用例（Use Case）GetUserProfile，它是业务逻辑的一部分。这个用例会从仓库（Repository）中获取用户的个人信息。 1234567891011121314// Domain层 - 定义用例class GetUserProfile(private val userRepository: UserRepository) &#123; suspend fun execute(userId: String): UserProfile &#123; return userRepository.getUserProfile(userId) &#125;&#125;// Domain层 - 定义仓库接口interface UserRepository &#123; suspend fun getUserProfile(userId: String): UserProfile&#125;// 用户个人信息的数据模型data class UserProfile(val userId: String, val name: String, val email: String) Data 层在Data层，我们实现了Domain层定义的UserRepository接口，提供了获取用户个人信息的实际逻辑。 1234567// Data层 - 仓库实现class UserRepositoryImpl : UserRepository &#123; override suspend fun getUserProfile(userId: String): UserProfile &#123; // 假设这里是从网络或本地数据库获取数据 return UserProfile(userId, &quot;John Doe&quot;, &quot;johndoe@example.com&quot;) &#125;&#125; Presentation 层在Presentation层，我们使用GetUserProfile用例来获取用户个人信息，并展示到UI上。这里以一个简单的ViewModel为例。 123456789101112// Presentation层 - ViewModelclass UserProfileViewModel(private val getUserProfile: GetUserProfile) : ViewModel() &#123; // LiveData用于观察数据变化，更新UI private val _userProfile = MutableLiveData&lt;UserProfile&gt;() val userProfile: LiveData&lt;UserProfile&gt; = _userProfile fun loadUserProfile(userId: String) &#123; viewModelScope.launch &#123; _userProfile.value = getUserProfile.execute(userId) &#125; &#125;&#125; 小结这个例子演示了在一个分层架构中，如何通过Domain层的用例来协调Data层和Presentation层的交互。Domain层定义了业务逻辑和接口，Data层实现了数据获取的逻辑，而Presentation层负责调用这些逻辑并更新UI。这种分层的方式有助于保持代码的清晰和可维护性。 描述一下，数据在几个层之间的传递，从起始到结束数据在分层架构中的传递通常遵循一个定义良好的流程，确保应用的各个组成部分职责明确、解耦合，同时促进模块间的协作。以下是一个典型的从起始到结束的数据传递流程，以一个简化的用户个人信息获取功能为例，该功能遵循Presentation、Domain和Data层的架构模式： 1. 用户界面触发 起始点：用户在应用的界面上执行一个动作（比如点击一个按钮），请求查看个人信息。 处理：这个动作被Presentation层的一个组件（例如，一个ViewModel或Activity）捕获。 2. Presentation 层处理 Presentation层的组件调用Domain层定义的用例（Use Case），比如GetUserProfile，来获取用户的个人信息。这个调用通常是异步的，以避免阻塞UI线程。 ViewModel通过用例接口，向Domain层表达获取数据的需求。 3. Domain 层中转 Domain层的GetUserProfile用例接收到请求，并将其转发给相应的UserRepository接口。此时，GetUserProfile仅知道需要调用仓库接口来获取数据，但不关心数据的具体来源。 Domain层起到了定义业务规则和操作流程的角色，但本身不处理数据的存取。 4. Data 层响应 Data层中，具体实现了UserRepository接口的类（如UserRepositoryImpl）负责处理数据的实际获取操作。这可能涉及访问网络API、查询本地数据库或读取缓存等操作。 一旦数据被成功获取，它会被封装成一个模型（如UserProfile），并返回给调用者——在这个例子中是Domain层的GetUserProfile用例。 5. 数据回流到Presentation层 GetUserProfile用例收到Data层提供的用户信息后，将这些信息返回给最初请求它的Presentation层的组件。 Presentation层的ViewModel接收到这些数据后，更新UI绑定的数据模型，通常是通过LiveData或类似机制。 6. UI更新显示数据 最后，随着ViewModel中LiveData（或其他观察者模式实现）的更新，UI监听这些变化，并据此刷新显示，向用户展示最新获取的用户个人信息。 总结这个过程展示了数据从用户触发获取请求，通过应用的各层传递，并最终显示回用户界面的完整流程。每一层都有其特定的职责：Presentation层管理UI逻辑和用户交互，Domain层定义业务规则和数据获取的抽象接口，而Data层负责具体的数据存取逻辑。这种分层架构不仅有助于保持代码的组织性和可维护性，还促进了各模块间的清晰分离和互操作性。 解释 Domain 层如何定义业务规则Domain层在分层架构中扮演着核心角色，它定义了应用程序的业务规则和逻辑。这一层是独立于用户界面（UI）和数据存储机制的，意味着它不应该依赖于任何特定的框架或库，以便于业务逻辑能够在不同的环境中重用和测试。Domain层的设计主要关注于应用程序的“什么”和“为什么”，而不是“怎么做”。 业务规则的定义业务规则是指那些定义企业如何运作、决策应如何做出、业务流程应如何管理的规则。在软件开发中，这些规则转化为可以执行的代码，用于指导应用程序的行为。业务规则包括但不限于： 实体（Entities）：代表业务概念的对象，如用户、订单等，以及这些对象的属性和行为。 用例（Use Cases）或服务（Services）：封装了应用程序的核心功能，每个用例代表一个或多个业务操作，如“获取用户信息”、“创建订单”等。 值对象（Value Objects）：描述了业务中的值和它们的属性，但没有唯一标识符（与实体不同）。 仓库接口（Repository Interfaces）：定义了如何访问外部数据源（如数据库或远程服务）的抽象接口，但不实现具体的数据访问逻辑。 Domain层的职责 封装业务逻辑：Domain层包含应用程序的业务逻辑，确保业务操作的正确性、有效性和连贯性。 定义业务模型：通过实体和值对象定义业务领域内的数据模型和它们之间的关系。 业务决策的实现：实现业务决策逻辑，如验证规则、计算和数据转换等。 保持独立性：Domain层的设计应确保它不依赖于特定的UI实现或数据存储策略，使得业务逻辑可以在不同的应用场景下重用。 举例假设有一个在线商店应用，其Domain层可能包含如下定义： 实体：Product（产品）、Customer（客户）、Order（订单）。 用例：PlaceOrder（下订单）、CancelOrder（取消订单）、UpdateCustomerProfile（更新客户资料）。 值对象：Address（地址）、Money（货币）。 仓库接口：OrderRepository（提供对订单数据的访问）、CustomerRepository（提供对客户数据的访问）。 在这个例子中，Domain层定义了在线商店运作的基本规则和逻辑，如何处理订单、如何管理客户信息，以及如何执行业务决策，所有这些都与特定的UI实现或数据持久化机制无关。 总结，Domain层的设计是为了确保应用程序的核心业务逻辑得到清晰定义、良好封装，从而易于维护和测试，同时提高了代码的可重用性。 解释 Domain 层定义了基本规则和逻辑，与特定的 UI 实现或数据持久化机制无关Domain层在软件架构中的作用是封装和实现应用程序的核心业务逻辑，独立于用户界面（UI）和数据持久化（数据库等）的具体实现。这种设计方法使得业务逻辑更加模块化、清晰，并且易于测试和维护。在在线商店的例子中，Domain层定义的业务规则和逻辑涉及以下几个关键方面： 如何处理订单在Domain层中，处理订单的逻辑包括订单的创建、验证、支付、取消等步骤。这些操作反映了订单生命周期中的各个阶段，每个阶段都基于业务规则来执行。例如，订单支付前需要验证订单详情和客户支付信息的有效性；订单一旦支付成功，就不能随意取消，除非满足特定的退款条件。 如何管理客户信息客户信息管理包括客户注册、信息更新、历史订单查询等功能。Domain层通过定义客户实体（Customer）和相关的业务操作（如UpdateCustomerProfile）来实现这一点。这些操作确保了客户信息的一致性和安全性，例如，客户密码需要加密存储，客户信息更新需要验证客户的身份。 如何执行业务决策业务决策涉及到基于特定条件执行的逻辑选择，比如根据库存量决定是否接受订单、根据客户购买历史提供个性化推荐等。这些决策通常通过Domain层中的业务规则来实现，业务规则可能包括各种验证逻辑、计算公式和决策树。 与UI和数据持久化机制的独立性Domain层的设计目的是保持对UI层和数据持久化层的独立性。这意味着，不管UI如何变化（无论是移动应用、Web页面还是桌面应用），Domain层的业务逻辑不需要做出改变。同样，数据存储的细节（是使用SQL数据库、NoSQL数据库还是云服务）对Domain层也是透明的。这一层只通过抽象的接口（如Repository接口）与数据交互，具体的实现细节由Data层负责。 通过将业务逻辑集中在Domain层，应用程序的核心功能和规则得到了清晰的定义和封装，这不仅有助于减少不同层之间的耦合，还使得业务逻辑更容易理解、测试和维护。此外，这种架构设计还增加了应用程序的灵活性，使得未来对应用程序的扩展和修改变得更加容易。 抽出 domain 层的意义是什么抽出Domain层在软件架构中的意义主要体现在以下几个方面： 1. 业务逻辑集中化将业务逻辑集中在Domain层，有助于明确应用程序的核心功能和规则，使得这些逻辑独立于其他层（如表示层和数据持久化层）的实现。这种集中化有助于保持业务规则的一致性，确保业务操作遵循同一套逻辑，无论是通过何种途径执行。 2. 提高可维护性通过将业务逻辑与数据访问代码（Data层）和用户界面代码（Presentation层）分离，开发人员可以更容易地理解、修改和扩展业务规则。当业务需求发生变化时，通常只需要修改Domain层的代码，而无需触及到其他层的实现，这大大降低了维护成本和复杂性。 3. 增强可测试性独立的Domain层使得业务逻辑的单元测试变得更加直接和简单。因为业务逻辑与外部的界面显示和数据存取逻辑解耦，测试可以集中在业务规则的正确性上，而不必担心UI或数据库的具体实现。这有助于提高测试覆盖率和发现潜在的业务逻辑错误。 4. 促进技术栈灵活性由于Domain层独立于具体的技术实现，因此可以在不影响业务逻辑的前提下更换表示层框架或数据持久化技术。例如，可以从一个数据库系统迁移到另一个，或者在不同的前端技术（如Web、移动应用）之间共享相同的业务逻辑。 5. 便于多团队协作在大型项目中，不同的团队可以负责不同的应用层，例如一个团队专注于Domain层的业务逻辑开发，而另一个团队专注于用户界面的实现。这种分工有助于提高开发效率，因为团队可以并行工作，而且减少了彼此工作的直接依赖。 6. 支持多种应用场景Domain层的业务逻辑可以被不同的应用场景重用，比如同一个业务逻辑既能服务于Web应用，也能服务于移动应用或桌面应用。这种重用性可以显著降低开发和维护新平台应用的成本和时间。 总之，抽出Domain层是实现软件架构清晰分层、提高代码质量和维护性的重要策略，它有助于构建更加健壯、灵活和可持续发展的软件系统。 这样做为什么可以只需要修改Domain层的代码，而无需触及到其他层的实现当业务需求发生变化时，通常只需要修改Domain层的代码而无需触及到其他层的实现，这个原理主要是基于软件设计中的分层架构和关注点分离的原则。让我们来详细解释一下为什么这样做是可行的： 分层架构在一个典型的分层架构中，软件被划分为几个层次，每个层次负责处理不同的任务。这些层次通常包括： 表示层（Presentation Layer）：负责用户界面和用户交云的处理。 领域层（Domain Layer）：包含业务逻辑和业务规则。 数据访问层（Data Access Layer）：负责数据持久化和数据检索。 关注点分离分层架构实现了关注点分离（Separation of Concerns, SoC）的原则，即不同的层次关注不同的方面。通过这种方式，每一层都可以独立于其他层变化，只要它们之间的接口保持不变。 对于业务逻辑的变化 业务逻辑变化通常发生在Domain层：因为Domain层封装了应用程序的核心业务规则和逻辑。当业务需求变化时，这些变化几乎总是直接影响到业务规则和逻辑，而这些都是Domain层的职责范畴。 表示层和数据访问层的独立性：由于表示层主要负责界面显示和用户交互，数据访问层主要负责数据的持久化和检索，这两层的工作与业务逻辑的具体内容相对独立。它们通过定义良好的接口与Domain层交互，只要这些接口不变，业务逻辑的变更就不会直接影响到它们。 接口作为契约：Domain层通过接口与其他层进行交互。当业务需求变化导致Domain层的逻辑变化时，只要接口保持不变，表示层和数据访问层就无需变化。即使接口需要变化，现代编程语言和框架提供的抽象和封装机制也能最小化这种变化的影响。 实例假设一个电子商务应用，其中有一个计算订单总价的业务逻辑。如果业务规定更改了订单的折扣计算方式，这个变化直接关系到订单总价的计算规则，这是Domain层的一部分。只需修改Domain层中计算总价的代码即可。只要Domain层对外提供的计算总价的接口不变，表示层（可能显示总价的界面）和数据访问层（可能存储订单详情的数据库操作）就不需要任何改动。 结论因此，将业务逻辑封装在Domain层，确保了应用程序在面对业务需求变化时，可以局部化修改影响，减少了需要修改的代码量，从而降低了维护成本和复杂性。这种设计使得软件系统更加灵活和可维护，更容易适应和响应业务变化。 给出代码例子让我们通过一个简化的代码示例来说明当业务需求发生变化时，通常只需要修改Domain层的代码而无需触及到其他层的实现。考虑一个电子商务应用，其中包含一个功能：计算订单总价。我们将展示Domain层、Data层和Presentation层的简化代码，并展示当业务规则（例如，订单折扣规则）变化时，如何只修改Domain层代码来应对这一变化。 初始实现Domain层12345678910111213// Domain层 - 定义业务逻辑接口interface OrderService &#123; fun calculateTotalPrice(items: List&lt;OrderItem&gt;): Double&#125;// Domain层 - 实现class OrderServiceImpl : OrderService &#123; override fun calculateTotalPrice(items: List&lt;OrderItem&gt;): Double &#123; return items.sumOf &#123; it.price * it.quantity &#125; &#125;&#125;data class OrderItem(val price: Double, val quantity: Int) Data层假设数据层处理订单数据的存储和检索，但与计算总价无关，因此在此示例中略过。 Presentation层1234567// Presentation层 - 使用Domain层的服务展示总价class OrderViewModel(private val orderService: OrderService) &#123; fun displayTotalPrice(items: List&lt;OrderItem&gt;) &#123; val totalPrice = orderService.calculateTotalPrice(items) println(&quot;Total Price: $totalPrice&quot;) &#125;&#125; 业务需求变化假设业务需求变化，现在需要对订单总价应用10%的折扣。 修改Domain层我们只需要在Domain层中修改OrderServiceImpl的实现来反映这一变化： 12345678// Domain层 - 修改后的实现class OrderServiceImpl : OrderService &#123; override fun calculateTotalPrice(items: List&lt;OrderItem&gt;): Double &#123; val originalTotal = items.sumOf &#123; it.price * it.quantity &#125; val discount = originalTotal * 0.1 // 应用10%的折扣 return originalTotal - discount &#125;&#125; 在这个修改中，我们没有触及Presentation层或Data层的代码。Presentation层仍然以相同的方式调用Domain层的calculateTotalPrice方法，而Data层（假设它负责数据的持久化）也不需要变化，因为它与订单价格的计算逻辑无关。 结论通过这个简化的例子，我们可以看到，当业务规则变化（如订单折扣规则）时，只需修改Domain层中的业务逻辑实现。Presentation层和Data层不需要修改，因为它们与Domain层通过抽象的接口进行交互，这个接口（在本例中是OrderService.calculateTotalPrice）保持不变。这种设计使得应用程序能够灵活应对业务需求的变化，同时最小化了修改的影响范围，提高了代码的可维护性。","categories":[{"name":"4 - 架构方案设计","slug":"4-架构方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"4.1 - MVI","slug":"4-架构方案设计/4-1-MVI","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-1-MVI/"}],"tags":[]},{"title":"Android 音视频屏幕旋转方案","slug":"4 架构方案设计/02 播放器架构方案设计/Android-音视频架构专项","date":"2023-08-28T18:45:14.000Z","updated":"2023-08-28T18:45:14.000Z","comments":true,"path":"2023/08/29/4 架构方案设计/02 播放器架构方案设计/Android-音视频架构专项/","link":"","permalink":"http://example.com/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/02%20%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%9E%B6%E6%9E%84%E4%B8%93%E9%A1%B9/","excerpt":"","text":"正文在Android平台上，实现音视频播放过程中的屏幕旋转涉及到以下几个方面：界面布局的调整、Activity的生命周期管理、保存和恢复播放状态、以及处理屏幕旋转时可能引发的音视频播放问题。以下是一个基本的音视频屏幕旋转方案的步骤： 布局调整在res文件夹中创建不同方向的布局文件，例如layout/activity_main.xml和layout-land/activity_main.xml分别表示竖屏和横屏时的布局。在这些布局文件中，你可以调整控件的摆放位置以适应不同方向的屏幕。 Activity的生命周期管理当屏幕发生旋转时，Activity会经历重新创建的过程。确保你的Activity正确处理生命周期事件，特别是onCreate、onSaveInstanceState和onRestoreInstanceState等方法。 保存和恢复播放状态在onSaveInstanceState方法中保存当前的播放状态，例如播放位置、播放状态（播放、暂停等），以及其他相关信息。然后在onCreate和onRestoreInstanceState方法中恢复这些状态。 处理屏幕旋转可能引发的问题屏幕旋转可能会导致播放器重新创建或重置，从而影响播放状态。你需要在Activity重新创建时恢复播放状态，并确保播放器不会中断或重置播放进度。 使用ViewModel来保存播放状态（可选）使用ViewModel可以更方便地在屏幕旋转时保持数据。ViewModel会在Activity重新创建时保持其状态，因此你可以将播放状态等数据存储在ViewModel中，以确保不会丢失。 锁定屏幕方向（可选）如果你希望在播放音视频时固定屏幕方向，可以在AndroidManifest.xml中的相应Activity中使用android:screenOrientation属性来指定所需的屏幕方向（如portrait或landscape）。 总结总之，处理音视频播放过程中的屏幕旋转需要综合考虑界面布局、生命周期管理、数据保存和恢复等方面的问题。合理使用布局文件、Activity生命周期方法、ViewModel等工具，可以帮助你实现稳定且用户友好的音视频播放体验。","categories":[{"name":"4 - 架构方案设计","slug":"4-架构方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"4.1 - 播放器架构方案设计","slug":"4-架构方案设计/4-1-播放器架构方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-1-%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"Android 音视频屏幕旋转方案","slug":"4 架构方案设计/03 Android 文件存储方案/Android-不同版本文件存储方案","date":"2023-08-28T18:45:14.000Z","updated":"2024-05-22T14:02:16.906Z","comments":true,"path":"2023/08/29/4 架构方案设计/03 Android 文件存储方案/Android-不同版本文件存储方案/","link":"","permalink":"http://example.com/2023/08/29/4%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/03%20Android%20%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/Android-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/","excerpt":"","text":"Q：我应该去哪里获取不同版本的存储策略 A：要获取不同版本的 Android 存储策略（Storage Policies），您可以访问以下资源，这些资源提供了详细的版本特定存储策略和变更的信息： 官方 Android 文档Android 官方文档是了解不同版本存储策略最可靠的来源。以下是一些重要的链接： **Android Developers Storage Documentation**：这是 Android 官方的存储文档，涵盖了各种存储选项和最佳实践。 **Android Platform Releases**：这个页面提供了每个 Android 版本的详细变更，包括存储策略的变更。 **Scoped Storage**：针对 Android 10（API Level 29）及更高版本的分区存储（Scoped Storage），是存储策略的重要变更点。 官方博客和公告Android 官方博客和公告也是了解存储策略变更的好资源： **Android Developers Blog**：在这个博客上，Google 发布了关于新功能和存储策略变更的详细信息和指导。 GitHub 和社区资源开源社区和开发者论坛也提供了大量关于存储策略的信息： **Google Samples on GitHub**：Google 提供的示例项目，可以查看不同版本的存储策略实现。 **Stack Overflow**：搜索关于 Android 存储策略的问题和答案，可以获取社区的解决方案和建议。 具体版本的存储策略变更要了解具体版本的存储策略变更，可以参考以下步骤： 访问 Android 开发者文档中的版本变更日志：每个 Android 版本的变更日志会详细列出该版本的新特性和变更，包括存储策略。 查找特定版本的存储策略文档：在 Android Developers 网站上，您可以找到特定版本的 API 参考和变更日志。 直接搜索具体问题如果您有特定的存储策略问题，可以直接在 Google 搜索： 例如：Android 10 Scoped Storage 例如：Android 11 Storage Policy Changes 通过这些资源，您应该能够找到详细的 Android 存储策略信息，并理解每个版本的特定变更。 Android 6 以下的文件存储和读取策略在Android 6.0（API Level 23）及以下版本中，文件存储和读取的策略主要涉及以下几个方面： 1. 存储位置Android系统提供了两种主要的存储位置：内部存储和外部存储。 内部存储 内部存储是应用的私有存储区域，只有该应用可以访问。 存储在内部存储中的文件默认在应用卸载时会被删除。 使用Context对象的方法可以在内部存储中读写文件，例如： openFileOutput(String name, int mode)：写文件 openFileInput(String name)：读文件 外部存储 外部存储可以是设备的外部存储卡或者内置存储分区。 分为公共外部存储和应用私有外部存储。 公共外部存储可以被所有应用访问，例如图片、音频文件等。 应用私有外部存储只能被创建该文件的应用访问，在应用卸载时会被删除。 使用Environment类和Context对象的方法可以在外部存储中读写文件，例如： getExternalFilesDir(String type)：获取应用私有外部存储目录 Environment.getExternalStoragePublicDirectory(String type)：获取公共外部存储目录 2. 权限管理在Android 6.0及以下版本中，应用需要在AndroidManifest.xml中声明对外部存储的读写权限： 读权限：&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 写权限：&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 这些权限在应用安装时由用户批准。 3. 文件操作代码示例内部存储写文件： 12345String filename = &quot;myfile.txt&quot;;String fileContents = &quot;Hello, world!&quot;;FileOutputStream fos = openFileOutput(filename, Context.MODE_PRIVATE);fos.write(fileContents.getBytes());fos.close(); 读文件： 12345678910FileInputStream fis = openFileInput(filename);InputStreamReader isr = new InputStreamReader(fis);BufferedReader bufferedReader = new BufferedReader(isr);StringBuilder sb = new StringBuilder();String line;while ((line = bufferedReader.readLine()) != null) &#123; sb.append(line);&#125;String fileContents = sb.toString();fis.close(); 外部存储检查存储状态： 1234String state = Environment.getExternalStorageState();if (Environment.MEDIA_MOUNTED.equals(state)) &#123; // 可以读写外部存储&#125; 写文件： 1234File file = new File(getExternalFilesDir(null), &quot;myfile.txt&quot;);FileOutputStream fos = new FileOutputStream(file);fos.write(fileContents.getBytes());fos.close(); 读文件： 1234567891011File file = new File(getExternalFilesDir(null), &quot;myfile.txt&quot;);FileInputStream fis = new FileInputStream(file);InputStreamReader isr = new InputStreamReader(fis);BufferedReader bufferedReader = new BufferedReader(isr);StringBuilder sb = new StringBuilder();String line;while ((line = bufferedReader.readLine()) != null) &#123; sb.append(line);&#125;String fileContents = sb.toString();fis.close(); 这些代码示例展示了在Android 6.0及以下版本中如何进行基本的文件读写操作。随着Android版本的升级，文件存储和权限管理策略也发生了显著变化，因此在开发过程中需要根据目标API版本进行适配。 Android 6 以上文件存储和读取策略在Android 6.0（API Level 23）及以上版本中，文件存储和读取策略发生了一些变化，特别是在权限管理和存储位置的使用方面。以下是各版本的策略变化和相应的文件存储读写方法。 1. Android 6.0 (API Level 23)动态权限 从Android 6.0开始，权限管理采用动态权限模式。用户可以在运行时授予或拒绝权限。 应用在使用外部存储时，需要在AndroidManifest.xml中声明权限，并在运行时请求权限。 权限请求代码示例： 1234if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_CODE);&#125; 2. Android 7.0 (API Level 24)文件URI策略 从Android 7.0开始，File URI不再被允许在应用之间共享。必须使用FileProvider来共享文件URI。 FileProvider配置示例：在AndroidManifest.xml中： 123456789&lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; 在res/xml/file_paths.xml中： 123&lt;paths&gt; &lt;external-path name=&quot;external_files&quot; path=&quot;.&quot; /&gt;&lt;/paths&gt; 3. Android 8.0 (API Level 26)安全性增强 在后台执行文件操作受到限制，必须在前台任务或通过服务进行文件操作。 4. Android 9.0 (API Level 28)共享存储访问 在Android 9.0中引入了新的API，用于访问共享存储，推荐使用ACTION_OPEN_DOCUMENT和ACTION_CREATE_DOCUMENT来访问和创建文件。 使用示例： 1234Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);intent.addCategory(Intent.CATEGORY_OPENABLE);intent.setType(&quot;*/*&quot;);startActivityForResult(intent, REQUEST_CODE_OPEN_DOCUMENT); 5. Android 10 (API Level 29)分区存储 (Scoped Storage) 引入了分区存储，应用只能访问其私有的外部存储空间，除非使用特定的API访问公共存储。 可以通过请求Legacy存储模式来继续使用传统的存储访问方式（直到Android 11）。 分区存储代码示例： 1234File file = new File(getExternalFilesDir(null), &quot;myfile.txt&quot;);FileOutputStream fos = new FileOutputStream(file);fos.write(fileContents.getBytes());fos.close(); 6. Android 11 (API Level 30)强制分区存储 强制启用分区存储，应用无法再使用requestLegacyExternalStorage标志。 提供了新的访问存储的API，如MediaStore。 MediaStore使用示例： 12345678910ContentValues values = new ContentValues();values.put(MediaStore.MediaColumns.DISPLAY_NAME, &quot;myfile.txt&quot;);values.put(MediaStore.MediaColumns.MIME_TYPE, &quot;text/plain&quot;);values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOCUMENTS);Uri uri = getContentResolver().insert(MediaStore.Files.getContentUri(&quot;external&quot;), values);if (uri != null) &#123; OutputStream outputStream = getContentResolver().openOutputStream(uri); outputStream.write(fileContents.getBytes()); outputStream.close();&#125; 7. Android 12 (API Level 31) 及更高版本进一步限制外部存储访问 在Android 12中，对特定类型的文件访问进行了更多的限制，需要使用特定的API来访问不同类型的文件，如音频、视频和图片等。 总结： Android 6.0及以上版本在权限管理上采用动态权限，需要在运行时请求权限。 Android 7.0开始引入FileProvider来共享文件URI。 Android 10引入分区存储，Android 11强制启用分区存储，进一步限制了应用对外部存储的访问。 使用MediaStore等新的API来进行文件的读写操作，以适应最新的存储策略。 了解并适应这些变化，可以确保应用在不同Android版本上的文件存储和读取操作安全且有效。","categories":[{"name":"4 - 架构方案设计","slug":"4-架构方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"4.2 - Android 存储文件方案设计","slug":"4-架构方案设计/4-2-Android-存储文件方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-2-Android-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"C++ 第一课-万物皆地址","slug":"5 C++/C++第一课-万物皆地址","date":"2023-08-28T18:45:14.000Z","updated":"2024-03-26T07:14:20.558Z","comments":true,"path":"2023/08/29/5 C++/C++第一课-万物皆地址/","link":"","permalink":"http://example.com/2023/08/29/5%20C++/C++%E7%AC%AC%E4%B8%80%E8%AF%BE-%E4%B8%87%E7%89%A9%E7%9A%86%E5%9C%B0%E5%9D%80/","excerpt":"","text":"作者：朕小猫与GPT4 怎么理解C++万物皆地址在 C++ 程序中，几乎所有元素（包括变量、对象、函数等）都可以通过它们的内存地址来引用或操作。这一点归根结底是因为 C++ 是一种底层的编程语言，它允许直接访问内存和底层硬件资源。这种能力带来了极高的灵活性和控制能力，但同时也要求程序员对程序的内存使用有深入的理解。下面是如何通过内存地址来引用或操作元素的几个方面： 变量和对象的内存地址：在 C++ 中，每个变量或对象都占据内存中的一个或多个连续位置。你可以使用 &amp; 操作符获得一个变量的内存地址，这个地址可以赋给一个指针变量。通过指针，你可以读取或修改存储在该地址的数据。这对于数组和自定义数据结构尤其有用，因为可以通过指针算术进行高效的遍历和访问。 函数的地址：C++ 允许获取函数的地址，并将其赋给函数指针。这使得程序可以在运行时决定调用哪个函数，提高了代码的灵活性和可重用性。函数指针广泛应用于回调机制、事件驱动编程和接口设计中。 引用：C++ 的引用机制实际上是一种特殊的语法糖，它在内部使用地址来实现。引用允许你创建一个变量的别名，通过别名可以直接访问和修改原始变量，而无需显式解引用。这样不仅代码更加简洁，而且避免了指针可能带来的错误。 动态内存分配：C++ 通过 new 和 delete 操作符提供了动态内存分配的能力。使用 new 分配的内存位于堆区，它会返回指向分配内存的指针。通过这个指针，程序可以在运行时动态地分配、访问和释放内存。 通过上述机制，C++ 程序可以精确地控制内存的使用方式，从而优化程序性能和资源管理。然而，这也意呀着程序员必须对指针、内存地址以及内存管理有充分的理解，才能有效地利用这些特性编写高效、安全的代码。 编写教程时，目标是清晰、简洁且具有实用性。以下是一个关于“如何在 C++ 中使用指针和地址”教程的示例内容。这段内容旨在介绍初学者到 C++ 的指针和地址概念，帮助他们理解和运用“万物皆地址”的原则。 C++ 指针和地址入门在 C++ 中，理解指针和地址是掌握语言的基石。本教程将引导你通过简单的步骤来理解和使用指针和地址。 1. 理解地址在 C++ 中，每个变量都存储在内存的一个特定位置，这个位置可以通过地址来访问。你可以使用 &amp; 操作符来获取变量的地址。 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; int var = 10; cout &lt;&lt; &quot;变量的地址: &quot; &lt;&lt; &amp;var &lt;&lt; endl; return 0;&#125; 这段代码会输出变量 var 的内存地址。 2. 使用指针指针是存储另一个变量地址的变量。在 C++ 中，你可以使用 * 来声明指针。 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int var = 10; int *ptr = &amp;var; cout &lt;&lt; &quot;ptr 指向的地址: &quot; &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; &quot;ptr 指向的地址上的值: &quot; &lt;&lt; *ptr &lt;&lt; endl; return 0;&#125; 在这个例子中，ptr 是一个指向 var 地址的指针。通过 *ptr，我们可以访问这个地址上的值。 3. 指针的使用场景指针在 C++ 中的应用非常广泛，包括： 动态内存管理：使用 new 和 delete 操作符分配和释放内存。 函数参数传递：通过传递指针或引用来修改函数外的变量。 构建复杂数据结构：如链表、树等。 4. 练习：使用指针交换两个变量的值123456789101112131415#include &lt;iostream&gt;using namespace std;void swap(int *x, int *y) &#123; int temp = *x; *x = *y; *y = temp;&#125;int main() &#123; int a = 5, b = 10; swap(&amp;a, &amp;b); cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; endl; return 0;&#125; 这个练习演示了如何使用指针来交换两个变量的值。 C++ 通过地址修改值在 C++ 中，通过地址修改值是指针操作的一个基本用途。指针是一种特殊的变量，其值为另一个变量的内存地址。通过指针，你可以直接访问和修改它指向的内存位置上存储的数据。这一过程涉及几个关键步骤：获取变量的地址、使用指针指向该地址、通过指针修改该地址上的值。下面通过一个简单的示例来说明这一过程： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int value = 10; // 定义一个变量value并初始化为10 int *ptr = &amp;value; // 定义一个指针ptr，将其初始化为value的地址 cout &lt;&lt; &quot;Original value: &quot; &lt;&lt; value &lt;&lt; endl; // 显示原始的value值 *ptr = 20; // 通过指针ptr修改value的值 cout &lt;&lt; &quot;Modified value: &quot; &lt;&lt; value &lt;&lt; endl; // 显示修改后的value值 return 0;&#125; 在上述代码中： 我们首先定义了一个类型为 int 的变量 value 并初始化为 10。 然后，我们定义了一个类型为 int* 的指针 ptr 并将其初始化为 value 的地址（&amp;value）。 通过 cout 输出语句，我们可以看到 value 的原始值。 接着，我们通过指针 ptr 来修改 value 的值。这里的 *ptr = 20; 表示将 ptr 指向的内存位置（即 value 的位置）上的数据修改为 20。*ptr 是解引用操作符的应用，它获取指针指向的内存地址上存储的值。 最后，再次通过 cout 输出 value 的值，可以看到它已经被修改为 20。 函数传参的内存地址在 C++ 中，理解函数传参的内存地址涉及到两个主要概念：按值传递（Pass by Value）和按引用传递（Pass by Reference）。理解这些概念有助于深入理解 C++ 如何在函数调用中处理参数的内存地址。 按值传递（Pass by Value）当函数参数是按值传递时，函数接收的是实参的一个副本。这意味着函数内部对参数所做的任何修改都不会影响到原始数据。在内存层面，这个过程涉及到将原始数据的值复制到新的内存地址中。这个新的地址是函数参数在函数调用栈上的局部地址。 优点 保护了原始数据，避免了意外修改。 对于基本数据类型，这种方式简单且效率较高。 缺点 对于大型结构或类实例，复制可能导致性能下降。 无法在函数外部反映函数内部对数据的修改。 按引用传递（Pass by Reference）按引用传递意味着函数接收的是实参的引用（或者说是内存地址）。这样，函数内部对参数的任何修改都会直接影响到原始数据。在内存层面，这避免了数据的复制，函数参数直接使用了实参的地址。 优点 可以直接修改原始数据。 避免了大型数据结构的复制，提高了效率。 可以通过返回多个结果值（通过修改传入的引用或指针参数）。 缺点 如果不希望修改原始数据，需要谨慎操作。 使用不当可能导致错误或数据损坏。 举个例子假设我们有一个简单的函数，目的是修改一个整数的值。 1234567891011// 按值传递void addTenByValue(int number) &#123; number += 10; // 这里修改的是number的副本，外部的原始变量不受影响&#125;// 按引用传递void addTenByReference(int &amp;number) &#123; number += 10; // 这里直接修改的是传入变量的值，外部的原始变量也会被修改&#125; 在这个例子中，addTenByValue 函数无法修改外部变量的值，因为它仅操作了参数的副本。而 addTenByReference 函数则直接操作了实参的内存地址，因此它能够修改外部变量的值。","categories":[{"name":"8 - C++","slug":"8-C","permalink":"http://example.com/categories/8-C/"},{"name":"8.1 - C++理论基础","slug":"8-C/8-1-C-理论基础","permalink":"http://example.com/categories/8-C/8-1-C-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++ 函数指针与指针函数,C++11 新特性","slug":"5 C++/C++函数指针与指针函数,C++11 新特性","date":"2023-08-28T18:45:14.000Z","updated":"2024-03-26T07:14:28.072Z","comments":true,"path":"2023/08/29/5 C++/C++函数指针与指针函数,C++11 新特性/","link":"","permalink":"http://example.com/2023/08/29/5%20C++/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0,C++11%20%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"作者：朕小猫与GPT4 C++函数指针在 C++ 中，函数指针是指向函数的指针，允许通过指针调用函数。这种特性让程序在运行时能够选择要调用的函数，增加了代码的灵活性和动态性。理解函数指针对于高级编程技巧，如回调函数、命令模式等是非常重要的。 定义函数指针函数指针的定义需要指定函数的返回类型、指针名称以及函数参数的类型。定义函数指针的基本语法如下： 1返回类型 (*指针变量名)(参数类型列表); 例如，如果你有一个返回类型为 int 并接受两个 int 类型参数的函数，你可以这样定义一个指向该函数的指针： 1int (*funcPtr)(int, int); 使用函数指针一旦定义了函数指针，就可以将其指向具有相应签名的任何函数，然后通过该指针调用函数。这里有一个使用函数指针的简单示例： 123456789101112131415161718#include &lt;iostream&gt;// 定义一个简单的函数int add(int x, int y) &#123; return x + y;&#125;int main() &#123; // 定义一个函数指针并使其指向add函数 int (*funcPtr)(int, int) = add; // 通过函数指针调用函数 int sum = funcPtr(2, 3); std::cout &lt;&lt; &quot;The sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 函数指针的用途函数指针最常见的用途包括： 回调函数：允许库或框架调用在使用库的代码中定义的函数。 事件处理：在发生特定事件时动态决定调用哪个函数。 接口实现：通过函数指针数组或结构体实现类似于面向对象编程中接口或虚函数的功能。 命令模式：将操作封装为对象，允许存储、传递和调用操作。 高级话题随着 C++11 的引入，现代 C++ 更倾向于使用 std::function 和 lambda 表达式来替代裸函数指针，因为它们提供了更高的灵活性和更简洁的语法。例如，std::function 可以存储并调用任何可调用的实体，包括普通函数、lambda 表达式、以及其他具有 operator() 的对象。 举例子，说明函数指针使用的几种场景函数指针在 C++ 中的应用非常广泛，提供了编程的灵活性和动态性。以下是几种典型场景，展示了函数指针的使用： 1. 回调函数回调函数是由用户编写的，但由系统或库在适当的时候调用的函数。函数指针允许用户提供具体的回调函数实现，使得库或框架可以在运行时调用用户定义的代码。 示例： 设计一个简单的事件处理器，当发生某个事件时，调用用户提供的回调函数。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;// 定义回调函数类型using Callback = void(*)(int);// 事件处理器类class EventProcessor &#123;public: void registerCallback(Callback cb) &#123; callbacks.push_back(cb); &#125; void triggerEvent(int eventData) &#123; for (auto&amp; cb : callbacks) &#123; cb(eventData); // 调用回调函数 &#125; &#125;private: std::vector&lt;Callback&gt; callbacks; // 回调函数列表&#125;;// 用户定义的回调函数void onEventTriggered(int data) &#123; std::cout &lt;&lt; &quot;Event triggered with data: &quot; &lt;&lt; data &lt;&lt; std::endl;&#125;int main() &#123; EventProcessor ep; ep.registerCallback(onEventTriggered); // 注册回调函数 ep.triggerEvent(42); // 触发事件，调用回调函数 return 0;&#125; 2. 函数指针数组函数指针数组可以存储指向不同函数的指针，使得程序可以基于运行时决策调用不同的函数。 示例： 创建一个简单的菜单系统，用户输入不同的选项执行不同的操作。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;void function1() &#123; std::cout &lt;&lt; &quot;Executing Function 1&quot; &lt;&lt; std::endl;&#125;void function2() &#123; std::cout &lt;&lt; &quot;Executing Function 2&quot; &lt;&lt; std::endl;&#125;void function3() &#123; std::cout &lt;&lt; &quot;Executing Function 3&quot; &lt;&lt; std::endl;&#125;int main() &#123; void(*functions[3])() = &#123;function1, function2, function3&#125;; int choice; std::cout &lt;&lt; &quot;Enter a choice (0-2): &quot;; std::cin &gt;&gt; choice; if (choice &gt;= 0 &amp;&amp; choice &lt; 3) &#123; (*functions[choice])(); // 调用选中的函数 &#125; else &#123; std::cout &lt;&lt; &quot;Invalid choice&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 3. 接口实现和策略模式通过函数指针，可以模拟面向对象编程中的接口或策略模式，允许在运行时选择不同的算法或行为。 示例： 设计一个简单的排序策略，用户可以选择不同的排序算法。 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using SortAlgorithm = void(*)(std::vector&lt;int&gt;&amp;);void ascendingSort(std::vector&lt;int&gt;&amp; data) &#123; std::sort(data.begin(), data.end());&#125;void descendingSort(std::vector&lt;int&gt;&amp; data) &#123; std::sort(data.begin(), data.end(), std::greater&lt;int&gt;());&#125;void sortData(std::vector&lt;int&gt;&amp; data, SortAlgorithm algorithm) &#123; algorithm(data); // 使用指定的排序算法&#125;int main() &#123; std::vector&lt;int&gt; data = &#123;4, 2, 5, 1, 3&#125;; sortData(data, ascendingSort); for (int n : data) std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; sortData(data, descendingSort); for (int n : data) std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; return 0;&#125; 这些示例展示了函数指针在回调、决策和策略选择等不同编程场景中的应用，证明了其为 C++ 编程带来的灵活性和动态性。 使用 std::function 和 lambda 表达式来替代裸函数指针，举例子std::function 和 lambda 表达式在 C++11 及之后的版本中提供了一种更加灵活和方便的方式来处理可调用对象。它们使得代码更加简洁且易于理解，特别是在需要函数作为参数或回调时。 Lambda 表达式Lambda 表达式提供了一种匿名函数的实现，允许你在需要函数对象的地方快速定义一个函数。Lambda 表达式的基本语法如下： 123[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体&#125;; 使用 std::function 和 Lambda 表达式std::function 是一个模板类，它可以用来存储任何可以调用的目标，如普通函数、Lambda 表达式、成员函数和函数对象。这提供了比裸函数指针更大的灵活性和功能。 下面是一个示例，展示了如何使用 std::function 和 Lambda 表达式来替代裸函数指针： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;functional&gt; // 必须包含这个头文件// 定义一个普通的函数int add(int x, int y) &#123; return x + y;&#125;int main() &#123; // 使用 std::function 存储普通函数 std::function&lt;int(int, int)&gt; func = add; std::cout &lt;&lt; &quot;The sum using a normal function: &quot; &lt;&lt; func(2, 3) &lt;&lt; std::endl; // 使用 std::function 存储 Lambda 表达式 std::function&lt;int(int, int)&gt; lambdaFunc = [](int x, int y) -&gt; int &#123; return x + y; &#125;; std::cout &lt;&lt; &quot;The sum using a lambda expression: &quot; &lt;&lt; lambdaFunc(2, 3) &lt;&lt; std::endl; return 0;&#125; 在这个示例中，我们首先定义了一个普通的函数 add。然后，我们创建了两个 std::function 对象，一个用来存储普通函数 add，另一个用来存储一个实现相同功能的 Lambda 表达式。通过这种方式，我们可以看到 std::function 和 Lambda 表达式如何提供了一种更加灵活的方式来处理可调用对象，而不必直接使用函数指针。 优点 std::function 可以存储任何类型的可调用对象，提供了极大的灵活性。 Lambda 表达式使得定义和使用匿名函数变得简单，特别是在作为一次性使用函数或局部函数时非常有用。 使用 std::function 和 Lambda 表达式可以使代码更加清晰和易于维护，特别是在复杂的项目中。 通过这种方式，C++11 提供的这些特性让处理函数和回调等场景变得更加优雅和高效。 C ++ 指针函数在 C++ 中，术语“指针函数”通常被误解或使用不当。实际上，人们通常是指返回指针的函数，或者简称为“函数返回指针”。这种类型的函数在使用时非常有用，尤其是当你需要从函数中返回动态分配的内存或数组、多级指针、或者指向不同数据结构的指针时。 定义返回指针的函数要定义一个返回指针的函数，你需要在函数声明的返回类型前加上*来指明返回的是指针。这里有一个简单的例子，说明如何定义和使用返回指针的函数： 1234567891011121314#include &lt;iostream&gt;// 定义一个返回int指针的函数int* getIntPtr() &#123; int* ptr = new int(10); // 动态分配内存 return ptr; // 返回指向int的指针&#125;int main() &#123; int* myPtr = getIntPtr(); // 调用函数，获取返回的指针 std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *myPtr &lt;&lt; std::endl; // 使用指针访问值 delete myPtr; // 释放分配的内存 return 0;&#125; 在这个例子中，getIntPtr函数分配了一个int类型的动态内存，并返回一个指向这块内存的指针。在main函数中，我们调用了getIntPtr，并使用返回的指针来访问和操作内存。最后，不要忘记使用delete释放动态分配的内存，以避免内存泄露。 注意事项 返回局部变量的地址是危险的，因为当函数执行完毕后，局部变量的存储空间会被回收，这样返回的指针会指向一个不再有效的内存区域，导致未定义行为。 当你的函数返回指向动态分配内存的指针时，确保在适当的时候释放这些内存，以避免内存泄露。 考虑使用智能指针（如std::unique_ptr或std::shared_ptr）来管理动态分配的内存，这样可以自动管理内存的生命周期，减少内存泄露的风险。 返回指针的函数提供了一种灵活的方式来创建和管理动态资源，但同时也需要谨慎处理指针和内存管理相关的问题。 如何使用智能指针（如std::unique_ptr或std::shared_ptr）来管理动态分配的内存在 C++ 中，智能指针是一种模板类，用于自动管理动态分配的内存，确保资源在不再需要时被正确释放，从而避免内存泄露。C++11 引入了两种主要的智能指针类型：std::unique_ptr 和 std::shared_ptr，它们分别用于独占所有权和共享所有权的场景。 使用 std::unique_ptrstd::unique_ptr 是一种独占所有权的智能指针，保证同一时间只有一个 std::unique_ptr 指向特定的资源。当 std::unique_ptr 被销毁或被重新分配时，它指向的对象也会被自动删除。 基本用法：1234567891011121314151617#include &lt;memory&gt;#include &lt;iostream&gt;class MyObject &#123;public: MyObject() &#123; std::cout &lt;&lt; &quot;MyObject created\\n&quot;; &#125; ~MyObject() &#123; std::cout &lt;&lt; &quot;MyObject destroyed\\n&quot;; &#125; void myMethod() &#123; std::cout &lt;&lt; &quot;MyMethod called\\n&quot;; &#125;&#125;;int main() &#123; std::unique_ptr&lt;MyObject&gt; myUniquePtr = std::make_unique&lt;MyObject&gt;(); myUniquePtr-&gt;myMethod(); // 使用-&gt;操作符调用成员函数 // 不需要手动删除对象，当unique_ptr离开作用域时，对象会被自动销毁 return 0;&#125; 使用 std::shared_ptrstd::shared_ptr 是一种共享所有权的智能指针，允许多个 std::shared_ptr 实例指向同一个对象。内部使用引用计数来跟踪有多少个 std::shared_ptr 指向同一个资源，当最后一个这样的指针被销毁时，所指向的对象也会被删除。 基本用法：1234567891011121314151617181920#include &lt;memory&gt;#include &lt;iostream&gt;class MyObject &#123;public: MyObject() &#123; std::cout &lt;&lt; &quot;MyObject created\\n&quot;; &#125; ~MyObject() &#123; std::cout &lt;&lt; &quot;MyObject destroyed\\n&quot;; &#125; void myMethod() &#123; std::cout &lt;&lt; &quot;MyMethod called\\n&quot;; &#125;&#125;;int main() &#123; std::shared_ptr&lt;MyObject&gt; mySharedPtr1 = std::make_shared&lt;MyObject&gt;(); &#123; std::shared_ptr&lt;MyObject&gt; mySharedPtr2 = mySharedPtr1; // 共享所有权 mySharedPtr2-&gt;myMethod(); // 当mySharedPtr2离开作用域时，对象不会被销毁，因为mySharedPtr1仍然存在 &#125; // 只有当最后一个指向对象的shared_ptr（这里是mySharedPtr1）离开作用域时，对象才会被销毁 return 0;&#125; 注意事项 使用智能指针可以减少内存泄露的风险，但仍需要注意循环引用问题，尤其是在使用 std::shared_ptr 时。循环引用会阻止引用计数达到零，导致内存泄露。解决循环引用问题通常使用 std::weak_ptr。 std::unique_ptr 通过移动语义实现所有权的转移，不能被复制。 std::shared_ptr 适用于资源需要被多个所有者共享的情况，但增加了额外的开销（引用计数管理）。 智能指针是现代 C++ 管理动态资源的首选方式，相比裸指针，它们提供了更安全、更简洁的资源管理机制。","categories":[{"name":"8 - C++","slug":"8-C","permalink":"http://example.com/categories/8-C/"},{"name":"8.1 - C++理论基础","slug":"8-C/8-1-C-理论基础","permalink":"http://example.com/categories/8-C/8-1-C-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Android Framework 专项 - IPC Binder 机制（一）","slug":"3 Android/Framework/04-Android-Framework-专项-IPC-Binder-机制1","date":"2023-08-27T15:16:28.000Z","updated":"2024-04-09T10:06:17.152Z","comments":true,"path":"2023/08/27/3 Android/Framework/04-Android-Framework-专项-IPC-Binder-机制1/","link":"","permalink":"http://example.com/2023/08/27/3%20Android/Framework/04-Android-Framework-%E4%B8%93%E9%A1%B9-IPC-Binder-%E6%9C%BA%E5%88%B61/","excerpt":"","text":"问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein Q: Binder 是什么？binder 是如何出现的 Q: Binder 通信模型是什么？ Q: Aidl 通信机制是什么？ Q: Bindservice 流程分析 Q: Binder 通信是如何走到 Native 层的 Q: ServiceManager 是什么？ Q: Binder 通信之 Client 端调度流程解析 从 Android 系统设计说起Android 的系统的三个层次application 应用层 - Framework 层- native 层 Android 中的应用层和系统服务层不在同一个进程，系统服务在单独的进程中。Android 中的不同应用属于不同的进程，每一个应用是 zygote fork 出来的 为了安全，Android 的应用层与系统层之间是隔离的 Android 系统 IPC 原理 每个 Android 的进程，只能运行在自己进程所拥有的虚拟地址空间。对应一个 4GB 的虚拟地址空间，其中 3GB 是用户空间，1GB 是内核空间，当然内核空间的大小是可以通过参数配置调整的。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client 进程向 Server 进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client 端与 Server 端进程往往采用 ioctl 等方法跟内核空间的驱动进行交互。 用户空间和内核空间知识补充怎么理解不同进程之间用户空间不能共享，而内核空间却是可共享的？ 用户空间的共享： 在标准情况下，不同进程的用户空间是彼此隔离的，不能直接共享内存。每个进程有自己独立的虚拟地址空间，不同进程的相同虚拟地址并不会映射到相同的物理内存。这意味着一个进程不能直接访问另一个进程的用户空间。 内核空间的共享： 内核空间是操作系统内核的一部分，对所有进程来说都是共享的。这是因为内核提供了操作系统的核心功能，比如进程调度、内存管理、文件系统等。不同进程需要与内核进行交互来请求服务和操作资源。因此，所有进程都共享一个操作系统内核。 内核空间中的数据隔离： 尽管内核空间对所有进程来说是共享的，但内核本身会实施严格的隔离措施，以防止一个进程的操作影响其他进程。内核使用许多机制来确保不同进程的请求和数据是独立的，从而保障系统的稳定性和安全性。 内核空间中的共享数据结构： 在某些情况下，内核中可能存在一些数据结构是为多个进程共享的，例如文件描述符表、进程控制块等。这种共享是通过内核维护的数据结构来实现的，而不是直接让不同进程的内核空间映射到相同的物理内存。 总结起来，不同进程的用户空间通常是不能直接共享的，每个进程都有自己的独立虚拟地址空间。但所有进程共享同一个内核空间，内核提供了操作系统的核心功能。内核空间中的数据隔离和共享是通过内核内部的机制来实现的。 页表知识补充页表是操作系统中用于管理虚拟内存与物理内存之间映射关系的数据结构。在计算机中，虚拟内存是指操作系统为每个进程提供的独立的内存地址空间，而物理内存则是实际的硬件内存。由于物理内存有限，虚拟内存允许多个进程同时运行，而不会受到物理内存大小的限制。 页表的主要功能是将虚拟地址转换为物理地址。当进程访问虚拟地址时，操作系统通过页表查找，找到对应的物理地址，从而实际完成内存的读写操作。 具体来说，页表包含了虚拟地址和物理地址之间的映射关系。每个进程都有自己的页表，其中的页表项记录了虚拟地址的页号（page number）与物理地址的页框号（page frame number）之间的对应关系。页框是物理内存的一个固定大小的块，而页是虚拟内存的一个固定大小的块。通过查找页表，操作系统可以找到虚拟地址对应的物理地址，从而实现内存访问。 总结 用户空间与内核空间: IPC 机制总的操作又可以分为用户空间进行的操作和内核空间进行的操作 内核空间中的数据结构不同: 不同 IPC 机制内核中的数据结构不同 复制与映射: IPC 机制利用进程间可共享的内核空间来完成底层通信工作，其中我们可以简单的分为复制和虚拟内存映射两种方式 我们从这几个角度来快速的区分 IPC 机制 IPC-共享内存用户空间与内核空间行为用户空间： 创建共享内存： 进程通过系统调用在用户空间申请一块共享内存，得到一个唯一的标识符。 映射共享内存： 进程使用系统调用将共享内存映射到自己的虚拟地址空间，从而可以直接访问这块内存区域。这个映射实际上是指向了内核空间中设置的共享页表项。 读写数据： 进程可以在映射的共享内存区域进行读写操作，与普通内存一样，无需复杂的通信操作。 内核空间： 设置共享内存页表： 内核负责在共享内存的物理地址和虚拟地址之间建立映射关系，设置页表项，确保多个进程能够访问相同的物理内存。 同步和权限控制： 内核维护共享内存的元信息，包括大小、权限等。在多个进程访问时，内核会处理访问的同步和权限控制问题。 不同进程的映射： 当不同进程请求映射共享内存时，内核将相同的物理内存映射到不同的进程虚拟地址空间，使它们共享同一块内存。它们共享相同的页表项，由 TLB（Translation Lookaside Buffer，页表查找缓冲器）实现。 内核空间中的关键数据结构共享的页表项 复制与映射双进程分享的是共享页表项，物理地址内数据只有一份，复制次数 0 IPC-管道不同管道类型无名管道（Unnamed Pipe） 无名管道是一种单向通信机制，只能用于父子进程或者具有共同祖先的进程之间通信。 创建无名管道使用的是 pipe() 系统调用。该调用返回一对文件描述符，一个用于读取，一个用于写入。 无名管道的数据传输是单向的，数据写入一个描述符后可以被另一个描述符读取。 在很多系统上，无名管道的缓冲区大小是固定的，通常为一页大小（例如4KB）。这意味着管道的数据容量有限，无法容纳大规模的数据。 有名管道（Named Pipe，FIFO）: 有名管道是一种基于文件系统的命名管道，可以用于任意进程之间通信，不受关系限制。 使用 mkfifo 命令或 mkfifo() 系统调用创建有名管道。它在文件系统中创建一个特殊的文件节点，进程可以像读写普通文件一样读写这个节点来进行通信。 有名管道的数据传输是单向的，需要同时创建一个读取端和一个写入端。多个进程可以连接到同一个有名管道进行通信。 有名管道（Named Pipe，FIFO）的缓冲区大小是由系统内核设置的，并且通常与页大小（Page Size）有关。在大多数Linux系统中，页大小通常为4KB，因此默认情况下，有名管道的缓冲区大小也会是4KB。 某些系统可能会允许你通过特定的系统参数进行配置。具体的设置方法可能会因操作系统版本和发行版而异。 管道的指针操作，写满与阻塞写入从头指针开始，读取从尾指针开始。写入之后，头指针挪动，读取之后尾指针挪动。如果是头指针赶上尾指针，那么管道被写满，写就会被阻塞。如果是尾指针赶上头指针，那么管道为空，read阻塞。 用户空间与内核空间行为用户空间： 创建管道： 进程通过系统调用在用户空间创建一个管道，得到两个文件描述符，一个用于读取，一个用于写入。 写入数据： 进程使用写入文件描述符将数据写入管道。 读取数据： 进程使用读取文件描述符从管道中读取数据。 内核空间： 管道管理： 内核维护管道的数据结构，包括缓冲区和读写指针。 数据传递： 内核通过管道将写入的数据从一个进程的写入文件描述符复制到另一个进程的读取文件描述符。 进程同步： 内核确保在多个进程访问管道时的同步，避免数据错乱。 内核空间中的关键数据结构单向管道 复制与映射在基本的管道（Pipe）IPC 机制中，数据实际上只涉及一次复制操作，因为管道是一个字节流传输机制，数据在管道中以字节为单位连续传输。 简单的说 Linux 是文件系统，管道也是文件，这个文件由两个指针进行操作，一头写入一头读取，当一个进程将数据写入管道时，数据直接写入这个文件内，即管道的缓冲区中，当另一个进程从管道中读取数据时，这些数据会被从管道的缓冲区读取到接收方进程的内存中，而管道不持有这些数据，数据的角度来看，实际上只有一次数据复制。 IPC-消息队列用户空间与内核空间行为用户空间： 创建消息队列： 进程通过系统调用在用户空间创建一个消息队列，得到一个唯一的标识符。 发送消息： 进程使用系统调用将消息发送到消息队列，包括消息类型和数据（需要通信双方约定好）。 接收消息： 进程使用系统调用从消息队列中接收消息，根据消息类型读取相应的数据。 内核空间： 消息队列管理： 内核维护消息队列的元信息，包括消息队列的状态、大小等。 消息传递： 内核将进程发送的消息复制到消息队列中，或从消息队列中复制消息给接收的进程。（跨进程消息队列两次复制） 进程同步： 内核确保在多个进程访问消息队列时的同步，以避免竞态条件。 内核空间中的关键数据结构消息队列 复制与映射两次复制 写入数据： 当一个进程将消息写入消息队列时，消息数据会从发送方进程的内存复制到消息队列的内核缓冲区中。这是第一次复制操作。 读取数据： 在接收方进程中，数据需要从内核缓冲区复制到接收方进程的内核空间中。这是第二次复制操作。 IPC-Socket用户空间与内核空间行为用户空间： 创建 Socket： 进程通过系统调用在用户空间创建一个 Socket，得到一个文件描述符，用于读写数据。 发送数据： 进程使用文件描述符发送数据到指定的 Socket。 接收数据： 进程使用文件描述符从 Socket 中接收数据。 内核空间： Socket 管理： 内核维护 Socket 的数据结构，包括缓冲区、连接状态等。 数据传递： 内核通过 Socket 将进程发送的数据从一个进程的发送缓冲区复制到另一个进程的接收缓冲区。 连接管理： 内核负责管理连接的建立、维护和断开，以及处理各种网络协议。 内核空间中的关键数据结构 内核空间中的关键数据结构 发送缓冲区： 发送方进程使用 Socket 发送数据时，数据首先被复制到发送缓冲区（Send Buffer）中。这个缓冲区在内核空间中，用于临时存储待发送的数据。发送缓冲区的大小可以由操作系统参数或套接字选项进行配置。 接收缓冲区： 接收方进程使用 Socket 接收数据时，数据会被存储在接收缓冲区（Receive Buffer）中。这个缓冲区同样位于内核空间，用于临时存储接收到的数据。接收缓冲区的大小也可以通过操作系统参数或套接字选项进行配置 复制与映射linux 2.4 内核以下两次用户、内核态的切换，三次数据拷贝 linux 2.4 内核及其以上两次用户、内核态的切换，两次数据拷贝 内核态零拷贝原理数据不再被复制到 socket 关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到 socket 关联的缓冲区中。DMA 直接将内核中的缓冲区中的数据传输给协议引擎，消除了那一次需要 cpu 周期的数据复制。 IPC-Binder用户空间与内核空间行为从用户空间和内核空间的角度来看，IPC（Inter-Process Communication，进程间通信）Binder 的工作可以简洁地描述如下： 用户空间： 创建 Binder 对象： 进程通过系统调用创建 Binder 对象，通常是 Binder 类的子类实例。这个对象用于表示一个通信通道，可以用来发送和接收数据。 发送数据： 进程通过 Binder 对象将数据（通常是 Parcel 对象）发送到另一个进程。这个过程会将数据传递给内核空间的 Binder 驱动。 接收数据： 进程通过 Binder 对象接收另一个进程发送的数据。接收的数据也是以 Parcel 对象的形式返回给用户空间。 内核空间： Binder 驱动： Binder 驱动位于内核空间，负责管理 Binder 通信。当进程发送数据时，数据会传递给 Binder 驱动。 数据传递： Binder 驱动将进程发送的数据从发送方进程的用户空间复制到接收方进程的用户空间，这一过程中涉及数据的复制和映射。 线程池管理： Binder 驱动还管理了一个线程池，用于处理进程间的数据传递请求。这确保了数据的传递不会阻塞主线程，提高了性能。 权限和安全性： Binder 驱动实施权限和安全性控制，确保只有经过授权的进程可以进行 Binder 通信。 内核空间中的关键数据结构指向物理内存的内核空间虚拟内存 复制与映射复制：发送方进程将数据复制到内核空间虚拟内存中。映射：将这个内核中的虚拟内存映射给接收方进程。 为什么 Android 要采用 Binder 作为 IPC 机制？在下不才，这个问题，交给大佬回答 作者：Gityuan链接：https://www.zhihu.com/question/39440766/answer/89210950来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 在开始回答 前，先简单概括性地说说Linux现有的所有进程间IPC方式： 管道: 在创建时分配一个page大小的内存，缓存区大小比较有限。 消息队列: 信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信。 共享内存: 无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快，但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决。 套接字: 作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信。 信号量: 常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等。 Android的内核也是基于Linux内核，为何不直接采用Linux现有的进程IPC方案呢，难道Linux社区那么多优秀人员都没有考虑到有Binder这样一个更优秀的方案，是google太过于牛B吗？事实是真相并非如此，请细细往下看，您就明白了。 接下来正面回答这个问题，从5个角度来展开对Binder的分析： （1）从性能的角度 数据拷贝次数：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。 （2）从稳定性的角度Binder是基于C&#x2F;S架构的，简单解释下C&#x2F;S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。 仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制，那么更重要的原因是： （3）从安全的角度传统Linux IPC的接收方无法获得对方进程可靠的UID&#x2F;PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。 Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C&#x2F;S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID&#x2F;PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。 针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。 Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：Android源码的Binder权限是如何控制？ -Gityuan的回答 传统IPC只能由用户在数据包里填入UID&#x2F;PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。 说到这，可能有人要反驳，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在Google举办的Android Bootcamp 2016大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。 话题扯远了，继续说Binder。 （4）从语言层面的角度大家多知道Linux是基于C语言面向过程的语言，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。 另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制，Android中的Kill Process采用的signal（信号）机制等等。而Binder更多则用在system_server进程与上层App层的IPC交互。 (5) 从公司战略的角度 总所周知，Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。 而Android 之父 Andy Rubin对于GPL显然是不能接受的，为此，Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性，仍有较大争议，但至少目前缓解Android，让GPL止步于内核空间，这是Google在GPL Linux下 开源与商业化共存的一个成功典范。 有了这些铺垫，我们再说说Binder的今世前缘 Binder是基于开源的 OpenBinder实现的，OpenBinder是一个开源的系统IPC机制,最初是由 Be Inc.开发，接着由 Palm, Inc. 公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择。 另外，再说一点关于OpenBinder，在2015年OpenBinder以及合入到Linux Kernel主线 3.19版本，这也算是Google对Linux的一点回馈吧。 综合上述5点，可知Binder是Android系统上层进程间通信的不二选择。 IPC 原理来自于 gityuan: http://gityuan.com/2015/10/31/binder-prepare/ 参考资料：《计算机操作系统》","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"}],"tags":[]},{"title":"Android Framework 专项 - Handler（三）","slug":"3 Android/Framework/03-Android-Framework-专项-Handler3","date":"2023-08-27T13:59:44.000Z","updated":"2024-04-09T10:03:12.596Z","comments":true,"path":"2023/08/27/3 Android/Framework/03-Android-Framework-专项-Handler3/","link":"","permalink":"http://example.com/2023/08/27/3%20Android/Framework/03-Android-Framework-%E4%B8%93%E9%A1%B9-Handler3/","excerpt":"","text":"要理解 Message 的创建，先要说内存抖动内存抖动的原因及引发的问题在 Android 虚拟机中，当我们在应用程序中创建大量的临时对象，并且这些对象的存在时间很短暂，虚拟机会识别这些临时对象并将它们标记为待清理的垃圾对象，以便在适当的时候回收它们。然而，这个垃圾回收过程可能会引发一个称为“stop the world”的现象。所谓“stop the world”指的是，在进行垃圾回收的过程中，虚拟机会暂停应用程序的正常执行，以便能够安全地识别和回收这些临时对象。 在 Java 字节码中，创建一个对象通常需要执行三个关键操作: new、dup 和 invokespecial。这三个操作合在一起构成了对象创建的原子过程。 虚拟机通常通过两种方式来判断一个对象是否是垃圾。一种方式是使用“引用计数”机制，但这种方法存在循环引用的问题，因此无法完全准确地标记垃圾对象，从而导致垃圾回收不彻底。另一种方式是使用“根可达”（或称为“根引用”）的方式，即从根对象（如线程栈、静态变量等）开始，追踪对象之间的引用关系，从而判断哪些对象是可达的，哪些是垃圾。 然而，在标记垃圾对象的过程中，如果垃圾回收线程与创建对象的线程同时工作，就可能出现问题。例如，如果一个对象刚刚被创建但尚未与变量关联，而垃圾回收线程已经扫描到这个对象并标记为垃圾，那么在后续的垃圾回收过程中，这个对象可能会被回收，而在应用程序中使用相关变量时可能会触发空指针异常。为了避免这种情况，标记垃圾的过程通常需要暂停所有工作线程，确保在标记过程中不会有对象的状态发生变化。这就是为什么在进行垃圾回收时会出现应用程序“停顿”的现象。 然而，如果垃圾回收过程耗时过长，会导致应用程序长时间无响应，造成卡顿现象。因此，我们需要尽量避免在应用中创建大量生命周期很短的临时对象，以减少垃圾回收的频率和影响。 内存抖动的原因: 创建了大量的生命周期很短的对象。导致的问题: 在用户看来程序出现了卡顿。 Message 中 obtain() 与 recycle()显而易见，Message 那真是生命周期极短数量极其庞大，是最容易内存抖动的地方所以 Message 内存必须被复用 我们说说 Message 的销毁与创建 创建: android.os.Message#obtain()注意：说创建是不准确的，应该是提供 1234567891011121314151617/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 这段代码是用于在 Android 中创建和管理消息对象的一部分。它通过维护一个对象池，允许在需要时重复利用已有的消息对象，从而减少内存分配和垃圾回收的开销。当需要获取一个新的消息对象时，它会首先检查对象池是否有可用的对象。如果有，它会从对象池中取出一个对象并重置其状态，然后返回；如果对象池为空，它会创建一个新的消息对象并返回。这种做法有助于提高应用程序的性能和效率。 12345synchronized (sPoolSync) &#123; if (sPool != null) &#123; ... &#125;&#125; 1Message m = sPool; 1sPool = m.next; 1m.next = null; 123m.flags=0;sPoolSize--;return m; 回收: android.os.Message#recycle()123456789101112131415161718/** * Return a Message instance to the global pool. * &lt;p&gt; * You MUST NOT touch the Message after calling this function because it has * effectively been freed. It is an error to recycle a message that is currently * enqueued or that is in the process of being delivered to a Handler. * &lt;/p&gt; */public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return; &#125; recycleUnchecked();&#125; 这里提一下 gCheckRecycle 12345public static void updateCheckRecycle(int targetSdkVersion) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123; gCheckRecycle = false; &#125;&#125; 在较低版本的 Android 上 ( &lt; 5.0 )，某些检查可能会导致不必要的异常情况，如 IllegalStateException。这可能会影响应用程序的稳定性。通过避免这些检查，可以避免异常的抛出，提高应用程序的可靠性。 回收: android.os.Message#recycleUnchecked1234567891011121314151617181920212223242526272829/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */@UnsupportedAppUsagevoid recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 123456789101112flags = FLAG_IN_USE;what = 0;arg1 = 0;arg2 = 0;obj = null;replyTo = null;sendingUid = UID_NONE;workSourceUid = UID_NONE;when = 0;target = null;callback = null;data = null; 消息的标志位 flags 的含义是消息对象是否正在使用中。 123456789@UnsupportedAppUsagevoid recycleUnchecked() &#123; ... synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; ... &#125; &#125;&#125; 在同步块中，检查消息池的大小是否小于最大池大小（MAX_POOL_SIZE）。 如果是，将当前消息对象放入消息池的链表中，以供将来重用。 更新消息池的大小。 1next=sPool; 1sPool=this; 内存抖动参考自:知乎博主Android小瓜: Android 性能优化大法——内存抖动原文链接: https://zhuanlan.zhihu.com/p/575959909 android.os.Message#obtain() 与 android.os.Message#recycleUnchecked 相关图片来自于:版权声明：本文为CSDN博主「-_-void」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xmh19936688/article/details/51901338","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"}],"tags":[]},{"title":"Android Framework 专项 - Handler（二）","slug":"3 Android/Framework/02-Android-Framework-专项-Handler2","date":"2023-08-23T10:38:38.000Z","updated":"2023-08-23T10:38:38.000Z","comments":true,"path":"2023/08/23/3 Android/Framework/02-Android-Framework-专项-Handler2/","link":"","permalink":"http://example.com/2023/08/23/3%20Android/Framework/02-Android-Framework-%E4%B8%93%E9%A1%B9-Handler2/","excerpt":"","text":"MessageQueue 到底是什么?从 MessageQueue 的创建说起1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//保证了MessageQueue的唯一性 mThread = Thread.currentThread();&#125; MessageQueue 就是在 Looper 的构造方法里创建的，一个 Looper 就对应了一个 MessageQueue。 MessageQueue 如何实现线程间的数据隔离线程是不持有系统资源的进程，所以同一个进程中的线程是共用的同一个进程持有的内存，说人话就是进程中持有的内存中的变量和数据每个线程都可以直接读取，MessageQueue 是存放线程要处理的消息的，我们当然不希望它是进程持有的线程之间共享的，不能被其他的线程所干扰，换句话说 MessageQueue 必须是线程隔离的 android.os.Looper#prepare(boolean) 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));//把新创建的 Looper 和 ThreadLocal 关联起来，保证 looper 的唯一性&#125; 注意 Looper 是一个静态类非一个实例，在 Looper 的 prepare 阶段，会去 new Looper(quitAllowed)，并将其放入 ThreadLocal，这样就让 Looper 成为了 线程变量，而 MessageQueue 由 Looper 创建并持有，所以 MessageQueue 自然也成了 线程变量，这样就实现了每个线程有自己独立的 Looper 和 MessageQueue 实例，且相互隔离。 MessageQueue 是每个线程独有的。每个线程都拥有自己的消息队列，因此在不同的线程之间无法直接共享消息队列。消息是在一个线程中创建和发送到该线程的消息队列，然后由该线程的 Looper 从队列中取出并处理。 1`ThreadLocal` 是一个线程级别的存储，它在每个线程中维护一个独立的存储空间（`ThreadLocalMap`），每个存储空间使用 `ThreadLocal` 对象作为键。不同线程的存储空间互不干扰，实现了线程间的数据隔离；但在同一个线程内，`ThreadLocal` 对象可以共享，对应的数据副本在不同方法间保持一致。、 MessageQueue 同步屏障试想一种情况 MessageQueue 需要处理 android.os.MessageQueue#next 中的另一种执行逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@UnsupportedAppUsageMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 我们重点看这一段 1234567if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 如果 msg !&#x3D; null，而 msg.target &#x3D;&#x3D; null 的时候，android.os.MessageQueue#next 执行了完全不同的另一种逻辑，target 就是 msg 的目标 handler，也就是说如果 msg 没有目标 handler 的时候，那么 msg 就是一个屏障消息，android.os.MessageQueue#next 就会进入无限循环读取异步消息的逻辑 从这里我们知道 MessageQueue 提供了一个屏障，这个屏障可以让 MessageQueue 越过所有同步消息优先执行异步消息 我们看看这个屏障该如何升起与取消 简单的发送一个 msg.target &#x3D;&#x3D; null 的消息升起同步屏障可以简单的发送一个 msg.target &#x3D;&#x3D; null 的消息来升起这个屏障吗？尝试一下你就会发现出现了”Message must have a target.”的异常 android.os.MessageQueue#enqueueMessage msg.target &#x3D;&#x3D; null 的危险性与抛出的异常123456boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; ...&#125; 我们发现 android.os.MessageQueue#enqueueMessage 第一步就是检查 msg.target 是否为 null，msg.target &#x3D;&#x3D; null 极度危险，一旦消息没有正确的被处理，会导致整个 MessageQueue 进入异步消息的死循环无法退出，因此 消息屏障的触发与取消必须被管控起来 严格管控下的同步屏障的触发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Posts a synchronization barrier to the Looper&#x27;s message queue. * * Message processing occurs as usual until the message queue encounters the * synchronization barrier that has been posted. When the barrier is encountered, * later synchronous messages in the queue are stalled (prevented from being executed) * until the barrier is released by calling &#123;@link #removeSyncBarrier&#125; and specifying * the token that identifies the synchronization barrier. * * This method is used to immediately postpone execution of all subsequently posted * synchronous messages until a condition is met that releases the barrier. * Asynchronous messages (see &#123;@link Message#isAsynchronous&#125; are exempt from the barrier * and continue to be processed as usual. * * This call must be always matched by a call to &#123;@link #removeSyncBarrier&#125; with * the same token to ensure that the message queue resumes normal operation. * Otherwise the application will probably hang! * * @return A token that uniquely identifies the barrier. This token must be * passed to &#123;@link #removeSyncBarrier&#125; to release the barrier. * * @hide */@UnsupportedAppUsage@TestApipublic int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 这段代码是 Android 消息机制中的一部分，用于实现同步屏障（Sync Barrier）。同步屏障是一种机制，可以用来控制消息队列中的消息执行顺序，特别是用于确保后续的同步消息在某个条件满足之前被阻塞执行。下面对这段代码进行分析： postSyncBarrier() 方法： 这个方法是向消息队列中添加一个同步屏障。 同步屏障是一种特殊的消息，它会阻塞后续的同步消息的执行，直到同步屏障被释放。 该方法返回一个用于标识同步屏障的 token，这个 token 在稍后调用 removeSyncBarrier() 方法时需要使用。 postSyncBarrier(long when) 方法： 这个方法是 postSyncBarrier() 的内部实现。 该方法会创建一个同步屏障消息，设置其触发时间（when）和一个唯一的 token。 同步屏障消息将被插入消息队列中，并根据触发时间排序。 在插入同步屏障消息时： 遍历消息队列，找到合适的位置插入同步屏障消息，以保持消息队列的顺序。 如果同步屏障消息需要插入的位置在已有消息之后，将同步屏障消息插入到该位置之后。 如果同步屏障消息需要插入的位置在已有消息之前，将同步屏障消息作为新的头部消息。 总结起来，这段代码实现了向消息队列中插入同步屏障消息的功能。同步屏障消息的作用是阻塞后续的同步消息的执行，直到满足某个条件后释放同步屏障。这种机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足之前某些消息不被执行。 严格管控下的同步屏障的取消12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Removes a synchronization barrier. * * @param token The synchronization barrier token that was returned by * &#123;@link #postSyncBarrier&#125;. * * @throws IllegalStateException if the barrier was not found. * * @hide */@UnsupportedAppUsage@TestApipublic void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException(&quot;The specified message queue synchronization &quot; + &quot; barrier token has not been posted or has already been removed.&quot;); &#125; final boolean needWake; if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycleUnchecked(); // If the loop is quitting then it is already awake. // We can assume mPtr != 0 when mQuitting is false. if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125;&#125; 这段代码是用于移除同步屏障（Sync Barrier）的逻辑。它会从消息队列中移除指定的同步屏障消息，并在必要时唤醒消息队列，以继续处理后续的消息。下面对这段代码进行分析： removeSyncBarrier(int token) 方法： 这个方法用于移除同步屏障。 它接受一个参数 token，即之前调用 postSyncBarrier() 方法返回的标识同步屏障的 token。 如果指定的同步屏障消息被找到并移除，将会在必要时唤醒消息队列。 在移除同步屏障消息时： 遍历消息队列，寻找包含指定 token 的同步屏障消息。 如果找到了匹配的同步屏障消息，将其从消息队列中移除。 如果在移除同步屏障消息后，消息队列不再被其他消息阻塞，会将队列唤醒，以继续处理后续的消息。 recycleUnchecked() 方法： 在移除同步屏障消息后，调用这个方法将消息对象回收，以便释放资源。 总结起来，这段代码实现了移除同步屏障消息的功能。当同步屏障条件满足后，通过调用 removeSyncBarrier() 方法来移除同步屏障消息，从而解除对后续同步消息的阻塞。这个机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足后执行后续的同步消息。 从 ViewRootImpl 看同步屏障的使用android.view.ViewRootImpl#scheduleTraversals 1234567891011@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 同步屏障的触发 1mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); 再看一下发送消息的逻辑 android.view.Choreographer#postCallback 123456789101112131415161718/** * Posts a callback to run on the next frame. * &lt;p&gt; * The callback runs once then is automatically removed. * &lt;/p&gt; * * @param callbackType The callback type. * @param action The callback action to run during the next frame. * @param token The callback token, or null if none. * * @see #removeCallbacks * @hide */@UnsupportedAppUsage@TestApipublic void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125; android.view.Choreographer#postCallbackDelayed 1234567891011121314151617181920212223242526272829/** * Posts a callback to run on the next frame after the specified delay. * &lt;p&gt; * The callback runs once then is automatically removed. * &lt;/p&gt; * * @param callbackType The callback type. * @param action The callback action to run during the next frame after the specified delay. * @param token The callback token, or null if none. * @param delayMillis The delay time in milliseconds. * * @see #removeCallback * @hide */@UnsupportedAppUsage@TestApipublic void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; if (action == null) &#123; throw new IllegalArgumentException(&quot;action must not be null&quot;); &#125; if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) &#123; throw new IllegalArgumentException(&quot;callbackType is invalid&quot;); &#125; postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125; 重点: android.view.Choreographer#postCallbackDelayedInternal 1234567891011121314151617181920212223private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType + &quot;, action=&quot; + action + &quot;, token=&quot; + token + &quot;, delayMillis=&quot; + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 我们看异步消息的发送逻辑 1234Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);msg.arg1 = callbackType;msg.setAsynchronous(true);mHandler.sendMessageAtTime(msg, dueTime); android.view.ViewRootImpl#unscheduleTraversals 12345678void unscheduleTraversals() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); mChoreographer.removeCallbacks( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); &#125;&#125; android.view.ViewRootImpl#unscheduleTraversals 的调用时机比较有意思，这里暂不做更多的分析 Skipped 30 frames!错误信息在进行 UI 更新的时候，如果 UI 线程忙碌，主线程有时会抛出异常信息：Skipped 30 frames! The application may be doing too much work on its main thread. 错误原因这是因为触发屏障的实际操作是发送一个 target 为 null 的 msg，但是如果这个 target 为 null 的消息被前面的耗时消息所耽误而一直没能执行，导致后面不断发送来的需要立即执行的异步消息都被耽误，触发同步屏障之后，系统发现，本该立即执行的异步消息已经积累了30帧只会，就会报出这个主线程忙碌的错误 改进方法罪魁祸首就是那个耽误了 target &#x3D;&#x3D; null 的同步屏障 msg 执行的 msg，这个同步消息的执行如此之耗时，以至于我们必须考虑对其优化或者考虑是不是适合放在主线程可以放到其他线程去执行 MessageQueue 中的 synchronizedandroid.os.MessageQueue#next 中的 synchronized12345678910111213141516171819202122232425262728293031323334353637383940@UnsupportedAppUsageMessage next() &#123; ... for (;;) &#123; ... synchronized (this) &#123; ... Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. ... &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. ... &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; ... if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; ... &#125;&#125; 第一处synchronized 用于同步代码块的范围涵盖了整个 next() 方法。具体来说，这段代码实现了一个消息循环（message loop）用于处理消息队列中的消息。在多线程环境下，有多个线程可能会调用 next() 方法来获取下一个消息，因此需要确保对共享资源的访问是安全的。 第二处mIdleHandlers.remove(idler)：这行代码从 mIdleHandlers 集合中移除一个 IdleHandler。由于多个线程可能同时访问和修改 mIdleHandlers，因此需要确保这个操作是原子的，以避免不一致或意外的结果。 其他函数都是 synchronized 保护下的MessageQueue 是 Android 框架中用于处理消息传递和线程通信的关键组件，多个线程可能会同时访问和修改消息队列，因此需要使用同步机制来避免竞态条件和其他线程安全问题。 MessageQueue 中的 IdleHandler使用与意义IdleHandler 是 Android 消息传递机制中的一个重要概念，它允许你在消息队列空闲时执行一些额外的操作。 使用： 你可以通过 MessageQueue 的 addIdleHandler() 方法将一个或多个 IdleHandler 添加到消息队列中。 意义： IdleHandler 允许你在消息队列空闲时执行一些轻量级的任务，这些任务通常是一些不需要立即处理、不会阻塞主线程的操作。常见的用例包括资源回收、后台数据同步、性能优化等。通过利用空闲时间执行这些任务，可以提高应用的性能和资源利用率。 执行时机： IdleHandler 的 queueIdle() 方法在消息队列没有即时任务需要处理时调用。如果 queueIdle() 返回 true，该 IdleHandler 将继续保持在队列中，以便在下一次空闲时调用；如果返回 false，则该 IdleHandler 将从队列中移除。 为什么会有多个 IdleHandler 功能分离： 不同的 IdleHandler 可以用于执行不同类型的任务，如资源回收、后台数据同步、性能优化等。通过将不同的任务逻辑分离到不同的 IdleHandler 中，可以使代码更加模块化和可维护。 任务优先级： 不同的 IdleHandler 可以根据优先级来执行任务。高优先级任务可以通过将对应的 IdleHandler 添加到队列中，确保在空闲时尽快执行。低优先级任务则可以延迟到更空闲的时候执行。 动态注册和注销： 多个 IdleHandler 允许开发者在不同的时刻动态地注册和注销任务。这使得可以根据应用程序的状态和需求来动态地调整任务的执行。 任务复用： 如果有多个相似的任务需要在空闲时执行，可以通过不同的 IdleHandler 实现任务的复用，避免重复编写类似的代码。 提高性能： 通过将不同的任务拆分到多个 IdleHandler 中，可以减少单个 IdleHandler 的负载，从而提高任务的执行效率。 关键行为分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@UnsupportedAppUsageMessage next() &#123; ... for (;;) &#123; ... synchronized (this) &#123; ... // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. /** * 如果首次进入空闲状态，则获取要运行的空闲处理程序数量。 * 空闲处理程序仅在消息队列为空或队列中的第一个消息（可能是一个屏障）将在未来被处理时运行。 */ if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 没有要运行的空闲处理程序。继续循环并等待一段时间。 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. /** * 运行空闲处理程序。 * 我们只会在第一次迭代期间到达这个代码块。 */ for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; ... &#125;&#125; mPendingIdleHandlers 与 mIdleHandlers mPendingIdleHandlers： 类型：IdleHandler[] 作用：用于存储当前等待执行的空闲时处理对象（IdleHandler）数组。在消息队列空闲时，这些处理会被调用，以执行额外的任务。 使用场景：用于临时存储等待执行的空闲时处理，直接与循环内部逻辑相关。 mIdleHandlers： 类型：ArrayList&lt;IdleHandler&gt; 作用：用于存储注册的空闲时处理对象。开发者可以将多个 IdleHandler 添加到这个列表中，以便在消息队列空闲时执行不同的任务。 使用场景：用于持久存储注册的空闲时处理，可以在任何时候添加或移除 IdleHandler。 总结区别： mPendingIdleHandlers 是一个数组，用于存储当前等待执行的空闲时处理对象。它是循环内部临时使用的，用于遍历调用每个等待执行的空闲时处理。 mIdleHandlers 是一个列表，用于持久存储注册的空闲时处理对象。开发者可以随时将 IdleHandler 添加到列表中，以便在消息队列空闲时执行不同的任务。 给 PendingIdleHandlers 分配新的数组空间123if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125; 这段代码的作用是在消息队列空闲时，检查是否需要运行空闲时处理。如果当前没有消息或者队列中的第一个消息的处理时间还未到来，并且之前的 pendingIdleHandlerCount 小于 0，那么它会获取当前注册的空闲时处理的数量，并将其赋值给 pendingIdleHandlerCount。这样，当队列为空或者第一个消息处理时间未到来时，代码会准备好运行已注册的空闲时处理。通常情况下，这个检查用于确保空闲时处理在适当的时机被调度执行。 123456if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 没有要运行的空闲处理程序。继续循环并等待一段时间。 mBlocked = true; continue;&#125; 这段代码的作用是在消息队列空闲时，如果没有等待执行的空闲时处理，就将消息队列标记为被阻塞状态，并继续等待更多的消息或任务进入队列。这个逻辑用于优化资源管理，确保在没有即时任务需要处理时，程序仍然能够保持运行，以便在有任务时能够立即执行。 123if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125; 注意：隐含的条件是 pendingIdleHandlerCount &lt;&#x3D; 0 才能走到这里，所以判断条件其实是 pendingIdleHandlerCount &lt;&#x3D; 0 &amp;&amp; mPendingIdleHandlers &#x3D;&#x3D; null，通常表示这是第一次运行空闲时处理 如果 mPendingIdleHandlers 为 null，则进入条件判断。在这里，使用 Math.max(pendingIdleHandlerCount, 4) 来计算数组的长度，其中 pendingIdleHandlerCount 是等待执行的空闲时处理的数量。如果等待执行的处理数量小于 4，则数组长度取值为 4，否则取值为 pendingIdleHandlerCount PendingIdleHandlers 赋值1mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); 运行空闲时处理 PendingIdleHandlers123456789101112131415161718192021222324// Run the idle handlers.// We only ever reach this code block during the first iteration./** * 运行空闲处理程序。 * 我们只会在第一次迭代期间到达这个代码块。 */for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125;&#125; 注意：这里注释中的第一次迭代是指的消息队列第一次处理完所有已经在队列中的消息的那一次迭代，是想说明在后续的迭代中，如果消息队列仍然处于空闲状态，那么这段代码块不会再执行，因为它只在消息队列刚刚变为空闲时运行。 队列的唤醒与阻塞android.os.MessageQueue#enqueueMessage12345678910111213141516171819202122232425262728293031323334353637383940boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; synchronized (this) &#123; ... boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 在这段代码中，mBlocked 在两个地方起到了不同的作用： 第一个 mBlocked 作用： 1needWake = mBlocked; 在这里，mBlocked 被赋值给变量 needWake。这个操作是为了判断是否需要唤醒事件队列（消息循环）。具体情况如下： 如果 mBlocked 为 true，表示事件队列当前正处于阻塞状态，即没有立即需要处理的消息。在这种情况下，如果新消息的插入导致事件队列不再阻塞，就需要唤醒事件队列，以便消息循环继续执行。 如果 mBlocked 为 false，表示事件队列没有阻塞，新消息的插入不会改变这个状态，因此不需要唤醒。 第二个 mBlocked 作用： 1needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); 在这里，mBlocked 参与了判断条件。这个条件用于判断是否需要唤醒事件队列，以提醒消息循环处理新消息。具体情况如下： 如果 mBlocked 为 true，表示事件队列当前正处于阻塞状态。然后，进一步判断消息队列中是否有异步消息，并且插入的新消息也是异步消息，那么需要唤醒事件队列，以便消息循环能够立即处理这个异步消息。 综上所述，mBlocked 在这段代码中的两个地方都与判断是否需要唤醒事件队列有关。第一个地方是用来判断是否需要在新消息插入时唤醒事件队列，以便消息循环继续执行。第二个地方是在特定条件下，判断是否需要唤醒事件队列来处理异步消息。 android.os.MessageQueue#next在提供的代码片段中，有三处不同的地方使用了 mBlocked 参数，并且它们在不同的上下文中起到了不同的作用。以下是每个位置的详细分析： 第一处 mBlocked 作用： 1mBlocked = false; 在这里，mBlocked 被设置为 false，表示消息队列不再处于阻塞状态。这是在找到了一个准备好被处理的消息后执行的操作。通过将 mBlocked 设置为 false，消息循环可以继续处理消息，而不需要等待。 第二处 mBlocked 作用： 1mBlocked = true; 在这里，mBlocked 被设置为 true，表示消息队列当前处于阻塞状态。这是在判断没有可处理的消息，并且没有要运行的空闲处理程序时执行的操作。通过将 mBlocked 设置为 true，消息循环进入了等待状态，等待新的消息或者空闲处理程序的到来。 第三处 mBlocked 作用： 1mBlocked = true; 这里的 mBlocked 也被设置为 true，与第二处的作用相同。这是在消息队列处理完所有的空闲处理程序之后，仍然没有要运行的空闲处理程序时执行的操作。通过将 mBlocked 设置为 true，消息循环会继续等待，直到有新的消息到达或者空闲处理程序需要运行。 总结来说，mBlocked 在这段代码中的三处不同的作用是： 在找到一个准备好被处理的消息后，将其设置为 false，使得消息循环可以继续处理消息。 在没有可处理的消息且没有要运行的空闲处理程序时，将其设置为 true，使得消息循环进入等待状态。 在所有空闲处理程序都被处理后，仍然没有要运行的空闲处理程序时，将其设置为 true，继续等待。 通过这样的设置，消息循环能够根据不同的情况来控制阻塞和等待状态，以便有效地处理消息和任务。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"}],"tags":[]},{"title":"Android Framework 专项 - Handler（一）","slug":"3 Android/Framework/01-Android-Framework-专项-Handler1","date":"2023-08-23T10:38:36.000Z","updated":"2023-08-23T10:38:36.000Z","comments":true,"path":"2023/08/23/3 Android/Framework/01-Android-Framework-专项-Handler1/","link":"","permalink":"http://example.com/2023/08/23/3%20Android/Framework/01-Android-Framework-%E4%B8%93%E9%A1%B9-Handler1/","excerpt":"","text":"问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein Q：一个线程有几个 Handler？ Q: 线程间的通信的原理是怎样的？ Q: Handler 内存泄漏的原因？为什么其他的内部类没有说过这个问题？ Q: 为何主线程可以 new Handler ？如果想要在子线程中 new Handler 要做些什么准备？ Q: 子线程中维护的 Looper，消息队列无消息的时候的处理方案是什么？有什么用？ Q: 既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个 Handler 可能处于不同线程），那它内部时如何确保线程安全的？ Q: Looper 死循环为什么不会导致应用卡死 Q: 为什么主线程不需要自己创建和管理消息循环 Handler 在 Android 中的应用1Handler 是针对 Android 系统中与 UI 线程通信而专门设计的多线程通信机制 Retorfit，eventbus，rxjava，Looper Handler 源代码分析子线程 发送 MSG​ android.os.Handler#sendMessage -&gt;​ android.os.Handler#sendMessageDelayed -&gt;​ android.os.Handler#sendMessageAtTime -&gt;​ android.os.Handler#enqueueMessage -&gt;​ android.os.MessageQueue#enqueueMessage -&gt;​ android.os.Looper#loop android.os.Handler#sendMessage123456789101112131415161718192021 /** * Pushes a message onto the end of the message queue after all pending messages * before the current time. It will be received in &#123;@link #handleMessage&#125;, * in the thread attached to this handler. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */ /** * 在所有挂起的消息之后将消息推送到消息队列的末尾 * 当前时间之前。它将在 &#123;@link #handleMessage&#125; 中收到， * 在附加到该处理程序的线程中。 * * @return 如果消息成功放入则返回 true * 消息队列。失败时返回 false，通常是因为 * 处理消息队列的 looper 正在退出。 */public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125; android.os.Handler#sendMessageDelayed123456789101112131415161718192021222324252627282930/** * Enqueue a message into the message queue after all pending messages * before (current time + delayMillis). You will receive it in * &#123;@link #handleMessage&#125;, in the thread attached to this handler. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. *//** * 将一条消息放入消息队列中，位于所有挂起的消息之后 * 之前（当前时间+delayMillis）。您将在以下时间收到它： * &#123;@link #handleMessage&#125;，在附加到该处理程序的线程中。 * * @return 如果消息成功放入则返回 true * 消息队列。失败时返回 false，通常是因为 * 处理消息队列的 looper 正在退出。请注意，一个 * true 的结果并不意味着该消息将被处理 -- 如果 * Looper 在消息发送之前退出 * 发生则消息将被丢弃。 */public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; android.os.Handler#sendMessageAtTime12345678910111213141516171819202122232425262728293031323334353637383940/** * Enqueue a message into the message queue after all pending messages * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;. * &lt;b&gt;The time-base is &#123;@link android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt; * Time spent in deep sleep will add an additional delay to execution. * You will receive it in &#123;@link #handleMessage&#125;, in the thread attached * to this handler. * * @param uptimeMillis The absolute time at which the message should be * delivered, using the * &#123;@link android.os.SystemClock#uptimeMillis&#125; time-base. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. *//** * 将消息排队到消息队列中，在绝对时间（以毫秒为单位）&lt;var&gt;uptimeMillis&lt;/var&gt;之后的所有挂起消息之后。 * &lt;b&gt;时间基准是 &#123;@link android.os.SystemClock#uptimeMillis&#125;。&lt;/b&gt; * 在深度睡眠期间花费的时间将会额外延迟执行。 * 您将在&#123;@link #handleMessage&#125;中接收它，该方法会在与此处理程序连接的线程中执行。 * * @param uptimeMillis 消息应该传递的绝对时间，使用&#123;@link android.os.SystemClock#uptimeMillis&#125;作为时间基准。 * * @return 如果消息成功放置到消息队列中，则返回 true 。如果失败，则返回 false ，通常是因为处理消息队列的消息循环正在退出。 * 请注意，返回true并不意味着消息将被处理 - 如果消息传递时间之前消息循环被退出，则消息将被丢弃。 */public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; android.os.Handler#enqueueMessage12345678910private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 到这里，发送流程都没什么好说的 重点：android.os.Handler#handleMessage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; synchronized (this) &#123; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; msg.target 是什么注意：这里 msg.target 就是 msg 持有的 handler 也是 为什么会有内存泄漏风险的原因。 分析代码： Handler 内存泄漏原因Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。 它的主要作用是将消息按照时间顺序插入到消息队列中，并在必要时唤醒队列以处理这些消息。下面逐步分析代码的功能和逻辑。 首先，代码对传入的消息 msg 进行一些验证。它确保消息有一个非空的目标（msg.target != null），否则抛出 IllegalArgumentException。 然后，代码在同步块内执行以下操作： 检查消息是否已经在使用中，如果是，则抛出 IllegalStateException。这可能是为了防止重复使用消息，确保每个消息只被处理一次。 检查当前处理器是否正在退出（mQuitting 标志），如果是，就回收消息并返回 false，表示消息未被成功加入队列。 将消息标记为正在使用，并设置消息的触发时间 msg.when 为传入的 when。 获取消息队列的头部消息 p。 接下来，代码根据以下条件进行处理： 如果消息队列为空，或者传入的触发时间 when 为 0，或者传入的 when 小于队列头部消息的触发时间 p.when，则将新消息插入到队列头部。如果队列当前被阻塞（mBlocked 标志），则设置需要唤醒队列（needWake = true）。 否则，如果消息需要插入队列中间，则根据条件判断是否需要唤醒队列。具体判断条件是：队列被阻塞、队列头部消息的目标为 null，且传入的消息是异步消息。然后，代码在一个循环中遍历消息队列，找到合适的位置插入新消息。循环会一直迭代，直到找到合适的位置或者遍历完整个队列。 在找到合适的位置后，代码将新消息 msg 插入到队列中。具体做法是，将 msg.next 设置为当前消息 p，然后将前一个消息 prev.next 设置为新消息 msg。 最后，代码根据之前的标志 needWake 来决定是否唤醒队列。如果需要唤醒，则调用本地的 nativeWake 方法（可能是一个底层的本地方法）来唤醒消息队列。 整个同步块结束后，代码返回 true，表示消息已经成功加入队列。 这段代码的核心功能是在消息队列中插入消息并进行适当的排序，以确保消息按照触发时间顺序进行处理。同时，它还处理了一些异常情况，如消息已经在使用中或者处理器正在退出。唤醒队列的逻辑也在代码的最后部分进行处理。 让我们逐步分析 MSG 插入队列的位置： 第一种插入头部的情况：12345678if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; else &#123; ...&#125; 如果消息队列为空，意味着当前没有任何消息在队列中等待处理。在这种情况下，不需要比较触发时间，直接将新消息插入到队列的头部。这会让新消息成为队列的第一个要处理的消息。 如果传入的触发时间 when 为 0，这可能表示该消息需要尽快处理，因此同样将它插入到队列的头部。 如果传入的触发时间 when 小于队列头部消息的触发时间 p.when，这意味着新消息应该在队列中位于当前头部消息之前，因此同样将它插入到队列的头部。 综合上述情况，无论是队列为空，还是传入的 when 值为 0，或者传入的 when 值小于队列头部消息的触发时间，都会将新消息插入到队列的头部。 第二种插入中间的情况：123456789101112131415161718192021if(p == null || when == 0 || when &lt; p.when) &#123; ...&#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; 首先，如果不满足前面提到的条件（消息队列为空，传入的触发时间为0，或传入的触发时间小于队列头部消息的触发时间），那么意味着要插入的新消息 msg 应该位于队列中间。 在这种情况下，代码会进入一个循环。这个循环的目的是遍历消息队列，以找到合适的位置将新消息 msg 插入队列中。 循环的条件是 for (;;)，这将创建一个无限循环，直到内部的某个条件满足而跳出循环。 在每次循环迭代中，代码会做以下事情： 将当前消息 p 的引用赋值给 prev，这样可以记录下前一个消息。 将 p 移动到下一个消息（p = p.next）。 然后，代码检查两个条件： 如果当前消息 p 为空，意味着已经遍历了整个队列，或者队列只有一个消息且当前消息是最后一个消息。 如果传入的触发时间 when 小于队列中当前消息 p 的触发时间 p.when。 如果满足以上任一条件，循环会被中断，这表示找到了合适的位置将新消息 msg 插入到消息队列中。 在循环的每个迭代中，代码还会检查以下条件： 如果需要唤醒队列（needWake = true），并且当前消息 p 是异步消息（p.isAsynchronous() 返回 true），则将 needWake 设置为 false。这个步骤可能是为了控制是否需要在队列中插入异步消息时唤醒队列。 一旦找到了合适的位置，代码会执行以下操作： 将新消息 msg 的 next 指针指向当前消息 p，这相当于将新消息插入到当前消息 p 之前。 将前一个消息 prev 的 next 指针指向新消息 msg，以确保队列中消息的连接关系正确。 循环结束后，新消息 msg 已经被插入到队列的合适位置，保持了消息队列的有序性。 总之，这段代码的目的是在消息队列中将新消息插入到适当的位置，以保持消息的时间顺序。在找到合适位置时，会根据一些条件来决定是否需要唤醒队列，这可能与队列的处理机制相关。 此外，如果当前消息队列被阻塞（mBlocked 为 true），则将标志 needWake 设置为 true。这是为了确保在需要唤醒队列以处理消息的情况下，能够在适当的时候执行唤醒操作。唤醒队列的操作可能涉及到一些底层机制，具体如何唤醒可能需要查看更多上下文代码。 总的来说，这段代码逻辑的目的是在特定条件下将新消息插入到消息队列的头部，并根据当前队列的阻塞状态决定是否需要唤醒队列以确保消息能够被及时处理。 主线程 取出 MSG​ android.os.Looper#loop -&gt;​ android.os.MessageQueue#next -&gt;​ android.os.Handler#dispatchMessage -&gt;​ android.os.Handler#handleMessage 主线程中的 Loop我们来看主线程的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); // Call per-process mainline module initialization. initializeMainlineModules(); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 与 handler 相关的关键代码： 123456789101112131415public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ··· Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 准备 Looper 1Looper.prepareMainLooper(); android.os.Looper#prepareMainLooper 1234567891011121314151617/** * Initialize the current thread as a looper, marking it as an * application&#x27;s main looper. See also: &#123;@link #prepare()&#125; * * @deprecated The main looper for your application is created by the Android environment, * so you should never need to call this function yourself. */@Deprecatedpublic static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125;&#125; android.os.Looper#prepare(boolean) 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 准备 Handler 123if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler();&#125; android.app.ActivityThread#getHandler 1234@UnsupportedAppUsage public Handler getHandler() &#123; return mH;&#125; android.app.ActivityThread#mH 12@UnsupportedAppUsagefinal H mH = new H(); 开启循环 1Looper.loop(); 重点：android.os.Looper#loop#loop123456789101112131415161718192021222324252627282930313233public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; if (me.mInLoop) &#123; Slog.w(TAG, &quot;Loop again would have the queued messages be executed&quot; + &quot; before this one completed.&quot;); &#125; me.mInLoop = true; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); me.mSlowDeliveryDetected = false; for (;;) &#123; if (!loopOnce(me, ident, thresholdOverride)) &#123; return; &#125; &#125;&#125; 这段代码是 Android 框架中 Looper 类的 loop() 方法的实现，负责在当前线程的消息循环中执行消息的分发和处理。 首先，通过 myLooper() 获取当前线程的 Looper 实例 me，如果没有 Looper 实例则抛出异常，表示未调用 Looper.prepare() 来准备 Looper。 检查 me.mInLoop，如果当前线程已经在消息循环中，则打印警告日志。 将 me.mInLoop 标志设置为 true，表示当前线程正在消息循环中。 使用 Binder.clearCallingIdentity() 来清除当前线程的调用标识，然后再次调用它并将返回的标识 ident 保存下来。 获取一个可能的系统属性覆盖值 thresholdOverride，用于调整慢分发的阈值。 将 me.mSlowDeliveryDetected 设置为 false，用于标记是否检测到慢投递。 进入一个无限循环，不断地执行消息分发和处理。 在循环中，调用 loopOnce(me, ident, thresholdOverride) 来执行一次消息分发。如果返回值为 false，表示没有更多的消息需要分发，退出循环。 总之，这段代码描述了 Android 中消息循环的核心逻辑。它会在一个无限循环中，不断地从消息队列中获取消息并执行消息分发和处理，直到没有更多的消息需要处理为止。在循环中，还会检查是否有慢分发阈值的系统属性覆盖，并根据需要清除调用标识。如果发现当前线程已经在消息循环中，则会打印警告信息。 #loopOnce1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) &#123; Message msg = me.mQueue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return false; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; // Make sure the observer won&#x27;t change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (me.mSlowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); me.mSlowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. me.mSlowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); return true; &#125; 这段代码是 Android 框架中 Looper 类的一个方法 loopOnce 的实现，主要负责处理消息队列中的消息分发过程。我会逐步解释代码的功能。 首先，通过 me.mQueue.next() 获取下一个消息，如果没有消息则表示消息队列正在退出，函数返回 false。 如果获取到了消息，则会根据是否设置了日志打印，打印消息的分发信息。 获取当前的观察者对象和跟踪标签。 根据阈值覆盖值，更新慢分发和慢投递的阈值。 判断是否需要记录开始时间和结束时间，如果需要，则记录当前时间作为分发开始时间。 如果设置了跟踪标签且跟踪标签是启用的，则开始跟踪。 设置开始分发时间，并获取一个 token 以用于观察者的消息分发起始回调。 设置当前线程的工作源为消息的工作源 UID。 使用目标 Handler（Handler 是消息处理的目标）来分发消息。 如果设置了观察者，通知观察者消息已分发。 结束分发，记录结束时间。 如果发生异常，通知观察者分发过程中出现异常，并将异常抛出。 最终，无论是否发生异常，都会恢复线程的工作源，并根据跟踪标签是否启用，结束跟踪。 如果设置了慢投递日志，会根据条件判断是否记录慢投递日志。 如果设置了慢分发日志，会根据条件记录慢分发日志。 如果设置了日志打印，会打印消息分发完成信息。 最后，检查分发过程中线程标识是否被更改，如果发生改变，会打印警告日志。 回收消息对象并返回 true，表示成功分发消息。 总之，这段代码描述了 Android 中消息队列中消息的分发过程，涵盖了消息的跟踪、日志记录、观察者通知等多个方面，确保消息能够按照正确的顺序分发到目标处理程序。 重点：android.os.MessageQueue#next123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@UnsupportedAppUsageMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 这段代码是一个 Android 消息循环（Message Loop）的一部分，它用于处理消息队列中的消息。消息循环是 Android 应用程序的核心部分，用于处理用户界面事件、线程间通信等。 以下是代码的主要功能和逻辑： 代码开头使用了一个注解 @UnsupportedAppUsage，这是 Android 的一个标记注解，用于标识不推荐使用的 API 或方法。 next() 方法是一个消息循环的主要函数。它会循环从消息队列中获取消息，然后处理这些消息。 首先，代码会获取 mPtr，这是一个表示消息队列的指针。如果 ptr 为 0，表示消息队列已经被释放，函数会返回 null。 接下来，进入一个无限循环 for (;;) &#123;...&#125;，在循环内部做以下操作： 如果 nextPollTimeoutMillis 不为 0，会刷新待处理的 Binder 命令（一种 Android 进程间通信机制）。 调用 nativePollOnce(ptr, nextPollTimeoutMillis)，它是一个本地方法，用于轮询获取下一个消息。 进入同步块，开始处理消息队列中的消息。 首先，获取当前时间 now，然后尝试获取下一个消息。如果消息的目标为 null，表示该消息是一个异步消息（可能由于障碍而被阻塞），会查找下一个异步消息。 如果找到消息并且消息的触发时间在当前时间之后，会设置一个定时器来在消息准备好时唤醒循环。 如果消息已经准备好（触发时间已到），会将消息从队列中移除，并返回该消息。 如果没有找到消息，会将 nextPollTimeoutMillis 设为 -1，表示没有更多消息。 如果 mQuitting 为 true，表示消息队列已经被停止，会调用 dispose() 释放资源，并返回 null。 如果是第一次空闲（没有消息待处理），会获取待运行的空闲处理器数量。 如果没有空闲处理器需要运行，会将 mBlocked 设为 true，继续等待。 如果有待运行的空闲处理器，会将它们放入 mPendingIdleHandlers 数组中。 执行空闲处理器的 queueIdle() 方法，该方法用于处理空闲状态。 如果 queueIdle() 返回 false，表示该空闲处理器不再需要运行，会将其从列表中移除。 重置空闲处理器数量为 0，以防止重复运行。 在处理完空闲处理器后，将 nextPollTimeoutMillis 设为 0，以便立即查找待处理的消息。 以上就是这段代码的主要逻辑。它负责不断地从消息队列中获取消息并处理，同时也处理了一些特殊情况，如消息队列已停止、空闲处理等。这种消息循环机制保证了 Android 应用程序的响应性和流畅性。 核心代码：给定代码中最重要的部分是主循环，该循环处理消息并运行空闲处理程序，在Android消息循环系统中负责处理消息并及时有效地运行空闲处理程序。让我们逐步分解关键组成部分及其重要性： 1234567891011121314151617181920212223242526272829303132333435363738for (;;) &#123; // ... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // ... if (msg != null) &#123; if (now &lt; msg.when) &#123; // ... &#125; else &#123; // 收到一条消息。 mBlocked = false; // 从队列中移除消息并返回。 // 这是消息处理的核心操作。 // 它允许根据其预定时间依次执行消息。 // 返回的“msg”对象包含用于处理的数据和指令。 msg.markInUse(); return msg; &#125; &#125; else &#123; // 没有更多消息。 nextPollTimeoutMillis = -1; &#125; // 处理退出消息并处理空闲处理程序。 // ... // 运行空闲处理程序。 // 该块遍历待处理的空闲处理程序并执行它们。 // 空闲处理程序用于在消息队列为空时执行任务。 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; // ... &#125; // 重置空闲处理程序计数并检查是否有新消息。 // ... &#125;&#125; 关键部分及其重要性如下： nativePollOnce(ptr, nextPollTimeoutMillis);：这个本地方法用于轮询来自底层系统的传入消息和事件。它等待指定的超时时间以获取新的消息。 消息处理： 循环检查是否有待处理的消息，并根据其预定时间（msg.when）对其进行处理。 如果一条消息准备好执行，它会从队列中移除并返回（return msg;）。 这是消息循环的核心，消息按照它们被发布的顺序逐个执行。 markInUse() 方法表示消息正在被处理。 退出消息和空闲处理程序： 循环检查消息循环是否正在退出（mQuitting）并在需要时释放资源。 还会处理空闲处理程序，这些程序在没有待处理消息时执行。 空闲处理程序是在消息循环处于非活动状态时执行任务的函数。 总的来说，这段代码片段代表了Android消息循环的核心机制，它对于管理异步任务、UI交互和基于事件的编程在Android应用中至关重要。这个循环的正常运行对于维持响应迅速、交互式的用户体验至关重要。 android.os.Handler#dispatchMessage123456789101112131415/** * Handle system messages here. */public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 这段代码是一个 Android 消息分发方法，用于处理系统消息。在 Android 中，消息分发是消息循环的一部分，用于将消息传递给相应的处理方法或回调函数。 以下是代码的主要功能和逻辑： 方法名为 dispatchMessage，接受一个非空的 Message 对象作为参数，用于处理系统消息。 首先，代码检查 msg 中是否存在一个非空的回调函数 callback。如果存在，表示该消息具有一个回调函数，将调用 handleCallback(msg) 来处理该回调函数。 如果 msg 中没有回调函数，代码会进入下一步判断。 首先，检查是否存在一个非空的成员变量 mCallback，它是一个消息处理器的回调接口。如果存在 mCallback，代码会调用 handleMessage(msg) 来处理消息。如果 mCallback.handleMessage(msg) 返回 true，表示消息已经被处理，函数会直接返回，不会继续执行后续的 handleMessage(msg)。 如果 mCallback.handleMessage(msg) 返回 false，表示 mCallback 没有处理该消息，代码会调用当前类的 handleMessage(msg) 方法来处理消息。 综合起来，这段代码实现了一个消息分发的逻辑，首先检查消息是否有回调函数，然后尝试使用回调函数处理消息。如果没有回调函数，它会检查是否存在一个全局的消息处理器 mCallback，尝试让它处理消息。如果都没有成功处理，最后会调用当前类的 handleMessage(msg) 方法来处理消息。 这种消息分发机制使得消息能够在不同的处理方法和回调函数之间进行传递和处理，提高了代码的灵活性和可扩展性。 android.os.Handler#handleMessage12345/** * Subclasses must implement this to receive messages. */public void handleMessage(@NonNull Message msg) &#123;&#125; 这段代码是一个方法声明，用于在子类中实现消息处理的逻辑。在 Android 中，消息处理是一种常见的模式，用于处理来自消息队列的不同类型的消息。 以下是代码的主要功能和逻辑： 方法名为 handleMessage，接受一个非空的 Message 对象作为参数，用于处理消息。 这是一个抽象方法，没有具体的实现，因此需要在子类中进行实现。 子类必须重写这个方法，并根据具体的业务逻辑来处理传递进来的消息。 通过在子类中实现不同的 handleMessage 方法，可以实现不同类型的消息处理，从而达到分离不同功能的目的。 在 Android 应用程序开发中，常常会使用这种消息处理机制来进行异步任务的处理、UI 更新、线程间通信等。子类可以根据不同的需求，实现不同的消息处理逻辑，使代码结构更加清晰和模块化。 使用 handler 通信机制由主线程向子线程发送消息我们已经了解了主线程中会创建 Looper 和 handler，也明白了期运行逻辑下面我们在子线程中创建这一套通信机制，用于主线程向子线程发送消息 创建一个 CustomLooperThread 手动创建子线程的 Looper 和关联的 Handler，以便在子线程中处理消息。 12345678910111213141516171819202122232425262728293031323334353637383940import android.os.Handler;import android.os.Looper;import android.os.Message;class CustomLooperThread extends Thread &#123; private Handler mHandler; private Looper mLooper; @Override public void run() &#123; Looper.prepare(); mLooper = Looper.myLooper(); mHandler = new Handler(mLooper) &#123; @Override public void handleMessage(Message msg) &#123; // 在线程中处理消息 // ... &#125; &#125;; Looper.loop(); &#125; public void executeTask(Runnable task) &#123; if (mHandler != null) &#123; mHandler.post(task); &#125; &#125; public Looper getLooper() &#123; return mLooper; &#125; public void quit() &#123; if (mLooper != null) &#123; mLooper.quit(); &#125; &#125;&#125; 方式二: 使用 HandlerThread： 使用 HandlerThread 类封装了子线程的 Looper 和关联的 Handler 创建过程。 1234567891011121314151617181920212223242526272829import android.os.Handler;import android.os.HandlerThread;import android.os.Message;public class CustomLooperThread extends HandlerThread &#123; private Handler mHandler; public CustomLooperThread(String name) &#123; super(name); &#125; @Override protected void onLooperPrepared() &#123; mHandler = new Handler(getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; // 在子线程中处理消息 // ... &#125; &#125;; &#125; public void sendMessageToThread(int what) &#123; if (mHandler != null) &#123; Message message = mHandler.obtainMessage(what); mHandler.sendMessage(message); &#125; &#125;&#125; 创建一个 MyThreadManager12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.os.Handler;import android.os.Looper;import android.os.Message;public class MyThreadManager &#123; private MyThread mThread; private Handler mHandler; public MyThreadManager() &#123; // 创建线程并启动 mThread = new MyThread(); mThread.start(); // 在线程的消息循环中创建 Handler mHandler = new Handler(mThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; // 在线程中处理消息 // ... &#125; &#125;; &#125; // 发送消息到线程中 public void sendMessage(int what) &#123; if (mHandler != null) &#123; Message message = mHandler.obtainMessage(what); mHandler.sendMessage(message); &#125; &#125; // 执行任务在线程中 public void executeTaskInThread(Runnable task) &#123; if (mThread != null) &#123; mThread.executeTask(task); &#125; &#125; // 关闭线程和消息循环 public void closeThread() &#123; if (mThread != null) &#123; mThread.quit(); mThread = null; &#125; &#125;&#125; 引出问题方式一，自定义 Looper 和 Handler 创建的 CustomLooperThread 中的 getLooper 有没有问题？1mThread.start(); 是在子线程中执行的 12345678// 在线程的消息循环中创建 HandlermHandler = new Handler(mThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; // 在线程中处理消息 // ... &#125;&#125;;thread.start()是在子线程中 是在主线程执行的也就是说在 mThread.getLooper() 时，有可能 mThread.start() 还没执行完所以这里有多线程并发问题 我们看一下 HandlerThread 中是怎么解决的 123456789101112131415161718192021222324252627282930313233/** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; boolean wasInterrupted = false; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; wasInterrupted = true; &#125; &#125; &#125; /* * We may need to restore the thread&#x27;s interrupted flag, because it may * have been cleared above since we eat InterruptedExceptions */ if (wasInterrupted) &#123; Thread.currentThread().interrupt(); &#125; Thread 中的 Handler 和 MyThreadManager 中 Handler 有什么不同 MyThread 类中的 Handler： 在 MyThread 类中的 Handler 用于处理子线程 MyThread 中的消息。它负责监听并处理从 MyThread 类的消息循环中传递过来的消息。这个 Handler 是在 MyThread 类的 run() 方法中创建并与 Looper 关联，以便在 MyThread 线程中处理消息。 MyThreadManager 类中的 Handler： 在 MyThreadManager 类中的 Handler 用于将消息发送到 MyThread 线程。它负责将来自主线程或其他地方的消息发送给 MyThread 线程的消息循环。这个 Handler 负责与 MyThread 线程进行通信，从而实现了在主线程或其他线程中触发 MyThread 线程执行特定任务。 这里我们提到了消息循环，我们下一章说 MessageQueue","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"}],"tags":[]},{"title":"Android Game Project 核心 Renderer.cpp","slug":"8渲染引擎/01 工程结构/01 Android GameProject 中最基础的 Renderer","date":"2023-08-23T10:38:36.000Z","updated":"2024-03-27T16:57:26.385Z","comments":true,"path":"2023/08/23/8渲染引擎/01 工程结构/01 Android GameProject 中最基础的 Renderer/","link":"","permalink":"http://example.com/2023/08/23/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01%20%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/01%20Android%20GameProject%20%E4%B8%AD%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%20Renderer/","excerpt":"","text":"Renderer 类图组成： 类名：Renderer 属性 EGLDisplay display_: 用于OpenGL ES渲染的显示设备。它是一个与本地显示系统相关联的EGL显示连接。 EGLSurface surface_: OpenGL ES渲染的表面。这是一个EGL表面，代表可以渲染OpenGL ES图形的绘图目标。 EGLContext context_: OpenGL ES渲染的上下文。它是一个封装了OpenGL ES状态机的EGL渲染上下文。 int width_: 渲染表面的宽度，以像素为单位。 int height_: 渲染表面的高度，以像素为单位。 bool shaderNeedsNewProjectionMatrix_: 一个标志，指示是否需要为着色器生成新的投影矩阵。当渲染表面的大小改变时，这个标志会被设置为true。 std::unique_ptr shader_: 指向当前使用的Shader对象的智能指针。Shader对象用于编译、链接和使用顶点和片段着色器。 std::vector models_: 包含所有要渲染的模型的容器。每个Model对象包含顶点数据、索引数据和纹理数据。 方法 析构函数 ~Renderer(): 清理Renderer对象，包括释放EGL资源（如显示设备、渲染表面和上下文）。 void render(): 执行渲染循环的一次迭代。这包括更新渲染状态、绘制模型和交换渲染表面的缓冲区。 void initRenderer(): 初始化渲染器，包括设置EGL上下文、选择EGL配置、创建渲染表面和上下文、初始化OpenGL ES状态和加载着色器。 void updateRenderArea(): 更新渲染区域的大小。如果渲染表面的大小发生变化，此方法更新width_和height_属性，并标记需要为着色器生成新的投影矩阵。 void createModels(): 创建演示模型。这个方法加载模型的顶点、索引和纹理数据，然后将模型添加到models_容器中。 void handleInput(): 处理输入事件，如触摸和按键。这个方法从Android的输入事件队列中读取事件，并根据需要响应这些事件。 关联和依赖关系： 依赖于Shader类：由于shader_属性和在initRenderer()方法中对Shader的调用。 依赖于Vertex和Index类型：在createModels()方法中使用这些类型来创建模型。 依赖于TextureAsset类：在createModels()方法中加载纹理资源。 使用了标准库中的类型，如std::vector、std::unique_ptr。 这个类图还可以展示Renderer类如何与Android的本地应用粘合层（native_app_glue）和OpenGL ES 3.0交互，特别是如何处理EGL上下文、表面创建和渲染循环。 下面是一个简化的类图表示，重点在于Renderer类及其直接关系： 12345678[Renderer] --|&gt; [EGLDisplay][Renderer] --|&gt; [EGLSurface][Renderer] --|&gt; [EGLContext][Renderer] ---&gt; [Shader][Renderer] --* [Model][Model] --* [Vertex][Model] --* [Index][Model] ---&gt; [TextureAsset] 说明： --|&gt; 表示拥有或创建关系。 ---&gt; 表示依赖关系。 --* 表示包含或集合关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include &quot;Renderer.h&quot;#include &lt;game-activity/native_app_glue/android_native_app_glue.h&gt;#include &lt;GLES3/gl3.h&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;android/imagedecoder.h&gt;#include &quot;AndroidOut.h&quot;#include &quot;Shader.h&quot;#include &quot;Utility.h&quot;#include &quot;TextureAsset.h&quot;// 宏定义，执行glGetString并将结果输出到logcat#define PRINT_GL_STRING(s) &#123;aout &lt;&lt; #s&quot;: &quot;&lt;&lt; glGetString(s) &lt;&lt; std::endl;&#125;// 宏定义，如果glGetString返回一个空格分隔的列表，则将每个元素打印在新行上/*! * @brief if glGetString returns a space separated list of elements, prints each one on a new line * * This works by creating an istringstream of the input c-style string. Then that is used to create * a vector -- each element of the vector is a new element in the input string. Finally a foreach * loop consumes this and outputs it to logcat using @a aout */#define PRINT_GL_STRING_AS_LIST(s) &#123; \\std::istringstream extensionStream((const char *) glGetString(s));\\std::vector&lt;std::string&gt; extensionList(\\ std::istream_iterator&lt;std::string&gt;&#123;extensionStream&#125;,\\ std::istream_iterator&lt;std::string&gt;());\\aout &lt;&lt; #s&quot;:\\n&quot;;\\for (auto&amp; extension: extensionList) &#123;\\ aout &lt;&lt; extension &lt;&lt; &quot;\\n&quot;;\\&#125;\\aout &lt;&lt; std::endl;\\&#125;// 定义一种颜色，玉米花蓝色。可以直接发送给glClearColor函数。#define CORNFLOWER_BLUE 100 / 255.f, 149 / 255.f, 237 / 255.f, 1// 顶点着色器和片段着色器的代码，通常这些会从资源文件中加载static const char *vertex = R&quot;vertex(#version 300 esin vec3 inPosition;in vec2 inUV;out vec2 fragUV;uniform mat4 uProjection;void main() &#123; fragUV = inUV; gl_Position = uProjection * vec4(inPosition, 1.0);&#125;)vertex&quot;;static const char *fragment = R&quot;fragment(#version 300 esprecision mediump float;in vec2 fragUV;uniform sampler2D uTexture;out vec4 outColor;void main() &#123; outColor = texture(uTexture, fragUV);&#125;)fragment&quot;;// 投影矩阵的半高度，这将给你一个从-2到2的高度为4的可渲染区域static constexpr float kProjectionHalfHeight = 2.f;// 投影矩阵的近平面距离。由于这是一个正交投影矩阵，负值便于排序（避免在0处的z-fighting）static constexpr float kProjectionNearPlane = -1.f;// 投影矩阵的远平面距离。与近平面等距的设置便于处理。/*! * The far plane distance for the projection matrix. Since this is an orthographic porjection * matrix, it&#x27;s convenient to have the far plane equidistant from 0 as the near plane. */static constexpr float kProjectionFarPlane = 1.f;// Renderer析构函数，处理EGL上下文的清理工作。Renderer::~Renderer() &#123; if (display_ != EGL_NO_DISPLAY) &#123; eglMakeCurrent(display_, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT); if (context_ != EGL_NO_CONTEXT) &#123; eglDestroyContext(display_, context_); context_ = EGL_NO_CONTEXT; &#125; if (surface_ != EGL_NO_SURFACE) &#123; eglDestroySurface(display_, surface_); surface_ = EGL_NO_SURFACE; &#125; eglTerminate(display_); display_ = EGL_NO_DISPLAY; &#125;&#125;// 渲染函数，包括渲染过程中的各种状态更新和绘制调用。void Renderer::render() &#123; // Check to see if the surface has changed size. This is _necessary_ to do every frame when // using immersive mode as you&#x27;ll get no other notification that your renderable area has // changed. updateRenderArea(); // When the renderable area changes, the projection matrix has to also be updated. This is true // even if you change from the sample orthographic projection matrix as your aspect ratio has // likely changed. if (shaderNeedsNewProjectionMatrix_) &#123; // a placeholder projection matrix allocated on the stack. Column-major memory layout float projectionMatrix[16] = &#123;0&#125;; // build an orthographic projection matrix for 2d rendering Utility::buildOrthographicMatrix( projectionMatrix, kProjectionHalfHeight, float(width_) / height_, kProjectionNearPlane, kProjectionFarPlane); // send the matrix to the shader // Note: the shader must be active for this to work. Since we only have one shader for this // demo, we can assume that it&#x27;s active. shader_-&gt;setProjectionMatrix(projectionMatrix); // make sure the matrix isn&#x27;t generated every frame shaderNeedsNewProjectionMatrix_ = false; &#125; // clear the color buffer glClear(GL_COLOR_BUFFER_BIT); // Render all the models. There&#x27;s no depth testing in this sample so they&#x27;re accepted in the // order provided. But the sample EGL setup requests a 24 bit depth buffer so you could // configure it at the end of initRenderer if (!models_.empty()) &#123; for (const auto &amp;model: models_) &#123; shader_-&gt;drawModel(model); &#125; &#125; // Present the rendered image. This is an implicit glFlush. auto swapResult = eglSwapBuffers(display_, surface_); assert(swapResult == EGL_TRUE);&#125;// 初始化渲染器，设置EGL上下文和OpenGL状态。void Renderer::initRenderer() &#123; // Choose your render attributes constexpr EGLint attribs[] = &#123; EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT, EGL_SURFACE_TYPE, EGL_WINDOW_BIT, EGL_BLUE_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_RED_SIZE, 8, EGL_DEPTH_SIZE, 24, EGL_NONE &#125;; // The default display is probably what you want on Android auto display = eglGetDisplay(EGL_DEFAULT_DISPLAY); eglInitialize(display, nullptr, nullptr); // figure out how many configs there are EGLint numConfigs; eglChooseConfig(display, attribs, nullptr, 0, &amp;numConfigs); // get the list of configurations std::unique_ptr &lt; EGLConfig[] &gt; supportedConfigs(new EGLConfig[numConfigs]); eglChooseConfig(display, attribs, supportedConfigs.get(), numConfigs, &amp;numConfigs); // Find a config we like. // Could likely just grab the first if we don&#x27;t care about anything else in the config. // Otherwise hook in your own heuristic auto config = *std::find_if( supportedConfigs.get(), supportedConfigs.get() + numConfigs, [&amp;display](const EGLConfig &amp;config) &#123; EGLint red, green, blue, depth; if (eglGetConfigAttrib(display, config, EGL_RED_SIZE, &amp;red) &amp;&amp; eglGetConfigAttrib(display, config, EGL_GREEN_SIZE, &amp;green) &amp;&amp; eglGetConfigAttrib(display, config, EGL_BLUE_SIZE, &amp;blue) &amp;&amp; eglGetConfigAttrib(display, config, EGL_DEPTH_SIZE, &amp;depth)) &#123; aout &lt;&lt; &quot;Found config with &quot; &lt;&lt; red &lt;&lt; &quot;, &quot; &lt;&lt; green &lt;&lt; &quot;, &quot; &lt;&lt; blue &lt;&lt; &quot;, &quot; &lt;&lt; depth &lt;&lt; std::endl; return red == 8 &amp;&amp; green == 8 &amp;&amp; blue == 8 &amp;&amp; depth == 24; &#125; return false; &#125;); aout &lt;&lt; &quot;Found &quot; &lt;&lt; numConfigs &lt;&lt; &quot; configs&quot; &lt;&lt; std::endl; aout &lt;&lt; &quot;Chose &quot; &lt;&lt; config &lt;&lt; std::endl; // create the proper window surface EGLint format; eglGetConfigAttrib(display, config, EGL_NATIVE_VISUAL_ID, &amp;format); EGLSurface surface = eglCreateWindowSurface(display, config, app_-&gt;window, nullptr); // Create a GLES 3 context EGLint contextAttribs[] = &#123;EGL_CONTEXT_CLIENT_VERSION, 3, EGL_NONE&#125;; EGLContext context = eglCreateContext(display, config, nullptr, contextAttribs); // get some window metrics auto madeCurrent = eglMakeCurrent(display, surface, surface, context); assert(madeCurrent); display_ = display; surface_ = surface; context_ = context; // make width and height invalid so it gets updated the first frame in @a updateRenderArea() width_ = -1; height_ = -1; PRINT_GL_STRING(GL_VENDOR); PRINT_GL_STRING(GL_RENDERER); PRINT_GL_STRING(GL_VERSION); PRINT_GL_STRING_AS_LIST(GL_EXTENSIONS); shader_ = std::unique_ptr&lt;Shader&gt;( Shader::loadShader(vertex, fragment, &quot;inPosition&quot;, &quot;inUV&quot;, &quot;uProjection&quot;)); assert(shader_); // Note: there&#x27;s only one shader in this demo, so I&#x27;ll activate it here. For a more complex game // you&#x27;ll want to track the active shader and activate/deactivate it as necessary shader_-&gt;activate(); // setup any other gl related global states glClearColor(CORNFLOWER_BLUE); // enable alpha globally for now, you probably don&#x27;t want to do this in a game glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // get some demo models into memory createModels();&#125;// 更新渲染区域的大小，如果有变化，则更新视口和投影矩阵。void Renderer::updateRenderArea() &#123; EGLint width; eglQuerySurface(display_, surface_, EGL_WIDTH, &amp;width); EGLint height; eglQuerySurface(display_, surface_, EGL_HEIGHT, &amp;height); if (width != width_ || height != height_) &#123; width_ = width; height_ = height; glViewport(0, 0, width, height); // make sure that we lazily recreate the projection matrix before we render shaderNeedsNewProjectionMatrix_ = true; &#125;&#125;// 创建演示模型的函数。/** * @brief Create any demo models we want for this demo. */void Renderer::createModels() &#123; /* * This is a square: * 0 --- 1 * | \\ | * | \\ | * | \\ | * 3 --- 2 */ std::vector &lt;Vertex&gt; vertices = &#123; Vertex(Vector3&#123;1, 1, 0&#125;, Vector2&#123;0, 0&#125;), // 0 Vertex(Vector3&#123;-1, 1, 0&#125;, Vector2&#123;1, 0&#125;), // 1 Vertex(Vector3&#123;-1, -1, 0&#125;, Vector2&#123;1, 1&#125;), // 2 Vertex(Vector3&#123;1, -1, 0&#125;, Vector2&#123;0, 1&#125;) // 3 &#125;; std::vector &lt;Index&gt; indices = &#123; 0, 1, 2, 0, 2, 3 &#125;; // loads an image and assigns it to the square. // // Note: there is no texture management in this sample, so if you reuse an image be careful not // to load it repeatedly. Since you get a shared_ptr you can safely reuse it in many models. auto assetManager = app_-&gt;activity-&gt;assetManager; auto spAndroidRobotTexture = TextureAsset::loadAsset(assetManager, &quot;android_robot.png&quot;); // Create a model and put it in the back of the render list. models_.emplace_back(vertices, indices, spAndroidRobotTexture);&#125;// 处理输入事件的函数，如触摸和按键事件。void Renderer::handleInput() &#123; // handle all queued inputs auto *inputBuffer = android_app_swap_input_buffers(app_); if (!inputBuffer) &#123; // no inputs yet. return; &#125; // handle motion events (motionEventsCounts can be 0). for (auto i = 0; i &lt; inputBuffer-&gt;motionEventsCount; i++) &#123; auto &amp;motionEvent = inputBuffer-&gt;motionEvents[i]; auto action = motionEvent.action; // Find the pointer index, mask and bitshift to turn it into a readable value. auto pointerIndex = (action &amp; AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) &gt;&gt; AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT; aout &lt;&lt; &quot;Pointer(s): &quot;; // get the x and y position of this event if it is not ACTION_MOVE. auto &amp;pointer = motionEvent.pointers[pointerIndex]; auto x = GameActivityPointerAxes_getX(&amp;pointer); auto y = GameActivityPointerAxes_getY(&amp;pointer); // determine the action type and process the event accordingly. switch (action &amp; AMOTION_EVENT_ACTION_MASK) &#123; case AMOTION_EVENT_ACTION_DOWN: case AMOTION_EVENT_ACTION_POINTER_DOWN: aout &lt;&lt; &quot;(&quot; &lt;&lt; pointer.id &lt;&lt; &quot;, &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) &quot; &lt;&lt; &quot;Pointer Down&quot;; break; case AMOTION_EVENT_ACTION_CANCEL: // treat the CANCEL as an UP event: doing nothing in the app, except // removing the pointer from the cache if pointers are locally saved. // code pass through on purpose. case AMOTION_EVENT_ACTION_UP: case AMOTION_EVENT_ACTION_POINTER_UP: aout &lt;&lt; &quot;(&quot; &lt;&lt; pointer.id &lt;&lt; &quot;, &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) &quot; &lt;&lt; &quot;Pointer Up&quot;; break; case AMOTION_EVENT_ACTION_MOVE: // There is no pointer index for ACTION_MOVE, only a snapshot of // all active pointers; app needs to cache previous active pointers // to figure out which ones are actually moved. for (auto index = 0; index &lt; motionEvent.pointerCount; index++) &#123; pointer = motionEvent.pointers[index]; x = GameActivityPointerAxes_getX(&amp;pointer); y = GameActivityPointerAxes_getY(&amp;pointer); aout &lt;&lt; &quot;(&quot; &lt;&lt; pointer.id &lt;&lt; &quot;, &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot;; if (index != (motionEvent.pointerCount - 1)) aout &lt;&lt; &quot;,&quot;; aout &lt;&lt; &quot; &quot;; &#125; aout &lt;&lt; &quot;Pointer Move&quot;; break; default: aout &lt;&lt; &quot;Unknown MotionEvent Action: &quot; &lt;&lt; action; &#125; aout &lt;&lt; std::endl; &#125; // clear the motion input count in this buffer for main thread to re-use. android_app_clear_motion_events(inputBuffer); // handle input key events. for (auto i = 0; i &lt; inputBuffer-&gt;keyEventsCount; i++) &#123; auto &amp;keyEvent = inputBuffer-&gt;keyEvents[i]; aout &lt;&lt; &quot;Key: &quot; &lt;&lt; keyEvent.keyCode &lt;&lt; &quot; &quot;; switch (keyEvent.action) &#123; case AKEY_EVENT_ACTION_DOWN: aout &lt;&lt; &quot;Key Down&quot;; break; case AKEY_EVENT_ACTION_UP: aout &lt;&lt; &quot;Key Up&quot;; break; case AKEY_EVENT_ACTION_MULTIPLE: // Deprecated since Android API level 29. aout &lt;&lt; &quot;Multiple Key Actions&quot;; break; default: aout &lt;&lt; &quot;Unknown KeyEvent Action: &quot; &lt;&lt; keyEvent.action; &#125; aout &lt;&lt; std::endl; &#125; // clear the key input count too. android_app_clear_key_events(inputBuffer);&#125;","categories":[{"name":"8 - 渲染引擎","slug":"8-渲染引擎","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"8.1 - 基础项目拆解","slug":"8-渲染引擎/8-1-基础项目拆解","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-1-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%8B%86%E8%A7%A3/"}],"tags":[]},{"title":"Android Game Project 项目结构","slug":"8渲染引擎/01 工程结构/02 Android GameProject 结构目录","date":"2023-08-23T10:38:36.000Z","updated":"2024-03-27T16:57:35.612Z","comments":true,"path":"2023/08/23/8渲染引擎/01 工程结构/02 Android GameProject 结构目录/","link":"","permalink":"http://example.com/2023/08/23/8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/01%20%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/02%20Android%20GameProject%20%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95/","excerpt":"","text":"author: 朕小猫-GPT4 图片显示的是一个典型的Android项目目录结构，这个项目中集成了C++原生代码。以下是各个组件的结构和作用的简述： src main assets android_robot.png 一个图像资产，可能用于应用的用户界面或游戏图形。 cpp AndroidOut.cpp 和 AndroidOut.h：C++源文件和头文件，可能用于原生代码中的日志或输出目的。 CMakeLists.txt：CMake配置文件，CMake是用于管理原生代码编译的构建系统。 main.cpp：主要的C++源文件，可能包含原生代码执行的入口点。 Model.h：很可能定义了一个数据模型或对象的头文件。 Renderer.cpp 和 Renderer.h：渲染相关的源文件和头文件，或许处理屏幕上图形的绘制。 Shader.cpp 和 Shader.h：与着色器程序相关的源文件和头文件，用于高级图形效果。 TextureAsset.cpp 和 TextureAsset.h：处理原生代码中纹理资产的源文件和头文件。 Utility.cpp 和 Utility.h：在原生代码库中使用的工具函数或类的源文件和头文件。 java com.jason.game MainActivity res： AndroidManifest.xml .gitignore：Git的配置文件，指定在版本控制中忽略哪些文件或目录。 build.gradle.kts：用Kotlin脚本编写的Gradle构建系统的构建配置文件，指定依赖和构建设置。 proguard-rules.pro：ProGuard的配置文件，ProGuard是一个用于代码缩减和混淆的工具，以防止应用发布构建的反向工程。 这个结构表明这是一个复杂的Android项目，它使用Java&#x2F;Kotlin来实现Android特定功能，并使用C++来处理性能密集型任务，可能用于游戏开发或计算密集型应用。","categories":[{"name":"8 - 渲染引擎","slug":"8-渲染引擎","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"8.1 - 基础项目拆解","slug":"8-渲染引擎/8-1-基础项目拆解","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-1-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%8B%86%E8%A7%A3/"}],"tags":[]},{"title":"Android Bitmap 性能专题 - Bitmap 内存从申请到回收","slug":"3 Android/性能优化/Android-Bitmap-性能专题","date":"2023-08-15T10:21:30.000Z","updated":"2024-03-23T16:51:11.270Z","comments":true,"path":"2023/08/15/3 Android/性能优化/Android-Bitmap-性能专题/","link":"","permalink":"http://example.com/2023/08/15/3%20Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/","excerpt":"","text":"问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein Q：Bitmap 如何开辟内存？ Q：Bitmap 内存是怎么复用和销毁的？本地资源图片应该怎么去做适配？ Q：该如何去优化这些占用较大内存的本地资源图片？ Q：如何判断和优化 Bitmap OOM，如何 dump 线上内存来做优化分析？ 从 Bitmap 的创建说起12345678910111213141516171819202122232425262728293031323334/** * Private constructor that must received an already allocated native bitmap * int (pointer). */// called from JNIBitmap(long nativeBitmap, int width, int height, int density, boolean isMutable, boolean requestPremultiplied, byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123; if (nativeBitmap == 0) &#123; throw new RuntimeException(&quot;internal error: native bitmap is 0&quot;); &#125; mWidth = width; mHeight = height; mIsMutable = isMutable; mRequestPremultiplied = requestPremultiplied; mNinePatchChunk = ninePatchChunk; mNinePatchInsets = ninePatchInsets; if (density &gt;= 0) &#123; mDensity = density; &#125; mNativePtr = nativeBitmap; long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount(); NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize); registry.registerNativeAllocation(this, nativeBitmap); if (ResourcesImpl.TRACE_FOR_DETAILED_PRELOAD) &#123; sPreloadTracingNumInstantiatedBitmaps++; sPreloadTracingTotalBitmapsSize += nativeSize; &#125;&#125; called from JNI 这个解释其实已经很明确了，也就是说这个对象是 Native 层构建返回的。因此我们跟踪到 BitmapFactory.decodeResource() 中去看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static Bitmap decodeResource(Resources res, int id, Options opts) &#123; validate(opts); Bitmap bm = null; InputStream is = null; try &#123; final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); &#125; catch (Exception e) &#123; /* do nothing. If the exception happened on open, bm will be null. If it happened on close, bm is still valid. */ &#125; finally &#123; try &#123; if (is != null) is.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123; throw new IllegalArgumentException(&quot;Problem decoding into existing bitmap&quot;); &#125; return bm;&#125;public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) &#123; validate(opts); if (opts == null) &#123; opts = new Options(); &#125; if (opts.inDensity == 0 &amp;&amp; value != null) &#123; final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) &#123; opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; &#125; else if (density != TypedValue.DENSITY_NONE) &#123; opts.inDensity = density; &#125; &#125; // 获取当前手机设备的 dpi if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123; opts.inTargetDensity = res.getDisplayMetrics().densityDpi; &#125; return decodeStream(is, pad, opts);&#125;// 省略部分跟踪代码 ......private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts); 最终调用的是 native 方法 nativeDecodeStream 这里以 Android N 版本为例: &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;BitmapFactory.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363static jobject nativeDecodeStream(JNIEnv *env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options) &#123; jobject bitmap = NULL; std::unique_ptr&lt;SkStream&gt; stream(CreateJavaInputStreamAdaptor(env, is, storage)); if (stream.get()) &#123; std::unique_ptr&lt;SkStreamRewindable&gt; bufferedStream( SkFrontBufferedStream::Create(stream.release(), SkCodec::MinBufferedBytesNeeded())); SkASSERT(bufferedStream.get() != NULL); bitmap = doDecode(env, bufferedStream.release(), padding, options); &#125; return bitmap;&#125;static jobject doDecode(JNIEnv *env, SkStreamRewindable *stream, jobject padding, jobject options) &#123; // This function takes ownership of the input stream. Since the SkAndroidCodec // will take ownership of the stream, we don&#x27;t necessarily need to take ownership // here. This is a precaution - if we were to return before creating the codec, // we need to make sure that we delete the stream. std::unique_ptr&lt;SkStreamRewindable&gt; streamDeleter(stream); // Set default values for the options parameters. int sampleSize = 1; // 是否只是获取图片的大小 bool onlyDecodeSize = false; SkColorType prefColorType = kN32_SkColorType; bool isMutable = false; float scale = 1.0f; bool requireUnpremultiplied = false; jobject javaBitmap = NULL; // Update with options supplied by the client. // 解析 options 参数 if (options != NULL) &#123; sampleSize = env-&gt;GetIntField(options, gOptions_sampleSizeFieldID); // Correct a non-positive sampleSize. sampleSize defaults to zero within the // options object, which is strange. if (sampleSize &lt;= 0) &#123; sampleSize = 1; &#125; if (env-&gt;GetBooleanField(options, gOptions_justBoundsFieldID)) &#123; onlyDecodeSize = true; &#125; // initialize these, in case we fail later on env-&gt;SetIntField(options, gOptions_widthFieldID, -1); env-&gt;SetIntField(options, gOptions_heightFieldID, -1); env-&gt;SetObjectField(options, gOptions_mimeFieldID, 0); // 解析 ColorType ，复用参数等等 jobject jconfig = env-&gt;GetObjectField(options, gOptions_configFieldID); prefColorType = GraphicsJNI::getNativeBitmapColorType(env, jconfig); isMutable = env-&gt;GetBooleanField(options, gOptions_mutableFieldID); requireUnpremultiplied = !env-&gt;GetBooleanField(options, gOptions_premultipliedFieldID); javaBitmap = env-&gt;GetObjectField(options, gOptions_bitmapFieldID); // 计算缩放的比例 if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123; // 获取图片当前 xhdpi 的 density const int density = env-&gt;GetIntField(options, gOptions_densityFieldID); // 获取当前设备的 dpi const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; // scale = 当前设备的 dpi / xhdpi 的 density // scale = 420/320 = 1.3125 scale = (float) targetDensity / density; &#125; &#125; &#125; // Create the codec. NinePatchPeeker peeker; std::unique_ptr&lt;SkAndroidCodec&gt; codec(SkAndroidCodec::NewFromStream(streamDeleter.release(), 280 &amp; peeker)); if (!codec.get()) &#123; return nullObjectReturn(&quot;SkAndroidCodec::NewFromStream returned null&quot;); &#125; // Do not allow ninepatch decodes to 565. In the past, decodes to 565 // would dither, and we do not want to pre-dither ninepatches, since we // know that they will be stretched. We no longer dither 565 decodes, // but we continue to prevent ninepatches from decoding to 565, in order // to maintain the old behavior. if (peeker.mPatch &amp;&amp; kRGB_565_SkColorType == prefColorType) &#123; prefColorType = kN32_SkColorType; &#125; // 获取当前图片的大小 // Determine the output size. SkISize size = codec-&gt;getSampledDimensions(sampleSize); int scaledWidth = size.width(); int scaledHeight = size.height(); bool willScale = false; // 处理 simpleSize 压缩，我们这里没穿，上面默认是 1 // Apply a fine scaling step if necessary. if (needsFineScale(codec-&gt;getInfo().dimensions(), size, sampleSize)) &#123; willScale = true; scaledWidth = codec-&gt;getInfo().width() / sampleSize; scaledHeight = codec-&gt;getInfo().height() / sampleSize; &#125; // Set the options and return if the client only wants the size. if (options != NULL) &#123; jstring mimeType = encodedFormatToString(env, codec-&gt;getEncodedFormat()); if (env-&gt;ExceptionCheck()) &#123; return nullObjectReturn(&quot;OOM in encodedFormatToString()&quot;); &#125; // 设置 options 对象中的 outWidth 和 outHeight env-&gt;SetIntField(options, gOptions_widthFieldID, scaledWidth); env-&gt;SetIntField(options, gOptions_heightFieldID, scaledHeight); env-&gt;SetObjectField(options, gOptions_mimeFieldID, mimeType); // 如果只是获取大小直接 return null 这里是 nullptr 而不是 NULL if (onlyDecodeSize) &#123; return nullptr; &#125; &#125; // Scale is necessary due to density differences. if (scale != 1.0f) &#123; willScale = true; // 计算 scaledWidth 和 scaledHeight // scaledWidth = 864 * 1.3125 + 0.5f = 1134 + 0.5f = 1134 scaledWidth = static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); // scaledHeight = 582 * 1.3125 + 0.5f = 763.875 + 0.5f = 764 scaledHeight = static_cast&lt;int&gt;(scaledHeight * scale + 0.5f); &#125; // 判断是否有复用的 Bitmap android::Bitmap *reuseBitmap = nullptr; unsigned int existingBufferSize = 0; if (javaBitmap != NULL) &#123; reuseBitmap = GraphicsJNI::getBitmap(env, javaBitmap); if (reuseBitmap-&gt;peekAtPixelRef()-&gt;isImmutable()) &#123; // 无法重用一个不变的位图图像解码器的目标。 ALOGW(&quot;Unable to reuse an immutable bitmap as an image decoder target.&quot;); javaBitmap = NULL; reuseBitmap = nullptr; &#125; else &#123; existingBufferSize = GraphicsJNI::getBitmapAllocationByteCount(env, javaBitmap); &#125; &#125; JavaPixelAllocator javaAllocator(env); RecyclingPixelAllocator recyclingAllocator(reuseBitmap, existingBufferSize); ScaleCheckingAllocator scaleCheckingAllocator(scale, existingBufferSize); SkBitmap::HeapAllocator heapAllocator; SkBitmap::Allocator *decodeAllocator; if (javaBitmap != nullptr &amp;&amp; willScale) &#123; // This will allocate pixels using a HeapAllocator, since there will be an extra // scaling step that copies these pixels into Java memory. This allocator // also checks that the recycled javaBitmap is large enough. decodeAllocator = &amp;scaleCheckingAllocator; &#125; else if (javaBitmap != nullptr) &#123; decodeAllocator = &amp;recyclingAllocator; &#125; else if (willScale) &#123; // This will allocate pixels using a HeapAllocator, since there will be an extra // scaling step that copies these pixels into Java memory. decodeAllocator = &amp;heapAllocator; &#125; else &#123; decodeAllocator = &amp;javaAllocator; &#125; // Set the decode colorType. This is necessary because we can&#x27;t always support // the requested colorType. SkColorType decodeColorType = codec-&gt;computeOutputColorType(prefColorType); // Construct a color table for the decode if necessary SkAutoTUnref &lt;SkColorTable&gt; colorTable(nullptr); SkPMColor *colorPtr = nullptr; int *colorCount = nullptr; int maxColors = 256; SkPMColor colors[256]; if (kIndex_8_SkColorType == decodeColorType) &#123; colorTable.reset(new SkColorTable(colors, maxColors)); // SkColorTable expects us to initialize all of the colors before creating an // SkColorTable. However, we are using SkBitmap with an Allocator to allocate // memory for the decode, so we need to create the SkColorTable before decoding. // It is safe for SkAndroidCodec to modify the colors because this SkBitmap is // not being used elsewhere. colorPtr = const_cast&lt;SkPMColor *&gt;(colorTable-&gt;readColors()); colorCount = &amp;maxColors; &#125; // Set the alpha type for the decode. SkAlphaType alphaType = codec-&gt;computeOutputAlphaType(requireUnpremultiplied); // 创建 SkImageInfo 信息，宽，高，ColorType，alphaType const SkImageInfo decodeInfo = SkImageInfo::Make(size.width(), size.height(), decodeColorType, alphaType); SkImageInfo bitmapInfo = decodeInfo; if (decodeColorType == kGray_8_SkColorType) &#123; // The legacy implementation of BitmapFactory used kAlpha8 for // grayscale images (before kGray8 existed). While the codec // recognizes kGray8, we need to decode into a kAlpha8 bitmap // in order to avoid a behavior change. bitmapInfo = SkImageInfo::MakeA8(size.width(), size.height()); &#125; // 解析 SkBitmap 设置 bitmapInfo，tryAllocPixels 开辟内存，具体分析在后面 SkBitmap decodingBitmap; if (!decodingBitmap.setInfo(bitmapInfo) || !decodingBitmap.tryAllocPixels(decodeAllocator, colorTable)) &#123; // SkAndroidCodec should recommend a valid SkImageInfo, so setInfo() // should only only fail if the calculated value for rowBytes is too // large. // tryAllocPixels() can fail due to OOM on the Java heap, OOM on the // native heap, or the recycled javaBitmap being too small to reuse. return nullptr; &#125; // Use SkAndroidCodec to perform the decode. SkAndroidCodec::AndroidOptions codecOptions; codecOptions.fZeroInitialized = (decodeAllocator == &amp;javaAllocator) ? SkCodec::kYes_ZeroInitialized : SkCodec::kNo_ZeroInitialized; codecOptions.fColorPtr = colorPtr; codecOptions.fColorCount = colorCount; codecOptions.fSampleSize = sampleSize; // 解析获取像素值 SkCodec::Result result = codec-&gt;getAndroidPixels(decodeInfo, decodingBitmap.getPixels(), decodingBitmap.rowBytes(), &amp;codecOptions); switch (result) &#123; case SkCodec::kSuccess: case SkCodec::kIncompleteInput: break; default: return nullObjectReturn(&quot;codec-&gt;getAndroidPixels() failed.&quot;); &#125; jbyteArray ninePatchChunk = NULL; if (peeker.mPatch != NULL) &#123; if (willScale) &#123; scaleNinePatchChunk(peeker.mPatch, scale, scaledWidth, scaledHeight); &#125; size_t ninePatchArraySize = peeker.mPatch-&gt;serializedSize(); ninePatchChunk = env-&gt;NewByteArray(ninePatchArraySize); if (ninePatchChunk == NULL) &#123; return nullObjectReturn(&quot;ninePatchChunk == null&quot;); &#125; jbyte *array = (jbyte *) env-&gt;GetPrimitiveArrayCritical(ninePatchChunk, NULL); if (array == NULL) &#123; return nullObjectReturn(&quot;primitive array == null&quot;); &#125; memcpy(array, peeker.mPatch, peeker.mPatchSize); env-&gt;ReleasePrimitiveArrayCritical(ninePatchChunk, array, 0); &#125; jobject ninePatchInsets = NULL; if (peeker.mHasInsets) &#123; ninePatchInsets = env-&gt;NewObject(gInsetStruct_class, gInsetStruct_constructorMethodID, peeker.mOpticalInsets[0], peeker.mOpticalInsets[1], peeker.mOpticalInsets[2], peeker.mOpticalInsets[3], peeker.mOutlineInsets[0], peeker.mOutlineInsets[1], peeker.mOutlineInsets[2], peeker.mOutlineInsets[3], peeker.mOutlineRadius, peeker.mOutlineAlpha, scale); if (ninePatchInsets == NULL) &#123; return nullObjectReturn(&quot;nine patch insets == null&quot;); &#125; if (javaBitmap != NULL) &#123; env-&gt;SetObjectField(javaBitmap, gBitmap_ninePatchInsetsFieldID, ninePatchInsets); &#125; &#125; // 构建 SkBitmap 这个才是最终的 SkBitmap outputBitmap; if (willScale) &#123; // 如果需要缩放，那需要重新创建一张图片，上面加载的是图片的本身大小 // This is weird so let me explain: we could use the scale parameter // directly, but for historical reasons this is how the corresponding // Dalvik code has always behaved. We simply recreate the behavior here. // The result is slightly different from simply using scale because of // the 0.5f rounding bias applied when computing the target image size const float sx = scaledWidth / float(decodingBitmap.width()); const float sy = scaledHeight / float(decodingBitmap.height()); // Set the allocator for the outputBitmap. SkBitmap::Allocator *outputAllocator; if (javaBitmap != nullptr) &#123; outputAllocator = &amp;recyclingAllocator; &#125; else &#123; outputAllocator = &amp;javaAllocator; &#125; SkColorType scaledColorType = colorTypeForScaledOutput(decodingBitmap.colorType()); // FIXME: If the alphaType is kUnpremul and the image has alpha, the // colors may not be correct, since Skia does not yet support drawing // to/from unpremultiplied bitmaps. // 设置 SkImageInfo ，注意这里是 scaledWidth ，scaledHeight outputBitmap.setInfo(SkImageInfo::Make(scaledWidth, scaledHeight, scaledColorType, decodingBitmap.alphaType())); // 开辟当前 Bitmap 图片的内存 if (!outputBitmap.tryAllocPixels(outputAllocator, NULL)) &#123; // This should only fail on OOM. The recyclingAllocator should have // enough memory since we check this before decoding using the // scaleCheckingAllocator. return nullObjectReturn(&quot;allocation failed for scaled bitmap&quot;); &#125; SkPaint paint; // kSrc_Mode instructs us to overwrite the unininitialized pixels in // outputBitmap. Otherwise we would blend by default, which is not // what we want. paint.setXfermodeMode(SkXfermode::kSrc_Mode); paint.setFilterQuality(kLow_SkFilterQuality); // decodingBitmap -&gt; 画到 outputBitmap SkCanvas canvas(outputBitmap); canvas.scale(sx, sy); canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &amp;paint); &#125; else &#123; outputBitmap.swap(decodingBitmap); &#125; if (padding) &#123; if (peeker.mPatch != NULL) &#123; GraphicsJNI::set_jrect(env, padding, peeker.mPatch-&gt;paddingLeft, peeker.mPatch-&gt;paddingTop, peeker.mPatch-&gt;paddingRight, peeker.mPatch-&gt;paddingBottom); &#125; else &#123; GraphicsJNI::set_jrect(env, padding, -1, -1, -1, -1); &#125; &#125; // If we get here, the outputBitmap should have an installed pixelref. if (outputBitmap.pixelRef() == NULL) &#123; return nullObjectReturn(&quot;Got null SkPixelRef&quot;); &#125; if (!isMutable &amp;&amp; javaBitmap == NULL) &#123; // promise we will never change our pixels (great for sharing and pictures) outputBitmap.setImmutable(); &#125; // 如果有复用返回原来的 javaBitmap bool isPremultiplied = !requireUnpremultiplied; if (javaBitmap != nullptr) &#123; GraphicsJNI::reinitBitmap(env, javaBitmap, outputBitmap.info(), isPremultiplied); outputBitmap.notifyPixelsChanged(); // If a java bitmap was passed in for reuse, pass it back return javaBitmap; &#125; int bitmapCreateFlags = 0x0; if (isMutable) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Mutable; if (isPremultiplied) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Premultiplied; // 没有复用的 Bitmap 创建一个新的 Bitmap // now create the java bitmap return GraphicsJNI::createBitmap(env, javaAllocator.getStorageObjAndReset(), bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1);&#125;jobject GraphicsJNI::createBitmap(JNIEnv *env, android::Bitmap *bitmap, int bitmapCreateFlags, jbyteArray ninePatchChunk, jobject ninePatchInsets, int density) &#123; bool isMutable = bitmapCreateFlags &amp; kBitmapCreateFlag_Mutable; bool isPremultiplied = bitmapCreateFlags &amp; kBitmapCreateFlag_Premultiplied; // The caller needs to have already set the alpha type properly, so the // native SkBitmap stays in sync with the Java Bitmap. assert_premultiplied(bitmap-&gt;info(), isPremultiplied); jobject obj = env-&gt;NewObject(gBitmap_class, gBitmap_constructorMethodID, reinterpret_cast&lt;jlong&gt;(bitmap), bitmap-&gt;javaByteArray(), bitmap-&gt;width(), bitmap-&gt;height(), density, isMutable, isPremultiplied, ninePatchChunk, ninePatchInsets); hasException(env); // For the side effect of logging. return obj;&#125; 上面的代码看起来比较长，其实是非常简单的，相信大家都能看得懂，这里我对上面的流程再做一些总结： 解析 java 层传递过来的 Options 的参数，如 simpleSize ，isMutable，javaBitmap 等等，同时计算出 scale 。 获取当前图片的大小，根据 sampleSize 判断是否需要压缩，同时计算出 scaledWidth ，scaledHeight。 设置 options 宽高为 scaledWidth ，scaledHeight ，如果只是解析宽高那么就直接返回，也就是 options.inJustDecodeBounds &#x3D; true 时，但是这里需要注意返回的是，资源图片的宽高并不是 Bitmap 最终的宽高。（我们大部分人对这个有误解） 创建 native 层的 SkImageInfo 和 SkBitmap ，然后调用 tryAllocPixels 去开辟图片的内存空间，然后调用 getAndroidPixels 去解析像素值 ，这里的 decodingBitmap 也并不是最终需要返回的 Bitmap ，而是原资源图片的 Bitmap 。 构建需要返回的 outputBitmap ，如果需要缩放那么重新去开辟一块内存空间，如果不需要缩放直接调用 swap 方法即可。最后判断有没有复用的 JavaBitmap ,如果有复用调用 reinitBitmap 然后直接返回，如果没有则调用 createBitmap 去创建一个新的 Bitmap 。 究竟需要多少内存？通过上面的分析，我们可能会有疑问？我们调用了两次 tryAllocPixels ，那如果加载一张 (1440x2560) 10M 的图片，岂不是需要 20M 的内存？ 在 Android 平台上，Bitmap 的内存申请操作通常涉及到 Java 层和 Native 层的协作，而 tryAllocPixels 方法的多次调用可能是由于内部的内存分配和管理流程所致。 在 Android 4.4 及以上版本中，当你尝试为 Bitmap 对象申请内存时，tryAllocPixels 方法可能会在底层进行两次调用。这个行为在底层库中被设计用来提高内存分配的成功率。 第一次调用 tryAllocPixels 旨在检查是否有足够的内存来分配 Bitmap 的像素数据。如果这次调用失败，系统会尝试触发一次垃圾回收（GC）操作，以释放一些已不再使用的内存资源。 第二次调用 tryAllocPixels 发生在垃圾回收之后，此时系统期望能够分配足够的内存来满足 Bitmap 的需求。如果第二次调用仍然失败，那么可能会抛出 OutOfMemoryError 错误。 这种设计的目的是为了提高 Bitmap 内存分配的成功率。由于 Android 平台上的内存管理和垃圾回收机制是相对复杂的，经过多次尝试分配内存和触发垃圾回收，可以增加 Bitmap 成功分配内存的可能性。 12345678910111213141516171819202122232425262728293031问题：两次调用需要两倍的内存吗GPT4: 在处理Android图片加载时，内存管理是一个关键考虑因素。特别是对于高分辨率的图片，如1440x2560像素大小的图片，观上可能会担心单纯通过分析像素数和颜色深度得出的内存需求量会加倍，尤其是在调用像`tryAllocPixels`这样的函数两次时。这里的关键在于理解`tryAllocPixels`函数的作用及其在Android图片处理中的实际行为。`tryAllocPixels`是 Android Skia 图形库中的一个函数，用于尝试分配内存以存储图片的像素数据。当你看到代码中似乎调用了两次`tryAllocPixels`，可能会误以为这意味着图片数据会被加载或复制两次，从而导致内存使用翻倍。然而，实际情况可能并非如此。首先，调用`tryAllocPixels`并不总是意味着实际的内存分配。这个函数的行为取决于多个因素，包括图片的存储格式、是否已经有足够的内存分配给图片，以及图像解码器的实现等。在某些情况下，如果图片已经在内存中有一个分配好的空间，第二次调用可能仅仅是一个重复的操作，而不会实际增加内存消耗。其次，即使图片数据需要被重新处理或在内存中重新定位，这也不一定意味着整个图片大小的内存会被再次完整分配。例如，某些优化操作可能仅仅需要额外的小量内存来处理图片数据，而不是复制整个图片。最后，Android平台和许多现代操作系统都采用了高效的内存管理和图像处理策略。这包括图片的压缩存储、延迟解码（只有在显示图片时才完全解码）、以及内存共享和重用机制等。这些机制意味着即使处理大型图片，系统也能通过优化减少实际的内存占用。因此，尽管从理论上分析像素和颜色深度可能会让人担心高内存消耗，实际上Android的图片加载和处理框架设计有多种优化，以保持内存使用的效率。对于开发者而言，关键是了解并利用这些机制，例如使用适当的图片加载库（如Glide、Picasso等），它们为图片处理提供了进一步的优化和内存管理策略。 在 Android 中，Bitmap 对象的内存使用量取决于图像的像素数量、每个像素的位深度和像素数据的存储方式。一个 10MB 的图片通常指的是文件大小，而不是图像的像素数量，因此具体的内存使用量会根据图像的属性而有所不同。 假设你有一张 10MB 的图片，我们可以估算一下将其加载为 Bitmap 时可能需要的内存量。请注意，以下是一个粗略的估算，实际内存使用量可能会受到压缩、图像格式和设备性能的影响。 图像大小： 假设你的图片大小为 10MB，这指的是文件的大小。这并不直接表示图像的像素数量，因为图像可以使用不同的压缩算法和格式存储。通常情况下，JPEG 格式的图像文件较小，而无损格式如 PNG 或 BMP 文件较大。 解码后的像素数据： 当你将图片解码为 Bitmap 时，其像素数据将被加载到内存中。假设该图片是一个 24 位的彩色图片（每个像素使用 8 位红、绿、蓝通道），那么像素数据的大小将是图像的宽度乘以高度乘以 3（每个像素 3 个通道）字节。这个估算不考虑额外的颜色通道、Alpha 通道等。 所以，一个粗略的估算如下： 假设图片的像素数据大小为 pixelsSize 字节，则需要的内存量约为：pixelsSize + Overhead。 Overhead 是 Bitmap 对象的开销，它通常取决于设备的位数、对象头信息、内存对齐等因素。对于一个普通的 24 位彩色图片，Overhead 大约在 4-8MB 左右。 需要注意的是，这只是一个估算，并且实际情况可能因为图片格式、加载库的实现、设备性能等因素而有所不同。在实际开发中，你可以使用一些工具来测量实际的内存使用量，例如 Android Studio 的内存分析工具。 Bitmap 的内存申请Bitmap 的内存申请不同版本间有些许差异，在 3.0-7.0 的 bitmap 像素内存都是存放在 Java heap 中的，而 8.0 以后则是放在 Native heap 中的 8.0 Bitmap 内存申请1234567891011121314151617181920@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); logMemory(); Bitmap bitmap = Bitmap.createBitmap(1024, 1024 * 500, Bitmap.Config.ARGB_8888); logMemory();&#125;private void logMemory() &#123; ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); activityManager.getMemoryInfo(memoryInfo); Log.e(&quot;TAG&quot;, &quot;AvailMem :&quot; + memoryInfo.availMem / 1024 / 1024); Log.e(&quot;TAG&quot;, &quot;lowMemory：&quot; + memoryInfo.lowMemory); Log.e(&quot;TAG&quot;, &quot;NativeHeapAllocatedSize :&quot; + Debug.getNativeHeapAllocatedSize() / 1024 / 1024);&#125; 上面我们创建了一张 2G 大小的 bitmap 我们在 8.0 以下的版本运行是会 OOM 的，而我们在 8.0 以上的版本运行是完全没问题，但 Native 内存多了 2G 的内存。 1234567E/TAG: AvailMem :1654E/TAG: lowMemory：falseE/TAG: NativeHeapAllocatedSize :4E/TAG: AvailMem :1656E/TAG: lowMemory：falseE/TAG: NativeHeapAllocatedSize :2052 为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况在 Android 应用中，一张大图片的像素数据如果放在 Java 层可能会导致 OutOfMemoryError (OOM) 错误，而放在 Native 层不会出现这个问题。这涉及到 Java 层和 Native 层内存管理的不同方式以及底层实现的细节。 Java 层内存管理： 在 Java 层，对象的内存管理由 Java 虚拟机 (JVM) 负责。当你创建一个 Bitmap 对象并加载大图片的像素数据时，这些像素数据会在 Java 堆内存中分配。Android 应用的 Java 堆内存限制通常较小，这是为了确保系统的稳定性，避免应用占用过多内存影响其他应用和系统的运行。Java 堆内存受到限制，当堆内存用尽时就会触发 OutOfMemoryError 错误。由于 Java 层的内存管理涉及垃圾回收和其他 Java 虚拟机机制，加载大量像素数据可能会导致内存碎片和性能问题，最终导致 OOM 错误。 Native 层内存管理： 在 Native 层，像素数据的内存分配和释放由底层操作系统和 C&#x2F;C++ 代码负责。通过在 Native 层使用本地代码（如 C&#x2F;C++），你可以更好地控制内存的分配和释放。Native 层不受 Java 堆内存限制，因此可以更灵活地处理大量的像素数据，减少内存碎片问题，并降低 OOM 风险。 7.0 与 8.0 Bitmap 内存申请 tryAllocPixels 方法通过之前的源码分析可知 bitmap 的内存创建都是通过 tryAllocPixels 方法来申请的，我们通过源码来对比一下他们之间的区别，我们首先来看下 7.0 的代码： &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool SkBitmap::tryAllocPixels(Allocator *allocator, SkColorTable *ctable) &#123; HeapAllocator stdalloc; if (nullptr == allocator) &#123; allocator = &amp;stdalloc; &#125; return allocator-&gt;allocPixelRef(this, ctable);&#125;bool JavaPixelAllocator::allocPixelRef(SkBitmap *bitmap, SkColorTable *ctable) &#123; JNIEnv *env = vm2env(mJavaVM); mStorage = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable); return mStorage != nullptr;&#125;android::Bitmap *GraphicsJNI::allocateJavaPixelRef(JNIEnv *env, SkBitmap *bitmap, SkColorTable *ctable) &#123; const SkImageInfo &amp;info = bitmap-&gt;info(); if (info.colorType() == kUnknown_SkColorType) &#123; doThrowIAE(env, &quot;unknown bitmap configuration&quot;); return NULL; &#125; size_t size; if (!computeAllocationSize(*bitmap, &amp;size)) &#123; return NULL; &#125; // we must respect the rowBytes value already set on the bitmap instead of // attempting to compute our own. const size_t rowBytes = bitmap-&gt;rowBytes(); jbyteArray arrayObj = (jbyteArray) env-&gt;CallObjectMethod(gVMRuntime, gVMRuntime_newNonMovableArray, gByte_class, size); if (env-&gt;ExceptionCheck() != 0) &#123; return NULL; &#125; SkASSERT(arrayObj); jbyte *addr = (jbyte *) env-&gt;CallLongMethod(gVMRuntime, gVMRuntime_addressOf, arrayObj); if (env-&gt;ExceptionCheck() != 0) &#123; return NULL; &#125; SkASSERT(addr); android::Bitmap *wrapper = new android::Bitmap(env, arrayObj, (void *) addr, info, rowBytes, ctable); wrapper-&gt;getSkBitmap(bitmap); // since we&#x27;re already allocated, we lockPixels right away // HeapAllocator behaves this way too bitmap-&gt;lockPixels(); return wrapper;&#125; 从上面就可以看到, new android::Bitmap 见： frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 1234567891011Bitmap::Bitmap(JNIEnv *env, jbyteArray storageObj, void *address, const SkImageInfo &amp;info, size_t rowBytes, SkColorTable *ctable) : mPixelStorageType(PixelStorageType::Java) &#123; env-&gt;GetJavaVM(&amp;mPixelStorage.java.jvm); mPixelStorage.java.jweakRef = env-&gt;NewWeakGlobalRef(storageObj); mPixelStorage.java.jstrongRef = nullptr; mPixelRef.reset(new WrappedPixelRef(this, address, info, rowBytes, ctable)); // Note: this will trigger a call to onStrongRefDestroyed(), but // we want the pixel ref to have a ref count of 0 at this point mPixelRef-&gt;unref();&#125; address 获取的是 arrayObj 的地址，而 arrayObj 是 jbyteArray 数据类型，也就是说这里是通过 JNI 进入了 Java 世界开辟了内存，好比 Zygote 进入 Java 世界是通过 JNI 调用 com.android.internal.os.ZygoteInit 类的 main 函数是一个道理~ 我们还可以继续跟到 gVMRuntime_newNonMovableArray 中去看看实现，最后是 runtime-&gt;GetHeap() 上分配内存也就是 Java heap 内存。 我们还得看下 8.0 的源码，比较一下它与 7.0 之间的区别： external&#x2F;skia&#x2F;src&#x2F;core&#x2F;SkBitmap.cpp 12345678910111213bool SkBitmap::tryAllocPixels(Allocator *allocator, SkColorTable *ctable) &#123; HeapAllocator stdalloc; if (nullptr == allocator) &#123; allocator = &amp;stdalloc; &#125; return allocator-&gt;allocPixelRef(this, ctable);&#125;bool HeapAllocator::allocPixelRef(SkBitmap *bitmap, SkColorTable *ctable) &#123; mStorage = android::Bitmap::allocateHeapBitmap(bitmap, ctable); return !!mStorage;&#125; allocateHeapBitmap方法会最终new Bitmap,分配内存 ,见: &#x2F;frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;hwui&#x2F;Bitmap.cpp 1234567891011121314151617181920212223242526272829sk_sp &lt;Bitmap&gt; Bitmap::allocateHeapBitmap(SkBitmap *bitmap, SkColorTable *ctable) &#123; return allocateBitmap(bitmap, ctable, &amp;android::allocateHeapBitmap);&#125;static sk_sp &lt;Bitmap&gt; allocateBitmap(SkBitmap *bitmap, SkColorTable *ctable, AllocPixeRef alloc) &#123; const SkImageInfo &amp;info = bitmap-&gt;info(); if (info.colorType() == kUnknown_SkColorType) &#123; LOG_ALWAYS_FATAL(&quot;unknown bitmap configuration&quot;); return nullptr; &#125; size_t size; // we must respect the rowBytes value already set on the bitmap instead of // attempting to compute our own. const size_t rowBytes = bitmap-&gt;rowBytes(); if (!computeAllocationSize(rowBytes, bitmap-&gt;height(), &amp;size)) &#123; return nullptr; &#125; auto wrapper = alloc(size, info, rowBytes, ctable); if (wrapper) &#123; wrapper-&gt;getSkBitmap(bitmap); // since we&#x27;re already allocated, we lockPixels right away // HeapAllocator behaves this way too bitmap-&gt;lockPixels(); &#125; return wrapper;&#125; Bitmap 内存模型 0-2.3 3.0-4.4 5.0-7.1 8.0 Bitmap对象 Java Heap Java Heap Java Heap 像素数据 Native Heap Java Heap Native Heap 迁移原因 解决Native Bitmap内存泄漏 共享整个系统的内存减少OOM Android Bitmap 回收机制源代码分析 (从2.3到7.0，8.0)android 2.3.3 和 更低的版本在 Android 2.3.3 之前开发者必须手动调用 recycle 方法去释放 Native 内存，因为那个时候管理Bitmap内存比较复杂，需要手动维护引用计数器 官网解释: 12345On Android 2.3.3 (API level 10) and lower, using recycle() is recommended. If you&#x27;re displaying large amounts of bitmap data in your app, you&#x27;re likely to run into OutOfMemoryError errors. The recycle()method allows an app to reclaim memory as soon as possible.Caution: You should use recycle() only when you are sure that the bitmap is no longer being used. If you call recycle() and later attempt to draw the bitmap, you will get the error: &quot;Canvas: trying to use a recycled bitmap&quot;.The following code snippet gives an example of calling recycle(). It uses reference counting (in the variables mDisplayRefCount and mCacheRefCount) to track whether a bitmap is currently being displayed or in the cache. The code recycles the bitmap when these conditions are met:The reference count for both mDisplayRefCount and mCacheRefCount is 0.The bitmap is not null, and it hasn&#x27;t been recycled yet. 在 Android 2.3.3 以后不需要开发者主动调用 recycle 方法来回收内存了，但 Android K,L,M,N,O 版本上，都还能看到 recycle 方法，为什么没有干掉呢? 调用它会不会真正的释放内存呢？既然不需要手动释放 Native Bitmap ，那 Native 层的对象是怎么自动释放的？我们先来看下 7.0 和 8.0 中 recycle 的方法实现。 7.0 和 8.0 中 recycle 的方法实现12345678910111213141516171819202122232425262728293031323334353637/** * Free the native object associated with this bitmap, and clear the * reference to the pixel data. This will not free the pixel data synchronously; * it simply allows it to be garbage collected if there are no other references. * The bitmap is marked as &quot;dead&quot;, meaning it will throw an exception if * getPixels() or setPixels() is called, and will draw nothing. This operation * cannot be reversed, so it should only be called if you are sure there are no * further uses for the bitmap. This is an advanced call, and normally need * not be called, since the normal GC process will free up this memory when * there are no more references to this bitmap. *//* * 释放与此位图关联的本机对象，并清除对像素数据的引用。这不会立即释放像素数据； * 它只是允许在没有其他引用时进行垃圾回收。该位图被标记为&quot;无效&quot;，这意味着如果调用 * getPixels()或setPixels()，它将抛出异常， * 并且不会绘制任何内容。此操作无法撤销，因此只有在确保不再需要位图时才应调用此方法。 * 这是一个高级调用，通常不需要调用，因为正常的垃圾回收过程将在不再引用该位图时释放此内 * 存。*/ public void recycle() &#123; if (!mRecycled &amp;&amp; mNativePtr != 0) &#123; if (nativeRecycle(mNativePtr)) &#123; // return value indicates whether native pixel object was actually recycled. // false indicates that it is still in use at the native level and these // objects should not be collected now. They will be collected later when the // Bitmap itself is collected. // 返回值指示本机像素对象是否实际已被回收。 // false 表示它仍在本机级别上使用，现在不应收集这些对象。它们将在位图本身被回收时稍后收集。 mNinePatchChunk = null; &#125; mRecycled = true; &#125; &#125; private static native boolean nativeRecycle(long nativeBitmap); 都是调用了native方法，下面看一下native方法 8.0 见：&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 123456789101112131415static jboolean Bitmap_recycle(JNIEnv *env, jobject, jlong bitmapHandle) &#123; LocalScopedBitmap bitmap(bitmapHandle); bitmap-&gt;freePixels(); return JNI_TRUE;&#125;void freePixels() &#123; mInfo = mBitmap-&gt;info(); mHasHardwareMipMap = mBitmap-&gt;hasHardwareMipMap(); mAllocationSize = mBitmap-&gt;getAllocationByteCount(); mRowBytes = mBitmap-&gt;rowBytes(); mGenerationId = mBitmap-&gt;getGenerationID(); mIsHardware = mBitmap-&gt;isHardware(); // 清空了数据 mBitmap.reset(); 7.0 见：&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 12345static jboolean Bitmap_recycle(JNIEnv *env, jobject, jlong bitmapHandle) &#123; LocalScopedBitmap bitmap(bitmapHandle); bitmap-&gt;freePixels(); return JNI_TRUE;&#125; 1234567891011121314151617181920212223242526272829void Bitmap::doFreePixels() &#123; switch (mPixelStorageType) &#123; case PixelStorageType::Invalid: // already free&#x27;d, nothing to do break; case PixelStorageType::External: mPixelStorage.external.freeFunc(mPixelStorage.external.address, mPixelStorage.external.context); break; case PixelStorageType::Ashmem: munmap(mPixelStorage.ashmem.address, mPixelStorage.ashmem.size); close(mPixelStorage.ashmem.fd); break; case PixelStorageType::Java: // 只是释放了 Java 层之前创建的引用 JNIEnv *env = jniEnv(); LOG_ALWAYS_FATAL_IF( mPixelStorage.java.jstrongRef, &quot;Deleting a bitmap wrapper while there are outstanding strong &quot; &quot;references! mPinnedRefCount = %d&quot;, mPinnedRefCount); env-&gt;DeleteWeakGlobalRef(mPixelStorage.java.jweakRef); break; &#125; if (android::uirenderer::Caches::hasInstance()) &#123; android::uirenderer::Caches::getInstance().textureCache.releaseTexture( mPixelRef-&gt;getStableID()); &#125;&#125; 7.0 和 8.0 中 手动调用 recycle 的方法，像素数据会被回收吗从上面的源码可以看出，如果是 8.0 : 我们手动调用 recycle 方法，数据是会立即释放的，因为像素数据本身就是在 Native 层开辟的。 8.0 以下，就算我们手动调用 recycle 方法，数据也是不会立即释放的，而是 DeleteWeakGlobalRef 交由 Java GC 来回收。 注意：以上的所说的释放数据仅代表释放像素数据，并未释放 Native 层的 Bitmap 对象。 Android M 版本及以前的版本, Bitmap 的内存回收Android M 版本及以前的版本, Bitmap 的内存回收主要是通过 BitmapFinalizer 来完成的见: &#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Bitmap(long nativeBitmap, byte[] buffer, int width, int height, int density, boolean isMutable, boolean requestPremultiplied, byte[] ninePatchChunk, NinePatchInsetStruct ninePatchInsets) &#123; if (nativeBitmap == 0) &#123; throw new RuntimeException(&quot;internal error: native bitmap is 0&quot;); &#125; mWidth = width; mHeight = height; mIsMutable = isMutable; mRequestPremultiplied = requestPremultiplied; mBuffer = buffer; mNinePatchChunk = ninePatchChunk; mNinePatchInsets = ninePatchInsets; if (density &gt;= 0) &#123; mDensity = density; &#125; mNativePtr = nativeBitmap; // 这个对象对象来回收 mFinalizer = new BitmapFinalizer(nativeBitmap); int nativeAllocationByteCount = (buffer == null ? getByteCount() : 0); mFinalizer.setNativeAllocationByteCount(nativeAllocationByteCount);&#125;private static class BitmapFinalizer &#123; private long mNativeBitmap; // Native memory allocated for the duration of the Bitmap, // if pixel data allocated into native memory, instead of java byte[] private int mNativeAllocationByteCount; BitmapFinalizer(long nativeBitmap) &#123; mNativeBitmap = nativeBitmap; &#125; public void setNativeAllocationByteCount(int nativeByteCount) &#123; if (mNativeAllocationByteCount != 0) &#123; VMRuntime.getRuntime().registerNativeFree(mNativeAllocationByteCount); &#125; mNativeAllocationByteCount = nativeByteCount; if (mNativeAllocationByteCount != 0) &#123; VMRuntime.getRuntime().registerNativeAllocation(mNativeAllocationByteCount); &#125; &#125; @Override public void finalize() &#123; try &#123; super.finalize(); &#125; catch (Throwable t) &#123; // Ignore &#125; finally &#123; // finalize 这里是 GC 回收该对象时会调用 setNativeAllocationByteCount(0); nativeDestructor(mNativeBitmap); mNativeBitmap = 0; &#125; &#125;&#125;private static native void nativeDestructor(long nativeBitmap); Android N 和 Android O 后，Bitmap 的内存回收没有了 BitmapFinalizer 类，但在 new Bitmap 时会注册 native 的 Finalizer 方法见: &#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java 使用 NativeAllocationRegistry 回收 native 内存 1234567891011121314151617181920212223242526272829/** * Private constructor that must received an already allocated native bitmap * int (pointer). */// called from JNIBitmap(long nativeBitmap, int width, int height, int density, boolean isMutable, boolean requestPremultiplied, byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123; if (nativeBitmap == 0) &#123; throw new RuntimeException(&quot;internal error: native bitmap is 0&quot;); &#125; mWidth = width; mHeight = height; mIsMutable = isMutable; mRequestPremultiplied = requestPremultiplied; mNinePatchChunk = ninePatchChunk; mNinePatchInsets = ninePatchInsets; if (density &gt;= 0) &#123; mDensity = density; &#125; mNativePtr = nativeBitmap; long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount(); NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize); registry.registerNativeAllocation(this, nativeBitmap);&#125; Bitmap 的 Java 对象 GC 之后，对应的 native 内存如何回收NativeAllocationRegistry 的原理与设计思想NativeAllocationRegistry是Android 8.0（API 27）引入的一种辅助回收native内存的机制 Bitmap 的内存分配分外两块：Java 堆和 native 堆。我们都知道 JVM 有垃圾回收机制，那么当 Bitmap的Java对象GC之后，对应的 native 堆内存会回收吗？ 提出问题掌握了NativeAllocationRegistry的作用和使用步骤后，很自然地会有一些疑问： 为什么在Java层对象被垃圾回收后，native内存会自动被回收呢？ NativeAllocationRegistry是从Android 8.0（API 27）开始引入，那么在此之前，native内存是如何回收的呢？ 使用步骤从Android 8.0（API 27）开始，Android中很多地方可以看到NativeAllocationRegistry的身影，我们以Bitmap为例子介绍NativeAllocationRegistry的使用步骤，涉及文件：Bitmap.java、Bitmap.h、Bitmap.cpp 步骤1：创建 NativeAllocationRegistry首先，我们看看实例化NativeAllocationRegistry的地方，具体在Bitmap的构造函数中： 1234567891011121314151617181920// # Android 8.0// Bitmap.java// called from JNIBitmap(long nativeBitmap,...)&#123; // 省略其他代码... // 【分析点 1：native 层需要的内存大小】 long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount(); // 【分析点 2：回收函数 nativeGetNativeFinalizer()】 // 【分析点 3：加载回收函数的类加载器：Bitmap.class.getClassLoader()】 NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize); // 注册 Java 层对象引用与 native 层对象的地址 registry.registerNativeAllocation(this, nativeBitmap);&#125;private static final long NATIVE_ALLOCATION_SIZE = 32;private static native long nativeGetNativeFinalizer(); 可以看到，Bitmap的构造函数（在从JNI中调用）中实例化了NativeAllocationRegistry，并传递了三个参数： 参数 解释 classLoader 加载freeFunction函数的类加载器 freeFunction 回收native内存的native函数直接地址 size 分配的native内存大小（单位：字节） 步骤2：注册对象紧接着，调用了registerNativeAllocation(...)，并传递两个参数： 参数 解释 referent Java层对象的引用 nativeBitmap native层对象的地址 1234567891011121314// Bitmap.java// called from JNIBitmap(long nativeBitmap,...)&#123; // 省略其他代码... // 注册 Java 层对象引用与 native 层对象的地址 registry.registerNativeAllocation(this, nativeBitmap);&#125;// NativeAllocationRegistry.javapublic Runnable registerNativeAllocation(Object referent, long nativePtr) &#123; // 代码省略，下文补充...&#125; 步骤3：回收内存完成前面两步后，当Java层对象被垃圾回收后，NativeAllocationRegistry会自动回收注册的native内存。例如，我们加载几张图片，随后释放Bitmap的引用，可以观察到GC之后，native层的内存也自动回收了： ava12345tv.setOnClickListener&#123; val map = HashSet&lt;Any&gt;() for(index in 0 .. 2)&#123; map.add(BitmapFactory.decodeResource(resources,R.drawable.test)) &#125; GC 前的内存分配情况 —— Android 8.0 GC 后的内存分配情况 —— Android 8.0 - 通过分析NativeAllocationRegistry源码，我们将一步步解答这些问题，请继续往下看。 NativeAllocationRegistry 源码分析现在我们将视野回到到NativeAllocationRegistry的源码，涉及文件：NativeAllocationRegistry.java 、NativeAllocationRegistry_Delegate.java、libcore_util_NativeAllocationRegistry.cpp 构造函数1234567891011121314151617181920// NativeAllocationRegistry.javapublic class NativeAllocationRegistry &#123; // 加载 freeFunction 函数的类加载器 private final ClassLoader classLoader; // 回收 native 内存的 native 函数直接地址 private final long freeFunction; // 分配的 native 内存大小（字节） private final long size; public NativeAllocationRegistry(ClassLoader classLoader, long freeFunction, long size) &#123; if (size &lt; 0) &#123; throw new IllegalArgumentException(&quot;Invalid native allocation size: &quot; + size); &#125; this.classLoader = classLoader; this.freeFunction = freeFunction; this.size = size; &#125;&#125; 可以看到，NativeAllocationRegistry的构造函数只是将三个参数保存下来，并没有执行额外操作。以Bitmap为例，三个参数在Bitmap的构造函数中获得，我们继续上一节未完成的分析过程： 分析点 1：native 层需要的内存大小 12345678910111213141516// Bitmap.java// 【分析点 1：native 层需要的内存大小】long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount();public final int getAllocationByteCount() &#123; if (mRecycled) &#123; Log.w(TAG, &quot;Called getAllocationByteCount() on a recycle()&#x27;d bitmap! &quot; + &quot;This is undefined behavior!&quot;); return 0; &#125; // 调用 native 方法 return nativeGetAllocationByteCount(mNativePtr);&#125;private static final long NATIVE_ALLOCATION_SIZE = 32; 可以看到，nativeSize由固定的32字节加上getAllocationByteCount()，总之，NativeAllocationRegistry需要一个native层内存大小的参数。 分析点 2：回收函数 nativeGetNativeFinalizer() 123456789101112131415161718192021// Bitmap.java// 【分析点 2：回收函数 nativeGetNativeFinalizer()】NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);private static native long nativeGetNativeFinalizer();// Java 层// ----------------------------------------------------------------------// native 层// Bitmap.cppstatic jlong Bitmap_getNativeFinalizer(JNIEnv*, jobject) &#123; // 转为long return static_cast&lt;jlong&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;Bitmap_destruct));&#125;static void Bitmap_destruct(BitmapWrapper* bitmap) &#123; delete bitmap;&#125; 可以看到，nativeGetNativeFinalizer()是一个native函数，返回值是一个long，这个值其实相当于Bitmap_destruct()函数的直接地址。很明显，Bitmap_destruct()就是用来回收native层内存的。 那么，Bitmap_destruct()是在哪里调用的呢？继续往下看！ 分析点 3：加载回收函数的类加载器 12// Bitmap.javaBitmap.class.getClassLoader() 另外，NativeAllocationRegistry还需要ClassLoader参数，文档注释指出：**classloader是加载freeFunction所在native库的类加载器**，但是NativeAllocationRegistry内部并没有使用这个参数。这里笔者也不理解为什么需要传递这个参数，如果有知道答案的小伙伴请告诉我一下~ 注册对象123456789101112131415161718192021222324252627282930// Bitmap.java// 注册 Java 层对象引用与 native 层对象的地址registry.registerNativeAllocation(this, nativeBitmap);// NativeAllocationRegistry.javapublic Runnable registerNativeAllocation(Object referent, long nativePtr) &#123; if (referent == null) &#123; throw new IllegalArgumentException(&quot;referent is null&quot;); &#125; if (nativePtr == 0) &#123; throw new IllegalArgumentException(&quot;nativePtr is null&quot;); &#125; CleanerThunk thunk; CleanerRunner result; try &#123; thunk = new CleanerThunk(); Cleaner cleaner = Cleaner.create(referent, thunk); result = new CleanerRunner(cleaner); registerNativeAllocation(this.size); &#125; catch (VirtualMachineError vme /* probably OutOfMemoryError */) &#123; applyFreeFunction(freeFunction, nativePtr); throw vme; // Other exceptions are impossible. // Enable the cleaner only after we can no longer throw anything, including OOME. thunk.setNativePtr(nativePtr); return result;&#125; 可以看到，registerNativeAllocation (...)方法参数是**Java层对象引用与native层对象的地址**。函数体乍一看是有点绕，笔者在这里也停留了好长一会。我们简化一下代码，try-catch代码先省略，函数返回值Runnable暂时用不到也先省略，瘦身后的代码如下： 123456789101112131415// NativeAllocationRegistry.java// （简化）public void registerNativeAllocation(Object referent, long nativePtr) &#123; CleanerThunk thunk thunk = new CleanerThunk(); // Cleaner 绑定 Java 对象与回收函数 Cleaner cleaner = Cleaner.create(referent, thunk); // 注册 native 内存 registerNativeAllocation(this.size); thunk.setNativePtr(nativePtr);&#125;private class CleanerThunk implements Runnable &#123; // 代码省略，下文补充...&#125; 看到这里，上文提出的第一个疑问就可以解释了，原来NativeAllocationRegistry内部是利用了sun.misc.Cleaner.java机制，简单来说：使用虚引用得知对象被GC的时机，在GC前执行额外的回收工作。 # 举一反三DirectByteBuffer内部也是利用了Cleaner实现堆外内存的释放的。若不了解，请务必阅读：《Java | 堆内存与堆外内存》 123456789101112131415161718192021private class CleanerThunk implements Runnable &#123; // native 层对象的地址 private long nativePtr; public CleanerThunk() &#123; this.nativePtr = 0; &#125; public void run() &#123; if (nativePtr != 0) &#123; // 【分析点 4：执行内存回收方法】 applyFreeFunction(freeFunction, nativePtr); // 【分析点 5：注销 native 内存】 registerNativeFree(size); &#125; &#125; public void setNativePtr(long nativePtr) &#123; this.nativePtr = nativePtr; &#125;&#125; 继续往下看，CleanerThunk其实是Runnable的实现类，run()在Java层对象被垃圾回收时触发，主要做了两件事： 分析点 4：执行内存回收方法 123456789101112131415public static native void applyFreeFunction(long freeFunction, long nativePtr);// NativeAllocationRegistry.cpptypedef void (*FreeFunction)(void*);static void NativeAllocationRegistry_applyFreeFunction(JNIEnv*, jclass, jlong freeFunction, jlong ptr) &#123; void* nativePtr = reinterpret_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(ptr)); FreeFunction nativeFreeFunction = reinterpret_cast&lt;FreeFunction&gt;(static_cast&lt;uintptr_t&gt;(freeFunction)); // 调用回收函数 nativeFreeFunction(nativePtr);&#125; 可以看到，applyFreeFunction(...)最终就是执行到了前面提到的内存回收函数，对于Bitmap就是Bitmap_destruct() 分析点 5：注册 &#x2F; 注销native内存 123456789101112131415// NativeAllocationRegistry.java// 注册 native 内存registerNativeAllocation(this.size);// 注销 native 内存registerNativeFree(size);// 提示：这一层函数其实就是为了将参数转为longprivate static void registerNativeAllocation(long size) &#123; VMRuntime.getRuntime().registerNativeAllocation((int)Math.min(size, Integer.MAX_VALUE));&#125;private static void registerNativeFree(long size) &#123; VMRuntime.getRuntime().registerNativeFree((int)Math.min(size, Integer.MAX_VALUE));&#125; 向VM注册native内存，比便在内存占用达到界限时触发GC，在该native内存回收时，需要向VM注销该内存量 对比 Android 8.0 之前回收 native 内存的方式前面我们已经分析完NativeAllocationRegistry的源码了，我们看一看在Android 8.0之前，Bitmap是用什么方法回收native内存的，涉及文件： &#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java 共同点： 分配的native层内存需要向VM注册 &#x2F; 注销 通过一个native层的内存回收函数来回收内存 不同点： NativeAllocationRegistry依赖于sun.misc.Cleaner.java BitmapFinalizer依赖于Object#finalize() 我们知道，finalize()在Java对象被垃圾回收时会调用，BitmapFinalizer就是利用了这个机制来回收native层内存的。 12345678以下是关于 finalize() 方法的一些要点：finalize() 方法的定义： finalize() 是一个在 Object 类中定义的方法，所有的 Java 类都可以选择覆盖它。它的签名为 protected void finalize() throws Throwable。垃圾回收触发： 当垃圾回收器决定要回收一个对象时（即对象变得不可达），在回收对象之前，会调用对象的 finalize() 方法。这个方法可能会在对象被回收之前执行一些清理操作，例如释放底层资源或资源的解引用。finalize() 方法的调用时机不确定： 由于垃圾回收的时机是不确定的，因此 finalize() 方法的调用时机也是不确定的。这意味着不能依赖于它来进行资源的及时释放或其他重要的清理操作。避免过度依赖 finalize()： 由于 finalize() 方法的调用时机不确定，且可能会影响性能，通常不建议过度依赖它。更好的做法是使用显式的资源管理，例如使用 try-finally 块来确保资源的释放。不同的垃圾回收方式： Java 使用不同的垃圾回收策略，包括标记-清除、标记-压缩等。在不同的垃圾回收方式中，finalize() 方法的调用时机可能会有所不同。需要注意的是，自从 Java 9 开始，finalize() 方法已经被标记为废弃（deprecated），这意味着在未来的 Java 版本中可能会被移除。推荐的做法是使用更可靠的资源管理和垃圾回收机制，例如使用 AutoCloseable 接口和 try-with-resources 语句来确保资源的正确释放。 再举几个常用的类在Android 8.0之前的源码为例子，原理都大同小异：Matrix.java (before Android 8.0)、Canvas.java (before Android 8.0) 12345678910111213141516171819202122232425262728293031323334353637383940414243// Matrix.java@Overrideprotected void finalize() throws Throwable &#123; try &#123; finalizer(native_instance); &#125; finally &#123; super.finalize(); &#125;&#125;private static native void finalizer(long native_instance);// Canvas.javaprivate final CanvasFinalizer mFinalizer;private static final class CanvasFinalizer &#123; private long mNativeCanvasWrapper; public CanvasFinalizer(long nativeCanvas) &#123; mNativeCanvasWrapper = nativeCanvas; &#125; @Override protected void finalize() throws Throwable &#123; try &#123; dispose(); &#125; finally &#123; super.finalize(); &#125; &#125; public void dispose() &#123; if (mNativeCanvasWrapper != 0) &#123; finalizer(mNativeCanvasWrapper); mNativeCanvasWrapper = 0; &#125; &#125;&#125;public Canvas() &#123; // 省略其他代码... mFinalizer = new CanvasFinalizer(mNativeCanvasWrapper);&#125; 问题回归 NativeAllocationRegistry利用虚引用感知Java对象被回收的时机，来回收native层内存 在Android 8.0 (API 27)之前，Android通常使用Object#finalize()调用时机来回收native层内存 Bitmap 的内存复用Bitmap 绝对是我们 Android 开发中最容易引起 OOM 的对象之一，因为其占用的像素数据内存比较大，而加载图片又是很常见的操作。如果不断反复的去开辟和销毁 Bitmap 数据内存，势必可能会引起应用的内存抖动，因此 Google 的开发者也为我们想了一些办法，那就是允许 Bitmap 内存复用，具体如下： 被复用的 Bitmap 必须为 Mutable（通过 BitmapFactory.Options 设置） 这是因为复用操作涉及对 Bitmap 对象像素数据的修改，而只有 Mutable 的 Bitmap 才允许对其像素数据进行修改。 4.4 之前 图像格式： 被复用的 Bitmap 和要解码的图像必须具有相同的像素格式，通常是 ARGB_8888 或 RGB_565 格式。这是因为像素格式的不匹配可能导致解码失败或图像显示异常。 图像尺寸： 被复用的 Bitmap 和要解码的图像必须具有相同的尺寸。如果尺寸不匹配，复用操作将被忽略。 图像类型： 在 Android 4.4 之前，被复用的 Bitmap 和要解码的图像必须是 JPEG 或 PNG 格式。其他格式的图像将无法被复用。 inSampleSize 设置： BitmapFactory.Options 的 inSampleSize 字段必须设置为 1，以表示不进行图像的缩放。这是因为在进行图像缩放的情况下，图像的尺寸和复用的 Bitmap 尺寸可能不匹配。 4.4 以后 BitmapFactory.Options 的 inBitmap 字段用于指定要复用的 Bitmap 对象。通过设置这个字段，你可以告诉解码器将解码后的图像数据存储在已经存在的 Bitmap 中，以便进行复用。 同时，要注意以下几点： 被解码的图像的内存大小不应该超过要复用的 Bitmap 的内存大小。 被解码的图像和要复用的 Bitmap 的像素格式和尺寸应该匹配。 解码时需要设置 inSampleSize 为 1，以确保图像不会被缩放。 12345678910111213// 不复用的写法，消耗内存 32 MlogMemory();Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.test2);Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.test2);logMemory();// 复用的写法，消耗内存 16 MlogMemory();BitmapFactory.Options options = new BitmapFactory.Options();options.inMutable = true;Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.test2, options);options.inBitmap = bitmap1;Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.test2, options);logMemory(); 在 Glide 中，Bitmap 复用是通过使用 BitmapPool 接口来实现的。BitmapPool 是一个用于管理和复用 Bitmap 对象的接口，它允许 Glide 在加载和显示图像时复用之前分配的 Bitmap 对象，从而减少内存分配和垃圾回收的开销。 以下是简要的 Glide Bitmap 复用的流程： Glide 首先会尝试从 BitmapPool 中获取一个可复用的 Bitmap 对象。如果 BitmapPool 中存在满足条件的 Bitmap，就会使用它。 如果 BitmapPool 中没有可复用的 Bitmap，Glide 会根据要加载的图像的尺寸和像素格式创建一个新的 Bitmap 对象。 加载和显示图像时，Glide 会将 Bitmap 对象放入 BitmapPool，以便以后可以复用。 为了更深入地了解 Glide 中 Bitmap 复用的实现，你可以查阅 Glide 的源代码，并关注以下关键部分： BitmapPool 接口及其实现类：Glide 使用 BitmapPool 接口来管理 Bitmap 对象的复用。BitmapPool 接口定义了一系列的方法，如 get() 获取可复用的 Bitmap，put() 将 Bitmap 放回池中等。在 Glide 源代码中，你可以查看 LruBitmapPool 和其他的 BitmapPool 实现类。 BitmapImageViewTarget：Glide 使用 BitmapImageViewTarget 来将 Bitmap 显示在 ImageView 中。在这个类中，你可以看到 Glide 如何从 BitmapPool 中获取可复用的 Bitmap 对象。 图片加载流程：Glide 的图片加载流程涉及到许多类和接口，包括请求管理、数据加载、资源解码等。在这些类中，你可以找到 Glide 如何利用 Bitmap 复用来优化内存使用。 Glide Bitmap 复用源代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381package com.bumptech.glide.load.engine.bitmap_recycle;import android.annotation.SuppressLint;import android.annotation.TargetApi;import android.content.ComponentCallbacks2;import android.graphics.Bitmap;import android.graphics.Color;import android.os.Build;import android.util.Log;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.bumptech.glide.util.Synthetic;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.Set;/** * An &#123;@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool&#125; implementation that uses an * &#123;@link com.bumptech.glide.load.engine.bitmap_recycle.LruPoolStrategy&#125; to bucket &#123;@link Bitmap&#125;s * and then uses an LRU eviction policy to evict &#123;@link android.graphics.Bitmap&#125;s from the least * recently used bucket in order to keep the pool below a given maximum size limit. */public class LruBitmapPool implements BitmapPool &#123; private static final String TAG = &quot;LruBitmapPool&quot;; private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888; private final LruPoolStrategy strategy; private final Set&lt;Bitmap.Config&gt; allowedConfigs; private final long initialMaxSize; private final BitmapTracker tracker; private long maxSize; private long currentSize; private int hits; private int misses; private int puts; private int evictions; // Exposed for testing only. LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123; this.initialMaxSize = maxSize; this.maxSize = maxSize; this.strategy = strategy; this.allowedConfigs = allowedConfigs; this.tracker = new NullBitmapTracker(); &#125; /** * Constructor for LruBitmapPool. * * @param maxSize The initial maximum size of the pool in bytes. */ public LruBitmapPool(long maxSize) &#123; this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs()); &#125; /** * Constructor for LruBitmapPool. * * @param maxSize The initial maximum size of the pool in bytes. * @param allowedConfigs A white listed put of &#123;@link android.graphics.Bitmap.Config&#125; that are * allowed to be put into the pool. Configs not in the allowed put will be rejected. */ // Public API. @SuppressWarnings(&quot;unused&quot;) public LruBitmapPool(long maxSize, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123; this(maxSize, getDefaultStrategy(), allowedConfigs); &#125; /** Returns the number of cache hits for bitmaps in the pool. */ public long hitCount() &#123; return hits; &#125; /** Returns the number of cache misses for bitmaps in the pool. */ public long missCount() &#123; return misses; &#125; /** Returns the number of bitmaps that have been evicted from the pool. */ public long evictionCount() &#123; return evictions; &#125; /** Returns the current size of the pool in bytes. */ public long getCurrentSize() &#123; return currentSize; &#125; @Override public long getMaxSize() &#123; return maxSize; &#125; @Override public synchronized void setSizeMultiplier(float sizeMultiplier) &#123; maxSize = Math.round(initialMaxSize * sizeMultiplier); evict(); &#125; @Override public synchronized void put(Bitmap bitmap) &#123; if (bitmap == null) &#123; throw new NullPointerException(&quot;Bitmap must not be null&quot;); &#125; if (bitmap.isRecycled()) &#123; throw new IllegalStateException(&quot;Cannot pool recycled bitmap&quot;); &#125; if (!bitmap.isMutable() || strategy.getSize(bitmap) &gt; maxSize || !allowedConfigs.contains(bitmap.getConfig())) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v( TAG, &quot;Reject bitmap from pool&quot; + &quot;, bitmap: &quot; + strategy.logBitmap(bitmap) + &quot;, is mutable: &quot; + bitmap.isMutable() + &quot;, is allowed config: &quot; + allowedConfigs.contains(bitmap.getConfig())); &#125; bitmap.recycle(); return; &#125; final int size = strategy.getSize(bitmap); strategy.put(bitmap); tracker.add(bitmap); puts++; currentSize += size; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Put bitmap in pool=&quot; + strategy.logBitmap(bitmap)); &#125; dump(); evict(); &#125; private void evict() &#123; trimToSize(maxSize); &#125; @Override @NonNull public Bitmap get(int width, int height, Bitmap.Config config) &#123; Bitmap result = getDirtyOrNull(width, height, config); if (result != null) &#123; // Bitmaps in the pool contain random data that in some cases must be cleared for an image // to be rendered correctly. we shouldn&#x27;t force all consumers to independently erase the // contents individually, so we do so here. See issue #131. result.eraseColor(Color.TRANSPARENT); &#125; else &#123; result = createBitmap(width, height, config); &#125; return result; &#125; @NonNull @Override public Bitmap getDirty(int width, int height, Bitmap.Config config) &#123; Bitmap result = getDirtyOrNull(width, height, config); if (result == null) &#123; result = createBitmap(width, height, config); &#125; return result; &#125; @NonNull private static Bitmap createBitmap(int width, int height, @Nullable Bitmap.Config config) &#123; return Bitmap.createBitmap(width, height, config != null ? config : DEFAULT_CONFIG); &#125; @TargetApi(Build.VERSION_CODES.O) private static void assertNotHardwareConfig(Bitmap.Config config) &#123; // Avoid short circuiting on sdk int since it breaks on some versions of Android. if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123; return; &#125; if (config == Bitmap.Config.HARDWARE) &#123; throw new IllegalArgumentException( &quot;Cannot create a mutable Bitmap with config: &quot; + config + &quot;. Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your&quot; + &quot; RequestOptions and/or in GlideBuilder.setDefaultRequestOptions&quot;); &#125; &#125; @Nullable private synchronized Bitmap getDirtyOrNull( int width, int height, @Nullable Bitmap.Config config) &#123; assertNotHardwareConfig(config); // Config will be null for non public config types, which can lead to transformations naively // passing in null as the requested config here. See issue #194. final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG); if (result == null) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Missing bitmap=&quot; + strategy.logBitmap(width, height, config)); &#125; misses++; &#125; else &#123; hits++; currentSize -= strategy.getSize(result); tracker.remove(result); normalize(result); &#125; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Get bitmap=&quot; + strategy.logBitmap(width, height, config)); &#125; dump(); return result; &#125; // Setting these two values provides Bitmaps that are essentially equivalent to those returned // from Bitmap.createBitmap. private static void normalize(Bitmap bitmap) &#123; bitmap.setHasAlpha(true); maybeSetPreMultiplied(bitmap); &#125; @TargetApi(Build.VERSION_CODES.KITKAT) private static void maybeSetPreMultiplied(Bitmap bitmap) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; bitmap.setPremultiplied(true); &#125; &#125; @Override public void clearMemory() &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;clearMemory&quot;); &#125; trimToSize(0); &#125; @SuppressLint(&quot;InlinedApi&quot;) @Override public void trimMemory(int level) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;trimMemory, level=&quot; + level); &#125; if ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) || ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &amp;&amp; (level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN))) &#123; clearMemory(); &#125; else if ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) || (level == ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL)) &#123; trimToSize(getMaxSize() / 2); &#125; &#125; private synchronized void trimToSize(long size) &#123; while (currentSize &gt; size) &#123; final Bitmap removed = strategy.removeLast(); // TODO: This shouldn&#x27;t ever happen, see #331. if (removed == null) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, &quot;Size mismatch, resetting&quot;); dumpUnchecked(); &#125; currentSize = 0; return; &#125; tracker.remove(removed); currentSize -= strategy.getSize(removed); evictions++; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Evicting bitmap=&quot; + strategy.logBitmap(removed)); &#125; dump(); removed.recycle(); &#125; &#125; private void dump() &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; dumpUnchecked(); &#125; &#125; private void dumpUnchecked() &#123; Log.v( TAG, &quot;Hits=&quot; + hits + &quot;, misses=&quot; + misses + &quot;, puts=&quot; + puts + &quot;, evictions=&quot; + evictions + &quot;, currentSize=&quot; + currentSize + &quot;, maxSize=&quot; + maxSize + &quot;\\nStrategy=&quot; + strategy); &#125; private static LruPoolStrategy getDefaultStrategy() &#123; final LruPoolStrategy strategy; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; strategy = new SizeConfigStrategy(); &#125; else &#123; strategy = new AttributeStrategy(); &#125; return strategy; &#125; @TargetApi(Build.VERSION_CODES.O) private static Set&lt;Bitmap.Config&gt; getDefaultAllowedConfigs() &#123; Set&lt;Bitmap.Config&gt; configs = new HashSet&lt;&gt;(Arrays.asList(Bitmap.Config.values())); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; // GIFs, among other types, end up with a native Bitmap config that doesn&#x27;t map to a java // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured // and are suitable for re-use. configs.add(null); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; configs.remove(Bitmap.Config.HARDWARE); &#125; return Collections.unmodifiableSet(configs); &#125; private interface BitmapTracker &#123; void add(Bitmap bitmap); void remove(Bitmap bitmap); &#125; @SuppressWarnings(&quot;unused&quot;) // Only used for debugging private static class ThrowingBitmapTracker implements BitmapTracker &#123; private final Set&lt;Bitmap&gt; bitmaps = Collections.synchronizedSet(new HashSet&lt;Bitmap&gt;()); @Override public void add(Bitmap bitmap) &#123; if (bitmaps.contains(bitmap)) &#123; throw new IllegalStateException( &quot;Can&#x27;t add already added bitmap: &quot; + bitmap + &quot; [&quot; + bitmap.getWidth() + &quot;x&quot; + bitmap.getHeight() + &quot;]&quot;); &#125; bitmaps.add(bitmap); &#125; @Override public void remove(Bitmap bitmap) &#123; if (!bitmaps.contains(bitmap)) &#123; throw new IllegalStateException(&quot;Cannot remove bitmap not in tracker&quot;); &#125; bitmaps.remove(bitmap); &#125; &#125; private static final class NullBitmapTracker implements BitmapTracker &#123; @Synthetic NullBitmapTracker() &#123;&#125; @Override public void add(Bitmap bitmap) &#123; // Do nothing. &#125; @Override public void remove(Bitmap bitmap) &#123; // Do nothing. &#125; &#125;&#125; 下面对代码进行逐段分析： 导入相关的包和类。 定义了一个名为 “LruBitmapPool” 的类，实现了 “BitmapPool” 接口，用于管理位图内存池。 定义了一些常量，如默认的位图配置和日志标签。 声明了一些成员变量，包括内存池策略、允许的位图配置、最大大小、当前大小、命中次数、未命中次数、添加次数和驱逐次数等。 构造函数，初始化内存池大小、策略和允许的位图配置等。 提供了一些公开方法用于获取统计信息，如命中次数、未命中次数、驱逐次数、当前大小等。 实现了 “BitmapPool” 接口中的一些方法，包括 setSizeMultiplier、put、get、getDirty、clearMemory、trimMemory 等。 定义了一些辅助方法，如 evict、assertNotHardwareConfig、normalize、maybeSetPreMultiplied、getDirtyOrNull、trimToSize、dump 和 dumpUnchecked 等。 定义了 “BitmapTracker” 接口，其中包含了添加和移除位图的方法。 定义了一些实现了 “BitmapTracker” 接口的类，如 “ThrowingBitmapTracker” 和 “NullBitmapTracker”。 总体来说，这段代码实现了一个基于 LRU（Least Recently Used）算法的位图内存池，用于管理位图对象的内存分配和回收。它可以跟踪位图的使用情况，限制内存池的大小，通过策略进行位图的管理和驱逐，以及提供一些统计信息用于优化和调试。 Gilde 是如何实现 Bitmap 复用的？在这段代码中，实现位图复用的核心思想是通过内存池策略（LruPoolStrategy）来管理位图的存储和获取。下面我将详细解释如何实现位图的复用： put(Bitmap bitmap) 方法：当你想要回收一个位图时，会调用这个方法。它会首先判断位图是否为空、是否已经被回收、是否是可变的位图，位图大小是否超过了内存池的最大大小，以及位图的配置是否允许被放入内存池。如果这些条件都满足，它会将位图放入内存池策略中，并更新当前内存池的大小。 get(int width, int height, Bitmap.Config config) 和 getDirty(int width, int height, Bitmap.Config config) 方法：当你想要获取一个位图时，会调用这两个方法之一。它首先会尝试从内存池策略中获取满足条件的位图，如果找到则返回该位图，否则会创建一个新的位图并返回。这里的位图创建使用了 Bitmap.createBitmap() 方法，确保了返回的位图是可复用的。 trimToSize(long size) 方法：当内存池的当前大小超过了最大限制时，会调用这个方法进行驱逐。它会循环地从内存池策略中移除最近未使用的位图，直到当前内存池大小小于等于指定的大小。 LruPoolStrategy 接口的实现：这个接口定义了位图内存池策略的规范，包括位图的添加、获取、移除等操作。在这段代码中，有两个实现类：SizeConfigStrategy 和 AttributeStrategy，分别在不同的 Android 版本上进行位图的管理。 通过这些机制，当位图被回收时，它会被添加到内存池中，下次需要位图时会优先从内存池中获取，以达到位图复用的效果。这样可以减少内存分配和回收的开销，提高性能和效率。 BitMap 创建，内存申请与内存模型相关内容整理参考自 作者：红橙Darren链接：https://www.jianshu.com/p/8e8ad414237e来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 具体回收细节参考自 版权声明：本文为CSDN博主「shihongyu12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/shihongyu12345/article/details/89681948 NativeAllocationRegistry 的原理与设计思想 摘录自 作者：彭旭锐链接：https://www.jianshu.com/p/6f042f9e47a8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 部分相关知识来自于 chat-GPT 3.5","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"Android-Framework-AMS专项-Activity启动的整体流程与第一个阶段解读参数","slug":"3 Android/Framework/05-Android-Framework-AMS专项-Activity启动的整体流程与第一个阶段解读参数","date":"2023-08-15T10:21:30.000Z","updated":"2024-04-13T12:26:21.029Z","comments":true,"path":"2023/08/15/3 Android/Framework/05-Android-Framework-AMS专项-Activity启动的整体流程与第一个阶段解读参数/","link":"","permalink":"http://example.com/2023/08/15/3%20Android/Framework/05-Android-Framework-AMS%E4%B8%93%E9%A1%B9-Activity%E5%90%AF%E5%8A%A8%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%A7%A3%E8%AF%BB%E5%8F%82%E6%95%B0/","excerpt":"","text":"Activity 启动整体流程分析我们把 Activity 的启动简单分为几个部分 Intent startActivity(intent):ActivityA ActivityB 解析 Activity 启动参数 ActivityRecord activityStack ActivityRecord，管理和启动 ActivityB AMS: activityStackSupervisor: 封装 clientTransaction（触发事件） 通信的流程：clientTransaction Application: process Activit Activity 启动第一阶段解析参数ActivityStarter：解析 Activity 启动参数，每一个 Activity 启动都会有一个 Starter 去启动它。ActivityStartController：Controller 回去生产 Starter 对象，控制 Starter 的创建。 Q：为什么需要 ActivityStartController？ AMS 和 ATMS 在 Android 操作系统中，ATMS（ActivityTaskManagerService）和AMS（ActivityManagerService）是两个关键的系统服务，负责管理应用程序的生命周期和任务栈。它们在 Android 的多任务处理和应用管理方面扮演着重要角色。随着 Android 系统的发展，这两个服务的职责和架构也发生了一些变化。下面是它们之间主要的区别： 职责分工： AMS（ActivityManagerService）：在 Android 10 及其之前的版本中，AMS 是负责管理系统中的所有活动（Activities）、应用进程和服务的核心服务。它处理应用的启动、切换、生命周期管理等任务。 ATMS（ActivityTaskManagerService）：从 Android 10（API 级别 29）开始引入，ATMS 负责管理活动和任务的栈管理（Activity and Task Stack Management）。这意味着 ATMS 处理应用的 UI&#x2F;界面任务，如任务视图、活动栈、分屏模式和最近应用的管理。ATMS 实质上是从 AMS 中拆分出来的，专注于任务和活动栈的管理，而让 AMS 能更专注于后台进程和应用管理。 架构变化： 随着 Android 系统的发展，其架构也在不断演进。引入 ATMS 是 Android 系统为了更好地模块化和清晰地区分不同服务的职责而做的改变。这种变化有助于简化系统服务的管理，使得系统架构更加清晰，同时也为未来的扩展和维护提供了便利。 目的： 分拆 AMS 和引入 ATMS 的目的是为了更好地分离和管理 Android 系统中的活动和任务栈管理逻辑，从而提高系统的稳定性和可维护性。ATMS 的引入，让 AMS 能够更加专注于进程管理和服务管理，而不是同时处理与 UI&#x2F;界面相关的复杂逻辑。 总结来说，ATMS 和 AMS 在 Android 10 之后的版本中共同工作，以更高效和清晰的方式管理应用的生命周期和用户界面任务。ATMS 的引入是 Android 系统架构演进的一个例证，显示了 Android 团队在不断追求更好的系统管理和性能优化方面的努力。 ActivityStartControllerAndroid 10 之前的版本，ActivityStartController 是在 AMS 的 initialize 时创建Android 10 开始，AMS 分离出了一些职责到 ATMS 中，包含了 initialize starter，factory，pool 与 recycle，reset在这个 initalize 中初始化了 ActivityStartControllerActivityStartController 初始化时去获取 starter 实际上是由 ActivityStartController 初始化时去 创建了一个 Factory这个 Factory 是定义在 ActivityStartController 内部的 DefaultFactory，通过 DefaultFactory 的 obtain 函数去获取一个 ActivityStarter DefaultFactory 中构建了一个 synchronizedPool 复用池子，就和 Hanlder 一样，通过 obtain 去获取 ActivityStarter，设置三个缓存采用享元模式去复用，避免内存抖动，同样的，使用完之后要去 recycle，recycle 的时候要去 reset，之后添加回 pool 所以 本质上是使用工厂模式去建造 ActivityStartController 缓存池，并管控 ActivityStartController 的复用，由 AMS 创建 Activity 的启动参数到底被谁持有了？ activity 的启动参数实际上是被添加到了 ActivityStarter 的 Request 中，之后执行 ActivityStarter 的 execute 函数 Request 是 Activity 的内部类，在这个内部类中包含了 Activity 启动过程中一系列的交互参数比如我们要从 Activity A 启动 Activity B，这个过程中需要记录 Activity A 与 Activity B 的核心参数（ 如果我们对 Activity A 启动 Activity B 之后，Activity A 和 B 生命周期函数的执行顺序有所了解，就非常容易理解这里为什么需要记录 A B 双方的核心参数，启动 B 的过程也是 A B 进行交互的过程） ActivityStarter 的 execute 函数会执行 executeRequest， 这时候 ActivityStarter 就会去创建一个 ActivityRecord，这就是我们要启动的 Activity 在启动之前，会先执行 ActivityStartController 的 doPendingActivityLaunches 函数这个函数是用来启动那些没有来得及启动的 Activity（举个例子，在启动之前按了 Home 键） 之后再调用 StartActivityUnchecked，其中调用 StartActivityInner这里注意下 StartActivityInner 头两个参数是 final ActivityRecord r，ActivityRecord sourceRecord这个函数里会计算 ActivityRecord （要启动的 Activity 的 task 标志），也就是启动模式，接着计算 sourceRecord（源 Activity）所在的 task，将计算后的启动模式 mLaunchFlags 设置给 Intent （ mIntent.setFlags(mLaunchFlags) ） Launcher 启动创建黑白屏注意完成上述操作之后我们去调用 Launcher 去启动一个 Activity 的时候，为了让用户知道我们已经进行了响应，会启动一个黑白屏 Q：这个时候 Activity 有启动吗？ A：并没有，上述操作只是在构建一个 Activity 的启动流程，并没有真正的去启动一个 Activity，因为 Activity 必须依附于一个进程存在，所以黑白屏是为了表示已经开始响应启动流程，但是进程的创建是一个相对缓慢的过程，之后进程创建之后才会启动 Activity Activity的真正启动启动完黑白屏之后，通过调用 mRootWindowContainer.resumeFocusedStackTopActivities 启动 Activity 首先，什么是 RootWindowContainer，注释上写 RootWindowContainer 就是 WindowContainer 的根容器，管理了所有窗口容器，设备上所有的窗口（Window）、显示（Display）都是由它管理的 它通过 RootWindowContainer 来检查当前任务栈顶部的 Activity 是否真的可见。 在这个过程中，RootWindowContainer 会考虑多个因素来确定一个 Activity 的可见性，包括但不限于： 屏幕的显示状态：例如，如果设备处于锁屏状态，则处于前台的 Activity 可能不会被认为是可见的。 其他应用的窗口：例如，如果有一个全屏模式的应用或是一个浮动窗口覆盖在当前 Activity 上方，可能会影响当前 Activity 的可见性。 系统对话框或通知：这些元素也可能覆盖在活动 Activity 上方，影响其可见性。 分屏模式：在分屏模式下，两个 Activity 可以同时处于可见状态，RootWindowContainer 需要管理这些 Activity 的可见性和布局。 基于上述因素的判断，如果 RootWindowContainer 确定任务栈顶部的 Activity 是可见的，resumeFocusedStackTopActivities 方法就会继续执行，恢复该 Activity。这个过程涉及调用 Activity 的 onResume() 方法，使其成为用户可以与之交互的活动界面。 这一机制确保了 Android 系统在恢复 Activity 时能够正确地管理用户界面的状态和交互，保持应用的流畅运行和用户体验的一致性。 当启动一个新的 Activity 时，resumeFocusedStackTopActivities 方法负责将这个新的 Activity 放置到正确的任务栈和位置上。如果判断结果为 !resumeOnDisplay，并且 focusedStack !&#x3D; null，那么就会执行 focusedStack.resumeTopActivityUncheckLocked，进入启动的第二阶段","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"}],"tags":[]},{"title":"06-Android-Framework-AMS专项-Activity生命周期事物封装","slug":"3 Android/Framework/06-Android-Framework-AMS专项-Activity生命周期事物封装","date":"2023-08-15T10:21:30.000Z","updated":"2024-04-13T12:20:19.806Z","comments":true,"path":"2023/08/15/3 Android/Framework/06-Android-Framework-AMS专项-Activity生命周期事物封装/","link":"","permalink":"http://example.com/2023/08/15/3%20Android/Framework/06-Android-Framework-AMS%E4%B8%93%E9%A1%B9-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E7%89%A9%E5%B0%81%E8%A3%85/","excerpt":"","text":"解读完启动参数之后，就进入到由 Activity 栈去管理和启动 Activity 的这个流程ActivityRcord 创建 ActivityRcord 之后，利用 RootWindowContainer 去管理 ActivityWindow 的显示状态，（除了启动，恢复显示也会经过这个 RootWindowContainer） 首先会从 RootWindowContainer 进入 ActivityStack","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"}],"tags":[]},{"title":"协程中的取消和异常 （取消操作详解）","slug":"1 Kotlin/01 Kotlin 协程/协程中的取消和异常 （取消操作详解）","date":"2023-08-10T23:19:12.000Z","updated":"2023-08-10T23:19:12.000Z","comments":true,"path":"2023/08/11/1 Kotlin/01 Kotlin 协程/协程中的取消和异常 （取消操作详解）/","link":"","permalink":"http://example.com/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/","excerpt":"","text":"正文在开发中，我们要避免不必要的的任务来节约设备的内存和电量的使用，协程也是如此。在使用的过程我们需要控制好它的生命周期，在不需要它的取消它。 调用cancel方法取消作用域会取消它的子协程当启动了很多个协程，我们一个个协程的取消比较麻烦，我们可以通过取消整个作用域来解决这个问题，因为取消作用域可以取消该作用域创建的所有协程。 123456/ 假设我们已经定义了一个作用域val job1 = scope.launch &#123; … &#125;val job2 = scope.launch &#123; … &#125;scope.cancel() 假设我们创建了一个作用域scope,并创建了两个协程job1和job2。我们通过调用scope.cancel()，取消作用域，将会把job1 和job2两个协程都取消。 单独取消某个协程，不会影响他的兄弟协程我们创建了两个协程，job1和job2.我们单独取消job1，不会影响到job2 1234567// 假设我们已经定义了一个作用域val job1 = scope.launch &#123; … &#125;val job2 = scope.launch &#123; … &#125; // 第一个协程将会被取消，而另一个则不受任何影响job1.cancel() 协程通过抛出一个特殊的异常 CancellationException 来处理取消操作在调用cancel函数的时候，我们需要传入一个CancellationException对象,如果我们没有传入，那就用默认的defaultCancellationException。 1234// external cancel with cause, never invoked implicitly from internal machinery public override fun cancel(cause: CancellationException?) &#123; cancelInternal(cause ?: defaultCancellationException()) &#125; 一旦抛出了CancellationException，我们就可以通过这一机制来处理协程的取消。在底层的实现中，子协程会通过抛出异常的方式将取消的情况通知它的父级，父协程通过传入的取消原因决定是否处理该异常。 不能在已取消的作用域中再次启动新的协程调用了 cancel 方法为什么协程处理的任务没有停止？不同的Diapatcher不同的区别，下一篇文章将介绍。 我们以Dispatchers.Default为例子 12345678910111213141516171819202122import kotlinx.coroutines.*suspend fun main() = runBlocking &#123; var startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; var nextTime = startTime var i = 0 while (i &lt; 5) &#123; if (System.currentTimeMillis() &gt;= nextTime) &#123; println(&quot;这是第$&#123;i&#125;次&quot;) i++ //1000毫秒执行一次 nextTime += 1000 &#125; &#125; &#125; delay(1000) println(&quot;取消&quot;) job.cancel() println(&quot;取消完毕&quot;)&#125; 1234567这是第0次这是第1次取消取消完毕这是第2次这是第3次这是第4次 调用cancel方法之后，协程的任务依然在运行。调用cancel方法的时候，此时协程处于cancelling正在取消的状态，接着我们打印了2，3，4，处理任务结束之后，协程变成cancelled已经取消的状态，这是以Default举例，Default调度会等待协程任务处理完毕才取消。 让协程可以被取消协程处理任务都是协作式的，协作的意思就是我们的处理任务要配合协程取消做处理。因此在执行任务期间我们要定时检查协程的状态是否已经取消，例如我们从磁盘读取文件之前我们先检查协程是否被取消了。 123456val job = launch &#123; for(file in files) &#123; // TODO 检查协程是否被取消 readFile(file) &#125;&#125; 协程中的挂起函数都是可取消的，使用他们的时候，我们不需要检查协程是否已取消。例如withContext，delay 。如果没有这些挂起函数，为了让我们的代码配合协程取消，可以使用一下两种方法： 检查 job.isActive 或者使用 ensureActive() 使用 yield() 来让其他任务进行 检查 job 的活跃状态先看一下第一种方法，在我们的 while(i&lt;5) 循环中添加对于协程状态的检查: 12// 因为处于 launch 的代码块中，可以访问到 job.isActive 属性while (i &lt; 5 &amp;&amp; isActive) 使用 yield() 函数运行其他任务Job.join 和 Deferred.await cancellation等待协程处理结果有两种方法，launch启动的job可以调用join，async 返回的Deferred 可以调用await方法 job.join会让协程挂起，直到等待协程处理任务完毕，我们可以配合cancel使用 deferred.await()如果我们关心协程的处理结果，我们可以使用deferred。结果由deferred.await返回。也是job类型，也可以被取消。 处理协程取消的副作用当我们需要在协程取消 后处理一些清理的工作，或者做一些打印日志。我们有几种办法： 通过检查协程的状态 123456789while (i &lt; 5 &amp;&amp; isActive) &#123; if (…) &#123; println(“Hello $&#123;i++&#125;”) nextPrintTime += 500L &#125;&#125; // 协程所处理的任务已经完成，因此我们可以做一些清理工作println(“Clean up!” 当判断协程不是isActive状态的时候，我们可以做一些清理 try catch finally 我们知道协程的取消会抛出CancellationException 异常，我们可以在协程提中使用try catch finally，在finally中做我们的一些清理的工作，或者打印日志 1234567891011121314val job = launch &#123; try &#123; work() &#125; catch (e: CancellationException)&#123; println(“Work cancelled!”) &#125; finally &#123; println(“Clean up!”) &#125;&#125;delay(1000L)println(“Cancel!”)job.cancel()println(“Done! 已经取消的协程，不能再被挂起已经取消的协程，不能再被挂起，但是当我们需要在取消的协程中调用挂起函数，那么我们可以在finally中使用NonCancellable ，意思是让协程挂起，直到处理挂起函数中的代码完毕，协程才会取消。 1234567891011121314151617val job = launch &#123; try &#123; work() &#125; catch (e: CancellationException)&#123; println(“Work cancelled!”) &#125; finally &#123; withContext(NonCancellable)&#123; delay(1000L) // 或一些其他的挂起函数 println(“Cleanup done!”) &#125; &#125;&#125;delay(1000L)println(“Cancel!”)job.cancel()println(“Done! 在jetpack中使用viewModelScope 或者lifecycleScope 中定义的作用域，他们在scope完成后取消他们的处理任务。如果我们手动创建自己的作用域CoroutineScope，我们需要协作协程，将我们的作用域和job绑定，在需要的时候取消。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"Kotlin 的协程本质到底什么","slug":"1 Kotlin/01 Kotlin 协程/Kotlin 的协程本质到底什么","date":"2023-08-10T23:19:04.000Z","updated":"2023-08-10T23:19:04.000Z","comments":true,"path":"2023/08/11/1 Kotlin/01 Kotlin 协程/Kotlin 的协程本质到底什么/","link":"","permalink":"http://example.com/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/","excerpt":"","text":"正文几乎就是用阻塞的写法来完成非阻塞的任务。Kotlin-JVM中所谓的协程是假协程Kotlin-JVM中所谓的 协程挂起 ，就是开启了一个子线程去执行任务 对于Java来说，不管你用什么方法，只要你没有魔改JVM，那么最终你代码里start几个线程，操作系统就会创建几个线程，是1比1的关系。Kotlin官网中那个创建10w个Kotlin协程没有oom的例子其实有误导性，本质上那10w个Kotlin协程就是10w个并发任务仅此而已，他下面运行的就是一个单线程的线程池。你往一个线程池里面丢多少个任务都不会OOM的（前提是你的线程池创建的时候设定了对应的拒绝策略，否则无界队列下，任务过多一定会OOM），因为在运行的始终是那几个线程。 创建协程的方式有五种： 12345GlobalScope.launch&#123;&#125;launch&#123;&#125;runBlocking&#123;&#125;coroutineScope&#123;&#125;async&#123;&#125;","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"协程核心概念的理解与应用(一)--翻译翻译什么是 CoroutineScope","slug":"1 Kotlin/01 Kotlin 协程/Kotlin 的协程本质到底什么 copy","date":"2023-08-10T23:19:04.000Z","updated":"2024-03-09T18:26:34.148Z","comments":true,"path":"2023/08/11/1 Kotlin/01 Kotlin 协程/Kotlin 的协程本质到底什么 copy/","link":"","permalink":"http://example.com/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/","excerpt":"","text":"作者：朕小猫与GPT4 Android 如何在一个非 LifecycleOwner 的类中使用协程在非LifecycleOwner的类中使用协程，你不能直接使用与生命周期相关的作用域，如lifecycleScope或viewModelScope。不过，你可以使用CoroutineScope来创建自己的作用域。使用CoroutineScope，你可以定义一个作用域，并指定一个Dispatcher来控制协程的执行线程。此外，你还需要手动管理协程的生命周期，以避免内存泄漏。 以下是如何在非LifecycleOwner类中使用协程的一个基本示例： 定义协程作用域：首先，定义一个协程作用域，通常是类的成员变量。这个作用域应当与你希望协程执行的生命周期绑定。例如，如果你在一个普通类中工作，你可能需要在类被销毁时取消所有协程。 12345678import kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobclass MyClass &#123; private val job = Job() private val coroutineScope = CoroutineScope(Dispatchers.Main + job)&#125; 在协程作用域内启动协程：使用定义的协程作用域启动协程，执行异步操作。 1234567891011import kotlinx.coroutines.launchclass MyClass &#123; // ...前面的代码 fun doSomething() &#123; coroutineScope.launch &#123; // 在这里执行协程代码 &#125; &#125;&#125; 管理协程生命周期：为避免内存泄漏，确保在不需要协程运行时取消它们。如果你的类有一个明确的生命周期结束点（如自定义视图的onDetachedFromWindow或者一个对象的close方法），你应当在那里取消作用域中的所有协程。 123fun onDestroy() &#123; job.cancel() // 取消与这个作用域相关的所有协程&#125; 通过以上步骤，你可以在不依赖于LifecycleOwner的情况下，安全地在任何类中使用协程。记住，手动管理协程的生命周期是避免内存泄漏的关键。 如何理解 CoroutineContextCoroutineContext是Kotlin协程中用于持有协程相关配置的接口。它由一组元素组成，每个元素都实现了CoroutineContext.Element接口，并且通过一个唯一的Key进行标识。CoroutineContext的实现并不限于某些固定的子类，而是通过组合不同的Element实例来扩展其功能。这意味着CoroutineContext的“子类”实际上是指一系列标准库或自定义库中定义的实现了CoroutineContext.Element接口的类，这些类代表了不同的协程配置和特性。以下是一些常见的CoroutineContext.Element实现，它们在Kotlin协程的使用中扮演着关键角色： Job: 控制协程的生命周期，允许启动、取消、和查询协程的状态。Job是协程工作的基本单位，可以被用来取消协程。 CoroutineDispatcher: 决定协程在哪个线程或线程池上执行。Dispatchers.Main、Dispatchers.IO、和Dispatchers.Default是最常用的几种调度器。 CoroutineName: 提供协程的名称，有助于调试。 CoroutineExceptionHandler: 定义了协程如何处理未捕获的异常。可以用来全局或局部地处理异常。 除了上述提到的标准元素外，开发者还可以实现自定义的CoroutineContext.Element来扩展协程的功能。每个元素都可以通过其Key加入到CoroutineContext中，同时保证CoroutineContext中的每个Key都是唯一的。 在实际应用中，这些元素可以通过+操作符组合在一起，形成一个包含多个配置的CoroutineContext，用于启动和管理协程。这种设计允许协程上下文在保持灵活性的同时，能够非常精确地控制协程的行为和环境。 协程的 + 号代表什么123456789101112131415161718/** * Returns a context containing elements from this context and elements from other [context]. * The elements from this context with the same key as in the other one are dropped. */public operator fun plus(context: CoroutineContext): CoroutineContext = if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation context.fold(this) &#123; acc, element -&gt; val removed = acc.minusKey(element.key) if (removed === EmptyCoroutineContext) element else &#123; // make sure interceptor is always last in the context (and thus is fast to get when present) val interceptor = removed[ContinuationInterceptor] if (interceptor == null) CombinedContext(removed, element) else &#123; val left = removed.minusKey(ContinuationInterceptor) if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else CombinedContext(CombinedContext(left, element), interceptor) &#125; &#125; &#125; 这个plus函数是CoroutineContext的一个操作符函数，用于合并两个协程上下文（CoroutineContext），返回一个包含两者元素的新上下文。如果两个上下文中有相同键（key）的元素，那么原上下文（this）中的元素会被丢弃。这个函数的主要逻辑可以分解为几个关键步骤： 快速路径检查：如果要添加的上下文（context）是一个空的协程上下文（EmptyCoroutineContext），则直接返回当前上下文（this），因为没有新元素需要添加。 遍历合并：使用fold方法遍历context中的每个元素。fold接收一个初始累加值（这里是this，即当前上下文）和一个操作函数。操作函数定义了如何将context中的元素合并到累加值中。 去除相同键的元素：对于context中的每个元素，先从累加值（即目前合并的结果）中移除具有相同键的元素。这一步确保了如果有相同键的元素，那么this中的元素会被context中的元素替换。 合并上下文：如果移除相同键元素后的上下文是空的（EmptyCoroutineContext），则只添加当前遍历到的元素。否则，检查是否存在ContinuationInterceptor元素（协程拦截器），因为拦截器应当始终位于上下文中的最后，以便快速获取。 调整拦截器位置：如果存在ContinuationInterceptor，将其移动到合并后的上下文的最后。这涉及到在没有拦截器的剩余上下文中添加当前元素，然后再添加拦截器。 返回新的合并上下文：最终返回包含了this和context元素（且context中的元素优先）的新上下文。如果存在ContinuationInterceptor，确保它位于最后。 简而言之，这个函数通过合并两个协程上下文并调整元素顺序，确保了新上下文中不会有重复的键，且ContinuationInterceptor（如果存在）总是位于最后，以优化性能。 如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。CoroutineContext在Kotlin协程中是一个关键概念，它是一组各种元素的集合，这些元素定义了协程的行为。每个元素都有一个Key，用于唯一标识该元素的类型，这样CoroutineContext就可以通过键值对的方式存储和检索协程的配置和状态信息。这里的“相同键（key）的元素”意味着两个元素属于同一类型，或者说执行相同的功能或角色。 CoroutineContext和 key **CoroutineContext：是一个集合，包含了控制协程行为的各种元素，例如调度器（Dispatcher）、协程名称、协程的异常处理器等。每个元素通过一个唯一的键（Key**）来识别，键通常由元素类型本身提供。 相同键的元素：如果两个CoroutineContext元素具有相同的键，它们被视为同一类型的配置或状态信息。在合并上下文时，不能有重复键的元素，否则会产生冲突。 为什么context中的元素优先在合并两个CoroutineContext时，如果存在相同键的元素，context参数中的元素会替换当前上下文（this）中的元素。这个设计选择是基于函数式编程中常见的不可变性原则，以及配置更新的需求：新提供的配置（即context参数中的）被认为是最新的，应优先于旧的配置。这样，开发者可以灵活更新协程的行为，而无需担心旧上下文的状态。 为什么ContinuationInterceptor位于最后ContinuationInterceptor是CoroutineContext中的一个特殊元素，用于拦截协程的执行。它是协程调度器（如Dispatchers.Main）的基础，控制着协程的执行线程。将ContinuationInterceptor放在合并后的CoroutineContext的最后，是出于性能考虑： 快速访问：协程在执行时频繁查询ContinuationInterceptor以确定执行线程。将其置于上下文的末尾可以优化这一查询过程，因为在CoroutineContext的实现中，较后的元素可以更快地被访问到。 避免冲突：确保ContinuationInterceptor总是最后一个被添加，意味着即使合并多个上下文，也能保证只有一个有效的调度器在最终的上下文中生效，这避免了多个调度器可能导致的潜在冲突。 综上所述，CoroutineContext及其键的概念允许协程行为的灵活配置和更新，而在合并上下文时优先考虑新的元素以及保持ContinuationInterceptor在最后，是出于更新优先级和性能优化的考虑。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"Android aar 文件到底是什么","slug":"6 Android编译打包/Android aar 文件到底是什么","date":"2023-08-10T23:19:04.000Z","updated":"2024-03-10T08:39:30.175Z","comments":true,"path":"2023/08/11/6 Android编译打包/Android aar 文件到底是什么/","link":"","permalink":"http://example.com/2023/08/11/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/Android%20aar%20%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"作者: 朕小猫与GPT4 问题起源：怎么打包发布一个含有 C++ 文件的 Library起因是 KOOM 2.2.1 Release 存在后台分析进程在部分机型失效，想自己发布一个适合自己项目的版本。 .so文件可以被打包到最终的AAR文件中吗是的，.so文件可以并且通常被打包到最终的AAR（Android Archive）文件中。AAR文件是Android开发中用于分发Android库的标准格式，它包含了库所需的所有资源、编译后的代码以及其他文件，比如.so文件（本地库文件）。 打包.so文件到AAR中的步骤 放置.so文件: 将你的.so文件放置在项目的src/main/jniLibs/目录下。按照不同的CPU架构，你可能需要创建相应的子目录，例如armeabi-v7a、arm64-v8a、x86等，然后将相应架构的.so文件放置在这些目录下。 配置Gradle构建脚本: 确保你的build.gradle文件正确配置，这样Gradle在构建过程中就会自动将jniLibs目录下的.so文件包括到AAR包中。大多数情况下，这个过程是自动完成的，无需额外配置。 示例目录结构12345678910111213141516YourLibraryProject/├── src/│ └── main/│ ├── java/│ │ └── ... (your Java or Kotlin source files)│ ├── res/│ │ └── ... (your resources)│ └── jniLibs/│ ├── armeabi-v7a/│ │ └── libyourlibrary.so│ ├── arm64-v8a/│ │ └── libyourlibrary.so│ ├── x86/│ │ └── libyourlibrary.so│ └── x86_64/│ └── libyourlibrary.so 构建AAR包当你构建你的库时（例如，通过运行./gradlew assembleRelease），Gradle会自动将jniLibs目录下的所有.so文件包括到生成的AAR文件中。这样，当其他开发者将你的AAR文件作为依赖项添加到他们的项目中时，这些.so文件就会被自动解压到正确的位置，供他们的应用使用。 确保在发布你的库之前测试它，以确保.so文件被正确包含且可以按预期工作。这通常涉及到在包含不同CPU架构设备的模拟器或真实设备上运行和测试你的库。 .aar 里可以有哪些文件一个AAR（Android Archive）文件是Android库项目的发布包格式，用于在开发者之间共享Android库。AAR文件包含了库所需要的所有内容，使其可以被其他的Android应用项目引用。以下是AAR文件通常包含的文件和目录： 必需的内容 classes.jar：包含库的所有编译后的Java类（.class文件）。 res/：包含库所使用的所有资源文件，如布局（layouts）、字符串（strings）、图片（drawables）等。 AndroidManifest.xml：库的Android清单文件，描述了库的包名、所需权限、活动（activities）、服务（services）等。 可选的内容 R.txt：包含库中所有资源的ID名称和类型的列表，这是为了在库被引用时帮助生成最终应用的R类。 aidl/：包含库所使用的所有AIDL（Android Interface Definition Language）文件，用于定义跨进程通信接口。 assets/：包含可以被库访问的原始文件，如文本、音频或视频文件。 libs/*.jar：包含库依赖的任何Java库的JAR文件。 jni/ 或 jniLibs/：包含库依赖的本地库（如.so文件），这些文件根据不同的CPU架构可能存放在不同的子目录下，如armeabi-v7a/、arm64-v8a/等。 proguard.txt：包含用于代码混淆的ProGuard规则。 lint.jar：包含自定义lint检查规则的JAR，这些规则可以在使用库的项目中被lint程序使用。 public.txt：列出了库公开的资源ID，这些资源ID在库的使用者中是可见的。 annotations.zip：包含用于工具支持的注解，比如nullability注解等。 如何查看AAR文件内容你可以通过解压AAR文件（它本质上是一个ZIP文件）来查看里面的内容。使用任何标准的压缩文件管理器，如WinRAR、7-Zip等，都可以打开AAR文件并浏览其中的内容。 使用AAR文件当你将AAR文件作为依赖项添加到Android项目中时，项目构建系统（如Gradle）会自动处理并引入这些内容，包括解析资源、合并清单文件等，从而使库中的功能可用于应用程序。","categories":[{"name":"6 - Android 打包编译","slug":"6-Android-打包编译","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/"},{"name":"6.1 - 文件分析","slug":"6-Android-打包编译/6-1-文件分析","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-1-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[]},{"title":"Android aar 文件到底是什么","slug":"6 Android编译打包/Android 云编译 gradle 配置","date":"2023-08-10T23:19:04.000Z","updated":"2024-07-21T11:08:30.135Z","comments":true,"path":"2023/08/11/6 Android编译打包/Android 云编译 gradle 配置/","link":"","permalink":"http://example.com/2023/08/11/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/Android%20%E4%BA%91%E7%BC%96%E8%AF%91%20gradle%20%E9%85%8D%E7%BD%AE/","excerpt":"","text":"作者: 朕小猫与GPT4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107task downloadApk &#123; doLast &#123; def remoteApkPath = &quot;/home/jason/AndroidStudioProjects/ncmusic/app/build/outputs/apk/debug/app-debug.apk&quot; def localApkDir = System.getProperty(&quot;user.home&quot;) + &quot;/Downloads/&quot; def localApkPath = localApkDir + &quot;app-debug.apk&quot; // 创建本地目录 new File(localApkDir).mkdirs() // 使用 scp 下载远程 APK 文件到本地 def command = &quot;sshpass -p &#x27;password&#x27; scp jason@192.168.1.100:$&#123;remoteApkPath&#125; $&#123;localApkPath&#125;&quot; println &quot;Executing command: $&#123;command&#125;&quot; exec &#123; commandLine &#x27;bash&#x27;, &#x27;-c&#x27;, command &#125; &#125;&#125;task installAndStart &#123; dependsOn downloadApk doLast &#123; def localApkPath = System.getProperty(&quot;user.home&quot;) + &quot;/Downloads/app-debug.apk&quot; // 确保 adb 可用 def adbPath = &#x27;/Users/jason/Library/Android/sdk/platform-tools/adb&#x27; if (!new File(adbPath).exists()) &#123; throw new GradleException(&quot;adb command not found at $&#123;adbPath&#125;! Please ensure Android SDK is properly installed.&quot;) &#125; // 安装 APK def installCommand = &quot;$&#123;adbPath&#125; install -r $&#123;localApkPath&#125;&quot; try &#123; exec &#123; commandLine &#x27;bash&#x27;, &#x27;-c&#x27;, installCommand &#125; &#125; catch (Exception e) &#123; throw new GradleException(&quot;Failed to install APK: $&#123;e.message&#125;&quot;) &#125; // 提取包名 def manifestFile = file(&quot;$&#123;rootProject.projectDir&#125;/app/src/main/AndroidManifest.xml&quot;) def packageName = &quot;&quot; if (manifestFile.exists()) &#123; manifestFile.eachLine &#123; line -&gt; if (line.contains(&quot;package=&quot;)) &#123; packageName = line.split(&#x27;package=&#x27;)[1].split(&#x27;&quot;&#x27;)[1] &#125; &#125; if (packageName == &quot;&quot;) &#123; throw new GradleException(&quot;Failed to extract package name from AndroidManifest.xml&quot;) &#125; &#125; else &#123; throw new GradleException(&quot;AndroidManifest.xml file not found!&quot;) &#125; // 启动应用 def launchCommand = &quot;$&#123;adbPath&#125; shell monkey -p $&#123;packageName&#125; -c android.intent.category.LAUNCHER 1&quot; println &quot;Executing command: $&#123;launchCommand&#125;&quot; try &#123; exec &#123; commandLine &#x27;bash&#x27;, &#x27;-c&#x27;, launchCommand &#125; &#125; catch (Exception e) &#123; throw new GradleException(&quot;Failed to launch application: $&#123;e.message&#125;&quot;) &#125; &#125;&#125;task downloadBuild &#123; doLast &#123; subprojects.each &#123; subproject -&gt; def remoteRootPath = &quot;/home/jason/AndroidStudioProjects/&quot; def remoteDirPath = remoteRootPath + &quot;$&#123;rootProject.name&#125;/$&#123;subproject.name&#125;/build&quot; def localDirPath = &quot;$&#123;subproject.projectDir&#125;&quot; // 创建本地目录 new File(localDirPath).mkdirs() // 使用 rsync 同步远程文件到本地 def command = &quot;sshpass -p &#x27;password&#x27; rsync -avz --delete jason@192.168.1.100:$&#123;remoteDirPath&#125; $&#123;localDirPath&#125;&quot; println &quot;Executing command: $&#123;command&#125;&quot; exec &#123; commandLine &#x27;bash&#x27;, &#x27;-c&#x27;, command &#125; &#125; &#125;&#125;task remoteBuild &#123; doLast &#123; // 远程构建命令 def command = &quot;sshpass -p &#x27;password&#x27; ssh jason@192.168.1.100 &#x27;cd /home/jason/AndroidStudioProjects/ncmusic/ &amp;&amp; ./gradlew assembleDebug&#x27;&quot; exec &#123; commandLine &#x27;bash&#x27;, &#x27;-c&#x27;, command &#125; &#125;&#125;// 定义一个任务来执行远程构建、下载 APK、安装并启动应用，然后同步构建产物task buildDownloadInstallAndStart &#123; dependsOn remoteBuild finalizedBy installAndStart, downloadBuild&#125;","categories":[{"name":"6 - Android 打包编译","slug":"6-Android-打包编译","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/"},{"name":"6.2 - 简单好用的 gradle 云编译设置","slug":"6-Android-打包编译/6-2-简单好用的-gradle-云编译设置","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-2-%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84-gradle-%E4%BA%91%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE/"}],"tags":[]},{"title":"Kotlin中的惰性操作容器——Sequence","slug":"1 Kotlin/02 Kotlin 基础/Kotlin中的惰性操作容器——Sequence","date":"2023-08-10T23:18:54.000Z","updated":"2023-08-10T23:18:54.000Z","comments":true,"path":"2023/08/11/1 Kotlin/02 Kotlin 基础/Kotlin中的惰性操作容器——Sequence/","link":"","permalink":"http://example.com/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/","excerpt":"","text":"Sequence序列Sequence 是Kotlin标准库提供的一种容器类型。它和Iterable一样具备对集合进行多步骤操作能力，但是却是采用了一种完全不同于Iterable的实现方式： 12345678val map = (0..3).filter &#123; println(&quot;filter:$it&quot;) it % 2 == 0&#125;.map &#123; println(&quot;map:$it&quot;) it + 1&#125;println(map) 上面的代码用来演示Iterable进行连续操作的情况。它的输出如下： 1234567filter:0filter:1filter:2filter:3map:0map:2[1, 3] 像map和filter这些链式集合函数它们都会立即执行并创建中间临时集用来保存数据。当原始数据不多时，这并不会有什么影响。但是，当原始数据量非常大的时候。这就会变的非常低效。而此时，就可以借助Sequence提高效率。 123456789val sequence = (0..3).asSequence().filter &#123; println(&quot;filter:$it&quot;) it % 2 == 0&#125;.map &#123; println(&quot;map:$it&quot;) it + 1&#125;println(&quot;准备开始执行&quot;)println(sequence.toList()) 上面的代码执行结果如下： 12345678准备开始执行filter:0map:0filter:1filter:2map:2filter:3[1, 3] 对比Iterable和Sequence： Iterable是即时的、Sequence是惰性的：前者会要求尽早的计算结果，因此在多步骤处理链的每一环都会有中间产物也就是新的集合产生；后者会尽可能的延迟计算结果，Sequence处理的中间函数不进行任何计算。相反，他们返回一个新Sequence的，用新的操作装饰前一个，所有的这些计算都只是在类似toList的终端操作期间进行。 区分中间操作符和末端操作符的方式也很简单：如果操作符返回的是一个Sequence类型的数据，它就是中间操作符。 在操作的执行方式上也有所不同：Iterable每次都是在整个集合执行完操作后再进行下一步操作——采用第一个操作并将其应用于整个集合，然后移动到下一个操作，官方将其称呼为急切式或者按步骤执行（Eager&#x2F;step-by-step）；而Sequence则是逐个对每个元素执行所有操作。是一种惰性顺序——取第一个元素并应用所有操作，然后取下一个元素，依此类推。官方将其称呼为惰性式或者按元素执行（Lazy&#x2F;element-by-element) 序列的惰性会带来一下几个优点： 它们的操作按照元素的自然顺序进行； 只做最少的操作； 元素可以是无限多个； 不需要在每一步都创建集合 Sequence可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。但是，惰性性质也会带来一些运行开销。所以在使用时要权衡惰性开销和中间步骤开销，在Sequence和Iterable中选择更加合适的实现方式。 执行的顺序1234567891011sequenceOf(1,2,3) .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125; .map &#123; print(&quot;M$it, &quot;); it * 2 &#125; .forEach &#123; print(&quot;E$it, &quot;) &#125; // Prints: F1, M1, E2, F2, F3, M3, E6,listOf(1,2,3) .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125; .map &#123; print(&quot;M$it, &quot;); it * 2 &#125; .forEach &#123; print(&quot;E$it, &quot;) &#125;// Prints: F1, F2, F3, M1, M3, E2, E6, sequence的执行时按照元素进行的，依次对元素执行所有的操作，对一个元素而言，所有操作时依次全部执行的。而普通集合操作则是以操作步骤进行的，当所有的元素执行完当前操作后才会进入下一个操作。 只做最少的操作试想一下我们有一千万个数字，我们要经过几次变换取出20个，使用下面的代码对比一下序列和不同集合操作的性能： 12345678910111213141516171819fun main()&#123; val fFlow = FFlow() fFlow.demoList() fFlow.demoSequence()&#125;fun demoSequence() &#123; val currentTimeMillis = System.currentTimeMillis() val list = (0..10000000).asSequence().map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList() println(&quot;demoSequence:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)&#125;fun demoList() &#123; val currentTimeMillis = System.currentTimeMillis() val list = (0..10000000).map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList() println(&quot;demoList:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)&#125; 输出的结果如下： 12demoSequence:20ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]demoList:4106ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37] 这就是只执行最少操作的意思，序列按照元素顺序执行，当取够29个元素之后便会立即停止计算。而不同的集合则不同，没有中间操作的概念。它的每次操作都会对整个数组中的所有元素执行完才会进行下一个——也就是前两个map都要执行一千万次。 序列可以是无限的看如下代码： 123456var list = emptyArray&lt;Int&gt;()var i = 0while(true)&#123; list[i] = i++&#125;list.take(10) 很明显，这段代码是没法正常运行的，因为这里有一个死循环。我们也无法创建一个无限长度的集合。但是：因为序列式按步骤依照需求进行处理的，所哟我们可以创建无限序列： 123456789val noEnd = sequence &#123; var i = 1 while (true) &#123; yield(i) i *= 2 &#125;&#125;noEnd.take(4).toList()//输出:[1, 2, 4, 8] 但是一定要注意，我们虽然可以这么写，但是务必不能真的让while一直循环。我们不能直接使用toList。必须提供一个能结束循环的操作符，也就是不能取出所有元素（无限个）——要么使用类似take的操作来限制它们的数量，要么使用不需要所有元素的终端操作，例如first, find, any, all, indexOf等。 序列不会在每个步骤创建集合普通的集合会在每次变换之后都会创建新的集合取存储所有变换后的元素。而每次创建集合和填入数据都会带来不小的性能开销。尤其是当我们处理大量或大量的集合时，性能问题会愈发凸显。而序列的按元素操作，则不会有这个问题。除非手动调用了终端操作符，否则不会生成新的集合。 Sequence的基本使用Sequence序列的使用和普通的Iterable极其相似，实际上其内部也还是借助Iterable实现的。在研究它的内部实现原理之前，想从Sequence的创建和基本的序列操作来演示Sequence的基本用法。 序列的创建创建Sequence的方式大概可以分为。分别是由元素创建、通过Iterable、借助函数以及由代码块创建。 由元素创建：通过调用顶级函数sequenceOf实现： 12val ints = sequenceOf(1, 2, 3, 4, 5, 6, 7)val strings = sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) 通过Iterable转化：借助Iterable的扩展函数asSequence实现： 12val ints = listOf(1, 2, 3, 4, 5, 6, 7).asSequence()val strings = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence() 通过generateSequence实现：该方法有三个： 123generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; 最终都是通过GeneratorSequence实现的，这里先不进行源码分析。只讨论使用方式： 其中三个函数都有的形参nextFunction可以理解为元素生成器，序列里的元素都通过调用该函数生成，当它返回为null是，序列停止生成（所以，nextFunction必须要在某个情况下返回null，否则会因为序列元素是无限多个触发java.lang.OutOfMemoryError: Java heap space异常）。 而另外两个的seedFunction和seed形参都是为了确定数据初始值的。区别在于一个直接指明，一个通过调用函数获取。 分别用这三个函数生成0~100的序列，代码如下： 12345678910111213141516171819202122val generateSequenceOne = generateSequence &#123; if (i &lt; 100) &#123; i++ &#125; else &#123; null &#125;&#125;val generateSequenceTwo = generateSequence(0) &#123; if (it &lt; 100) &#123; it+1//此处的it是上一个元素 &#125; else &#123; null &#125;&#125;val generateSequenceThree = generateSequence(&#123; 0 &#125;) &#123; if (it &lt; 100) &#123; it+1//此处的it是上一个元素 &#125; else &#123; null &#125;&#125; 由代码块生成：借助sequence(block: suspend SequenceScope.() -&gt; Unit)函数。改函数接受一个挂起函数，该函数会接受一个SequenceScope实例，这个实例无需我们创建（后面源码分析会讲到）。SequenceScope提供了yield和yieldAll方法复杂返回序列元素给调用者，并暂停序列的执行，直到使用者请求下一个元素。 用该函数生成0~100的序列，代码如下： 12345val ints = sequence &#123; repeat(100) &#123; yield(it) &#125;&#125; 序列的操作对序列的操作可以分为中间操作和末端操作两种。它们只要有一下另种区别： 中间操作返回惰性生成的一个新的序列，而末端序列则为其他普通的数据类型； 中间操作不会立刻执行代码，仅当执行了末端操作序列才会开始执行。 常见的中间操作包括：map、fliter、first、last、take等；它们会序列提供数据变化过滤等增强功能基本上和kotlin提供的集合操作符有着相同的功能。 常见的末端操作有：toList、toMutableList、sum、count等。它们在提供序列操作功能的同时，还会触发序列的运行。 Sequence源码分析上文对序列做了简单的入门介绍。接下来深入源码去了解一下Sequence的实现方式。 Sequence是什么？Kotlin对的定义Sequence很简单： 123public interface Sequence &lt;out T&gt; &#123; public operator fun iterator(): Iterator&lt;T&gt;&#125; 就是一个接口，定义了一个返回Iterator的方法。接口本身只定义了Sequence具有返回一个迭代器的能力。具体的功能实现还是靠它的实现类完成。 可以概括一些：序列就是一个具备提供了迭代器能力的类。 序列的创建方式分析结合上文中提到的序列的四种创建方式，我们依次分析一下它的创建流程。 我们首先以比较常用的通过Iterable转化获取序列，它需要借助asSequence方法分析一下，使用listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()生成一个序列。调用链如下： 1234567public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123; return Sequence &#123; this.iterator() &#125;&#125;public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 流程很简单，一个扩展函数加一个内联函数。最终通过匿名内部类的方式创建一个Sequence并返回。代码很好理解，实际上它的实现逻辑等同于下面的代码： 1234567val sequence = MySequence(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).iterator())class MySequence&lt;T&gt;(private val iterator:Iterator&lt;T&gt;):Sequence&lt;T&gt;&#123; override fun iterator(): Iterator&lt;T&gt; &#123; return iterator &#125;&#125; 接着看一下通过调用顶级函数sequenceOf实现，以sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)为例，它的调用逻辑如下： 1public fun &lt;T&gt; sequenceOf(vararg elements: T): Sequence&lt;T&gt; = if (elements.isEmpty()) emptySequence() else elements.asSequence() 可以看到依旧是借助asSequence实现的。 接下来看一下代码块和generateSequence的实现方式，这两个方式会比较复杂一点，毕竟前面两个都是借助List进行转换，而List本身就能提供迭代器Iterator。后面两个明显需要提供新的迭代器。 首先看一下代码看的实现方式： 12345val ints = sequence &#123; repeat(100) &#123; yield(it) &#125; &#125; 其中sequence的调用逻辑如下： 123456789101112public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; iterator(block) &#125;public fun &lt;T&gt; iterator(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123; //创建迭代器 val iterator = SequenceBuilderIterator&lt;T&gt;() iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator) return iterator&#125;public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 可以发现：该方法和asSequence一样最终也是通过匿名内部类的方式创建了一个Sequence。不过区别在于，该方法需要创建一个新的迭代器，也就是SequenceBuilderIterator 。同样以MySequence为例，它的创建流程等同于一下代码： 123456789101112131415fun mian()&#123; create&lt;Int&gt; &#123; myblock() &#125;&#125;suspend fun SequenceScope&lt;Int&gt;.myblock()&#123; repeat(100) &#123; yield(it) &#125;&#125;fun &lt;Int&gt; create(block: suspend SequenceScope&lt;Int&gt;.() -&gt; Unit):Sequence&lt;Int&gt;&#123; val iterator = SequenceBuilderIterator&lt;Int&gt;() iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator) return MySequence(iterator)&#125; 当然，这是不可能实现的，因为SequenceBuilderIterator是被private修饰了，我们是无法直接访问的。这里强制写出来演示一下它的流程。 最后看一下通过generateSequence方法创建序列的源码，一共有三个： 123456789101112public fun &lt;T : Any&gt; generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = GeneratorSequence(seedFunction, nextFunction)public fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = if (seed == null) EmptySequence else GeneratorSequence(&#123; seed &#125;, nextFunction)public fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; &#123; return GeneratorSequence(nextFunction, &#123; nextFunction() &#125;).constrainOnce()&#125; 最终都是创建了GeneratorSequence的一个实例并返回，而GeneratorSequence实现了Sequence接口并重写了iterator()方法： 1234567891011121314151617181920212223242526272829private class GeneratorSequence&lt;T : Any&gt;(private val getInitialValue: () -&gt; T?, private val getNextValue: (T) -&gt; T?) : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; var nextItem: T? = null var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue private fun calcNext() &#123; nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!) nextState = if (nextItem == null) 0 else 1 &#125; override fun next(): T &#123; if (nextState &lt; 0) calcNext() if (nextState == 0) throw NoSuchElementException() val result = nextItem as T // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue nextState = -1 return result &#125; override fun hasNext(): Boolean &#123; if (nextState &lt; 0) calcNext() return nextState == 1 &#125; &#125;&#125; 总结一下Sequence的创建大致可以分为三类： 使用List自带的迭代器通过匿名的方式创建Sequence实例，sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)和listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()就是这种方式； 创建新的SequenceBuilderIterator迭代器，并通过匿名的方式创建Sequence实例。例如使用代码块的创建方式。 创建GeneratorSequence，通过重写iterator()方法，使用匿名的方式创建Iterator。GeneratorSequence方法就是采用的这种方式。 看完创建方式，也没什么奇特的，就是一个提供迭代器的普通类。还是看不出是如何惰性执行操作的。接下来就分析一下惰性操作的原理。 序列的惰性原理以最常用的map操作符为例：普通的集合操作源码如下： 123456789101112public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123; //出啊年一个新的ArrayList，并调用mapTo方法 return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)&#125;public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123; //遍历原始的集合，进行变换操作，然后将变换后的数据依次加入到新创建的集合 for (item in this) destination.add(transform(item)) //返回新集合 return destination&#125; 可以看到：当List.map被调用后，便会立即创建新的集合，然后遍历老数据并进行变换操作。最后返回一个新的数据。这印证了上面提到的普通集合的操作时按照步骤且会立刻执行的理论。 接下来看一下序列的map方法，它的源码如下： 1234567891011121314151617181920212223public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123; return TransformingSequence(this, transform)&#125;internal class TransformingSequence&lt;T, R&gt;constructor(private val sequence: Sequence&lt;T&gt;, private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123; override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123; //注释一：TransformingSequence的iterator持有上一个序列的迭代器 val iterator = sequence.iterator() override fun next(): R &#123; //注释二：在开始执行迭代时，向上调用前一个序列的迭代器。 return transformer(iterator.next()) &#125; override fun hasNext(): Boolean &#123; return iterator.hasNext() &#125; &#125; internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123; return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator) &#125;&#125; 代码并不复杂，它接收用户提供的变换函数和序列，然后创建了一个TransformingSequence并返回。TransformingSequence本身和上文中提到的序列没什么区别，唯一的区别在于它的迭代器：在通过next依次取数据的时候，并不是直接返回元素。而是先调用调用者提供的函数进行变换。返回变换后的数据——这也没什么新鲜的，和普通集合的map操作符和RxJava的Map都是同样的原理。 但是，这里却又有点不一样。操作符里没有任何开启迭代的代码，它只是对序列以及迭代进行了嵌套处理，并不会开启迭代.如果用户不手动调用（后者间接调用）迭代器的next函数，序列就不会被执行——这就是惰性执行的机制的原理所在。 而且，由于操作符返回的是一个Sequence类型的值，当你重复不断调用map时，例如下面的代码： 12345678(0..10).asSequence().map&#123;add(it)&#125;.map&#123;add(it)&#125;.map&#123;add(it)&#125;.toList()//等同于val sequence1 = (0..10).asSequence()val sequence2 = sequence1.map &#123; it+1 &#125;val sequence3 = sequence2.map &#123; it+1 &#125;sequence3.toList() 最终，序列sequence3的结构持有如下：sequence3-&gt; sequence2 -&gt; sequence1。而它们都有各自的迭代器。迭代器里都重写了各自的变换逻辑: 123456789override fun next(): R &#123; return transformer(iterator.next())&#125;//由于这里都是执行的+1操作，所以变换逻辑transformer可以认为等同于如下操作:override fun next(): R &#123; return iterator.next()+1&#125; 而当我们通过sequence3.toList执行代码时，它的流程如下： 123456789101112131415161718public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123; return this.toMutableList().optimizeReadOnlyList()&#125;public fun &lt;T&gt; Sequence&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123; //末端操作符，此处才会开始创建新的集合 return toCollection(ArrayList&lt;T&gt;())&#125;public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123; //执行迭代器next操作 //当调用（末端操作符）走到这里时，便会和普通结合的操作符一样 //此时为新创建的集合赋值 for (item in this) &#123; destination.add(item) &#125; return destination&#125; 经过几次扩展函数调用，最终在toCollection里开始执行迭代(Iterator的典型的操作)，也就是获取了sequence3的iterator实例，并不断通过next取出数据。而在上文中的TransformingSequence源码里可以看到，TransformingSequence会持有上一个迭代器的实例（代码注释一）。 并且在迭代开始后，在进行transformer操作（也就是执行+1操作）前，会调用上一个迭代器的next方法进行迭代（代码注释二）。这样不断的迭代，最终，最终会调用到sequence1的next方法。再结合上文中的序列创建里的分析——sequence1里所持有的迭代器就是就是原始数据里的迭代器。 那么当最终执行toList方法时，它会循环sequence3.iterator方法。而在每次循环内，都会首先执行sequence3所持有的sequence2.iterator的next方法。sequence2依次类推执行到sequence1的sequence1.iterator&#96;方法，最终执行到我们原始数组的迭代器next方法： 整个流程如下： 原理就是这么简单：中间操作符通过序列嵌套，实现对迭代器iterator的嵌套。这样在进行迭代的时候，会依次调用各个iterator迭代器直到调用到原始集合数据里的迭代器开始并返回元素。而当元素返回时，会依次执行各个迭代器持有变换操作方法实现对数据的变换。 而其他操作符，也是遵循这个基本的规则。无非就是增加一些其他的操作。 总结 序列通过中间操作符对迭代器进行嵌套和复写，以此实现按元素操作执行变换； 中间操作符只负责根据需求创建并嵌套迭代器，并不负责开启迭代器。以此实现惰性操作且不产生临时集合； 末端操作符负责开启迭代，按照嵌套顺序执行迭代操作。依次获取操作后的数据，并且会创建新的集合用来存储最终数据； 序列不是万能的，因为要引入新的对象。在带来惰性和顺序执行的优势时，这些对象必然会带来性能开销。所以要依需求在集合和序列之间进行选择，使用合适的方式进行迭代。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Kotlin中有哪些类","slug":"1 Kotlin/02 Kotlin 基础/Kotlin中有哪些类","date":"2023-08-10T23:18:54.000Z","updated":"2024-04-14T04:44:00.321Z","comments":true,"path":"2023/08/11/1 Kotlin/02 Kotlin 基础/Kotlin中有哪些类/","link":"","permalink":"http://example.com/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB/","excerpt":"","text":"在 Kotlin 中，类的概念是非常广泛的，包括各种类型的类设计用于不同的目的和场景。Kotlin 提供了丰富的类类型以支持现代软件开发的需要。下面是一些在 Kotlin 中常见的类类型： 1. 数据类（Data Class）数据类是专门用于存储数据的类。Kotlin 的数据类通过 data 关键字定义，它自动从所声明的属性中派生出 equals()、hashCode() 和 toString() 等方法，以及 copy() 函数和 componentN() 函数（按声明顺序对应于所有属性）。 1data class User(val name: String, val age: Int) 2. 枚举类（Enum Class）枚举类用于定义一组命名常量。Kotlin 中的枚举不仅可以有属性，还可以有自己的方法。 123enum class Direction &#123; NORTH, SOUTH, EAST, WEST;&#125; 3. 密封类（Sealed Class）密封类用于表示受限的类层次结构，即一个值只能是有限集合中的某个类型，而不能是任何其他类型。这对于当你在使用 when 表达式时，想要确保覆盖所有可能的类型非常有用。 1234sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() 4. 抽象类（Abstract Class）抽象类是不能被实例化的类，通常用作其他类的基类。抽象类可以包含抽象方法（没有实现的方法）和非抽象方法。 1234abstract class Vehicle &#123; abstract fun drive() fun park() &#123; println(&quot;Parked&quot;) &#125;&#125; 5. 内部类（Inner Class）内部类是定义在另一个类内部的类。内部类持有其外部类的一个引用，因此可以访问其成员。 123456class Outer &#123; private val bar: Int = 1 inner class Inner &#123; fun foo() = bar &#125;&#125; 6. 嵌套类（Nested Class）与内部类相比，嵌套类没有对外部类的隐式引用。 123456class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = 2 &#125;&#125; 7. 对象声明（Object Declaration）Kotlin 支持对象声明，这是实现单例模式的一种方式。对象声明的实例自动成为一个单例。 12345object DataProviderManager &#123; fun registerDataProvider(provider: String) &#123; println(&quot;Provider registered: $provider&quot;) &#125;&#125; 8. 伴生对象（Companion Object）在 Kotlin 中，没有静态方法，但可以用伴生对象来模拟静态方法的效果。伴生对象的成员可以通过类名直接访问。 12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125; 9. 接口（Interface）虽然不是类，但接口在 Kotlin 中用于定义可以由类实现或继承的协定。 12345interface Drivable &#123; fun drive() &#123; println(&quot;Driving&quot;) &#125;&#125; 这些类类型展示了 Kotlin 语言的灵活性和现代特性，旨在提供简洁而强大的语法来支持各种编程范式和设计模式。 密封类在 Kotlin 中，密封类（sealed class）是一种特殊的类，它用于表示严格的类层次结构。使用密封类，你可以定义一个类的可能的子类集合，而且这些子类只能在与密封类相同的文件中定义。这种限制确保了除文件内定义的子类之外，无法有其他子类存在，从而使得使用时更加安全和维护更加方便。 密封类的主要特点和优势： 受限的继承： 密封类本身是抽象的，不能直接实例化，只能通过其子类进行实例化。 所有的子类必须与密封类在同一个文件中声明，这提高了可维护性，因为所有扩展都在一个集中的位置。 类型安全： 密封类非常适合用在 when 表达式中，因为它们可以确保覆盖所有可能的情况，不需要再添加一个 else 子句。这是因为编译器能够检测到所有定义的子类。 更精确的控制： 使用密封类可以精确控制类的继承结构，这对于构建不可变数据类型和状态管理非常有用。 密封类的用法示例：首先，定义一个密封类，然后在同一个文件中定义其所有子类： 1234567891011sealed class Expr &#123; data class Const(val number: Double) : Expr() data class Sum(val e1: Expr, val e2: Expr) : Expr() object NotANumber : Expr()&#125;fun eval(expr: Expr): Double = when (expr) &#123; is Expr.Const -&gt; expr.number is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2) Expr.NotANumber -&gt; Double.NaN&#125; 在这个例子中，Expr 是一个密封类，有三个子类：Const、Sum 和 NotANumber。这使得 eval 函数可以安全地使用 when 表达式来处理所有可能的 Expr 类型，而不需要 else 分支，因为编译器知道所有可能的子类。 使用密封类的场景： 状态管理：在应用程序状态管理或者在处理有限状态机（FSM）时，密封类提供了一种清晰的方式来表示所有可能的状态。 返回类型的多样性：在函数需要返回多种类型的结果时，可以使用密封类来封装这些不同类型的返回值。 在模式匹配中增强类型安全：如上面示例中的 eval 函数，使用密封类可以确保 when 表达式已经处理了所有可能的情况，这在处理复杂的逻辑分支时非常有帮助。 通过这种方式，Kotlin 的密封类增加了代码的安全性和清晰度，特别是在需要表达一个有限的类层次结构时。 内联类Kotlin 1.3 引入了内联类，主要目的是提供一种无开销的抽象方式。内联类允许你创建一个包含单个属性的类，当这个类被使用时，它会在编译时被内联，即直接替换为它包含的那个值，从而避免了额外的内存分配和间接访问。 内联类的定义和使用内联类定义时需要使用 inline 关键字，且必须有一个主构造函数，该构造函数恰好接收一个参数： 1inline class Password(val value: String) 这里的 Password 类包裹了一个字符串，但在编译后，Kotlin 编译器会尽可能将 Password 类的实例替换为简单的 String 类型，从而减少对象创建的开销。当你在代码中使用 Password 类型时，例如将它作为函数参数或从函数中返回时，实际上传递的将是一个 String 类型。 内联类的特点和优势 性能优化：内联类主要用于性能优化，可以避免对象分配，并减少方法调用的层次。 类型安全：虽然内联类在运行时表现为它们包装的类型（例如 String 或 Int），但在编译时，它们是不同的类型。这意味着你可以用它们来实现类型安全的操作，例如防止将普通字符串与经过验证的密码字符串混淆。 限制：内联类不能有初始化块 (init 块)，它们也不能包含其他属性或构造函数。此外，内联类可以实现接口，但不能从其他类继承。 示例代码12345678910inline class Password(val value: String)fun takePassword(password: Password) &#123; println(&quot;Password is $&#123;password.value&#125;&quot;)&#125;fun main() &#123; val password = Password(&quot;my_secret_password&quot;) takePassword(password) // 在这里，password 被内联，实际传递的是一个 String 对象&#125; 在这个例子中，尽管我们定义了一个名为 Password 的内联类，并在函数 takePassword 中使用它，实际上，在编译后，这些函数调用会直接使用 String 类型，而不会有任何包装和解包的性能开销。 结论内联类是 Kotlin 提供的一种非常有用的特性，特别适合那些需要通过类型来提供更丰富语义但又不想引入运行时开销的场景。通过内联类，Kotlin 开发者可以在享受类型安全的同时，保持代码的高性能。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"synchronized 关键字为什么会引入锁的竞争","slug":"2 Java/多线程/synchronized 关键字为什么会引入锁的竞争","date":"2023-08-10T23:17:50.000Z","updated":"2023-08-10T23:17:50.000Z","comments":true,"path":"2023/08/11/2 Java/多线程/synchronized 关键字为什么会引入锁的竞争/","link":"","permalink":"http://example.com/2023/08/11/2%20Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/","excerpt":"","text":"正文synchronized 关键字用于实现线程同步，它可以保证在同一时间只有一个线程能够执行被 synchronized 修饰的代码块或方法。当一个线程获取了对象的锁，其他线程需要等待该线程释放锁才能继续执行。 当多个线程同时竞争同一个锁时，就会发生锁的竞争。这种竞争会导致多个线程按顺序排队等待锁的释放，从而引入性能问题。具体来说，锁的竞争可能导致以下情况： 线程争用：多个线程同时竞争同一个锁，会导致线程进行上下文切换，从而增加了线程切换的开销。 阻塞等待：当一个线程获取了锁，其他线程需要等待，直到该线程释放锁。这会导致其他线程阻塞，降低了并发性能。 锁饥饿：如果某个线程频繁地获取锁，其他线程无法获得执行的机会，会导致其他线程长时间等待锁，造成锁饥饿的情况。 因此，当多个线程同时竞争同一个锁时，就会引入锁的竞争问题，进而影响程序的性能。在高并发场景中，合理设计并发控制机制，避免不必要的锁竞争，可以提高程序的并发性能。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 多线程","slug":"2-Java/2-0-Java-多线程","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"java.util.Stack 类为什么是线程安全的","slug":"2 Java/Java程序基础/java.util.Stack 类为什么是线程安全的_2023_05_28 周日- 5_24_39.15","date":"2023-08-10T23:17:24.000Z","updated":"2023-08-10T23:17:24.000Z","comments":true,"path":"2023/08/11/2 Java/Java程序基础/java.util.Stack 类为什么是线程安全的_2023_05_28 周日- 5_24_39.15/","link":"","permalink":"http://example.com/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/","excerpt":"","text":"正文在Java中，java.util.Stack 类是线程安全的，这是因为它是通过在每个方法上添加synchronized关键字来实现同步的。synchronized关键字可以确保在同一时间只有一个线程可以访问被标记为synchronized的方法或代码块。当一个线程执行一个被synchronized关键字修饰的方法时，它将获得一个锁，其他线程必须等待该锁释放才能访问相同的方法。这样可以确保在任何给定的时刻只有一个线程可以修改Stack的状态，从而防止并发访问导致的数据不一致或竞态条件。然而，需要注意的是，虽然Stack类本身是线程安全的，但在某些情况下，使用synchronized关键字可能会降低性能，特别是在高并发环境下。因此，在Java中，推荐使用java.util.concurrent包提供的并发集合类，如java.util.concurrent.ArrayDeque或java.util.concurrent.LinkedBlockingDeque，它们提供了更高效和灵活的线程安全操作。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java Stack 过时了吗","slug":"2 Java/Java程序基础/Java Stack 过时了吗","date":"2023-08-10T23:17:20.000Z","updated":"2023-08-10T23:17:20.000Z","comments":true,"path":"2023/08/11/2 Java/Java程序基础/Java Stack 过时了吗/","link":"","permalink":"http://example.com/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/","excerpt":"","text":"正文在 Java 中，Stack 类并没有过时，仍然可以使用。然而，根据 Java 官方文档的建议，推荐使用 Deque 接口的实现类 ArrayDeque 来代替 Stack。 Stack 类是基于向量（Vector）实现的，而 Vector 是线程安全的、同步的，因此在性能上可能会有一些开销。而 ArrayDeque 是基于数组实现的双端队列，性能更高，并且在大多数情况下能够提供与 Stack 类相同的功能。 此外，Deque 接口提供了更丰富的操作方法，例如在队首或队尾插入、删除元素等，使得其更灵活且更符合现代编程的需求。 因此，尽管 Stack 类仍然可用，但在新的代码中，推荐使用 ArrayDeque 或其他实现了 Deque 接口的类来代替 Stack。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略","slug":"2 Java/Java程序基础/ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略_2023_05_28 周日- 5_24_39.07","date":"2023-08-10T23:17:16.000Z","updated":"2023-08-10T23:17:16.000Z","comments":true,"path":"2023/08/11/2 Java/Java程序基础/ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略_2023_05_28 周日- 5_24_39.07/","link":"","permalink":"http://example.com/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/","excerpt":"","text":"ArrayDeque 和 java.util.Stack 和 MutableList 的区别是什么ArrayDeque、java.util.Stack 和 MutableList（如 ArrayList）是实现栈的不同方式，它们有一些区别： 实现接口：ArrayDeque 实现了 Deque 接口，而 java.util.Stack 继承自 Vector 类，MutableList 则是 Kotlin 标准库中的可变列表接口。 内部数据结构：ArrayDeque 使用循环数组（circular array）作为内部数据结构，而 java.util.Stack 内部使用数组（Array），MutableList 则可以使用数组、链表或其他数据结构。 动态扩容：ArrayDeque 和 MutableList 都支持动态扩容，可以根据需要自动调整容量，而 java.util.Stack 不支持动态扩容，需要手动调整容量。 性能：ArrayDeque 在大多数操作上具有更好的性能，因为它使用了循环数组和更优化的实现。而 java.util.Stack 是一个遗留类，性能可能相对较差。MutableList 的性能取决于具体实现。 综上所述，如果你想要使用性能较好且功能丰富的栈实现，推荐使用 ArrayDeque。如果你需要与现有的代码兼容或使用特定的接口，可以选择 java.util.Stack 或 MutableList。 ArrayDeque 怎么用循环数组实现的ArrayDeque 使用循环数组（circular array）实现，它在内部维护了一个固定大小的数组来存储元素。下面是简单介绍 ArrayDeque 如何使用循环数组实现的一些关键点： 内部数组：ArrayDeque 内部有一个对象数组来存储元素，通常使用 elements 或 array 字段表示。 头部和尾部指针：ArrayDeque 有两个指针，分别指向头部和尾部。通常使用 head 和 tail 字段表示。 循环数组特性：ArrayDeque 的关键之处在于利用循环数组的性质。当头部或尾部指针到达数组的边界时，它们会回绕到数组的另一侧，形成循环效果。 扩容和缩容：当元素数量达到数组容量时，ArrayDeque 会自动扩容。在扩容时，会创建一个更大的数组，并将原始数组中的元素按照循环顺序复制到新数组中。类似地，当元素数量较少时，ArrayDeque 也会自动缩容。 添加和移除元素：添加元素时，头部指针向前移动一个位置，并将元素放入头部位置。移除元素时，头部指针向后移动一个位置，并返回头部位置的元素。 通过这种方式，ArrayDeque 可以在不断添加和移除元素的过程中高效地利用数组空间，并保持循环数组的特性。这使得 ArrayDeque 在栈和队列等数据结构的实现中具有较高的性能和灵活性。 ArrayList 和 ArrayDeque 的区别两种实现之间的主要区别在于调整大小的策略。 ArrayList 的调整大小策略是将其调整为 oldCapacity + (oldCapacity &gt;&gt; 1) 的新大小，增加了约 50%。默认容量为 10，在调整大小后的容量为 15、22、33、49、73、109、163、244、366… ArrayDeque 总是调整为 2 的幂次方。在调整大小时，容量会加倍。从默认值 16 开始，调整大小后的容量为 32、64、128、256… 因此，ArrayDeque 达到了更高的容量，而调整大小的操作更少，这是因为数组的复制操作很耗费资源。例如，要在默认大小的 ArrayList 中存储 256，需要进行 9 次调整大小操作，而 ArrayDeque 只需要 4 次。数组的复制操作可能很快，但也可能需要 GC 来释放一些空间用于新的数据集，此外还需要进行内存复制操作（ArrayDeque 可能在这方面表现更好，因为它对齐到 2 的幂次方）。 这两种数据结构的最佳情况复杂度为 O(1)。ArrayList 的 push 和 pop 操作通过直接访问头部和尾部（ArrayDeque）来实现，而 add 和 removeLast 操作（ArrayList）则是通过直接访问大小来实现。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ArrayDeque 的接口","slug":"2 Java/Java程序基础/ArrayDeque 的接口","date":"2023-08-10T23:17:10.000Z","updated":"2023-08-10T23:17:10.000Z","comments":true,"path":"2023/08/11/2 Java/Java程序基础/ArrayDeque 的接口/","link":"","permalink":"http://example.com/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"正文ArrayDeque 实现了 Deque 接口，该接口继承自 Queue 接口。下面是 Deque 接口中定义的一些主要方法： 添加元素操作： addFirst(element: E)：将元素添加到双端队列的开头。 addLast(element: E)：将元素添加到双端队列的末尾。 offerFirst(element: E)：将元素添加到双端队列的开头，并返回是否成功。 offerLast(element: E)：将元素添加到双端队列的末尾，并返回是否成功。 获取元素操作： getFirst(): E：获取双端队列的第一个元素，但不删除它。 getLast(): E：获取双端队列的最后一个元素，但不删除它。 peekFirst(): E：获取双端队列的第一个元素，如果队列为空则返回 null。 peekLast(): E：获取双端队列的最后一个元素，如果队列为空则返回 null。 移除元素操作： removeFirst(): E：移除并返回双端队列的第一个元素。 removeLast(): E：移除并返回双端队列的最后一个元素。 pollFirst(): E：移除并返回双端队列的第一个元素，如果队列为空则返回 null。 pollLast(): E：移除并返回双端队列的最后一个元素，如果队列为空则返回 null。 此外，ArrayDeque 还实现了 Queue 接口中定义的方法，如 offer(element: E)、remove(): E、poll(): E 等。 需要注意的是，ArrayDeque 是一个可变大小的数组双端队列，可以在队列的两端进行高效的插入和删除操作，同时也支持随机访问。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"6. N 字形变换","slug":"0 算法/02 算法题目/6 N 字形变换","date":"2023-08-10T23:16:30.000Z","updated":"2025-02-27T14:48:11.015Z","comments":true,"path":"2023/08/11/0 算法/02 算法题目/6 N 字形变换/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"","text":"题目将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1： 12输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot; 示例 2： 1234567输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P I NA L S I GY A H RP I 示例 3： 12输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由英文字母（小写和大写）、&#39;,&#39; 和 &#39;.&#39; 组成 1 &lt;= numRows &lt;= 1000 简介1234重点不在字形，重点在变换是什么变换关键词：一维函数变二维函数往复变化函数 正文我们思考，为什么这个算法难写分析 N字形 的离散函数，我们面临着一个唯一的 x 对应着 1- N 个 y在 x 变化的时候，我们首先要算该 x 对应了几个 y这根本不符合函数的定义函数是指一个集合中的每个元素都有且仅有一个映射到另一个集合中的元素，这种关系被称为函数映射 推出我们需要把一个一维度线性离线函数 s &#x3D; f(n) 变成二维离散函数 s &#x3D; g(x, y)注意，这里好玩的是 y 和 x 其实是数列即 s &#x3D; g(x(n), y(n))我们开始推导 123456789101112x(n) = x(n-1) + 1函数 x(n) 很简单，我们怎么表达 y(n) 呢我们发现 y(n) 是一个往复的等差数列对于本题有y(n) = y(n - 1) + step(n)step 是一个往复函数用 flag 代表往复函数的方向 | -1 当 y(n - 1) 到达最大值或者最小值时flag = | 1 其他step(n) = flag * step(n-1) 当 y(n - 1) 到达最大值或者最小值时 | -step(n-1) 其他step(n) = | step(n) 1234567891011121314151617class Solution &#123; fun convert(s: String, numRows: Int): String &#123; 推出 (numRows &lt; 2) return s val rows: MutableList&lt;StringBuilder&gt; = ArrayList() for (i in 0 until numRows) rows.add(StringBuilder()) var i = 0 var step = -1 for (c in s.toCharArray()) &#123; rows[i].append(c) if (i == 0 || i == numRows - 1) step = -step i += step &#125; val res = StringBuilder() for (row in rows) res.append(row) return res.toString() &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.1 - 中等","slug":"0-算法/0-2-算法题目/0-2-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-1-%E4%B8%AD%E7%AD%89/"}],"tags":[]},{"title":"5. 最长回文子串","slug":"0 算法/02 算法题目/5 最长回文子串","date":"2023-08-10T23:16:26.000Z","updated":"2025-02-27T14:48:05.278Z","comments":true,"path":"2023/08/11/0 算法/02 算法题目/5 最长回文子串/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 简介12345介绍 Manacher 算法理解回文串的对称性，减少与回文串相交的字符串的计算量关键词情况一：完全包含，直接赋值情况二：部分相交。直接从后一位接续计算 正文数据预处理： 首先回文子串有两种形式 奇数 与 偶数 也就有两种对应的指针操作方式 假定有字符数组 ababaabc 改成 # a # b # a # b # a # a # b # c # 将偶数数组变成奇数统一处理 索性改成 ^ # a # b # a # b # a # a # b # c # $，头尾清晰这样就可以通过把每个字符作为回文子串的中心向两边扩展，找出最长回文子串 时间复杂度是 O(n^2) 现在需要我们观察回文子串的规律，简化计算 123456789101112131415161718192021 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ^ # a # b # a # b # a # a # b # c # $0 ^ P[0] = 01 ^ P[1] = 02 --^-- p[2] = 13 ^ P[3] = 04 ------^------ P[4] = 35 ^ P[5] = 06 ----------^---------- P[6] = 57 ^ P[7] = 08 ------^------ P[8] = 39 ^ P[9] = 010 --^-- P[10] = 111 --------^-------- P[11] = 212 --^-- P[12] = 013 ^ P[13] = 014 --^-- P[14] = 115 ^ P[15] = 016 --^-- P[16] = 117 ^ P[17] = 018 ^ P[18] = 0 情况一： 12310 --^-- P[10] = 111 --------^-------- P[11] = 212 --^-- P[12] = 0 第 10 行，第 12 行 都是 第 11 行 的子串，完全包含在 第 11 行 之中，由于回文串的对称性 此时直接有 P[10] &#x3D; P[12] 情况二： 1234 ------^------ P[4] = 36 ----------^---------- P[6] = 58 ------^------ P[8] = 3 第 4 行，第 8 行 都是 第 6 行 的子串，分别位于字符串的两端，当我们知道 第 4 行 的信息之后，我们知道 第 8 行 至少有 第 4 行 那么长，至于会不会更长，继续试着向两边扩展即可 此时需要干两件事 1. 将 P[8] &#x3D; P[4]; 2. 继续向外扩展 情况三： 8 ——^—— P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 第 8 行 部分与 第 11 行 重叠，第 14 行 是 第 11 行 的子串，非常简单，舍弃超出部分 8 –^– P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 当成这样处理即可 定义遍历指针 i ，指向回文的中心的指针 center 和 指向回文串右边界的指针 r 此时需要干两件事 1. 将 P[8] &#x3D; r - i ; 2. 继续向外扩展 好，我们现在已经理解了 Manacher 算法的精髓了 我们思考一下算法该怎么写 P[i] 计算过程 123456789101112131415161718192021 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ^ # a # b # a # b # a # a # b # c # $0 ^ P[0] = 0 -- 起始，不必计算，更新 r1 ^ P[1] = 0 -- 暴力计算，一次计算，更新 r2 --^-- p[2] = 1 -- 暴力计算，二次计算，更新 r3 ^ P[3] = 0 -- 情况二，一次计算4 ------^------ P[4] = 3 -- 暴力计算，四次计算，更新 r5 ^ P[5] = 0 -- 情况一，零次计算6 ----------^---------- P[6] = 5 -- 情况二，六次计算，更新 r7 ^ P[7] = 0 -- 情况一，零次计算8 ------^------ P[8] = 3 -- 情况二，一次计算9 ^ P[9] = 0 -- 情况一，零次计算10 --^-- P[10] = 1 -- 情况二，一次计算11 --------^-------- P[11] = 2 -- 情况二，五次计算，更新 r12 --^-- P[12] = 0 -- 情况一，零次计算13 ^ P[13] = 0 -- 情况一，零次计算14 --^-- P[14] = 1 -- 情况三，一次计算15 ^ P[15] = 0 -- 情况二，一次计算16 --^-- P[16] = 1 -- 暴力计算，两次计算，更新 r17 ^ P[17] = 0 -- 情况二，一次计算18 ^ P[18] = 0 -- 终止 我列出了每次计算面对的情况，计算的次数以及是否需要 r 我希望大家思考 当新计算出的 r 与旧的 r 相等时，是否应该更新 center ？ 当然不应该，我们肯定更倾向于选择更长的回文串 是这样吗？ 我们思考一种情况 1234567892 --^-- p[2] = 13 ^ P[3] = 04 ------^------ P[4] = 35 ^ P[5] = 06 ----------^---------- P[6] = 57 ^ P[7] = 08 ------^------ P[8] = 39 ^ P[9] = 010 --^-- P[10] = 1 第 6 行 较长有什么用呢，有用的只是 i 到 r 这一小截而已，不更新是因为都一样，没必要更新，所以只有当我们发现了更右边的 r 更新即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; private fun formatString(s: String): String&#123; val tString : StringBuffer = StringBuffer(&quot;^#&quot;) for ( i in s.indices )&#123; tString.append(s[i]) tString.append(&#x27;#&#x27;) &#125; return tString.append(&#x27;$&#x27;).toString() &#125; private fun extend(s: String, leftIndex: Int, rightIndex: Int): Int &#123; var r = 0 var left = leftIndex var right = rightIndex while (left &gt; 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] == s[right])&#123; r ++ left -- right ++ &#125; return r &#125; fun longestPalindrome(s: String): String &#123; val tString = formatString(s) var maxR = 0 var maxCenter = 0 var center = -1 var R = 0 val p = Array&lt;Int&gt;(tString.length) &#123; 0 &#125; for ( i in tString.indices )&#123; val iMirror = center - (i - center) var rightIndex = i var leftIndex = i val maxLength = R - i val hasMirrorIndex = i &lt; R &amp;&amp; center - maxLength &gt; 0 val case1CompletelyIncluded = hasMirrorIndex &amp;&amp; i &gt; center &amp;&amp; p[iMirror] &lt; R - i val case2NotCompletelyInclude = hasMirrorIndex &amp;&amp; !case1CompletelyIncluded if(!hasMirrorIndex)&#123; p[i] = 0 rightIndex = i + 1 leftIndex = i - 1 &#125; else &#123; if(case1CompletelyIncluded) &#123; p[i] = p[iMirror] continue &#125; else if (case2NotCompletelyInclude) &#123; p[i] = maxLength rightIndex = R + 1 leftIndex = i - (rightIndex - i) &#125; &#125; p[i] += extend(tString, leftIndex, rightIndex) // 更新最右边的 R 和 center if(i + p[i] &gt; R)&#123; R = i + p[i] center = i &#125; // 判断是不是最长的回文串 if(p[i] &gt; maxR)&#123; maxR = p[i] maxCenter = i &#125; &#125; if(maxR == 0) return &quot;&quot; val start = maxCenter - maxR val end = maxCenter + maxR return tString.substring(start..end).replace(&quot;#&quot;, &quot;&quot;) &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.1 - 中等","slug":"0-算法/0-2-算法题目/0-2-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-1-%E4%B8%AD%E7%AD%89/"}],"tags":[]},{"title":"4. 寻找两个正序数组的中位数","slug":"0 算法/02 算法题目/4 寻找两个正序数组的中位数","date":"2023-08-10T23:16:24.000Z","updated":"2025-02-27T14:47:35.536Z","comments":true,"path":"2023/08/11/0 算法/02 算法题目/4 寻找两个正序数组的中位数/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"题目给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 123输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 123输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6 简介123456789101112讨论在两个有序数组中寻找中位数的问题观察单个有序数组，通过比较元素大小找到舍弃的元素，确定中位数。类推两个有序数组，准备两个区间来存放偏小值和偏大值。根据区间需要满足必要条件，使得偏小区间的元素都小于偏大区间。问题转化为在单个有序数组中查找满足条件的关键元素位置，可以使用二分查找。关键词:偏小区间偏大区间二分查找 正文首先思考我们是否可以避免全排序找到中位数 我们有一种想法就是通过比较元素的大小找到需要舍弃的元素 我们观察一个有序数组，我们准备两个区间 RSmall, RBig 分别存放这个数组的偏小值与偏大值（相对中位数而言） 分别用 left，right 指针从两头操作偏小值与偏大值，将他们依次放入对应的数组 直到 「偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1」，中位数显然易得 好，现在我们来看两个有序数组的复杂情况 我们同样准备两个区间 RSmall, RBig，同样我们需要将数组偏小值放进 RSmall，偏大值放进 RBig 与一个有序数组不同的是，现在我们必须综合考虑两个有序数组的情况 所以 RSmall 区间里可能既包含 num1 数组的偏小元素也包含 num2 数组的偏小元素，对于RBig也是一样 这就让我们的思考变得复杂了，这使得 RSmall，RBig 变得无序 现在将这个 RSmall 再细分为 RSmallN1 区间，以及 RSmallN2 区间，同样有 RBigN1，RBigN2 区间 想要得到中位数，那么偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1 也就有 「 必要条件一： 偶数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size 奇数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size +1 」 同时 RSmall 区间内任何一个元素都必须小于 RBig 区间 自然有 Small 区间的子区间的任何一个元素都小于 Big 区间的子区间的任何一个元素 所以得到 「 必要条件二： RSmallN1 的最大值 &lt; RBigN1 的最小值 ( 因为数组有序，这是不用判断的 ) RSmallN1 的最大值 &lt; RBigN2 的最小值 RSmallN2 的最大值 &lt; RBigN1 的最小值 RSmallN2 的最大值 &lt; RBigN2 的最小值 ( 因为数组有序，这是不用判断的 )」 简化一下 「 必要条件二： maxOf( RSmallN1 ) &lt; minOf ( RBigN2 ) maxOf( RSmallN2 ) &lt; minOf ( RBigN1 ) 」 显然必要条件一加上必要条件二就是充分必要条件 现在我们要得到这四个区间，或者说要在两个有序数组分别划分出这四个区间 我们要在这两个数组中分别找到关键的那个分隔元素 因为必要条件一的原因，我们找到了 num1 数组的分割元素，我们也就找到了 num2 数组的分割元素 这非常好理解，因为 Small 区间和 Big 区间的数量是固定的，RSmallN1 多了一个元素，RSmallN2 就要对应减少一个元素 所以我们只要找到 num1 数组的分隔元素即可 至此，问题成功转化成了 在 num1 数组中查找出一个关键元素位置，这个关键元素满足上述两条必要条件 这是一个典型的有判断条件的查找问题，我们就可以使用二分查找，测试每个元素是否符合上述两个条件 关于二分查找这里不再赘述。 以下是基于二分查找的 Kotlin 代码实现，用于找出两个有序数组的中位数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 该函数用于在两个已排序整数数组中找到它们的中位数，返回类型为 Double。fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123; // 获取 nums1 和 nums2 的长度。 val n1 = nums1.size val n2 = nums2.size // 如果 nums1 的长度大于 nums2，则交换它们，确保 nums1 的长度小于等于 nums2。 if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1) &#125; // 设置左右指针的初始值。 var left = 0 // 如果把 num1 和 num2 合并元素重新排序，最左边 var right = n1 // 如果把 num1 和 num2 合并元素重新排序，相当于 num2 最左边 // 当左指针小于等于右指针时，执行二分查找。 while (left &lt;= right) &#123; // 因为 n1 &lt; n2 // 计算 nums1 中间的索引 i 和 nums2 中间的索引 j。 val num1HalfIndex = (left + right) / 2 val num2HalfIndex = ((n1 + n2 + 1) / 2) - num1HalfIndex // 计算 nums1 和 nums2 的左侧和右侧的最大值和最小值。 val maxOfNum1SmallRange = if (num1HalfIndex == 0) Int.MIN_VALUE else nums1[num1HalfIndex - 1] // nums1 小区间的最大值 val minOfNum1BigRange = if (num1HalfIndex == n1) Int.MAX_VALUE else nums1[num1HalfIndex] // nums1 大区间的最小值 val maxOfNum2SmallRange = if (j == 0) Int.MIN_VALUE else nums2[j - 1] // nums2 小区间的最大值 val minOfNum2BigRange = if (j == n2) Int.MAX_VALUE else nums2[j] // nums2 大区间的最小值 // 如果满足条件，则返回中位数。 if (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; // num1小 &lt; num2大 &amp;&amp; num2小 &lt; num1大, 也就是说“小区间都小于大区间” return if ((n1 + n2) % 2 == 0) &#123; // 如果 nums1 和 nums2 的长度之和为偶数 // 则返回左右两侧最大值和最小值的平均值。 (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / 2.0 &#125; else &#123; // 如果 nums1 和 nums2 的长度之和为奇数，则返回左侧最大值。 maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() &#125; &#125; else if (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; // num1大 &lt; num2小 // 如果 nums1 的左侧最大值大于 nums2 的右侧最小值，则需要将 num1HalfIndex 向左移动。 /* left num1HalfIndex right | | | 1 1 1 1 1 1 1 1 1 1 1 1 E 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ right = num1HalfIndex - 1 /* num1HalfIndex left | right | | | 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ &#125; else &#123; // 如果 nums2 的左侧最大值大于 nums1 的右侧最小值，则需要将 num1HalfIndex 向右移动。 /* left num1HalfIndex right | | | 1 1 1 1 1 1 1 1 1 1 1 1 E 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ left = num1HalfIndex + 1 /* 留给大家画 */ &#125; &#125; // 如果找不到中位数，则返回 0.0。 return 0.0&#125; 1234567891011121314151617181920212223242526272829fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123; val n1 = nums1.size val n2 = nums2.size if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1) &#125; var left = 0 var right = n1 while (left &lt;= right) &#123; // 因为 n1 &lt; n2 val num1HalfIndex = (left + right) / 2 val num2HalfIndex = ((n1 + n2 + 1) / 2) - num1HalfIndex val maxOfNum1SmallRange = if (num1HalfIndex == 0) Int.MIN_VALUE else nums1[num1HalfIndex - 1] val minOfNum1BigRange = if (num1HalfIndex == n1) Int.MAX_VALUE else nums1[num1HalfIndex] val maxOfNum2SmallRange = if (j == 0) Int.MIN_VALUE else nums2[j - 1] val minOfNum2BigRange = if (j == n2) Int.MAX_VALUE else nums2[j] if (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; return if ((n1 + n2) % 2 == 0) &#123; (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / 2.0 &#125; else &#123; maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() &#125; &#125; else if (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; right = num1HalfIndex - 1 &#125; else &#123; left = num1HalfIndex + 1 &#125; &#125; return 0.0&#125; 留给大家一个问题，问 N 个有序数组的中位数怎么求？","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.2 - 困难","slug":"0-算法/0-2-算法题目/0-2-2-困难","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-2-%E5%9B%B0%E9%9A%BE/"}],"tags":[]},{"title":"3. 无重复字符的最长子串","slug":"0 算法/02 算法题目/3 无重复字符的最长子串","date":"2023-08-10T23:16:20.000Z","updated":"2025-02-27T14:47:40.475Z","comments":true,"path":"2023/08/11/0 算法/02 算法题目/3 无重复字符的最长子串/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 简介12345巧妙的使用 HashMap&lt;Char, Int&gt; 记录每个字符的最新的位置巧妙的确定了每个元素对应的滑动窗口的左边界关键词：HashMap &lt;Char, Int&gt;用以查找位置窗口长度不固定，遍历指针作为左边界 正文本题的巧妙在于使用 HashMap 和 遍历指针构建了一个滑动窗口 在寻找滑动窗口的时候，我们总是固定住一端位置去寻找另一端的位置，通常需要我们找到两个端点之间的关系 来分析滑动窗口的性质：左边届位置，右边界的位置，滑动窗口的长度三者有以下这些关系：滑动窗口的长度 = 滑动窗口右边届 - 滑动窗口左边界无论算法如何变化，我们知二求一 我们分析，遍历指针和左右边界的关系有三情况一：遍历指针是滑动窗口的左边界情况二：遍历指针是滑动窗口的右边界情况三：遍历指针在滑动窗口的中间 结合滑动窗口的性质情况一：知道窗口的长度，以遍历指针为左边界情况二：窗口长度不固定，新增的元素决定窗口的长度，也就是左边界的位置情况三：对于滑动窗口算法，通常情况下遍历指针要么位于窗口的左边界，要么位于右边界，用于控制窗口的扩展和收缩。在常规的滑动窗口算法中，遍历指针并不位于窗口的中间位置。 显然这种是情况二 当滑动窗口的位置和长度变化受制于新增的元素时，我们将遍历指针设置为 12345678910111213141516171819class Solution &#123; fun lengthOfLongestSubstring(s: String): Int &#123; var maxLen = 0 // 最长不含重复字符子串的长度 var left = 0 // 窗口左边界 val map = HashMap&lt;Char, Int&gt;() // 哈希表记录字符最后出现的位置 for(right in s.indices)&#123; val char = s[right] if(map.containsKey(char) &amp;&amp; map[char]!! &gt;= left)&#123; left = (map[char]?: 0) + 1 &#125; map[char] = right maxLen = maxOf(maxLen, right - left + 1) &#125; return maxLen &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.1 - 中等","slug":"0-算法/0-2-算法题目/0-2-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-1-%E4%B8%AD%E7%AD%89/"}],"tags":[]},{"title":"2. 两数相加","slug":"0 算法/02 算法题目/2 两数相加","date":"2023-08-10T23:16:16.000Z","updated":"2025-02-27T14:47:45.434Z","comments":true,"path":"2023/08/11/0 算法/02 算法题目/2 两数相加/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"题目给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 简介1234遍历两个链表，元素相加生成新列表。关键词：哨兵节点 val dummy = ListNode(0)关键返回值 dummy?.next 正文12345678910111213141516171819202122232425262728293031323334class Solution &#123; fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123; // 定义两个指针 p1 和 p2，分别指向两个链表的头节点 var p1 = l1 var p2 = l2 // 定义一个哨兵节点 dummy，作为结果链表的头节点 val dummy = ListNode(0) // 定义一个节点 cur, 作为结果链表的尾节点 var cur = dummy var carry = 0 while(p1 != null || p2 != null)&#123; val x = p1?.`val` ?: 0 val y = p2?.`val` ?: 0 var sum = x + y + carry carry = sum / 10 sum = sum % 10 cur?.next = ListNode(sum) p1 = p1?.next p2 = p2?.next cur = cur?.next &#125; if(carry &gt; 0)&#123; cur?.next = ListNode(carry) &#125; return dummy?.next &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.0 - 简单","slug":"0-算法/0-2-算法题目/0-2-0-简单","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-0-%E7%AE%80%E5%8D%95/"}],"tags":[]},{"title":"1. 两数之和","slug":"0 算法/02 算法题目/1 两数之和","date":"2023-08-10T23:16:10.000Z","updated":"2025-02-27T14:47:53.585Z","comments":true,"path":"2023/08/11/0 算法/02 算法题目/1 两数之和/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/02%20%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10^4 -109 &lt;= nums[i] &lt;= 10^9 -109 &lt;= target &lt;= 10^9 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 简介1234这道题的关键在于对 hashmap 查找时间复杂度 O(1) 的应用关键词：HashMap&lt;Key, Value&gt;hashmap.containsKey(Value) 正文12345678910111213class Solution &#123; fun twoSum(nums: IntArray, target: Int): IntArray &#123; val hashmap = HashMap&lt;Int, Int&gt;() for(i in nums.indices)&#123; val complement = target - nums[i] if(hashmap.containsKey(complement))&#123; return intArrayOf(hashmap[complement]!!, i) &#125; hashmap[nums[i]] = i &#125; return intArrayOf() &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.0 - 简单","slug":"0-算法/0-2-算法题目/0-2-0-简单","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-0-%E7%AE%80%E5%8D%95/"}],"tags":[]},{"title":"23. 构建前缀树（字典树）","slug":"0 算法/01 算法模板/23 构建前缀树（字典树）","date":"2023-08-10T23:15:56.000Z","updated":"2025-02-27T14:47:00.761Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/23 构建前缀树（字典树）/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/23%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89/","excerpt":"","text":"正文1234567891011121314151617181920212223242526272829303132333435363738394041class TrieNode &#123; val children = HashMap&lt;Char, TrieNode&gt;() var isWord = false&#125;class Trie &#123; private val root = TrieNode() fun insert(word: String) &#123; var node = root for (char in word) &#123; if (!node.children.containsKey(char)) &#123; node.children[char] = TrieNode() &#125; node = node.children[char]!! &#125; node.isWord = true &#125; fun search(word: String): Boolean &#123; var node = root for (char in word) &#123; if (!node.children.containsKey(char)) &#123; return false &#125; node = node.children[char]!! &#125; return node.isWord &#125; fun startsWith(prefix: String): Boolean &#123; var node = root for (char in prefix) &#123; if (!node.children.containsKey(char)) &#123; return false &#125; node = node.children[char]!! &#125; return true &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"22. 动态规划-自顶向下法","slug":"0 算法/01 算法模板/22 动态规划-自顶向下法","date":"2023-08-10T23:15:54.000Z","updated":"2025-02-27T14:46:55.954Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/22 动态规划-自顶向下法/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/22%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B3%95/","excerpt":"","text":"正文12345678910111213141516fun dp(n: Int, memo: IntArray): Int &#123; // 检查是否已经计算过该值 if (memo[n] != -1) &#123; return memo[n] &#125; // 边界条件 if (n == 0 || n == 1) &#123; memo[n] = n return n &#125; // 递归计算并保存结果 memo[n] = dp(n - 1, memo) + dp(n - 2, memo) return memo[n]&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"21. 回溯","slug":"0 算法/01 算法模板/21 回溯","date":"2023-08-10T23:15:50.000Z","updated":"2025-02-27T14:46:51.207Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/21 回溯/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/21%20%E5%9B%9E%E6%BA%AF/","excerpt":"","text":"正文1234567891011121314151617181920fun backtrack(...) &#123; // 检查是否达到结束条件 if (满足结束条件) &#123; // 处理结果 处理结果 return &#125; // 遍历所有可能的选择 for (选择 in 可选列表) &#123; // 做选择 做选择 // 进入下一层决策树 backtrack(...) // 撤销选择 撤销选择 &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"20. 二分查找-贪心问题","slug":"0 算法/01 算法模板/20 二分查找-贪心问题","date":"2023-08-10T23:15:48.000Z","updated":"2025-02-27T14:46:45.897Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/20 二分查找-贪心问题/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"正文12345678910111213141516fun binarySearch(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 when &#123; nums[mid] == target -&gt; return mid nums[mid] &lt; target -&gt; left = mid + 1 else -&gt; right = mid - 1 &#125; &#125; return -1&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"19. 二分查找-重复元素，最右边的插入点","slug":"0 算法/01 算法模板/19 二分查找-重复元素，最右边的插入点","date":"2023-08-10T23:15:44.000Z","updated":"2025-02-27T14:46:38.739Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/19 二分查找-重复元素，最右边的插入点/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/19%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/","excerpt":"","text":"正文123456789101112131415161718192021fun searchInsert(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 var result = nums.size // 默认插入到最右边 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 if (nums[mid] &lt;= target) &#123; if (nums[mid] == target) &#123; // 找到目标元素，更新结果为当前索引 result = mid &#125; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; &#125; return result&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"18. 二分查找-重复元素，最左边的插入点","slug":"0 算法/01 算法模板/18 二分查找-重复元素，最左边的插入点","date":"2023-08-10T23:15:40.000Z","updated":"2025-02-27T14:46:32.579Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/18 二分查找-重复元素，最左边的插入点/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/18%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/","excerpt":"","text":"正文12345678910111213141516171819202122fun searchInsert(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 if (nums[mid] == target) &#123; // 找到了目标元素，返回索引 return mid &#125; else if (nums[mid] &lt; target) &#123; // 目标元素在右半部分，更新左边界 left = mid + 1 &#125; else &#123; // 目标元素在左半部分，更新右边界 right = mid - 1 &#125; &#125; // 目标元素不存在，返回插入位置 return left&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"17. 二分查找","slug":"0 算法/01 算法模板/17 二分查找","date":"2023-08-10T23:15:38.000Z","updated":"2025-02-27T14:46:28.050Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/17 二分查找/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/17%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"正文123456789101112131415161718fun binarySearch(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 if (nums[mid] == target) &#123; return mid &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; &#125; return -1&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"16. 找到堆的前 k 个元素","slug":"0 算法/01 算法模板/16 找到堆的前 k 个元素","date":"2023-08-10T23:15:34.000Z","updated":"2025-02-27T14:46:21.251Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/16 找到堆的前 k 个元素/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/16%20%E6%89%BE%E5%88%B0%E5%A0%86%E7%9A%84%E5%89%8D%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"正文1234567891011121314151617fun findKthLargest(nums: IntArray, k: Int): Int &#123; // 创建最小堆 val minHeap = PriorityQueue&lt;Int&gt;() // 将数组中的元素依次加入最小堆 for (num in nums) &#123; minHeap.offer(num) // 如果最小堆的大小超过 k，移除堆顶元素 if (minHeap.size &gt; k) &#123; minHeap.poll() &#125; &#125; // 返回堆顶元素，即第 k 大的元素 return minHeap.peek()&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"15. 图-BFS","slug":"0 算法/01 算法模板/15 图-BFS","date":"2023-08-10T23:15:32.000Z","updated":"2025-02-27T14:46:16.579Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/15 图-BFS/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/15%20%E5%9B%BE-BFS/","excerpt":"","text":"正文12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*class Graph &#123; private val adjacencyList: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = HashMap() fun addEdge(src: Int, dest: Int) &#123; adjacencyList.computeIfAbsent(src) &#123; mutableListOf() &#125;.add(dest) adjacencyList.computeIfAbsent(dest) &#123; mutableListOf() &#125; &#125; fun bfs(startVertex: Int) &#123; val visited = BooleanArray(adjacencyList.size) val queue: Queue&lt;Int&gt; = LinkedList() visited[startVertex] = true queue.offer(startVertex) while (!queue.isEmpty()) &#123; val currentVertex = queue.poll() print(&quot;$currentVertex &quot;) val neighbors = adjacencyList[currentVertex] if (neighbors != null) &#123; for (neighbor in neighbors) &#123; if (!visited[neighbor]) &#123; visited[neighbor] = true queue.offer(neighbor) &#125; &#125; &#125; &#125; &#125;&#125;fun main() &#123; val graph = Graph() graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 2) graph.addEdge(2, 0) graph.addEdge(2, 3) graph.addEdge(3, 3) println(&quot;BFS traversal starting from vertex 2:&quot;) graph.bfs(2)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"14. 图-DFS (迭代)","slug":"0 算法/01 算法模板/14 图-DFS-(迭代)","date":"2023-08-10T23:15:20.000Z","updated":"2025-02-27T14:46:10.884Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/14 图-DFS-(迭代)/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/14%20%E5%9B%BE-DFS-(%E8%BF%AD%E4%BB%A3)/","excerpt":"","text":"正文123456789101112131415161718192021222324252627282930313233343536373839404142class Graph &#123; private val adjacencyList: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = mutableMapOf() fun addEdge(u: Int, v: Int) &#123; adjacencyList.computeIfAbsent(u) &#123; mutableListOf() &#125;.add(v) &#125; fun dfs(start: Int) &#123; val visited = mutableSetOf&lt;Int&gt;() val stack = mutableListOf&lt;Int&gt;() stack.add(start) while (stack.isNotEmpty()) &#123; val vertex = stack.removeAt(stack.size - 1) if (!visited.contains(vertex)) &#123; visited.add(vertex) println(&quot;Visited vertex: $vertex&quot;) adjacencyList[vertex]?.reversed()?.forEach &#123; neighbor -&gt; if (!visited.contains(neighbor)) &#123; stack.add(neighbor) &#125; &#125; &#125; &#125; &#125;&#125;fun main() &#123; val graph = Graph() // 添加图的边 graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 3) graph.addEdge(1, 4) graph.addEdge(2, 5) graph.addEdge(2, 6) // 从顶点0开始进行DFS graph.dfs(0)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"13. 图-DFS (递归)","slug":"0 算法/01 算法模板/13 图-DFS (递归)","date":"2023-08-10T23:15:18.000Z","updated":"2025-02-27T14:46:06.101Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/13 图-DFS (递归)/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/13%20%E5%9B%BE-DFS%20(%E9%80%92%E5%BD%92)/","excerpt":"","text":"正文123456789101112131415161718192021222324252627282930313233343536373839class Graph &#123; private val adjList: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = mutableMapOf() fun addEdge(u: Int, v: Int) &#123; adjList.getOrPut(u) &#123; mutableListOf() &#125;.add(v) &#125; fun dfs(vertex: Int) &#123; val visited = mutableSetOf&lt;Int&gt;() dfsHelper(vertex, visited) &#125; private fun dfsHelper(vertex: Int, visited: MutableSet&lt;Int&gt;) &#123; visited.add(vertex) println(vertex) // 在这里可以对当前节点进行相关操作 val neighbors = adjList[vertex] if (neighbors != null) &#123; for (neighbor in neighbors) &#123; if (!visited.contains(neighbor)) &#123; dfsHelper(neighbor, visited) &#125; &#125; &#125; &#125;&#125;fun main() &#123; val graph = Graph() // 添加图的边 graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 3) graph.addEdge(2, 4) graph.addEdge(3, 4) // 从节点 0 开始进行深度优先搜索 graph.dfs(0)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"09. 单调递增栈","slug":"0 算法/01 算法模板/09 单调递增栈","date":"2023-08-10T23:15:04.000Z","updated":"2025-02-27T14:45:42.707Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/09 单调递增栈/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/09%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88/","excerpt":"","text":"正文1234567891011121314151617181920fun monotonicStack(nums: IntArray): IntArray &#123; val stack = mutableListOf&lt;Int&gt;() val result = IntArray(nums.size) &#123; -1 &#125; for (i in nums.indices) &#123; while (stack.isNotEmpty() &amp;&amp; stack.last() &lt; nums[i]) &#123; stack.removeAt(stack.size - 1) &#125; // 在这里可以根据题目需求进行处理 // 例如：找到栈中元素的下一个更大元素 if (stack.isNotEmpty()) &#123; result[i] = stack.last() &#125; stack.add(nums[i]) &#125; return result&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"08. 找到符合确切条件的子数组数","slug":"0 算法/01 算法模板/08 找到符合确切条件的子数组数","date":"2023-08-10T23:15:02.000Z","updated":"2025-02-27T14:45:37.512Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/08 找到符合确切条件的子数组数/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/08%20%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E7%A1%AE%E5%88%87%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0/","excerpt":"","text":"正文123456789101112131415161718192021222324252627fun numSubarraysWithSum(nums: IntArray, goal: Int): Int &#123; var count = 0 var total = 0 var left = 0 for (right in nums.indices) &#123; total += nums[right] while (left &lt;= right &amp;&amp; total &gt; goal) &#123; total -= nums[left] left++ &#125; if (total == goal) &#123; count++ // 统计连续的0 var temp = left while (temp &lt;= right &amp;&amp; nums[temp] == 0) &#123; count++ temp++ &#125; &#125; &#125; return count&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"07. 反转链表","slug":"0 算法/01 算法模板/07 反转链表","date":"2023-08-10T23:14:58.000Z","updated":"2025-02-27T14:45:32.747Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/07 反转链表/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/07%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"正文123456789101112131415class ListNode(var value: Int) &#123; var next: ListNode? = null&#125;fun reverseList(head: ListNode?): ListNode? &#123; var prev: ListNode? = null var current = head while (current != null) &#123; val nextNode = current.next current.next = prev prev = current current = nextNode&#125;return prev","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"06. 链表-快慢指针","slug":"0 算法/01 算法模板/06 链表-快慢指针","date":"2023-08-10T23:14:56.000Z","updated":"2025-02-27T14:45:28.076Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/06 链表-快慢指针/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/06%20%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","excerpt":"","text":"正文在模板中，我们使用两个指针，一个指针每次向后移动一个节点，另一个指针每次向后移动两个节点。如果链表中存在循环，快指针最终会追上慢指针，这样我们就可以判断出链表有循环。如果链表没有循环，快指针会先到达链表的末尾，此时我们就可以判断链表没有循环。 123456789101112131415fun hasCycle(head: ListNode?): Boolean &#123; var slow = head var fast = head while (fast?.next != null &amp;&amp; fast.next?.next != null) &#123; slow = slow?.next fast = fast.next?.next if (slow == fast) &#123; return true &#125; &#125; return false&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"05. 高效的字符串构建","slug":"0 算法/01 算法模板/05 高效的字符串构建","date":"2023-08-10T23:14:52.000Z","updated":"2025-02-27T14:45:21.523Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/05 高效的字符串构建/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/05%20%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E5%BB%BA/","excerpt":"","text":"正文以下是一个高效的字符串构建算法模板： 123456789fun buildString(chars: List&lt;Char&gt;): String &#123; val sb = StringBuilder() for (ch in chars) &#123; sb.append(ch) &#125; return sb.toString()&#125; 在这个模板中，我们使用 StringBuilder 来构建字符串。StringBuilder 是可变的字符串类，可以高效地进行字符串的拼接操作。 我们通过遍历字符列表 chars，逐个将字符添加到 StringBuilder 中。最后，通过调用 toString() 方法，将 StringBuilder 转换为最终的字符串结果并返回。 使用 StringBuilder 的好处是它避免了在每次拼接字符串时创建新的字符串对象，从而提高了性能和效率。特别是在需要频繁拼接大量字符串的情况下，使用 StringBuilder 可以避免不必要的性能损耗。 使用这个模板，你可以根据具体需求构建字符串。可以根据问题的要求在遍历过程中进行一些字符处理、条件判断等操作。","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"04. 构建前缀和","slug":"0 算法/01 算法模板/04 构建前缀和","date":"2023-08-10T23:14:48.000Z","updated":"2025-02-27T14:45:16.027Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/04 构建前缀和/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/04%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"正文以下是一个前缀和算法的常见模板： 12345678910fun prefixSum(nums: IntArray): IntArray &#123; val prefixSum = IntArray(nums.size + 1) // 计算前缀和数组 for (i in 1..nums.size) &#123; prefixSum[i] = prefixSum[i - 1] + nums[i - 1] &#125; return prefixSum&#125; 在这个模板中，我们使用一个额外的数组 prefixSum 来存储原始数组 nums 的前缀和。通过遍历原始数组，我们可以计算每个位置的前缀和并存储在 prefixSum 中。 使用前缀和数组 prefixSum，我们可以高效地回答多个查询，例如计算某个区间的和。假设我们需要计算区间 [left, right] 的和，我们可以使用如下方式获取结果： 1val sum = prefixSum[right + 1] - prefixSum[left 这个计算结果即为原始数组中从位置 left 到位置 right 的元素之和。请注意，在模板中，前缀和数组 prefixSum 的长度比原始数组 nums 的长度多了一个元素。这是为了方便计算区间和时的边界情况。","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"03. 滑动窗口","slug":"0 算法/01 算法模板/03 滑动窗口","date":"2023-08-10T23:14:28.000Z","updated":"2025-02-27T14:45:08.570Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/03 滑动窗口/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/03%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"正文12345678910111213141516171819202122fun slidingWindow(nums: IntArray, k: Int): Int &#123; val n = nums.size var sum = 0 var maxSum = 0 // 计算第一个窗口的和 for (i in 0 until k) &#123; sum += nums[i] &#125; maxSum = sum // 滑动窗口 for (i in k until n) &#123; // 新窗口的和等于之前窗口的和加上新进入窗口的元素，减去滑出窗口的元素 sum += nums[i] - nums[i - k] // 更新最大和 maxSum = maxOf(maxSum, sum) &#125; return maxSum&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"02. 双指针-有两个输入, 两个都需要遍历完","slug":"0 算法/01 算法模板/02 双指针-有两个输入, 两个都需要遍历完","date":"2023-08-10T23:14:22.000Z","updated":"2025-02-27T14:45:03.749Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/02 双指针-有两个输入, 两个都需要遍历完/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/02%20%E5%8F%8C%E6%8C%87%E9%92%88-%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%E5%AE%8C/","excerpt":"","text":"正文1234567891011121314151617181920212223242526fun twoPointers(nums1: IntArray, nums2: IntArray) &#123; var pointer1 = 0 var pointer2 = 0 while (pointer1 &lt; nums1.size &amp;&amp; pointer2 &lt; nums2.size) &#123; // 处理指针1和指针2对应位置的元素 // ... // 移动指针 pointer1++ pointer2++ &#125; // 处理剩余未遍历完的元素 while (pointer1 &lt; nums1.size) &#123; // 处理指针1对应位置的元素 // ... pointer1++ &#125; while (pointer2 &lt; nums2.size) &#123; // 处理指针2对应位置的元素 // ... pointer2++ &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"算法进阶心法","slug":"0 算法/00 心法","date":"2023-08-10T23:14:00.000Z","updated":"2025-02-27T13:23:50.042Z","comments":true,"path":"2023/08/11/0 算法/00 心法/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/00%20%E5%BF%83%E6%B3%95/","excerpt":"","text":"算法高手养成体系一、筑基阶段（1-3个月）武器库建设数据结构： ​数组​前缀和、差分数组、双指针技巧（快慢指针&#x2F;对撞指针） ​链表​环形检测（Floyd龟兔算法）、LRU缓存实现 ​树​红黑树旋转规则、B+树在数据库索引的应用 ​图​邻接表与邻接矩阵的存储差异，Dijkstra堆优化版时间复杂度推导 算法范式： ​分治​Karatsuba大数乘法（时间复杂度$O(n^{\\log 3})$） ​贪心​Huffman编码的熵最优性证明 ​DP​背包问题状态压缩技巧（滚动数组） 每日训练 完成《算法导论》第1-15章课后习题（重点：递归式求解主方法） 在LeetCode按类型刷题，每日3道（Easy 1, Medium 2） 二、思维强化阶段（3-6个月）高阶算法模式位运算魔法： 用XOR找缺失数（LC268） 快速幂算法（矩阵快速幂解斐波那契） 空间换时间： 单调栈解决Next Greater Element（LC496） 跳表(SkipList)实现$O(\\log N)$查询 数学建模： 约瑟夫环递推公式推导 用中国剩余定理解决周期问题（LC1250） 实战突破： 参加每周LeetCode周赛，目标进入前10% 实现《算法竞赛入门经典》中的STL轮子（手写红黑树） 三、领域专精阶段（6-12个月）分支选择与深化机器学习算法： 推导XGBoost损失函数泰勒展开过程 手写SVM对偶问题求解器（SMO算法） 分布式算法： Raft协议Leader选举的随机超时机制 Gossip协议在Cassandra中的应用 几何计算： 凸包Graham扫描法实现 使用扫描线算法求矩形并集面积（LC850） 专项训练： 在Codeforces刷2200+分的计算几何题目 复现Google Spanner的TrueTime API设计 四、思维跃迁训练法降维打击法 将字符串匹配问题转化为自动机（AC自动机实现） 用FFT加速多项式乘法（大数乘法优化） 极限压榨法 在内存限制1MB下实现外排序（多路归并） 用位图处理40亿整数去重（LC原题变形） 五、工具链配置调试神器# 重定向调试工具 import pdb pdb.set_trace()","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 学习规划","slug":"0-算法/0-0-学习规划","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"01. 双指针-只有一个输入, 从两端开始遍历","slug":"0 算法/01 算法模板/01 双指针-只有一个输入, 从两端开始遍历","date":"2023-08-10T23:14:00.000Z","updated":"2025-02-27T14:44:55.928Z","comments":true,"path":"2023/08/11/0 算法/01 算法模板/01 双指针-只有一个输入, 从两端开始遍历/","link":"","permalink":"http://example.com/2023/08/11/0%20%E7%AE%97%E6%B3%95/01%20%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/01%20%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%BB%8E%E4%B8%A4%E7%AB%AF%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86/","excerpt":"","text":"正文123456789101112131415fun doublePointer(arr: IntArray): Int &#123; var left = 0 var right = arr.size - 1 while (left &lt; right) &#123; // 根据 left 和 right 相关的条件进行操作 if (CONDITION) &#123; left++ &#125; else &#123; right-- &#125; &#125; return 0 // 返回需要的结果&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]}],"categories":[{"name":"8 - 渲染引擎","slug":"8-渲染引擎","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"8.3 - Vulkan","slug":"8-渲染引擎/8-3-Vulkan","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-3-Vulkan/"},{"name":"7 - 复杂代码模版","slug":"7-复杂代码模版","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/"},{"name":"7.3 - 复杂 UI 效果","slug":"7-复杂代码模版/7-3-复杂-UI-效果","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-3-%E5%A4%8D%E6%9D%82-UI-%E6%95%88%E6%9E%9C/"},{"name":"9 - 音视频","slug":"9-音视频","permalink":"http://example.com/categories/9-%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"9.1 - 播放器实战","slug":"9-音视频/9-1-播放器实战","permalink":"http://example.com/categories/9-%E9%9F%B3%E8%A7%86%E9%A2%91/9-1-%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98/"},{"name":"6 - Android 打包编译","slug":"6-Android-打包编译","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/"},{"name":"6.1 - 文件分析","slug":"6-Android-打包编译/6-1-文件分析","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-1-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"},{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.4 - Jetpacket","slug":"3-Android/3-4-Jetpacket","permalink":"http://example.com/categories/3-Android/3-4-Jetpacket/"},{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.3 - 80 道基础算法","slug":"0-算法/0-3-80-道基础算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-3-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"7.1 - UI 绘制模版","slug":"7-复杂代码模版/7-1-UI-绘制模版","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-1-UI-%E7%BB%98%E5%88%B6%E6%A8%A1%E7%89%88/"},{"name":"7.2 - 手势分发","slug":"7-复杂代码模版/7-2-手势分发","permalink":"http://example.com/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-2-%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"3.2 - Arouter","slug":"3-Android/3-2-Arouter","permalink":"http://example.com/categories/3-Android/3-2-Arouter/"},{"name":"0.1 - 算法模版","slug":"0-算法/0-1-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"name":"4 - 架构方案设计","slug":"4-架构方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"4.1 - MVI","slug":"4-架构方案设计/4-1-MVI","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-1-MVI/"},{"name":"4.1 - 播放器架构方案设计","slug":"4-架构方案设计/4-1-播放器架构方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-1-%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"4.2 - Android 存储文件方案设计","slug":"4-架构方案设计/4-2-Android-存储文件方案设计","permalink":"http://example.com/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-2-Android-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"8 - C++","slug":"8-C","permalink":"http://example.com/categories/8-C/"},{"name":"8.1 - C++理论基础","slug":"8-C/8-1-C-理论基础","permalink":"http://example.com/categories/8-C/8-1-C-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"},{"name":"3.1 - Framework","slug":"3-Android/3-1-Framework","permalink":"http://example.com/categories/3-Android/3-1-Framework/"},{"name":"8.1 - 基础项目拆解","slug":"8-渲染引擎/8-1-基础项目拆解","permalink":"http://example.com/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-1-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%8B%86%E8%A7%A3/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"},{"name":"6.2 - 简单好用的 gradle 云编译设置","slug":"6-Android-打包编译/6-2-简单好用的-gradle-云编译设置","permalink":"http://example.com/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-2-%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84-gradle-%E4%BA%91%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE/"},{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 多线程","slug":"2-Java/2-0-Java-多线程","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"},{"name":"0.2 - 算法题目","slug":"0-算法/0-2-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.2.1 - 中等","slug":"0-算法/0-2-算法题目/0-2-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-1-%E4%B8%AD%E7%AD%89/"},{"name":"0.2.2 - 困难","slug":"0-算法/0-2-算法题目/0-2-2-困难","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-2-%E5%9B%B0%E9%9A%BE/"},{"name":"0.2.0 - 简单","slug":"0-算法/0-2-算法题目/0-2-0-简单","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-2-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-2-0-%E7%AE%80%E5%8D%95/"},{"name":"0.0 - 学习规划","slug":"0-算法/0-0-学习规划","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"}],"tags":[]}