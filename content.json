{"meta":{"title":"喵星科技报","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"About Author","date":"2023-08-09T03:40:47.000Z","updated":"2023-08-09T17:43:32.561Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-08-08T22:26:40.000Z","updated":"2023-08-08T23:16:57.285Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-09T03:39:01.000Z","updated":"2023-08-09T03:39:55.133Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android FrameWork 专项 - Handler（三）","slug":"Android/FrameWork/Android-FrameWork-专项-Handler3","date":"2023-08-19T02:28:06.546Z","updated":"2023-08-19T02:52:08.540Z","comments":true,"path":"2023/08/19/Android/FrameWork/Android-FrameWork-专项-Handler3/","link":"","permalink":"http://example.com/2023/08/19/Android/FrameWork/Android-FrameWork-%E4%B8%93%E9%A1%B9-Handler3/","excerpt":"","text":"要理解 Message 的创建，先要说内存抖动内存抖动的原因及引发的问题在 Android 虚拟机中，当我们在应用程序中创建大量的临时对象，并且这些对象的存在时间很短暂，虚拟机会识别这些临时对象并将它们标记为待清理的垃圾对象，以便在适当的时候回收它们。然而，这个垃圾回收过程可能会引发一个称为“stop the world”的现象。所谓“stop the world”指的是，在进行垃圾回收的过程中，虚拟机会暂停应用程序的正常执行，以便能够安全地识别和回收这些临时对象。 在 Java 字节码中，创建一个对象通常需要执行三个关键操作: new、dup 和 invokespecial。这三个操作合在一起构成了对象创建的原子过程。 虚拟机通常通过两种方式来判断一个对象是否是垃圾。一种方式是使用“引用计数”机制，但这种方法存在循环引用的问题，因此无法完全准确地标记垃圾对象，从而导致垃圾回收不彻底。另一种方式是使用“根可达”（或称为“根引用”）的方式，即从根对象（如线程栈、静态变量等）开始，追踪对象之间的引用关系，从而判断哪些对象是可达的，哪些是垃圾。 然而，在标记垃圾对象的过程中，如果垃圾回收线程与创建对象的线程同时工作，就可能出现问题。例如，如果一个对象刚刚被创建但尚未与变量关联，而垃圾回收线程已经扫描到这个对象并标记为垃圾，那么在后续的垃圾回收过程中，这个对象可能会被回收，而在应用程序中使用相关变量时可能会触发空指针异常。为了避免这种情况，标记垃圾的过程通常需要暂停所有工作线程，确保在标记过程中不会有对象的状态发生变化。这就是为什么在进行垃圾回收时会出现应用程序“停顿”的现象。 然而，如果垃圾回收过程耗时过长，会导致应用程序长时间无响应，造成卡顿现象。因此，我们需要尽量避免在应用中创建大量生命周期很短的临时对象，以减少垃圾回收的频率和影响。 内存抖动的原因: 创建了大量的生命周期很短的对象。导致的问题: 在用户看来程序出现了卡顿。 Message 中 obtain() 与 recycle()显而易见，Message 那真是生命周期极短数量极其庞大，是最容易内存抖动的地方所以 Message 内存必须被复用 我们说说 Message 的销毁与创建 创建: android.os.Message#obtain()注意：说创建是不准确的，应该是提供 1234567891011121314151617/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 这段代码是用于在 Android 中创建和管理消息对象的一部分。它通过维护一个对象池，允许在需要时重复利用已有的消息对象，从而减少内存分配和垃圾回收的开销。当需要获取一个新的消息对象时，它会首先检查对象池是否有可用的对象。如果有，它会从对象池中取出一个对象并重置其状态，然后返回；如果对象池为空，它会创建一个新的消息对象并返回。这种做法有助于提高应用程序的性能和效率。 12345synchronized (sPoolSync) &#123; if (sPool != null) &#123; ... &#125;&#125; 1Message m = sPool; 1sPool = m.next; 1m.next = null; 123m.flags=0;sPoolSize--;return m; 回收: android.os.Message#recycle()123456789101112131415161718/** * Return a Message instance to the global pool. * &lt;p&gt; * You MUST NOT touch the Message after calling this function because it has * effectively been freed. It is an error to recycle a message that is currently * enqueued or that is in the process of being delivered to a Handler. * &lt;/p&gt; */public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return; &#125; recycleUnchecked();&#125; 这里提一下 gCheckRecycle 12345public static void updateCheckRecycle(int targetSdkVersion) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123; gCheckRecycle = false; &#125;&#125; 在较低版本的 Android 上 ( &lt; 5.0 )，某些检查可能会导致不必要的异常情况，如 IllegalStateException。这可能会影响应用程序的稳定性。通过避免这些检查，可以避免异常的抛出，提高应用程序的可靠性。 回收: android.os.Message#recycleUnchecked1234567891011121314151617181920212223242526272829/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */@UnsupportedAppUsagevoid recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 123456789101112flags = FLAG_IN_USE;what = 0;arg1 = 0;arg2 = 0;obj = null;replyTo = null;sendingUid = UID_NONE;workSourceUid = UID_NONE;when = 0;target = null;callback = null;data = null; 消息的标志位 flags 的含义是消息对象是否正在使用中。 123456789@UnsupportedAppUsagevoid recycleUnchecked() &#123; ... synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; ... &#125; &#125;&#125; 在同步块中，检查消息池的大小是否小于最大池大小（MAX_POOL_SIZE）。 如果是，将当前消息对象放入消息池的链表中，以供将来重用。 更新消息池的大小。 1next=sPool; 1sPool=this; 内存抖动参考自:知乎博主Android小瓜: Android 性能优化大法——内存抖动原文链接: https://zhuanlan.zhihu.com/p/575959909 android.os.Message#obtain() 与 android.os.Message#recycleUnchecked 相关图片来自于:版权声明：本文为CSDN博主「-_-void」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xmh19936688/article/details/51901338","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - FrameWork","slug":"3-Android/3-1-FrameWork","permalink":"http://example.com/categories/3-Android/3-1-FrameWork/"}],"tags":[]},{"title":"Android FrameWork 专项 - Handler（二）","slug":"Android/FrameWork/Android-FrameWork-专项-Handler2","date":"2023-08-17T08:33:14.922Z","updated":"2023-08-19T02:51:59.228Z","comments":true,"path":"2023/08/17/Android/FrameWork/Android-FrameWork-专项-Handler2/","link":"","permalink":"http://example.com/2023/08/17/Android/FrameWork/Android-FrameWork-%E4%B8%93%E9%A1%B9-Handler2/","excerpt":"","text":"MessageQueue 到底是什么?从 MessageQueue 的创建说起1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//保证了MessageQueue的唯一性 mThread = Thread.currentThread();&#125; MessageQueue 就是在 Looper 的构造方法里创建的，一个 Looper 就对应了一个 MessageQueue。 MessageQueue 如何实现线程间的数据隔离线程是不持有系统资源的进程，所以同一个进程中的线程是共用的同一个进程持有的内存，说人话就是进程中持有的内存中的变量和数据每个线程都可以直接读取，MessageQueue 是存放线程要处理的消息的，我们当然不希望它是进程持有的线程之间共享的，不能被其他的线程所干扰，换句话说 MessageQueue 必须是线程隔离的 android.os.Looper#prepare(boolean) 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));//把新创建的 Looper 和 ThreadLocal 关联起来，保证 looper 的唯一性&#125; 注意 Looper 是一个静态类非一个实例，在 Looper 的 prepare 阶段，会去 new Looper(quitAllowed)，并将其放入 ThreadLocal，这样就让 Looper 成为了 线程变量，而 MessageQueue 由 Looper 创建并持有，所以 MessageQueue 自然也成了 线程变量，这样就实现了每个线程有自己独立的 Looper 和 MessageQueue 实例，且相互隔离。 MessageQueue 是每个线程独有的。每个线程都拥有自己的消息队列，因此在不同的线程之间无法直接共享消息队列。消息是在一个线程中创建和发送到该线程的消息队列，然后由该线程的 Looper 从队列中取出并处理。 1`ThreadLocal` 是一个线程级别的存储，它在每个线程中维护一个独立的存储空间（`ThreadLocalMap`），每个存储空间使用 `ThreadLocal` 对象作为键。不同线程的存储空间互不干扰，实现了线程间的数据隔离；但在同一个线程内，`ThreadLocal` 对象可以共享，对应的数据副本在不同方法间保持一致。、 MessageQueue 同步屏障试想一种情况 MessageQueue 需要处理 android.os.MessageQueue#next 中的另一种执行逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@UnsupportedAppUsageMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 我们重点看这一段 1234567if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 如果 msg !&#x3D; null，而 msg.target &#x3D;&#x3D; null 的时候，android.os.MessageQueue#next 执行了完全不同的另一种逻辑，target 就是 msg 的目标 handler，也就是说如果 msg 没有目标 handler 的时候，那么 msg 就是一个屏障消息，android.os.MessageQueue#next 就会进入无限循环读取异步消息的逻辑 从这里我们知道 MessageQueue 提供了一个屏障，这个屏障可以让 MessageQueue 越过所有同步消息优先执行异步消息 我们看看这个屏障该如何升起与取消 简单的发送一个 msg.target &#x3D;&#x3D; null 的消息升起同步屏障可以简单的发送一个 msg.target &#x3D;&#x3D; null 的消息来升起这个屏障吗？尝试一下你就会发现出现了”Message must have a target.”的异常 android.os.MessageQueue#enqueueMessage msg.target &#x3D;&#x3D; null 的危险性与抛出的异常123456boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; ...&#125; 我们发现 android.os.MessageQueue#enqueueMessage 第一步就是检查 msg.target 是否为 null，msg.target &#x3D;&#x3D; null 极度危险，一旦消息没有正确的被处理，会导致整个 MessageQueue 进入异步消息的死循环无法退出，因此 消息屏障的触发与取消必须被管控起来 严格管控下的同步屏障的触发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Posts a synchronization barrier to the Looper&#x27;s message queue. * * Message processing occurs as usual until the message queue encounters the * synchronization barrier that has been posted. When the barrier is encountered, * later synchronous messages in the queue are stalled (prevented from being executed) * until the barrier is released by calling &#123;@link #removeSyncBarrier&#125; and specifying * the token that identifies the synchronization barrier. * * This method is used to immediately postpone execution of all subsequently posted * synchronous messages until a condition is met that releases the barrier. * Asynchronous messages (see &#123;@link Message#isAsynchronous&#125; are exempt from the barrier * and continue to be processed as usual. * * This call must be always matched by a call to &#123;@link #removeSyncBarrier&#125; with * the same token to ensure that the message queue resumes normal operation. * Otherwise the application will probably hang! * * @return A token that uniquely identifies the barrier. This token must be * passed to &#123;@link #removeSyncBarrier&#125; to release the barrier. * * @hide */@UnsupportedAppUsage@TestApipublic int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 这段代码是 Android 消息机制中的一部分，用于实现同步屏障（Sync Barrier）。同步屏障是一种机制，可以用来控制消息队列中的消息执行顺序，特别是用于确保后续的同步消息在某个条件满足之前被阻塞执行。下面对这段代码进行分析： postSyncBarrier() 方法： 这个方法是向消息队列中添加一个同步屏障。 同步屏障是一种特殊的消息，它会阻塞后续的同步消息的执行，直到同步屏障被释放。 该方法返回一个用于标识同步屏障的 token，这个 token 在稍后调用 removeSyncBarrier() 方法时需要使用。 postSyncBarrier(long when) 方法： 这个方法是 postSyncBarrier() 的内部实现。 该方法会创建一个同步屏障消息，设置其触发时间（when）和一个唯一的 token。 同步屏障消息将被插入消息队列中，并根据触发时间排序。 在插入同步屏障消息时： 遍历消息队列，找到合适的位置插入同步屏障消息，以保持消息队列的顺序。 如果同步屏障消息需要插入的位置在已有消息之后，将同步屏障消息插入到该位置之后。 如果同步屏障消息需要插入的位置在已有消息之前，将同步屏障消息作为新的头部消息。 总结起来，这段代码实现了向消息队列中插入同步屏障消息的功能。同步屏障消息的作用是阻塞后续的同步消息的执行，直到满足某个条件后释放同步屏障。这种机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足之前某些消息不被执行。 严格管控下的同步屏障的取消12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Removes a synchronization barrier. * * @param token The synchronization barrier token that was returned by * &#123;@link #postSyncBarrier&#125;. * * @throws IllegalStateException if the barrier was not found. * * @hide */@UnsupportedAppUsage@TestApipublic void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException(&quot;The specified message queue synchronization &quot; + &quot; barrier token has not been posted or has already been removed.&quot;); &#125; final boolean needWake; if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycleUnchecked(); // If the loop is quitting then it is already awake. // We can assume mPtr != 0 when mQuitting is false. if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125;&#125; 这段代码是用于移除同步屏障（Sync Barrier）的逻辑。它会从消息队列中移除指定的同步屏障消息，并在必要时唤醒消息队列，以继续处理后续的消息。下面对这段代码进行分析： removeSyncBarrier(int token) 方法： 这个方法用于移除同步屏障。 它接受一个参数 token，即之前调用 postSyncBarrier() 方法返回的标识同步屏障的 token。 如果指定的同步屏障消息被找到并移除，将会在必要时唤醒消息队列。 在移除同步屏障消息时： 遍历消息队列，寻找包含指定 token 的同步屏障消息。 如果找到了匹配的同步屏障消息，将其从消息队列中移除。 如果在移除同步屏障消息后，消息队列不再被其他消息阻塞，会将队列唤醒，以继续处理后续的消息。 recycleUnchecked() 方法： 在移除同步屏障消息后，调用这个方法将消息对象回收，以便释放资源。 总结起来，这段代码实现了移除同步屏障消息的功能。当同步屏障条件满足后，通过调用 removeSyncBarrier() 方法来移除同步屏障消息，从而解除对后续同步消息的阻塞。这个机制可以用于控制消息队列中消息的执行顺序，确保在特定条件满足后执行后续的同步消息。 从 ViewRootImpl 看同步屏障的使用android.view.ViewRootImpl#scheduleTraversals 1234567891011@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 同步屏障的触发 1mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); 再看一下发送消息的逻辑 android.view.Choreographer#postCallback 123456789101112131415161718/** * Posts a callback to run on the next frame. * &lt;p&gt; * The callback runs once then is automatically removed. * &lt;/p&gt; * * @param callbackType The callback type. * @param action The callback action to run during the next frame. * @param token The callback token, or null if none. * * @see #removeCallbacks * @hide */@UnsupportedAppUsage@TestApipublic void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125; android.view.Choreographer#postCallbackDelayed 1234567891011121314151617181920212223242526272829/** * Posts a callback to run on the next frame after the specified delay. * &lt;p&gt; * The callback runs once then is automatically removed. * &lt;/p&gt; * * @param callbackType The callback type. * @param action The callback action to run during the next frame after the specified delay. * @param token The callback token, or null if none. * @param delayMillis The delay time in milliseconds. * * @see #removeCallback * @hide */@UnsupportedAppUsage@TestApipublic void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; if (action == null) &#123; throw new IllegalArgumentException(&quot;action must not be null&quot;); &#125; if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) &#123; throw new IllegalArgumentException(&quot;callbackType is invalid&quot;); &#125; postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125; 重点: android.view.Choreographer#postCallbackDelayedInternal 1234567891011121314151617181920212223private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType + &quot;, action=&quot; + action + &quot;, token=&quot; + token + &quot;, delayMillis=&quot; + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 我们看异步消息的发送逻辑 1234Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);msg.arg1 = callbackType;msg.setAsynchronous(true);mHandler.sendMessageAtTime(msg, dueTime); android.view.ViewRootImpl#unscheduleTraversals 12345678void unscheduleTraversals() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); mChoreographer.removeCallbacks( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); &#125;&#125; android.view.ViewRootImpl#unscheduleTraversals 的调用时机比较有意思，这里暂不做更多的分析 Skipped 30 frames!错误信息在进行 UI 更新的时候，如果 UI 线程忙碌，主线程有时会抛出异常信息：Skipped 30 frames! The application may be doing too much work on its main thread. 错误原因这是因为触发屏障的实际操作是发送一个 target 为 null 的 msg，但是如果这个 target 为 null 的消息被前面的耗时消息所耽误而一直没能执行，导致后面不断发送来的需要立即执行的异步消息都被耽误，触发同步屏障之后，系统发现，本该立即执行的异步消息已经积累了30帧只会，就会报出这个主线程忙碌的错误 改进方法罪魁祸首就是那个耽误了 target &#x3D;&#x3D; null 的同步屏障 msg 执行的 msg，这个同步消息的执行如此之耗时，以至于我们必须考虑对其优化或者考虑是不是适合放在主线程可以放到其他线程去执行 MessageQueue 中的 synchronizedandroid.os.MessageQueue#next 中的 synchronized12345678910111213141516171819202122232425262728293031323334353637383940@UnsupportedAppUsageMessage next() &#123; ... for (;;) &#123; ... synchronized (this) &#123; ... Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. ... &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. ... &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; ... if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; ... &#125;&#125; 第一处synchronized 用于同步代码块的范围涵盖了整个 next() 方法。具体来说，这段代码实现了一个消息循环（message loop）用于处理消息队列中的消息。在多线程环境下，有多个线程可能会调用 next() 方法来获取下一个消息，因此需要确保对共享资源的访问是安全的。 第二处mIdleHandlers.remove(idler)：这行代码从 mIdleHandlers 集合中移除一个 IdleHandler。由于多个线程可能同时访问和修改 mIdleHandlers，因此需要确保这个操作是原子的，以避免不一致或意外的结果。 其他函数都是 synchronized 保护下的MessageQueue 是 Android 框架中用于处理消息传递和线程通信的关键组件，多个线程可能会同时访问和修改消息队列，因此需要使用同步机制来避免竞态条件和其他线程安全问题。 MessageQueue 中的 IdleHandler使用与意义IdleHandler 是 Android 消息传递机制中的一个重要概念，它允许你在消息队列空闲时执行一些额外的操作。 使用： 你可以通过 MessageQueue 的 addIdleHandler() 方法将一个或多个 IdleHandler 添加到消息队列中。 意义： IdleHandler 允许你在消息队列空闲时执行一些轻量级的任务，这些任务通常是一些不需要立即处理、不会阻塞主线程的操作。常见的用例包括资源回收、后台数据同步、性能优化等。通过利用空闲时间执行这些任务，可以提高应用的性能和资源利用率。 执行时机： IdleHandler 的 queueIdle() 方法在消息队列没有即时任务需要处理时调用。如果 queueIdle() 返回 true，该 IdleHandler 将继续保持在队列中，以便在下一次空闲时调用；如果返回 false，则该 IdleHandler 将从队列中移除。 为什么会有多个 IdleHandler 功能分离： 不同的 IdleHandler 可以用于执行不同类型的任务，如资源回收、后台数据同步、性能优化等。通过将不同的任务逻辑分离到不同的 IdleHandler 中，可以使代码更加模块化和可维护。 任务优先级： 不同的 IdleHandler 可以根据优先级来执行任务。高优先级任务可以通过将对应的 IdleHandler 添加到队列中，确保在空闲时尽快执行。低优先级任务则可以延迟到更空闲的时候执行。 动态注册和注销： 多个 IdleHandler 允许开发者在不同的时刻动态地注册和注销任务。这使得可以根据应用程序的状态和需求来动态地调整任务的执行。 任务复用： 如果有多个相似的任务需要在空闲时执行，可以通过不同的 IdleHandler 实现任务的复用，避免重复编写类似的代码。 提高性能： 通过将不同的任务拆分到多个 IdleHandler 中，可以减少单个 IdleHandler 的负载，从而提高任务的执行效率。 关键行为分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@UnsupportedAppUsageMessage next() &#123; ... for (;;) &#123; ... synchronized (this) &#123; ... // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. /** * 如果首次进入空闲状态，则获取要运行的空闲处理程序数量。 * 空闲处理程序仅在消息队列为空或队列中的第一个消息（可能是一个屏障）将在未来被处理时运行。 */ if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 没有要运行的空闲处理程序。继续循环并等待一段时间。 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. /** * 运行空闲处理程序。 * 我们只会在第一次迭代期间到达这个代码块。 */ for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; ... &#125;&#125; mPendingIdleHandlers 与 mIdleHandlers mPendingIdleHandlers： 类型：IdleHandler[] 作用：用于存储当前等待执行的空闲时处理对象（IdleHandler）数组。在消息队列空闲时，这些处理会被调用，以执行额外的任务。 使用场景：用于临时存储等待执行的空闲时处理，直接与循环内部逻辑相关。 mIdleHandlers： 类型：ArrayList&lt;IdleHandler&gt; 作用：用于存储注册的空闲时处理对象。开发者可以将多个 IdleHandler 添加到这个列表中，以便在消息队列空闲时执行不同的任务。 使用场景：用于持久存储注册的空闲时处理，可以在任何时候添加或移除 IdleHandler。 总结区别： mPendingIdleHandlers 是一个数组，用于存储当前等待执行的空闲时处理对象。它是循环内部临时使用的，用于遍历调用每个等待执行的空闲时处理。 mIdleHandlers 是一个列表，用于持久存储注册的空闲时处理对象。开发者可以随时将 IdleHandler 添加到列表中，以便在消息队列空闲时执行不同的任务。 给 PendingIdleHandlers 分配新的数组空间123if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125; 这段代码的作用是在消息队列空闲时，检查是否需要运行空闲时处理。如果当前没有消息或者队列中的第一个消息的处理时间还未到来，并且之前的 pendingIdleHandlerCount 小于 0，那么它会获取当前注册的空闲时处理的数量，并将其赋值给 pendingIdleHandlerCount。这样，当队列为空或者第一个消息处理时间未到来时，代码会准备好运行已注册的空闲时处理。通常情况下，这个检查用于确保空闲时处理在适当的时机被调度执行。 123456if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 没有要运行的空闲处理程序。继续循环并等待一段时间。 mBlocked = true; continue;&#125; 这段代码的作用是在消息队列空闲时，如果没有等待执行的空闲时处理，就将消息队列标记为被阻塞状态，并继续等待更多的消息或任务进入队列。这个逻辑用于优化资源管理，确保在没有即时任务需要处理时，程序仍然能够保持运行，以便在有任务时能够立即执行。 123if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125; 注意：隐含的条件是 pendingIdleHandlerCount &lt;&#x3D; 0 才能走到这里，所以判断条件其实是 pendingIdleHandlerCount &lt;&#x3D; 0 &amp;&amp; mPendingIdleHandlers &#x3D;&#x3D; null，通常表示这是第一次运行空闲时处理 如果 mPendingIdleHandlers 为 null，则进入条件判断。在这里，使用 Math.max(pendingIdleHandlerCount, 4) 来计算数组的长度，其中 pendingIdleHandlerCount 是等待执行的空闲时处理的数量。如果等待执行的处理数量小于 4，则数组长度取值为 4，否则取值为 pendingIdleHandlerCount PendingIdleHandlers 赋值1mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); 运行空闲时处理 PendingIdleHandlers123456789101112131415161718192021222324// Run the idle handlers.// We only ever reach this code block during the first iteration./** * 运行空闲处理程序。 * 我们只会在第一次迭代期间到达这个代码块。 */for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125;&#125; 注意：这里注释中的第一次迭代是指的消息队列第一次处理完所有已经在队列中的消息的那一次迭代，是想说明在后续的迭代中，如果消息队列仍然处于空闲状态，那么这段代码块不会再执行，因为它只在消息队列刚刚变为空闲时运行。 队列的唤醒与阻塞android.os.MessageQueue#enqueueMessage12345678910111213141516171819202122232425262728293031323334353637383940boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; synchronized (this) &#123; ... boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 在这段代码中，mBlocked 在两个地方起到了不同的作用： 第一个 mBlocked 作用： 1needWake = mBlocked; 在这里，mBlocked 被赋值给变量 needWake。这个操作是为了判断是否需要唤醒事件队列（消息循环）。具体情况如下： 如果 mBlocked 为 true，表示事件队列当前正处于阻塞状态，即没有立即需要处理的消息。在这种情况下，如果新消息的插入导致事件队列不再阻塞，就需要唤醒事件队列，以便消息循环继续执行。 如果 mBlocked 为 false，表示事件队列没有阻塞，新消息的插入不会改变这个状态，因此不需要唤醒。 第二个 mBlocked 作用： 1needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); 在这里，mBlocked 参与了判断条件。这个条件用于判断是否需要唤醒事件队列，以提醒消息循环处理新消息。具体情况如下： 如果 mBlocked 为 true，表示事件队列当前正处于阻塞状态。然后，进一步判断消息队列中是否有异步消息，并且插入的新消息也是异步消息，那么需要唤醒事件队列，以便消息循环能够立即处理这个异步消息。 综上所述，mBlocked 在这段代码中的两个地方都与判断是否需要唤醒事件队列有关。第一个地方是用来判断是否需要在新消息插入时唤醒事件队列，以便消息循环继续执行。第二个地方是在特定条件下，判断是否需要唤醒事件队列来处理异步消息。 android.os.MessageQueue#next在提供的代码片段中，有三处不同的地方使用了 mBlocked 参数，并且它们在不同的上下文中起到了不同的作用。以下是每个位置的详细分析： 第一处 mBlocked 作用： 1mBlocked = false; 在这里，mBlocked 被设置为 false，表示消息队列不再处于阻塞状态。这是在找到了一个准备好被处理的消息后执行的操作。通过将 mBlocked 设置为 false，消息循环可以继续处理消息，而不需要等待。 第二处 mBlocked 作用： 1mBlocked = true; 在这里，mBlocked 被设置为 true，表示消息队列当前处于阻塞状态。这是在判断没有可处理的消息，并且没有要运行的空闲处理程序时执行的操作。通过将 mBlocked 设置为 true，消息循环进入了等待状态，等待新的消息或者空闲处理程序的到来。 第三处 mBlocked 作用： 1mBlocked = true; 这里的 mBlocked 也被设置为 true，与第二处的作用相同。这是在消息队列处理完所有的空闲处理程序之后，仍然没有要运行的空闲处理程序时执行的操作。通过将 mBlocked 设置为 true，消息循环会继续等待，直到有新的消息到达或者空闲处理程序需要运行。 总结来说，mBlocked 在这段代码中的三处不同的作用是： 在找到一个准备好被处理的消息后，将其设置为 false，使得消息循环可以继续处理消息。 在没有可处理的消息且没有要运行的空闲处理程序时，将其设置为 true，使得消息循环进入等待状态。 在所有空闲处理程序都被处理后，仍然没有要运行的空闲处理程序时，将其设置为 true，继续等待。 通过这样的设置，消息循环能够根据不同的情况来控制阻塞和等待状态，以便有效地处理消息和任务。","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - FrameWork","slug":"3-Android/3-1-FrameWork","permalink":"http://example.com/categories/3-Android/3-1-FrameWork/"}],"tags":[]},{"title":"Android FrameWork 专项 - Handler（一）","slug":"Android/FrameWork/Android-FrameWork-专项-Handler1","date":"2023-08-14T21:02:48.688Z","updated":"2023-08-15T21:35:35.421Z","comments":true,"path":"2023/08/15/Android/FrameWork/Android-FrameWork-专项-Handler1/","link":"","permalink":"http://example.com/2023/08/15/Android/FrameWork/Android-FrameWork-%E4%B8%93%E9%A1%B9-Handler1/","excerpt":"","text":"问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein Q：一个线程有几个 Handler？ Q: 线程间的通信的原理是怎样的？ Q: Handler 内存泄漏的原因？为什么其他的内部类没有说过这个问题？ Q: 为何主线程可以 new Handler ？如果想要在子线程中 new Handler 要做些什么准备？ Q: 子线程中维护的 Looper，消息队列无消息的时候的处理方案是什么？有什么用？ Q: 既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个 Handler 可能处于不同线程），那它内部时如何确保线程安全的？ Q: Looper 死循环为什么不会导致应用卡死 Q: 为什么主线程不需要自己创建和管理消息循环 Handler 在 Android 中的应用1Handler 是针对 Android 系统中与 UI 线程通信而专门设计的多线程通信机制 Retorfit，eventbus，rxjava，Looper Handler 源代码分析子线程 发送 MSG​ android.os.Handler#sendMessage -&gt;​ android.os.Handler#sendMessageDelayed -&gt;​ android.os.Handler#sendMessageAtTime -&gt;​ android.os.Handler#enqueueMessage -&gt;​ android.os.MessageQueue#enqueueMessage -&gt;​ android.os.Looper#loop android.os.Handler#sendMessage123456789101112131415161718192021 /** * Pushes a message onto the end of the message queue after all pending messages * before the current time. It will be received in &#123;@link #handleMessage&#125;, * in the thread attached to this handler. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */ /** * 在所有挂起的消息之后将消息推送到消息队列的末尾 * 当前时间之前。它将在 &#123;@link #handleMessage&#125; 中收到， * 在附加到该处理程序的线程中。 * * @return 如果消息成功放入则返回 true * 消息队列。失败时返回 false，通常是因为 * 处理消息队列的 looper 正在退出。 */public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125; android.os.Handler#sendMessageDelayed123456789101112131415161718192021222324252627282930/** * Enqueue a message into the message queue after all pending messages * before (current time + delayMillis). You will receive it in * &#123;@link #handleMessage&#125;, in the thread attached to this handler. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. *//** * 将一条消息放入消息队列中，位于所有挂起的消息之后 * 之前（当前时间+delayMillis）。您将在以下时间收到它： * &#123;@link #handleMessage&#125;，在附加到该处理程序的线程中。 * * @return 如果消息成功放入则返回 true * 消息队列。失败时返回 false，通常是因为 * 处理消息队列的 looper 正在退出。请注意，一个 * true 的结果并不意味着该消息将被处理 -- 如果 * Looper 在消息发送之前退出 * 发生则消息将被丢弃。 */public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; android.os.Handler#sendMessageAtTime12345678910111213141516171819202122232425262728293031323334353637383940/** * Enqueue a message into the message queue after all pending messages * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;. * &lt;b&gt;The time-base is &#123;@link android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt; * Time spent in deep sleep will add an additional delay to execution. * You will receive it in &#123;@link #handleMessage&#125;, in the thread attached * to this handler. * * @param uptimeMillis The absolute time at which the message should be * delivered, using the * &#123;@link android.os.SystemClock#uptimeMillis&#125; time-base. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. *//** * 将消息排队到消息队列中，在绝对时间（以毫秒为单位）&lt;var&gt;uptimeMillis&lt;/var&gt;之后的所有挂起消息之后。 * &lt;b&gt;时间基准是 &#123;@link android.os.SystemClock#uptimeMillis&#125;。&lt;/b&gt; * 在深度睡眠期间花费的时间将会额外延迟执行。 * 您将在&#123;@link #handleMessage&#125;中接收它，该方法会在与此处理程序连接的线程中执行。 * * @param uptimeMillis 消息应该传递的绝对时间，使用&#123;@link android.os.SystemClock#uptimeMillis&#125;作为时间基准。 * * @return 如果消息成功放置到消息队列中，则返回 true 。如果失败，则返回 false ，通常是因为处理消息队列的消息循环正在退出。 * 请注意，返回true并不意味着消息将被处理 - 如果消息传递时间之前消息循环被退出，则消息将被丢弃。 */public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; android.os.Handler#enqueueMessage12345678910private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 到这里，发送流程都没什么好说的 重点：android.os.Handler#handleMessage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; synchronized (this) &#123; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; msg.target 是什么注意：这里 msg.target 就是 msg 持有的 handler 也是 为什么会有内存泄漏风险的原因。 分析代码： Handler 内存泄漏原因Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。 它的主要作用是将消息按照时间顺序插入到消息队列中，并在必要时唤醒队列以处理这些消息。下面逐步分析代码的功能和逻辑。 首先，代码对传入的消息 msg 进行一些验证。它确保消息有一个非空的目标（msg.target != null），否则抛出 IllegalArgumentException。 然后，代码在同步块内执行以下操作： 检查消息是否已经在使用中，如果是，则抛出 IllegalStateException。这可能是为了防止重复使用消息，确保每个消息只被处理一次。 检查当前处理器是否正在退出（mQuitting 标志），如果是，就回收消息并返回 false，表示消息未被成功加入队列。 将消息标记为正在使用，并设置消息的触发时间 msg.when 为传入的 when。 获取消息队列的头部消息 p。 接下来，代码根据以下条件进行处理： 如果消息队列为空，或者传入的触发时间 when 为 0，或者传入的 when 小于队列头部消息的触发时间 p.when，则将新消息插入到队列头部。如果队列当前被阻塞（mBlocked 标志），则设置需要唤醒队列（needWake = true）。 否则，如果消息需要插入队列中间，则根据条件判断是否需要唤醒队列。具体判断条件是：队列被阻塞、队列头部消息的目标为 null，且传入的消息是异步消息。然后，代码在一个循环中遍历消息队列，找到合适的位置插入新消息。循环会一直迭代，直到找到合适的位置或者遍历完整个队列。 在找到合适的位置后，代码将新消息 msg 插入到队列中。具体做法是，将 msg.next 设置为当前消息 p，然后将前一个消息 prev.next 设置为新消息 msg。 最后，代码根据之前的标志 needWake 来决定是否唤醒队列。如果需要唤醒，则调用本地的 nativeWake 方法（可能是一个底层的本地方法）来唤醒消息队列。 整个同步块结束后，代码返回 true，表示消息已经成功加入队列。 这段代码的核心功能是在消息队列中插入消息并进行适当的排序，以确保消息按照触发时间顺序进行处理。同时，它还处理了一些异常情况，如消息已经在使用中或者处理器正在退出。唤醒队列的逻辑也在代码的最后部分进行处理。 让我们逐步分析 MSG 插入队列的位置： 第一种插入头部的情况：12345678if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; else &#123; ...&#125; 如果消息队列为空，意味着当前没有任何消息在队列中等待处理。在这种情况下，不需要比较触发时间，直接将新消息插入到队列的头部。这会让新消息成为队列的第一个要处理的消息。 如果传入的触发时间 when 为 0，这可能表示该消息需要尽快处理，因此同样将它插入到队列的头部。 如果传入的触发时间 when 小于队列头部消息的触发时间 p.when，这意味着新消息应该在队列中位于当前头部消息之前，因此同样将它插入到队列的头部。 综合上述情况，无论是队列为空，还是传入的 when 值为 0，或者传入的 when 值小于队列头部消息的触发时间，都会将新消息插入到队列的头部。 第二种插入中间的情况：123456789101112131415161718192021if(p == null || when == 0 || when &lt; p.when) &#123; ...&#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; 首先，如果不满足前面提到的条件（消息队列为空，传入的触发时间为0，或传入的触发时间小于队列头部消息的触发时间），那么意味着要插入的新消息 msg 应该位于队列中间。 在这种情况下，代码会进入一个循环。这个循环的目的是遍历消息队列，以找到合适的位置将新消息 msg 插入队列中。 循环的条件是 for (;;)，这将创建一个无限循环，直到内部的某个条件满足而跳出循环。 在每次循环迭代中，代码会做以下事情： 将当前消息 p 的引用赋值给 prev，这样可以记录下前一个消息。 将 p 移动到下一个消息（p = p.next）。 然后，代码检查两个条件： 如果当前消息 p 为空，意味着已经遍历了整个队列，或者队列只有一个消息且当前消息是最后一个消息。 如果传入的触发时间 when 小于队列中当前消息 p 的触发时间 p.when。 如果满足以上任一条件，循环会被中断，这表示找到了合适的位置将新消息 msg 插入到消息队列中。 在循环的每个迭代中，代码还会检查以下条件： 如果需要唤醒队列（needWake = true），并且当前消息 p 是异步消息（p.isAsynchronous() 返回 true），则将 needWake 设置为 false。这个步骤可能是为了控制是否需要在队列中插入异步消息时唤醒队列。 一旦找到了合适的位置，代码会执行以下操作： 将新消息 msg 的 next 指针指向当前消息 p，这相当于将新消息插入到当前消息 p 之前。 将前一个消息 prev 的 next 指针指向新消息 msg，以确保队列中消息的连接关系正确。 循环结束后，新消息 msg 已经被插入到队列的合适位置，保持了消息队列的有序性。 总之，这段代码的目的是在消息队列中将新消息插入到适当的位置，以保持消息的时间顺序。在找到合适位置时，会根据一些条件来决定是否需要唤醒队列，这可能与队列的处理机制相关。 此外，如果当前消息队列被阻塞（mBlocked 为 true），则将标志 needWake 设置为 true。这是为了确保在需要唤醒队列以处理消息的情况下，能够在适当的时候执行唤醒操作。唤醒队列的操作可能涉及到一些底层机制，具体如何唤醒可能需要查看更多上下文代码。 总的来说，这段代码逻辑的目的是在特定条件下将新消息插入到消息队列的头部，并根据当前队列的阻塞状态决定是否需要唤醒队列以确保消息能够被及时处理。 主线程 取出 MSG​ android.os.Looper#loop -&gt;​ android.os.MessageQueue#next -&gt;​ android.os.Handler#dispatchMessage -&gt;​ android.os.Handler#handleMessage 主线程中的 Loop我们来看主线程的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); // Call per-process mainline module initialization. initializeMainlineModules(); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 与 handler 相关的关键代码： 123456789101112131415public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ··· Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 准备 Looper 1Looper.prepareMainLooper(); android.os.Looper#prepareMainLooper 1234567891011121314151617/** * Initialize the current thread as a looper, marking it as an * application&#x27;s main looper. See also: &#123;@link #prepare()&#125; * * @deprecated The main looper for your application is created by the Android environment, * so you should never need to call this function yourself. */@Deprecatedpublic static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125;&#125; android.os.Looper#prepare(boolean) 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 准备 Handler 123if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler();&#125; android.app.ActivityThread#getHandler 1234@UnsupportedAppUsage public Handler getHandler() &#123; return mH;&#125; android.app.ActivityThread#mH 12@UnsupportedAppUsagefinal H mH = new H(); 开启循环 1Looper.loop(); 重点：android.os.Looper#loop#loop123456789101112131415161718192021222324252627282930313233public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; if (me.mInLoop) &#123; Slog.w(TAG, &quot;Loop again would have the queued messages be executed&quot; + &quot; before this one completed.&quot;); &#125; me.mInLoop = true; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); me.mSlowDeliveryDetected = false; for (;;) &#123; if (!loopOnce(me, ident, thresholdOverride)) &#123; return; &#125; &#125;&#125; 这段代码是 Android 框架中 Looper 类的 loop() 方法的实现，负责在当前线程的消息循环中执行消息的分发和处理。 首先，通过 myLooper() 获取当前线程的 Looper 实例 me，如果没有 Looper 实例则抛出异常，表示未调用 Looper.prepare() 来准备 Looper。 检查 me.mInLoop，如果当前线程已经在消息循环中，则打印警告日志。 将 me.mInLoop 标志设置为 true，表示当前线程正在消息循环中。 使用 Binder.clearCallingIdentity() 来清除当前线程的调用标识，然后再次调用它并将返回的标识 ident 保存下来。 获取一个可能的系统属性覆盖值 thresholdOverride，用于调整慢分发的阈值。 将 me.mSlowDeliveryDetected 设置为 false，用于标记是否检测到慢投递。 进入一个无限循环，不断地执行消息分发和处理。 在循环中，调用 loopOnce(me, ident, thresholdOverride) 来执行一次消息分发。如果返回值为 false，表示没有更多的消息需要分发，退出循环。 总之，这段代码描述了 Android 中消息循环的核心逻辑。它会在一个无限循环中，不断地从消息队列中获取消息并执行消息分发和处理，直到没有更多的消息需要处理为止。在循环中，还会检查是否有慢分发阈值的系统属性覆盖，并根据需要清除调用标识。如果发现当前线程已经在消息循环中，则会打印警告信息。 #loopOnce1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) &#123; Message msg = me.mQueue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return false; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; // Make sure the observer won&#x27;t change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (me.mSlowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); me.mSlowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. me.mSlowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); return true; &#125; 这段代码是 Android 框架中 Looper 类的一个方法 loopOnce 的实现，主要负责处理消息队列中的消息分发过程。我会逐步解释代码的功能。 首先，通过 me.mQueue.next() 获取下一个消息，如果没有消息则表示消息队列正在退出，函数返回 false。 如果获取到了消息，则会根据是否设置了日志打印，打印消息的分发信息。 获取当前的观察者对象和跟踪标签。 根据阈值覆盖值，更新慢分发和慢投递的阈值。 判断是否需要记录开始时间和结束时间，如果需要，则记录当前时间作为分发开始时间。 如果设置了跟踪标签且跟踪标签是启用的，则开始跟踪。 设置开始分发时间，并获取一个 token 以用于观察者的消息分发起始回调。 设置当前线程的工作源为消息的工作源 UID。 使用目标 Handler（Handler 是消息处理的目标）来分发消息。 如果设置了观察者，通知观察者消息已分发。 结束分发，记录结束时间。 如果发生异常，通知观察者分发过程中出现异常，并将异常抛出。 最终，无论是否发生异常，都会恢复线程的工作源，并根据跟踪标签是否启用，结束跟踪。 如果设置了慢投递日志，会根据条件判断是否记录慢投递日志。 如果设置了慢分发日志，会根据条件记录慢分发日志。 如果设置了日志打印，会打印消息分发完成信息。 最后，检查分发过程中线程标识是否被更改，如果发生改变，会打印警告日志。 回收消息对象并返回 true，表示成功分发消息。 总之，这段代码描述了 Android 中消息队列中消息的分发过程，涵盖了消息的跟踪、日志记录、观察者通知等多个方面，确保消息能够按照正确的顺序分发到目标处理程序。 重点：android.os.MessageQueue#next123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@UnsupportedAppUsageMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 这段代码是一个 Android 消息循环（Message Loop）的一部分，它用于处理消息队列中的消息。消息循环是 Android 应用程序的核心部分，用于处理用户界面事件、线程间通信等。 以下是代码的主要功能和逻辑： 代码开头使用了一个注解 @UnsupportedAppUsage，这是 Android 的一个标记注解，用于标识不推荐使用的 API 或方法。 next() 方法是一个消息循环的主要函数。它会循环从消息队列中获取消息，然后处理这些消息。 首先，代码会获取 mPtr，这是一个表示消息队列的指针。如果 ptr 为 0，表示消息队列已经被释放，函数会返回 null。 接下来，进入一个无限循环 for (;;) &#123;...&#125;，在循环内部做以下操作： 如果 nextPollTimeoutMillis 不为 0，会刷新待处理的 Binder 命令（一种 Android 进程间通信机制）。 调用 nativePollOnce(ptr, nextPollTimeoutMillis)，它是一个本地方法，用于轮询获取下一个消息。 进入同步块，开始处理消息队列中的消息。 首先，获取当前时间 now，然后尝试获取下一个消息。如果消息的目标为 null，表示该消息是一个异步消息（可能由于障碍而被阻塞），会查找下一个异步消息。 如果找到消息并且消息的触发时间在当前时间之后，会设置一个定时器来在消息准备好时唤醒循环。 如果消息已经准备好（触发时间已到），会将消息从队列中移除，并返回该消息。 如果没有找到消息，会将 nextPollTimeoutMillis 设为 -1，表示没有更多消息。 如果 mQuitting 为 true，表示消息队列已经被停止，会调用 dispose() 释放资源，并返回 null。 如果是第一次空闲（没有消息待处理），会获取待运行的空闲处理器数量。 如果没有空闲处理器需要运行，会将 mBlocked 设为 true，继续等待。 如果有待运行的空闲处理器，会将它们放入 mPendingIdleHandlers 数组中。 执行空闲处理器的 queueIdle() 方法，该方法用于处理空闲状态。 如果 queueIdle() 返回 false，表示该空闲处理器不再需要运行，会将其从列表中移除。 重置空闲处理器数量为 0，以防止重复运行。 在处理完空闲处理器后，将 nextPollTimeoutMillis 设为 0，以便立即查找待处理的消息。 以上就是这段代码的主要逻辑。它负责不断地从消息队列中获取消息并处理，同时也处理了一些特殊情况，如消息队列已停止、空闲处理等。这种消息循环机制保证了 Android 应用程序的响应性和流畅性。 核心代码：给定代码中最重要的部分是主循环，该循环处理消息并运行空闲处理程序，在Android消息循环系统中负责处理消息并及时有效地运行空闲处理程序。让我们逐步分解关键组成部分及其重要性： 1234567891011121314151617181920212223242526272829303132333435363738for (;;) &#123; // ... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // ... if (msg != null) &#123; if (now &lt; msg.when) &#123; // ... &#125; else &#123; // 收到一条消息。 mBlocked = false; // 从队列中移除消息并返回。 // 这是消息处理的核心操作。 // 它允许根据其预定时间依次执行消息。 // 返回的“msg”对象包含用于处理的数据和指令。 msg.markInUse(); return msg; &#125; &#125; else &#123; // 没有更多消息。 nextPollTimeoutMillis = -1; &#125; // 处理退出消息并处理空闲处理程序。 // ... // 运行空闲处理程序。 // 该块遍历待处理的空闲处理程序并执行它们。 // 空闲处理程序用于在消息队列为空时执行任务。 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; // ... &#125; // 重置空闲处理程序计数并检查是否有新消息。 // ... &#125;&#125; 关键部分及其重要性如下： nativePollOnce(ptr, nextPollTimeoutMillis);：这个本地方法用于轮询来自底层系统的传入消息和事件。它等待指定的超时时间以获取新的消息。 消息处理： 循环检查是否有待处理的消息，并根据其预定时间（msg.when）对其进行处理。 如果一条消息准备好执行，它会从队列中移除并返回（return msg;）。 这是消息循环的核心，消息按照它们被发布的顺序逐个执行。 markInUse() 方法表示消息正在被处理。 退出消息和空闲处理程序： 循环检查消息循环是否正在退出（mQuitting）并在需要时释放资源。 还会处理空闲处理程序，这些程序在没有待处理消息时执行。 空闲处理程序是在消息循环处于非活动状态时执行任务的函数。 总的来说，这段代码片段代表了Android消息循环的核心机制，它对于管理异步任务、UI交互和基于事件的编程在Android应用中至关重要。这个循环的正常运行对于维持响应迅速、交互式的用户体验至关重要。 android.os.Handler#dispatchMessage123456789101112131415/** * Handle system messages here. */public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 这段代码是一个 Android 消息分发方法，用于处理系统消息。在 Android 中，消息分发是消息循环的一部分，用于将消息传递给相应的处理方法或回调函数。 以下是代码的主要功能和逻辑： 方法名为 dispatchMessage，接受一个非空的 Message 对象作为参数，用于处理系统消息。 首先，代码检查 msg 中是否存在一个非空的回调函数 callback。如果存在，表示该消息具有一个回调函数，将调用 handleCallback(msg) 来处理该回调函数。 如果 msg 中没有回调函数，代码会进入下一步判断。 首先，检查是否存在一个非空的成员变量 mCallback，它是一个消息处理器的回调接口。如果存在 mCallback，代码会调用 handleMessage(msg) 来处理消息。如果 mCallback.handleMessage(msg) 返回 true，表示消息已经被处理，函数会直接返回，不会继续执行后续的 handleMessage(msg)。 如果 mCallback.handleMessage(msg) 返回 false，表示 mCallback 没有处理该消息，代码会调用当前类的 handleMessage(msg) 方法来处理消息。 综合起来，这段代码实现了一个消息分发的逻辑，首先检查消息是否有回调函数，然后尝试使用回调函数处理消息。如果没有回调函数，它会检查是否存在一个全局的消息处理器 mCallback，尝试让它处理消息。如果都没有成功处理，最后会调用当前类的 handleMessage(msg) 方法来处理消息。 这种消息分发机制使得消息能够在不同的处理方法和回调函数之间进行传递和处理，提高了代码的灵活性和可扩展性。 android.os.Handler#handleMessage12345/** * Subclasses must implement this to receive messages. */public void handleMessage(@NonNull Message msg) &#123;&#125; 这段代码是一个方法声明，用于在子类中实现消息处理的逻辑。在 Android 中，消息处理是一种常见的模式，用于处理来自消息队列的不同类型的消息。 以下是代码的主要功能和逻辑： 方法名为 handleMessage，接受一个非空的 Message 对象作为参数，用于处理消息。 这是一个抽象方法，没有具体的实现，因此需要在子类中进行实现。 子类必须重写这个方法，并根据具体的业务逻辑来处理传递进来的消息。 通过在子类中实现不同的 handleMessage 方法，可以实现不同类型的消息处理，从而达到分离不同功能的目的。 在 Android 应用程序开发中，常常会使用这种消息处理机制来进行异步任务的处理、UI 更新、线程间通信等。子类可以根据不同的需求，实现不同的消息处理逻辑，使代码结构更加清晰和模块化。 使用 handler 通信机制由主线程向子线程发送消息我们已经了解了主线程中会创建 Looper 和 handler，也明白了期运行逻辑下面我们在子线程中创建这一套通信机制，用于主线程向子线程发送消息 创建一个 CustomLooperThread 手动创建子线程的 Looper 和关联的 Handler，以便在子线程中处理消息。 12345678910111213141516171819202122232425262728293031323334353637383940import android.os.Handler;import android.os.Looper;import android.os.Message;class CustomLooperThread extends Thread &#123; private Handler mHandler; private Looper mLooper; @Override public void run() &#123; Looper.prepare(); mLooper = Looper.myLooper(); mHandler = new Handler(mLooper) &#123; @Override public void handleMessage(Message msg) &#123; // 在线程中处理消息 // ... &#125; &#125;; Looper.loop(); &#125; public void executeTask(Runnable task) &#123; if (mHandler != null) &#123; mHandler.post(task); &#125; &#125; public Looper getLooper() &#123; return mLooper; &#125; public void quit() &#123; if (mLooper != null) &#123; mLooper.quit(); &#125; &#125;&#125; 方式二: 使用 HandlerThread： 使用 HandlerThread 类封装了子线程的 Looper 和关联的 Handler 创建过程。 1234567891011121314151617181920212223242526272829import android.os.Handler;import android.os.HandlerThread;import android.os.Message;public class CustomLooperThread extends HandlerThread &#123; private Handler mHandler; public CustomLooperThread(String name) &#123; super(name); &#125; @Override protected void onLooperPrepared() &#123; mHandler = new Handler(getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; // 在子线程中处理消息 // ... &#125; &#125;; &#125; public void sendMessageToThread(int what) &#123; if (mHandler != null) &#123; Message message = mHandler.obtainMessage(what); mHandler.sendMessage(message); &#125; &#125;&#125; 创建一个 MyThreadManager12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.os.Handler;import android.os.Looper;import android.os.Message;public class MyThreadManager &#123; private MyThread mThread; private Handler mHandler; public MyThreadManager() &#123; // 创建线程并启动 mThread = new MyThread(); mThread.start(); // 在线程的消息循环中创建 Handler mHandler = new Handler(mThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; // 在线程中处理消息 // ... &#125; &#125;; &#125; // 发送消息到线程中 public void sendMessage(int what) &#123; if (mHandler != null) &#123; Message message = mHandler.obtainMessage(what); mHandler.sendMessage(message); &#125; &#125; // 执行任务在线程中 public void executeTaskInThread(Runnable task) &#123; if (mThread != null) &#123; mThread.executeTask(task); &#125; &#125; // 关闭线程和消息循环 public void closeThread() &#123; if (mThread != null) &#123; mThread.quit(); mThread = null; &#125; &#125;&#125; 引出问题方式一，自定义 Looper 和 Handler 创建的 CustomLooperThread 中的 getLooper 有没有问题？1mThread.start(); 是在子线程中执行的 12345678// 在线程的消息循环中创建 HandlermHandler = new Handler(mThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; // 在线程中处理消息 // ... &#125;&#125;;thread.start()是在子线程中 是在主线程执行的也就是说在 mThread.getLooper() 时，有可能 mThread.start() 还没执行完所以这里有多线程并发问题 我们看一下 HandlerThread 中是怎么解决的 123456789101112131415161718192021222324252627282930313233/** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; boolean wasInterrupted = false; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; wasInterrupted = true; &#125; &#125; &#125; /* * We may need to restore the thread&#x27;s interrupted flag, because it may * have been cleared above since we eat InterruptedExceptions */ if (wasInterrupted) &#123; Thread.currentThread().interrupt(); &#125; Thread 中的 Handler 和 MyThreadManager 中 Handler 有什么不同 MyThread 类中的 Handler： 在 MyThread 类中的 Handler 用于处理子线程 MyThread 中的消息。它负责监听并处理从 MyThread 类的消息循环中传递过来的消息。这个 Handler 是在 MyThread 类的 run() 方法中创建并与 Looper 关联，以便在 MyThread 线程中处理消息。 MyThreadManager 类中的 Handler： 在 MyThreadManager 类中的 Handler 用于将消息发送到 MyThread 线程。它负责将来自主线程或其他地方的消息发送给 MyThread 线程的消息循环。这个 Handler 负责与 MyThread 线程进行通信，从而实现了在主线程或其他线程中触发 MyThread 线程执行特定任务。 这里我们提到了消息循环，我们下一章说 MessageQueue","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - FrameWork","slug":"3-Android/3-1-FrameWork","permalink":"http://example.com/categories/3-Android/3-1-FrameWork/"}],"tags":[]},{"title":"Android Bitmap 性能专题 - Bitmap 内存从申请到回收","slug":"Android/性能优化/Android-Bitmap-性能专题","date":"2023-08-12T03:16:40.223Z","updated":"2023-08-12T19:16:44.513Z","comments":true,"path":"2023/08/12/Android/性能优化/Android-Bitmap-性能专题/","link":"","permalink":"http://example.com/2023/08/12/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/","excerpt":"","text":"问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein Q：Bitmap 如何开辟内存？ Q：Bitmap 内存是怎么复用和销毁的？本地资源图片应该怎么去做适配？ Q：该如何去优化这些占用较大内存的本地资源图片？ Q：如何判断和优化 Bitmap OOM，如何 dump 线上内存来做优化分析？ 从 Bitmap 的创建说起12345678910111213141516171819202122232425262728293031323334/** * Private constructor that must received an already allocated native bitmap * int (pointer). */// called from JNIBitmap(long nativeBitmap, int width, int height, int density, boolean isMutable, boolean requestPremultiplied, byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123; if (nativeBitmap == 0) &#123; throw new RuntimeException(&quot;internal error: native bitmap is 0&quot;); &#125; mWidth = width; mHeight = height; mIsMutable = isMutable; mRequestPremultiplied = requestPremultiplied; mNinePatchChunk = ninePatchChunk; mNinePatchInsets = ninePatchInsets; if (density &gt;= 0) &#123; mDensity = density; &#125; mNativePtr = nativeBitmap; long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount(); NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize); registry.registerNativeAllocation(this, nativeBitmap); if (ResourcesImpl.TRACE_FOR_DETAILED_PRELOAD) &#123; sPreloadTracingNumInstantiatedBitmaps++; sPreloadTracingTotalBitmapsSize += nativeSize; &#125;&#125; called from JNI 这个解释其实已经很明确了，也就是说这个对象是 Native 层构建返回的。因此我们跟踪到 BitmapFactory.decodeResource() 中去看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static Bitmap decodeResource(Resources res, int id, Options opts) &#123; validate(opts); Bitmap bm = null; InputStream is = null; try &#123; final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); &#125; catch (Exception e) &#123; /* do nothing. If the exception happened on open, bm will be null. If it happened on close, bm is still valid. */ &#125; finally &#123; try &#123; if (is != null) is.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123; throw new IllegalArgumentException(&quot;Problem decoding into existing bitmap&quot;); &#125; return bm;&#125;public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) &#123; validate(opts); if (opts == null) &#123; opts = new Options(); &#125; if (opts.inDensity == 0 &amp;&amp; value != null) &#123; final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) &#123; opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; &#125; else if (density != TypedValue.DENSITY_NONE) &#123; opts.inDensity = density; &#125; &#125; // 获取当前手机设备的 dpi if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123; opts.inTargetDensity = res.getDisplayMetrics().densityDpi; &#125; return decodeStream(is, pad, opts);&#125;// 省略部分跟踪代码 ......private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts); 最终调用的是 native 方法 nativeDecodeStream 这里以 Android N 版本为例: &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;BitmapFactory.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363static jobject nativeDecodeStream(JNIEnv *env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options) &#123; jobject bitmap = NULL; std::unique_ptr&lt;SkStream&gt; stream(CreateJavaInputStreamAdaptor(env, is, storage)); if (stream.get()) &#123; std::unique_ptr&lt;SkStreamRewindable&gt; bufferedStream( SkFrontBufferedStream::Create(stream.release(), SkCodec::MinBufferedBytesNeeded())); SkASSERT(bufferedStream.get() != NULL); bitmap = doDecode(env, bufferedStream.release(), padding, options); &#125; return bitmap;&#125;static jobject doDecode(JNIEnv *env, SkStreamRewindable *stream, jobject padding, jobject options) &#123; // This function takes ownership of the input stream. Since the SkAndroidCodec // will take ownership of the stream, we don&#x27;t necessarily need to take ownership // here. This is a precaution - if we were to return before creating the codec, // we need to make sure that we delete the stream. std::unique_ptr&lt;SkStreamRewindable&gt; streamDeleter(stream); // Set default values for the options parameters. int sampleSize = 1; // 是否只是获取图片的大小 bool onlyDecodeSize = false; SkColorType prefColorType = kN32_SkColorType; bool isMutable = false; float scale = 1.0f; bool requireUnpremultiplied = false; jobject javaBitmap = NULL; // Update with options supplied by the client. // 解析 options 参数 if (options != NULL) &#123; sampleSize = env-&gt;GetIntField(options, gOptions_sampleSizeFieldID); // Correct a non-positive sampleSize. sampleSize defaults to zero within the // options object, which is strange. if (sampleSize &lt;= 0) &#123; sampleSize = 1; &#125; if (env-&gt;GetBooleanField(options, gOptions_justBoundsFieldID)) &#123; onlyDecodeSize = true; &#125; // initialize these, in case we fail later on env-&gt;SetIntField(options, gOptions_widthFieldID, -1); env-&gt;SetIntField(options, gOptions_heightFieldID, -1); env-&gt;SetObjectField(options, gOptions_mimeFieldID, 0); // 解析 ColorType ，复用参数等等 jobject jconfig = env-&gt;GetObjectField(options, gOptions_configFieldID); prefColorType = GraphicsJNI::getNativeBitmapColorType(env, jconfig); isMutable = env-&gt;GetBooleanField(options, gOptions_mutableFieldID); requireUnpremultiplied = !env-&gt;GetBooleanField(options, gOptions_premultipliedFieldID); javaBitmap = env-&gt;GetObjectField(options, gOptions_bitmapFieldID); // 计算缩放的比例 if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123; // 获取图片当前 xhdpi 的 density const int density = env-&gt;GetIntField(options, gOptions_densityFieldID); // 获取当前设备的 dpi const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; // scale = 当前设备的 dpi / xhdpi 的 density // scale = 420/320 = 1.3125 scale = (float) targetDensity / density; &#125; &#125; &#125; // Create the codec. NinePatchPeeker peeker; std::unique_ptr&lt;SkAndroidCodec&gt; codec(SkAndroidCodec::NewFromStream(streamDeleter.release(), 280 &amp; peeker)); if (!codec.get()) &#123; return nullObjectReturn(&quot;SkAndroidCodec::NewFromStream returned null&quot;); &#125; // Do not allow ninepatch decodes to 565. In the past, decodes to 565 // would dither, and we do not want to pre-dither ninepatches, since we // know that they will be stretched. We no longer dither 565 decodes, // but we continue to prevent ninepatches from decoding to 565, in order // to maintain the old behavior. if (peeker.mPatch &amp;&amp; kRGB_565_SkColorType == prefColorType) &#123; prefColorType = kN32_SkColorType; &#125; // 获取当前图片的大小 // Determine the output size. SkISize size = codec-&gt;getSampledDimensions(sampleSize); int scaledWidth = size.width(); int scaledHeight = size.height(); bool willScale = false; // 处理 simpleSize 压缩，我们这里没穿，上面默认是 1 // Apply a fine scaling step if necessary. if (needsFineScale(codec-&gt;getInfo().dimensions(), size, sampleSize)) &#123; willScale = true; scaledWidth = codec-&gt;getInfo().width() / sampleSize; scaledHeight = codec-&gt;getInfo().height() / sampleSize; &#125; // Set the options and return if the client only wants the size. if (options != NULL) &#123; jstring mimeType = encodedFormatToString(env, codec-&gt;getEncodedFormat()); if (env-&gt;ExceptionCheck()) &#123; return nullObjectReturn(&quot;OOM in encodedFormatToString()&quot;); &#125; // 设置 options 对象中的 outWidth 和 outHeight env-&gt;SetIntField(options, gOptions_widthFieldID, scaledWidth); env-&gt;SetIntField(options, gOptions_heightFieldID, scaledHeight); env-&gt;SetObjectField(options, gOptions_mimeFieldID, mimeType); // 如果只是获取大小直接 return null 这里是 nullptr 而不是 NULL if (onlyDecodeSize) &#123; return nullptr; &#125; &#125; // Scale is necessary due to density differences. if (scale != 1.0f) &#123; willScale = true; // 计算 scaledWidth 和 scaledHeight // scaledWidth = 864 * 1.3125 + 0.5f = 1134 + 0.5f = 1134 scaledWidth = static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); // scaledHeight = 582 * 1.3125 + 0.5f = 763.875 + 0.5f = 764 scaledHeight = static_cast&lt;int&gt;(scaledHeight * scale + 0.5f); &#125; // 判断是否有复用的 Bitmap android::Bitmap *reuseBitmap = nullptr; unsigned int existingBufferSize = 0; if (javaBitmap != NULL) &#123; reuseBitmap = GraphicsJNI::getBitmap(env, javaBitmap); if (reuseBitmap-&gt;peekAtPixelRef()-&gt;isImmutable()) &#123; // 无法重用一个不变的位图图像解码器的目标。 ALOGW(&quot;Unable to reuse an immutable bitmap as an image decoder target.&quot;); javaBitmap = NULL; reuseBitmap = nullptr; &#125; else &#123; existingBufferSize = GraphicsJNI::getBitmapAllocationByteCount(env, javaBitmap); &#125; &#125; JavaPixelAllocator javaAllocator(env); RecyclingPixelAllocator recyclingAllocator(reuseBitmap, existingBufferSize); ScaleCheckingAllocator scaleCheckingAllocator(scale, existingBufferSize); SkBitmap::HeapAllocator heapAllocator; SkBitmap::Allocator *decodeAllocator; if (javaBitmap != nullptr &amp;&amp; willScale) &#123; // This will allocate pixels using a HeapAllocator, since there will be an extra // scaling step that copies these pixels into Java memory. This allocator // also checks that the recycled javaBitmap is large enough. decodeAllocator = &amp;scaleCheckingAllocator; &#125; else if (javaBitmap != nullptr) &#123; decodeAllocator = &amp;recyclingAllocator; &#125; else if (willScale) &#123; // This will allocate pixels using a HeapAllocator, since there will be an extra // scaling step that copies these pixels into Java memory. decodeAllocator = &amp;heapAllocator; &#125; else &#123; decodeAllocator = &amp;javaAllocator; &#125; // Set the decode colorType. This is necessary because we can&#x27;t always support // the requested colorType. SkColorType decodeColorType = codec-&gt;computeOutputColorType(prefColorType); // Construct a color table for the decode if necessary SkAutoTUnref &lt;SkColorTable&gt; colorTable(nullptr); SkPMColor *colorPtr = nullptr; int *colorCount = nullptr; int maxColors = 256; SkPMColor colors[256]; if (kIndex_8_SkColorType == decodeColorType) &#123; colorTable.reset(new SkColorTable(colors, maxColors)); // SkColorTable expects us to initialize all of the colors before creating an // SkColorTable. However, we are using SkBitmap with an Allocator to allocate // memory for the decode, so we need to create the SkColorTable before decoding. // It is safe for SkAndroidCodec to modify the colors because this SkBitmap is // not being used elsewhere. colorPtr = const_cast&lt;SkPMColor *&gt;(colorTable-&gt;readColors()); colorCount = &amp;maxColors; &#125; // Set the alpha type for the decode. SkAlphaType alphaType = codec-&gt;computeOutputAlphaType(requireUnpremultiplied); // 创建 SkImageInfo 信息，宽，高，ColorType，alphaType const SkImageInfo decodeInfo = SkImageInfo::Make(size.width(), size.height(), decodeColorType, alphaType); SkImageInfo bitmapInfo = decodeInfo; if (decodeColorType == kGray_8_SkColorType) &#123; // The legacy implementation of BitmapFactory used kAlpha8 for // grayscale images (before kGray8 existed). While the codec // recognizes kGray8, we need to decode into a kAlpha8 bitmap // in order to avoid a behavior change. bitmapInfo = SkImageInfo::MakeA8(size.width(), size.height()); &#125; // 解析 SkBitmap 设置 bitmapInfo，tryAllocPixels 开辟内存，具体分析在后面 SkBitmap decodingBitmap; if (!decodingBitmap.setInfo(bitmapInfo) || !decodingBitmap.tryAllocPixels(decodeAllocator, colorTable)) &#123; // SkAndroidCodec should recommend a valid SkImageInfo, so setInfo() // should only only fail if the calculated value for rowBytes is too // large. // tryAllocPixels() can fail due to OOM on the Java heap, OOM on the // native heap, or the recycled javaBitmap being too small to reuse. return nullptr; &#125; // Use SkAndroidCodec to perform the decode. SkAndroidCodec::AndroidOptions codecOptions; codecOptions.fZeroInitialized = (decodeAllocator == &amp;javaAllocator) ? SkCodec::kYes_ZeroInitialized : SkCodec::kNo_ZeroInitialized; codecOptions.fColorPtr = colorPtr; codecOptions.fColorCount = colorCount; codecOptions.fSampleSize = sampleSize; // 解析获取像素值 SkCodec::Result result = codec-&gt;getAndroidPixels(decodeInfo, decodingBitmap.getPixels(), decodingBitmap.rowBytes(), &amp;codecOptions); switch (result) &#123; case SkCodec::kSuccess: case SkCodec::kIncompleteInput: break; default: return nullObjectReturn(&quot;codec-&gt;getAndroidPixels() failed.&quot;); &#125; jbyteArray ninePatchChunk = NULL; if (peeker.mPatch != NULL) &#123; if (willScale) &#123; scaleNinePatchChunk(peeker.mPatch, scale, scaledWidth, scaledHeight); &#125; size_t ninePatchArraySize = peeker.mPatch-&gt;serializedSize(); ninePatchChunk = env-&gt;NewByteArray(ninePatchArraySize); if (ninePatchChunk == NULL) &#123; return nullObjectReturn(&quot;ninePatchChunk == null&quot;); &#125; jbyte *array = (jbyte *) env-&gt;GetPrimitiveArrayCritical(ninePatchChunk, NULL); if (array == NULL) &#123; return nullObjectReturn(&quot;primitive array == null&quot;); &#125; memcpy(array, peeker.mPatch, peeker.mPatchSize); env-&gt;ReleasePrimitiveArrayCritical(ninePatchChunk, array, 0); &#125; jobject ninePatchInsets = NULL; if (peeker.mHasInsets) &#123; ninePatchInsets = env-&gt;NewObject(gInsetStruct_class, gInsetStruct_constructorMethodID, peeker.mOpticalInsets[0], peeker.mOpticalInsets[1], peeker.mOpticalInsets[2], peeker.mOpticalInsets[3], peeker.mOutlineInsets[0], peeker.mOutlineInsets[1], peeker.mOutlineInsets[2], peeker.mOutlineInsets[3], peeker.mOutlineRadius, peeker.mOutlineAlpha, scale); if (ninePatchInsets == NULL) &#123; return nullObjectReturn(&quot;nine patch insets == null&quot;); &#125; if (javaBitmap != NULL) &#123; env-&gt;SetObjectField(javaBitmap, gBitmap_ninePatchInsetsFieldID, ninePatchInsets); &#125; &#125; // 构建 SkBitmap 这个才是最终的 SkBitmap outputBitmap; if (willScale) &#123; // 如果需要缩放，那需要重新创建一张图片，上面加载的是图片的本身大小 // This is weird so let me explain: we could use the scale parameter // directly, but for historical reasons this is how the corresponding // Dalvik code has always behaved. We simply recreate the behavior here. // The result is slightly different from simply using scale because of // the 0.5f rounding bias applied when computing the target image size const float sx = scaledWidth / float(decodingBitmap.width()); const float sy = scaledHeight / float(decodingBitmap.height()); // Set the allocator for the outputBitmap. SkBitmap::Allocator *outputAllocator; if (javaBitmap != nullptr) &#123; outputAllocator = &amp;recyclingAllocator; &#125; else &#123; outputAllocator = &amp;javaAllocator; &#125; SkColorType scaledColorType = colorTypeForScaledOutput(decodingBitmap.colorType()); // FIXME: If the alphaType is kUnpremul and the image has alpha, the // colors may not be correct, since Skia does not yet support drawing // to/from unpremultiplied bitmaps. // 设置 SkImageInfo ，注意这里是 scaledWidth ，scaledHeight outputBitmap.setInfo(SkImageInfo::Make(scaledWidth, scaledHeight, scaledColorType, decodingBitmap.alphaType())); // 开辟当前 Bitmap 图片的内存 if (!outputBitmap.tryAllocPixels(outputAllocator, NULL)) &#123; // This should only fail on OOM. The recyclingAllocator should have // enough memory since we check this before decoding using the // scaleCheckingAllocator. return nullObjectReturn(&quot;allocation failed for scaled bitmap&quot;); &#125; SkPaint paint; // kSrc_Mode instructs us to overwrite the unininitialized pixels in // outputBitmap. Otherwise we would blend by default, which is not // what we want. paint.setXfermodeMode(SkXfermode::kSrc_Mode); paint.setFilterQuality(kLow_SkFilterQuality); // decodingBitmap -&gt; 画到 outputBitmap SkCanvas canvas(outputBitmap); canvas.scale(sx, sy); canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &amp;paint); &#125; else &#123; outputBitmap.swap(decodingBitmap); &#125; if (padding) &#123; if (peeker.mPatch != NULL) &#123; GraphicsJNI::set_jrect(env, padding, peeker.mPatch-&gt;paddingLeft, peeker.mPatch-&gt;paddingTop, peeker.mPatch-&gt;paddingRight, peeker.mPatch-&gt;paddingBottom); &#125; else &#123; GraphicsJNI::set_jrect(env, padding, -1, -1, -1, -1); &#125; &#125; // If we get here, the outputBitmap should have an installed pixelref. if (outputBitmap.pixelRef() == NULL) &#123; return nullObjectReturn(&quot;Got null SkPixelRef&quot;); &#125; if (!isMutable &amp;&amp; javaBitmap == NULL) &#123; // promise we will never change our pixels (great for sharing and pictures) outputBitmap.setImmutable(); &#125; // 如果有复用返回原来的 javaBitmap bool isPremultiplied = !requireUnpremultiplied; if (javaBitmap != nullptr) &#123; GraphicsJNI::reinitBitmap(env, javaBitmap, outputBitmap.info(), isPremultiplied); outputBitmap.notifyPixelsChanged(); // If a java bitmap was passed in for reuse, pass it back return javaBitmap; &#125; int bitmapCreateFlags = 0x0; if (isMutable) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Mutable; if (isPremultiplied) bitmapCreateFlags |= GraphicsJNI::kBitmapCreateFlag_Premultiplied; // 没有复用的 Bitmap 创建一个新的 Bitmap // now create the java bitmap return GraphicsJNI::createBitmap(env, javaAllocator.getStorageObjAndReset(), bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1);&#125;jobject GraphicsJNI::createBitmap(JNIEnv *env, android::Bitmap *bitmap, int bitmapCreateFlags, jbyteArray ninePatchChunk, jobject ninePatchInsets, int density) &#123; bool isMutable = bitmapCreateFlags &amp; kBitmapCreateFlag_Mutable; bool isPremultiplied = bitmapCreateFlags &amp; kBitmapCreateFlag_Premultiplied; // The caller needs to have already set the alpha type properly, so the // native SkBitmap stays in sync with the Java Bitmap. assert_premultiplied(bitmap-&gt;info(), isPremultiplied); jobject obj = env-&gt;NewObject(gBitmap_class, gBitmap_constructorMethodID, reinterpret_cast&lt;jlong&gt;(bitmap), bitmap-&gt;javaByteArray(), bitmap-&gt;width(), bitmap-&gt;height(), density, isMutable, isPremultiplied, ninePatchChunk, ninePatchInsets); hasException(env); // For the side effect of logging. return obj;&#125; 上面的代码看起来比较长，其实是非常简单的，相信大家都能看得懂，这里我对上面的流程再做一些总结： 解析 java 层传递过来的 Options 的参数，如 simpleSize ，isMutable，javaBitmap 等等，同时计算出 scale 。 获取当前图片的大小，根据 sampleSize 判断是否需要压缩，同时计算出 scaledWidth ，scaledHeight。 设置 options 宽高为 scaledWidth ，scaledHeight ，如果只是解析宽高那么就直接返回，也就是 options.inJustDecodeBounds &#x3D; true 时，但是这里需要注意返回的是，资源图片的宽高并不是 Bitmap 最终的宽高。（我们大部分人对这个有误解） 创建 native 层的 SkImageInfo 和 SkBitmap ，然后调用 tryAllocPixels 去开辟图片的内存空间，然后调用 getAndroidPixels 去解析像素值 ，这里的 decodingBitmap 也并不是最终需要返回的 Bitmap ，而是原资源图片的 Bitmap 。 构建需要返回的 outputBitmap ，如果需要缩放那么重新去开辟一块内存空间，如果不需要缩放直接调用 swap 方法即可。最后判断有没有复用的 JavaBitmap ,如果有复用调用 reinitBitmap 然后直接返回，如果没有则调用 createBitmap 去创建一个新的 Bitmap 。 究竟需要多少内存？通过上面的分析，我们可能会有疑问？我们调用了两次 tryAllocPixels ，那如果加载一张 (1440x2560) 10M 的图片，岂不是需要 20M 的内存？ 在 Android 平台上，Bitmap 的内存申请操作通常涉及到 Java 层和 Native 层的协作，而 tryAllocPixels 方法的多次调用可能是由于内部的内存分配和管理流程所致。 在 Android 4.4 及以上版本中，当你尝试为 Bitmap 对象申请内存时，tryAllocPixels 方法可能会在底层进行两次调用。这个行为在底层库中被设计用来提高内存分配的成功率。 第一次调用 tryAllocPixels 旨在检查是否有足够的内存来分配 Bitmap 的像素数据。如果这次调用失败，系统会尝试触发一次垃圾回收（GC）操作，以释放一些已不再使用的内存资源。 第二次调用 tryAllocPixels 发生在垃圾回收之后，此时系统期望能够分配足够的内存来满足 Bitmap 的需求。如果第二次调用仍然失败，那么可能会抛出 OutOfMemoryError 错误。 这种设计的目的是为了提高 Bitmap 内存分配的成功率。由于 Android 平台上的内存管理和垃圾回收机制是相对复杂的，经过多次尝试分配内存和触发垃圾回收，可以增加 Bitmap 成功分配内存的可能性。 在 Android 中，Bitmap 对象的内存使用量取决于图像的像素数量、每个像素的位深度和像素数据的存储方式。一个 10MB 的图片通常指的是文件大小，而不是图像的像素数量，因此具体的内存使用量会根据图像的属性而有所不同。 假设你有一张 10MB 的图片，我们可以估算一下将其加载为 Bitmap 时可能需要的内存量。请注意，以下是一个粗略的估算，实际内存使用量可能会受到压缩、图像格式和设备性能的影响。 图像大小： 假设你的图片大小为 10MB，这指的是文件的大小。这并不直接表示图像的像素数量，因为图像可以使用不同的压缩算法和格式存储。通常情况下，JPEG 格式的图像文件较小，而无损格式如 PNG 或 BMP 文件较大。 解码后的像素数据： 当你将图片解码为 Bitmap 时，其像素数据将被加载到内存中。假设该图片是一个 24 位的彩色图片（每个像素使用 8 位红、绿、蓝通道），那么像素数据的大小将是图像的宽度乘以高度乘以 3（每个像素 3 个通道）字节。这个估算不考虑额外的颜色通道、Alpha 通道等。 所以，一个粗略的估算如下： 假设图片的像素数据大小为 pixelsSize 字节，则需要的内存量约为：pixelsSize + Overhead。 Overhead 是 Bitmap 对象的开销，它通常取决于设备的位数、对象头信息、内存对齐等因素。对于一个普通的 24 位彩色图片，Overhead 大约在 4-8MB 左右。 需要注意的是，这只是一个估算，并且实际情况可能因为图片格式、加载库的实现、设备性能等因素而有所不同。在实际开发中，你可以使用一些工具来测量实际的内存使用量，例如 Android Studio 的内存分析工具。 Bitmap 的内存申请Bitmap 的内存申请不同版本间有些许差异，在 3.0-7.0 的 bitmap 像素内存都是存放在 Java heap 中的，而 8.0 以后则是放在 Native heap 中的 8.0 Bitmap 内存申请1234567891011121314151617181920@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); logMemory(); Bitmap bitmap = Bitmap.createBitmap(1024, 1024 * 500, Bitmap.Config.ARGB_8888); logMemory();&#125;private void logMemory() &#123; ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); activityManager.getMemoryInfo(memoryInfo); Log.e(&quot;TAG&quot;, &quot;AvailMem :&quot; + memoryInfo.availMem / 1024 / 1024); Log.e(&quot;TAG&quot;, &quot;lowMemory：&quot; + memoryInfo.lowMemory); Log.e(&quot;TAG&quot;, &quot;NativeHeapAllocatedSize :&quot; + Debug.getNativeHeapAllocatedSize() / 1024 / 1024);&#125; 上面我们创建了一张 2G 大小的 bitmap 我们在 8.0 以下的版本运行是会 OOM 的，而我们在 8.0 以上的版本运行是完全没问题，但 Native 内存多了 2G 的内存。 1234567E/TAG: AvailMem :1654E/TAG: lowMemory：falseE/TAG: NativeHeapAllocatedSize :4E/TAG: AvailMem :1656E/TAG: lowMemory：falseE/TAG: NativeHeapAllocatedSize :2052 为什么会有一张大图片的像素数据放在Java层会OOM，放在Native层却不会的情况在 Android 应用中，一张大图片的像素数据如果放在 Java 层可能会导致 OutOfMemoryError (OOM) 错误，而放在 Native 层不会出现这个问题。这涉及到 Java 层和 Native 层内存管理的不同方式以及底层实现的细节。 Java 层内存管理： 在 Java 层，对象的内存管理由 Java 虚拟机 (JVM) 负责。当你创建一个 Bitmap 对象并加载大图片的像素数据时，这些像素数据会在 Java 堆内存中分配。Android 应用的 Java 堆内存限制通常较小，这是为了确保系统的稳定性，避免应用占用过多内存影响其他应用和系统的运行。Java 堆内存受到限制，当堆内存用尽时就会触发 OutOfMemoryError 错误。由于 Java 层的内存管理涉及垃圾回收和其他 Java 虚拟机机制，加载大量像素数据可能会导致内存碎片和性能问题，最终导致 OOM 错误。 Native 层内存管理： 在 Native 层，像素数据的内存分配和释放由底层操作系统和 C&#x2F;C++ 代码负责。通过在 Native 层使用本地代码（如 C&#x2F;C++），你可以更好地控制内存的分配和释放。Native 层不受 Java 堆内存限制，因此可以更灵活地处理大量的像素数据，减少内存碎片问题，并降低 OOM 风险。 7.0 与 8.0 Bitmap 内存申请 tryAllocPixels 方法通过之前的源码分析可知 bitmap 的内存创建都是通过 tryAllocPixels 方法来申请的，我们通过源码来对比一下他们之间的区别，我们首先来看下 7.0 的代码： &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool SkBitmap::tryAllocPixels(Allocator *allocator, SkColorTable *ctable) &#123; HeapAllocator stdalloc; if (nullptr == allocator) &#123; allocator = &amp;stdalloc; &#125; return allocator-&gt;allocPixelRef(this, ctable);&#125;bool JavaPixelAllocator::allocPixelRef(SkBitmap *bitmap, SkColorTable *ctable) &#123; JNIEnv *env = vm2env(mJavaVM); mStorage = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable); return mStorage != nullptr;&#125;android::Bitmap *GraphicsJNI::allocateJavaPixelRef(JNIEnv *env, SkBitmap *bitmap, SkColorTable *ctable) &#123; const SkImageInfo &amp;info = bitmap-&gt;info(); if (info.colorType() == kUnknown_SkColorType) &#123; doThrowIAE(env, &quot;unknown bitmap configuration&quot;); return NULL; &#125; size_t size; if (!computeAllocationSize(*bitmap, &amp;size)) &#123; return NULL; &#125; // we must respect the rowBytes value already set on the bitmap instead of // attempting to compute our own. const size_t rowBytes = bitmap-&gt;rowBytes(); jbyteArray arrayObj = (jbyteArray) env-&gt;CallObjectMethod(gVMRuntime, gVMRuntime_newNonMovableArray, gByte_class, size); if (env-&gt;ExceptionCheck() != 0) &#123; return NULL; &#125; SkASSERT(arrayObj); jbyte *addr = (jbyte *) env-&gt;CallLongMethod(gVMRuntime, gVMRuntime_addressOf, arrayObj); if (env-&gt;ExceptionCheck() != 0) &#123; return NULL; &#125; SkASSERT(addr); android::Bitmap *wrapper = new android::Bitmap(env, arrayObj, (void *) addr, info, rowBytes, ctable); wrapper-&gt;getSkBitmap(bitmap); // since we&#x27;re already allocated, we lockPixels right away // HeapAllocator behaves this way too bitmap-&gt;lockPixels(); return wrapper;&#125; 从上面就可以看到, new android::Bitmap 见： frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 1234567891011Bitmap::Bitmap(JNIEnv *env, jbyteArray storageObj, void *address, const SkImageInfo &amp;info, size_t rowBytes, SkColorTable *ctable) : mPixelStorageType(PixelStorageType::Java) &#123; env-&gt;GetJavaVM(&amp;mPixelStorage.java.jvm); mPixelStorage.java.jweakRef = env-&gt;NewWeakGlobalRef(storageObj); mPixelStorage.java.jstrongRef = nullptr; mPixelRef.reset(new WrappedPixelRef(this, address, info, rowBytes, ctable)); // Note: this will trigger a call to onStrongRefDestroyed(), but // we want the pixel ref to have a ref count of 0 at this point mPixelRef-&gt;unref();&#125; address 获取的是 arrayObj 的地址，而 arrayObj 是 jbyteArray 数据类型，也就是说这里是通过 JNI 进入了 Java 世界开辟了内存，好比 Zygote 进入 Java 世界是通过 JNI 调用 com.android.internal.os.ZygoteInit 类的 main 函数是一个道理~ 我们还可以继续跟到 gVMRuntime_newNonMovableArray 中去看看实现，最后是 runtime-&gt;GetHeap() 上分配内存也就是 Java heap 内存。 我们还得看下 8.0 的源码，比较一下它与 7.0 之间的区别： external&#x2F;skia&#x2F;src&#x2F;core&#x2F;SkBitmap.cpp 12345678910111213bool SkBitmap::tryAllocPixels(Allocator *allocator, SkColorTable *ctable) &#123; HeapAllocator stdalloc; if (nullptr == allocator) &#123; allocator = &amp;stdalloc; &#125; return allocator-&gt;allocPixelRef(this, ctable);&#125;bool HeapAllocator::allocPixelRef(SkBitmap *bitmap, SkColorTable *ctable) &#123; mStorage = android::Bitmap::allocateHeapBitmap(bitmap, ctable); return !!mStorage;&#125; allocateHeapBitmap方法会最终new Bitmap,分配内存 ,见: &#x2F;frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;hwui&#x2F;Bitmap.cpp 1234567891011121314151617181920212223242526272829sk_sp &lt;Bitmap&gt; Bitmap::allocateHeapBitmap(SkBitmap *bitmap, SkColorTable *ctable) &#123; return allocateBitmap(bitmap, ctable, &amp;android::allocateHeapBitmap);&#125;static sk_sp &lt;Bitmap&gt; allocateBitmap(SkBitmap *bitmap, SkColorTable *ctable, AllocPixeRef alloc) &#123; const SkImageInfo &amp;info = bitmap-&gt;info(); if (info.colorType() == kUnknown_SkColorType) &#123; LOG_ALWAYS_FATAL(&quot;unknown bitmap configuration&quot;); return nullptr; &#125; size_t size; // we must respect the rowBytes value already set on the bitmap instead of // attempting to compute our own. const size_t rowBytes = bitmap-&gt;rowBytes(); if (!computeAllocationSize(rowBytes, bitmap-&gt;height(), &amp;size)) &#123; return nullptr; &#125; auto wrapper = alloc(size, info, rowBytes, ctable); if (wrapper) &#123; wrapper-&gt;getSkBitmap(bitmap); // since we&#x27;re already allocated, we lockPixels right away // HeapAllocator behaves this way too bitmap-&gt;lockPixels(); &#125; return wrapper;&#125; Bitmap 内存模型 0-2.3 3.0-4.4 5.0-7.1 8.0 Bitmap对象 Java Heap Java Heap Java Heap 像素数据 Native Heap Java Heap Native Heap 迁移原因 解决Native Bitmap内存泄漏 共享整个系统的内存减少OOM Android Bitmap 回收机制源代码分析 (从2.3到7.0，8.0)android 2.3.3 和 更低的版本在 Android 2.3.3 之前开发者必须手动调用 recycle 方法去释放 Native 内存，因为那个时候管理Bitmap内存比较复杂，需要手动维护引用计数器 官网解释: 12345On Android 2.3.3 (API level 10) and lower, using recycle() is recommended. If you&#x27;re displaying large amounts of bitmap data in your app, you&#x27;re likely to run into OutOfMemoryError errors. The recycle()method allows an app to reclaim memory as soon as possible.Caution: You should use recycle() only when you are sure that the bitmap is no longer being used. If you call recycle() and later attempt to draw the bitmap, you will get the error: &quot;Canvas: trying to use a recycled bitmap&quot;.The following code snippet gives an example of calling recycle(). It uses reference counting (in the variables mDisplayRefCount and mCacheRefCount) to track whether a bitmap is currently being displayed or in the cache. The code recycles the bitmap when these conditions are met:The reference count for both mDisplayRefCount and mCacheRefCount is 0.The bitmap is not null, and it hasn&#x27;t been recycled yet. 在 Android 2.3.3 以后不需要开发者主动调用 recycle 方法来回收内存了，但 Android K,L,M,N,O 版本上，都还能看到 recycle 方法，为什么没有干掉呢? 调用它会不会真正的释放内存呢？既然不需要手动释放 Native Bitmap ，那 Native 层的对象是怎么自动释放的？我们先来看下 7.0 和 8.0 中 recycle 的方法实现。 7.0 和 8.0 中 recycle 的方法实现12345678910111213141516171819202122232425262728293031323334353637/** * Free the native object associated with this bitmap, and clear the * reference to the pixel data. This will not free the pixel data synchronously; * it simply allows it to be garbage collected if there are no other references. * The bitmap is marked as &quot;dead&quot;, meaning it will throw an exception if * getPixels() or setPixels() is called, and will draw nothing. This operation * cannot be reversed, so it should only be called if you are sure there are no * further uses for the bitmap. This is an advanced call, and normally need * not be called, since the normal GC process will free up this memory when * there are no more references to this bitmap. *//* * 释放与此位图关联的本机对象，并清除对像素数据的引用。这不会立即释放像素数据； * 它只是允许在没有其他引用时进行垃圾回收。该位图被标记为&quot;无效&quot;，这意味着如果调用 * getPixels()或setPixels()，它将抛出异常， * 并且不会绘制任何内容。此操作无法撤销，因此只有在确保不再需要位图时才应调用此方法。 * 这是一个高级调用，通常不需要调用，因为正常的垃圾回收过程将在不再引用该位图时释放此内 * 存。*/ public void recycle() &#123; if (!mRecycled &amp;&amp; mNativePtr != 0) &#123; if (nativeRecycle(mNativePtr)) &#123; // return value indicates whether native pixel object was actually recycled. // false indicates that it is still in use at the native level and these // objects should not be collected now. They will be collected later when the // Bitmap itself is collected. // 返回值指示本机像素对象是否实际已被回收。 // false 表示它仍在本机级别上使用，现在不应收集这些对象。它们将在位图本身被回收时稍后收集。 mNinePatchChunk = null; &#125; mRecycled = true; &#125; &#125; private static native boolean nativeRecycle(long nativeBitmap); 都是调用了native方法，下面看一下native方法 8.0 见：&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 123456789101112131415static jboolean Bitmap_recycle(JNIEnv *env, jobject, jlong bitmapHandle) &#123; LocalScopedBitmap bitmap(bitmapHandle); bitmap-&gt;freePixels(); return JNI_TRUE;&#125;void freePixels() &#123; mInfo = mBitmap-&gt;info(); mHasHardwareMipMap = mBitmap-&gt;hasHardwareMipMap(); mAllocationSize = mBitmap-&gt;getAllocationByteCount(); mRowBytes = mBitmap-&gt;rowBytes(); mGenerationId = mBitmap-&gt;getGenerationID(); mIsHardware = mBitmap-&gt;isHardware(); // 清空了数据 mBitmap.reset(); 7.0 见：&#x2F;xref&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android&#x2F;graphics&#x2F;Bitmap.cpp 12345static jboolean Bitmap_recycle(JNIEnv *env, jobject, jlong bitmapHandle) &#123; LocalScopedBitmap bitmap(bitmapHandle); bitmap-&gt;freePixels(); return JNI_TRUE;&#125; 1234567891011121314151617181920212223242526272829void Bitmap::doFreePixels() &#123; switch (mPixelStorageType) &#123; case PixelStorageType::Invalid: // already free&#x27;d, nothing to do break; case PixelStorageType::External: mPixelStorage.external.freeFunc(mPixelStorage.external.address, mPixelStorage.external.context); break; case PixelStorageType::Ashmem: munmap(mPixelStorage.ashmem.address, mPixelStorage.ashmem.size); close(mPixelStorage.ashmem.fd); break; case PixelStorageType::Java: // 只是释放了 Java 层之前创建的引用 JNIEnv *env = jniEnv(); LOG_ALWAYS_FATAL_IF( mPixelStorage.java.jstrongRef, &quot;Deleting a bitmap wrapper while there are outstanding strong &quot; &quot;references! mPinnedRefCount = %d&quot;, mPinnedRefCount); env-&gt;DeleteWeakGlobalRef(mPixelStorage.java.jweakRef); break; &#125; if (android::uirenderer::Caches::hasInstance()) &#123; android::uirenderer::Caches::getInstance().textureCache.releaseTexture( mPixelRef-&gt;getStableID()); &#125;&#125; 7.0 和 8.0 中 手动调用 recycle 的方法，像素数据会被回收吗从上面的源码可以看出，如果是 8.0 : 我们手动调用 recycle 方法，数据是会立即释放的，因为像素数据本身就是在 Native 层开辟的。 8.0 以下，就算我们手动调用 recycle 方法，数据也是不会立即释放的，而是 DeleteWeakGlobalRef 交由 Java GC 来回收。 注意：以上的所说的释放数据仅代表释放像素数据，并未释放 Native 层的 Bitmap 对象。 Android M 版本及以前的版本, Bitmap 的内存回收Android M 版本及以前的版本, Bitmap 的内存回收主要是通过 BitmapFinalizer 来完成的见: &#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Bitmap(long nativeBitmap, byte[] buffer, int width, int height, int density, boolean isMutable, boolean requestPremultiplied, byte[] ninePatchChunk, NinePatchInsetStruct ninePatchInsets) &#123; if (nativeBitmap == 0) &#123; throw new RuntimeException(&quot;internal error: native bitmap is 0&quot;); &#125; mWidth = width; mHeight = height; mIsMutable = isMutable; mRequestPremultiplied = requestPremultiplied; mBuffer = buffer; mNinePatchChunk = ninePatchChunk; mNinePatchInsets = ninePatchInsets; if (density &gt;= 0) &#123; mDensity = density; &#125; mNativePtr = nativeBitmap; // 这个对象对象来回收 mFinalizer = new BitmapFinalizer(nativeBitmap); int nativeAllocationByteCount = (buffer == null ? getByteCount() : 0); mFinalizer.setNativeAllocationByteCount(nativeAllocationByteCount);&#125;private static class BitmapFinalizer &#123; private long mNativeBitmap; // Native memory allocated for the duration of the Bitmap, // if pixel data allocated into native memory, instead of java byte[] private int mNativeAllocationByteCount; BitmapFinalizer(long nativeBitmap) &#123; mNativeBitmap = nativeBitmap; &#125; public void setNativeAllocationByteCount(int nativeByteCount) &#123; if (mNativeAllocationByteCount != 0) &#123; VMRuntime.getRuntime().registerNativeFree(mNativeAllocationByteCount); &#125; mNativeAllocationByteCount = nativeByteCount; if (mNativeAllocationByteCount != 0) &#123; VMRuntime.getRuntime().registerNativeAllocation(mNativeAllocationByteCount); &#125; &#125; @Override public void finalize() &#123; try &#123; super.finalize(); &#125; catch (Throwable t) &#123; // Ignore &#125; finally &#123; // finalize 这里是 GC 回收该对象时会调用 setNativeAllocationByteCount(0); nativeDestructor(mNativeBitmap); mNativeBitmap = 0; &#125; &#125;&#125;private static native void nativeDestructor(long nativeBitmap); Android N 和 Android O 后，Bitmap 的内存回收没有了 BitmapFinalizer 类，但在 new Bitmap 时会注册 native 的 Finalizer 方法见: &#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java 使用 NativeAllocationRegistry 回收 native 内存 1234567891011121314151617181920212223242526272829/** * Private constructor that must received an already allocated native bitmap * int (pointer). */// called from JNIBitmap(long nativeBitmap, int width, int height, int density, boolean isMutable, boolean requestPremultiplied, byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123; if (nativeBitmap == 0) &#123; throw new RuntimeException(&quot;internal error: native bitmap is 0&quot;); &#125; mWidth = width; mHeight = height; mIsMutable = isMutable; mRequestPremultiplied = requestPremultiplied; mNinePatchChunk = ninePatchChunk; mNinePatchInsets = ninePatchInsets; if (density &gt;= 0) &#123; mDensity = density; &#125; mNativePtr = nativeBitmap; long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount(); NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize); registry.registerNativeAllocation(this, nativeBitmap);&#125; Bitmap 的 Java 对象 GC 之后，对应的 native 内存如何回收NativeAllocationRegistry 的原理与设计思想NativeAllocationRegistry是Android 8.0（API 27）引入的一种辅助回收native内存的机制 Bitmap 的内存分配分外两块：Java 堆和 native 堆。我们都知道 JVM 有垃圾回收机制，那么当 Bitmap的Java对象GC之后，对应的 native 堆内存会回收吗？ 提出问题掌握了NativeAllocationRegistry的作用和使用步骤后，很自然地会有一些疑问： 为什么在Java层对象被垃圾回收后，native内存会自动被回收呢？ NativeAllocationRegistry是从Android 8.0（API 27）开始引入，那么在此之前，native内存是如何回收的呢？ 使用步骤从Android 8.0（API 27）开始，Android中很多地方可以看到NativeAllocationRegistry的身影，我们以Bitmap为例子介绍NativeAllocationRegistry的使用步骤，涉及文件：Bitmap.java、Bitmap.h、Bitmap.cpp 步骤1：创建 NativeAllocationRegistry首先，我们看看实例化NativeAllocationRegistry的地方，具体在Bitmap的构造函数中： 1234567891011121314151617181920// # Android 8.0// Bitmap.java// called from JNIBitmap(long nativeBitmap,...)&#123; // 省略其他代码... // 【分析点 1：native 层需要的内存大小】 long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount(); // 【分析点 2：回收函数 nativeGetNativeFinalizer()】 // 【分析点 3：加载回收函数的类加载器：Bitmap.class.getClassLoader()】 NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize); // 注册 Java 层对象引用与 native 层对象的地址 registry.registerNativeAllocation(this, nativeBitmap);&#125;private static final long NATIVE_ALLOCATION_SIZE = 32;private static native long nativeGetNativeFinalizer(); 可以看到，Bitmap的构造函数（在从JNI中调用）中实例化了NativeAllocationRegistry，并传递了三个参数： 参数 解释 classLoader 加载freeFunction函数的类加载器 freeFunction 回收native内存的native函数直接地址 size 分配的native内存大小（单位：字节） 步骤2：注册对象紧接着，调用了registerNativeAllocation(...)，并传递两个参数： 参数 解释 referent Java层对象的引用 nativeBitmap native层对象的地址 1234567891011121314// Bitmap.java// called from JNIBitmap(long nativeBitmap,...)&#123; // 省略其他代码... // 注册 Java 层对象引用与 native 层对象的地址 registry.registerNativeAllocation(this, nativeBitmap);&#125;// NativeAllocationRegistry.javapublic Runnable registerNativeAllocation(Object referent, long nativePtr) &#123; // 代码省略，下文补充...&#125; 步骤3：回收内存完成前面两步后，当Java层对象被垃圾回收后，NativeAllocationRegistry会自动回收注册的native内存。例如，我们加载几张图片，随后释放Bitmap的引用，可以观察到GC之后，native层的内存也自动回收了： 12345tv.setOnClickListener&#123; val map = HashSet&lt;Any&gt;() for(index in 0 .. 2)&#123; map.add(BitmapFactory.decodeResource(resources,R.drawable.test)) &#125; GC 前的内存分配情况 —— Android 8.0 GC 后的内存分配情况 —— Android 8.0 - 通过分析NativeAllocationRegistry源码，我们将一步步解答这些问题，请继续往下看。 NativeAllocationRegistry 源码分析现在我们将视野回到到NativeAllocationRegistry的源码，涉及文件：NativeAllocationRegistry.java 、NativeAllocationRegistry_Delegate.java、libcore_util_NativeAllocationRegistry.cpp 构造函数1234567891011121314151617181920// NativeAllocationRegistry.javapublic class NativeAllocationRegistry &#123; // 加载 freeFunction 函数的类加载器 private final ClassLoader classLoader; // 回收 native 内存的 native 函数直接地址 private final long freeFunction; // 分配的 native 内存大小（字节） private final long size; public NativeAllocationRegistry(ClassLoader classLoader, long freeFunction, long size) &#123; if (size &lt; 0) &#123; throw new IllegalArgumentException(&quot;Invalid native allocation size: &quot; + size); &#125; this.classLoader = classLoader; this.freeFunction = freeFunction; this.size = size; &#125;&#125; 可以看到，NativeAllocationRegistry的构造函数只是将三个参数保存下来，并没有执行额外操作。以Bitmap为例，三个参数在Bitmap的构造函数中获得，我们继续上一节未完成的分析过程： 分析点 1：native 层需要的内存大小 12345678910111213141516// Bitmap.java// 【分析点 1：native 层需要的内存大小】long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount();public final int getAllocationByteCount() &#123; if (mRecycled) &#123; Log.w(TAG, &quot;Called getAllocationByteCount() on a recycle()&#x27;d bitmap! &quot; + &quot;This is undefined behavior!&quot;); return 0; &#125; // 调用 native 方法 return nativeGetAllocationByteCount(mNativePtr);&#125;private static final long NATIVE_ALLOCATION_SIZE = 32; 可以看到，nativeSize由固定的32字节加上getAllocationByteCount()，总之，NativeAllocationRegistry需要一个native层内存大小的参数。 分析点 2：回收函数 nativeGetNativeFinalizer() 123456789101112131415161718192021// Bitmap.java// 【分析点 2：回收函数 nativeGetNativeFinalizer()】NativeAllocationRegistry registry = new NativeAllocationRegistry( Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);private static native long nativeGetNativeFinalizer();// Java 层// ----------------------------------------------------------------------// native 层// Bitmap.cppstatic jlong Bitmap_getNativeFinalizer(JNIEnv*, jobject) &#123; // 转为long return static_cast&lt;jlong&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;Bitmap_destruct));&#125;static void Bitmap_destruct(BitmapWrapper* bitmap) &#123; delete bitmap;&#125; 可以看到，nativeGetNativeFinalizer()是一个native函数，返回值是一个long，这个值其实相当于Bitmap_destruct()函数的直接地址。很明显，Bitmap_destruct()就是用来回收native层内存的。 那么，Bitmap_destruct()是在哪里调用的呢？继续往下看！ 分析点 3：加载回收函数的类加载器 12// Bitmap.javaBitmap.class.getClassLoader() 另外，NativeAllocationRegistry还需要ClassLoader参数，文档注释指出：**classloader是加载freeFunction所在native库的类加载器**，但是NativeAllocationRegistry内部并没有使用这个参数。这里笔者也不理解为什么需要传递这个参数，如果有知道答案的小伙伴请告诉我一下~ 注册对象123456789101112131415161718192021222324252627282930// Bitmap.java// 注册 Java 层对象引用与 native 层对象的地址registry.registerNativeAllocation(this, nativeBitmap);// NativeAllocationRegistry.javapublic Runnable registerNativeAllocation(Object referent, long nativePtr) &#123; if (referent == null) &#123; throw new IllegalArgumentException(&quot;referent is null&quot;); &#125; if (nativePtr == 0) &#123; throw new IllegalArgumentException(&quot;nativePtr is null&quot;); &#125; CleanerThunk thunk; CleanerRunner result; try &#123; thunk = new CleanerThunk(); Cleaner cleaner = Cleaner.create(referent, thunk); result = new CleanerRunner(cleaner); registerNativeAllocation(this.size); &#125; catch (VirtualMachineError vme /* probably OutOfMemoryError */) &#123; applyFreeFunction(freeFunction, nativePtr); throw vme; // Other exceptions are impossible. // Enable the cleaner only after we can no longer throw anything, including OOME. thunk.setNativePtr(nativePtr); return result;&#125; 可以看到，registerNativeAllocation (...)方法参数是**Java层对象引用与native层对象的地址**。函数体乍一看是有点绕，笔者在这里也停留了好长一会。我们简化一下代码，try-catch代码先省略，函数返回值Runnable暂时用不到也先省略，瘦身后的代码如下： 123456789101112131415// NativeAllocationRegistry.java// （简化）public void registerNativeAllocation(Object referent, long nativePtr) &#123; CleanerThunk thunk thunk = new CleanerThunk(); // Cleaner 绑定 Java 对象与回收函数 Cleaner cleaner = Cleaner.create(referent, thunk); // 注册 native 内存 registerNativeAllocation(this.size); thunk.setNativePtr(nativePtr);&#125;private class CleanerThunk implements Runnable &#123; // 代码省略，下文补充...&#125; 看到这里，上文提出的第一个疑问就可以解释了，原来NativeAllocationRegistry内部是利用了sun.misc.Cleaner.java机制，简单来说：使用虚引用得知对象被GC的时机，在GC前执行额外的回收工作。 # 举一反三DirectByteBuffer内部也是利用了Cleaner实现堆外内存的释放的。若不了解，请务必阅读：《Java | 堆内存与堆外内存》 123456789101112131415161718192021private class CleanerThunk implements Runnable &#123; // native 层对象的地址 private long nativePtr; public CleanerThunk() &#123; this.nativePtr = 0; &#125; public void run() &#123; if (nativePtr != 0) &#123; // 【分析点 4：执行内存回收方法】 applyFreeFunction(freeFunction, nativePtr); // 【分析点 5：注销 native 内存】 registerNativeFree(size); &#125; &#125; public void setNativePtr(long nativePtr) &#123; this.nativePtr = nativePtr; &#125;&#125; 继续往下看，CleanerThunk其实是Runnable的实现类，run()在Java层对象被垃圾回收时触发，主要做了两件事： 分析点 4：执行内存回收方法 123456789101112131415public static native void applyFreeFunction(long freeFunction, long nativePtr);// NativeAllocationRegistry.cpptypedef void (*FreeFunction)(void*);static void NativeAllocationRegistry_applyFreeFunction(JNIEnv*, jclass, jlong freeFunction, jlong ptr) &#123; void* nativePtr = reinterpret_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(ptr)); FreeFunction nativeFreeFunction = reinterpret_cast&lt;FreeFunction&gt;(static_cast&lt;uintptr_t&gt;(freeFunction)); // 调用回收函数 nativeFreeFunction(nativePtr);&#125; 可以看到，applyFreeFunction(...)最终就是执行到了前面提到的内存回收函数，对于Bitmap就是Bitmap_destruct() 分析点 5：注册 &#x2F; 注销native内存 123456789101112131415// NativeAllocationRegistry.java// 注册 native 内存registerNativeAllocation(this.size);// 注销 native 内存registerNativeFree(size);// 提示：这一层函数其实就是为了将参数转为longprivate static void registerNativeAllocation(long size) &#123; VMRuntime.getRuntime().registerNativeAllocation((int)Math.min(size, Integer.MAX_VALUE));&#125;private static void registerNativeFree(long size) &#123; VMRuntime.getRuntime().registerNativeFree((int)Math.min(size, Integer.MAX_VALUE));&#125; 向VM注册native内存，比便在内存占用达到界限时触发GC，在该native内存回收时，需要向VM注销该内存量 对比 Android 8.0 之前回收 native 内存的方式前面我们已经分析完NativeAllocationRegistry的源码了，我们看一看在Android 8.0之前，Bitmap是用什么方法回收native内存的，涉及文件： &#x2F;frameworks&#x2F;base&#x2F;graphics&#x2F;java&#x2F;android&#x2F;graphics&#x2F;Bitmap.java 共同点： 分配的native层内存需要向VM注册 &#x2F; 注销 通过一个native层的内存回收函数来回收内存 不同点： NativeAllocationRegistry依赖于sun.misc.Cleaner.java BitmapFinalizer依赖于Object#finalize() 我们知道，finalize()在Java对象被垃圾回收时会调用，BitmapFinalizer就是利用了这个机制来回收native层内存的。 12345678以下是关于 finalize() 方法的一些要点：finalize() 方法的定义： finalize() 是一个在 Object 类中定义的方法，所有的 Java 类都可以选择覆盖它。它的签名为 protected void finalize() throws Throwable。垃圾回收触发： 当垃圾回收器决定要回收一个对象时（即对象变得不可达），在回收对象之前，会调用对象的 finalize() 方法。这个方法可能会在对象被回收之前执行一些清理操作，例如释放底层资源或资源的解引用。finalize() 方法的调用时机不确定： 由于垃圾回收的时机是不确定的，因此 finalize() 方法的调用时机也是不确定的。这意味着不能依赖于它来进行资源的及时释放或其他重要的清理操作。避免过度依赖 finalize()： 由于 finalize() 方法的调用时机不确定，且可能会影响性能，通常不建议过度依赖它。更好的做法是使用显式的资源管理，例如使用 try-finally 块来确保资源的释放。不同的垃圾回收方式： Java 使用不同的垃圾回收策略，包括标记-清除、标记-压缩等。在不同的垃圾回收方式中，finalize() 方法的调用时机可能会有所不同。需要注意的是，自从 Java 9 开始，finalize() 方法已经被标记为废弃（deprecated），这意味着在未来的 Java 版本中可能会被移除。推荐的做法是使用更可靠的资源管理和垃圾回收机制，例如使用 AutoCloseable 接口和 try-with-resources 语句来确保资源的正确释放。 再举几个常用的类在Android 8.0之前的源码为例子，原理都大同小异：Matrix.java (before Android 8.0)、Canvas.java (before Android 8.0) 12345678910111213141516171819202122232425262728293031323334353637383940414243// Matrix.java@Overrideprotected void finalize() throws Throwable &#123; try &#123; finalizer(native_instance); &#125; finally &#123; super.finalize(); &#125;&#125;private static native void finalizer(long native_instance);// Canvas.javaprivate final CanvasFinalizer mFinalizer;private static final class CanvasFinalizer &#123; private long mNativeCanvasWrapper; public CanvasFinalizer(long nativeCanvas) &#123; mNativeCanvasWrapper = nativeCanvas; &#125; @Override protected void finalize() throws Throwable &#123; try &#123; dispose(); &#125; finally &#123; super.finalize(); &#125; &#125; public void dispose() &#123; if (mNativeCanvasWrapper != 0) &#123; finalizer(mNativeCanvasWrapper); mNativeCanvasWrapper = 0; &#125; &#125;&#125;public Canvas() &#123; // 省略其他代码... mFinalizer = new CanvasFinalizer(mNativeCanvasWrapper);&#125; 问题回归 NativeAllocationRegistry利用虚引用感知Java对象被回收的时机，来回收native层内存 在Android 8.0 (API 27)之前，Android通常使用Object#finalize()调用时机来回收native层内存 Bitmap 的内存复用Bitmap 绝对是我们 Android 开发中最容易引起 OOM 的对象之一，因为其占用的像素数据内存比较大，而加载图片又是很常见的操作。如果不断反复的去开辟和销毁 Bitmap 数据内存，势必可能会引起应用的内存抖动，因此 Google 的开发者也为我们想了一些办法，那就是允许 Bitmap 内存复用，具体如下： 被复用的 Bitmap 必须为 Mutable（通过 BitmapFactory.Options 设置） 这是因为复用操作涉及对 Bitmap 对象像素数据的修改，而只有 Mutable 的 Bitmap 才允许对其像素数据进行修改。 4.4 之前 图像格式： 被复用的 Bitmap 和要解码的图像必须具有相同的像素格式，通常是 ARGB_8888 或 RGB_565 格式。这是因为像素格式的不匹配可能导致解码失败或图像显示异常。 图像尺寸： 被复用的 Bitmap 和要解码的图像必须具有相同的尺寸。如果尺寸不匹配，复用操作将被忽略。 图像类型： 在 Android 4.4 之前，被复用的 Bitmap 和要解码的图像必须是 JPEG 或 PNG 格式。其他格式的图像将无法被复用。 inSampleSize 设置： BitmapFactory.Options 的 inSampleSize 字段必须设置为 1，以表示不进行图像的缩放。这是因为在进行图像缩放的情况下，图像的尺寸和复用的 Bitmap 尺寸可能不匹配。 4.4 以后 BitmapFactory.Options 的 inBitmap 字段用于指定要复用的 Bitmap 对象。通过设置这个字段，你可以告诉解码器将解码后的图像数据存储在已经存在的 Bitmap 中，以便进行复用。 同时，要注意以下几点： 被解码的图像的内存大小不应该超过要复用的 Bitmap 的内存大小。 被解码的图像和要复用的 Bitmap 的像素格式和尺寸应该匹配。 解码时需要设置 inSampleSize 为 1，以确保图像不会被缩放。 12345678910111213// 不复用的写法，消耗内存 32 MlogMemory();Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.test2);Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.test2);logMemory();// 复用的写法，消耗内存 16 MlogMemory();BitmapFactory.Options options = new BitmapFactory.Options();options.inMutable = true;Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.test2, options);options.inBitmap = bitmap1;Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.test2, options);logMemory(); 在 Glide 中，Bitmap 复用是通过使用 BitmapPool 接口来实现的。BitmapPool 是一个用于管理和复用 Bitmap 对象的接口，它允许 Glide 在加载和显示图像时复用之前分配的 Bitmap 对象，从而减少内存分配和垃圾回收的开销。 以下是简要的 Glide Bitmap 复用的流程： Glide 首先会尝试从 BitmapPool 中获取一个可复用的 Bitmap 对象。如果 BitmapPool 中存在满足条件的 Bitmap，就会使用它。 如果 BitmapPool 中没有可复用的 Bitmap，Glide 会根据要加载的图像的尺寸和像素格式创建一个新的 Bitmap 对象。 加载和显示图像时，Glide 会将 Bitmap 对象放入 BitmapPool，以便以后可以复用。 为了更深入地了解 Glide 中 Bitmap 复用的实现，你可以查阅 Glide 的源代码，并关注以下关键部分： BitmapPool 接口及其实现类：Glide 使用 BitmapPool 接口来管理 Bitmap 对象的复用。BitmapPool 接口定义了一系列的方法，如 get() 获取可复用的 Bitmap，put() 将 Bitmap 放回池中等。在 Glide 源代码中，你可以查看 LruBitmapPool 和其他的 BitmapPool 实现类。 BitmapImageViewTarget：Glide 使用 BitmapImageViewTarget 来将 Bitmap 显示在 ImageView 中。在这个类中，你可以看到 Glide 如何从 BitmapPool 中获取可复用的 Bitmap 对象。 图片加载流程：Glide 的图片加载流程涉及到许多类和接口，包括请求管理、数据加载、资源解码等。在这些类中，你可以找到 Glide 如何利用 Bitmap 复用来优化内存使用。 Glide Bitmap 复用源代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381package com.bumptech.glide.load.engine.bitmap_recycle;import android.annotation.SuppressLint;import android.annotation.TargetApi;import android.content.ComponentCallbacks2;import android.graphics.Bitmap;import android.graphics.Color;import android.os.Build;import android.util.Log;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.bumptech.glide.util.Synthetic;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.Set;/** * An &#123;@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool&#125; implementation that uses an * &#123;@link com.bumptech.glide.load.engine.bitmap_recycle.LruPoolStrategy&#125; to bucket &#123;@link Bitmap&#125;s * and then uses an LRU eviction policy to evict &#123;@link android.graphics.Bitmap&#125;s from the least * recently used bucket in order to keep the pool below a given maximum size limit. */public class LruBitmapPool implements BitmapPool &#123; private static final String TAG = &quot;LruBitmapPool&quot;; private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888; private final LruPoolStrategy strategy; private final Set&lt;Bitmap.Config&gt; allowedConfigs; private final long initialMaxSize; private final BitmapTracker tracker; private long maxSize; private long currentSize; private int hits; private int misses; private int puts; private int evictions; // Exposed for testing only. LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123; this.initialMaxSize = maxSize; this.maxSize = maxSize; this.strategy = strategy; this.allowedConfigs = allowedConfigs; this.tracker = new NullBitmapTracker(); &#125; /** * Constructor for LruBitmapPool. * * @param maxSize The initial maximum size of the pool in bytes. */ public LruBitmapPool(long maxSize) &#123; this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs()); &#125; /** * Constructor for LruBitmapPool. * * @param maxSize The initial maximum size of the pool in bytes. * @param allowedConfigs A white listed put of &#123;@link android.graphics.Bitmap.Config&#125; that are * allowed to be put into the pool. Configs not in the allowed put will be rejected. */ // Public API. @SuppressWarnings(&quot;unused&quot;) public LruBitmapPool(long maxSize, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123; this(maxSize, getDefaultStrategy(), allowedConfigs); &#125; /** Returns the number of cache hits for bitmaps in the pool. */ public long hitCount() &#123; return hits; &#125; /** Returns the number of cache misses for bitmaps in the pool. */ public long missCount() &#123; return misses; &#125; /** Returns the number of bitmaps that have been evicted from the pool. */ public long evictionCount() &#123; return evictions; &#125; /** Returns the current size of the pool in bytes. */ public long getCurrentSize() &#123; return currentSize; &#125; @Override public long getMaxSize() &#123; return maxSize; &#125; @Override public synchronized void setSizeMultiplier(float sizeMultiplier) &#123; maxSize = Math.round(initialMaxSize * sizeMultiplier); evict(); &#125; @Override public synchronized void put(Bitmap bitmap) &#123; if (bitmap == null) &#123; throw new NullPointerException(&quot;Bitmap must not be null&quot;); &#125; if (bitmap.isRecycled()) &#123; throw new IllegalStateException(&quot;Cannot pool recycled bitmap&quot;); &#125; if (!bitmap.isMutable() || strategy.getSize(bitmap) &gt; maxSize || !allowedConfigs.contains(bitmap.getConfig())) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v( TAG, &quot;Reject bitmap from pool&quot; + &quot;, bitmap: &quot; + strategy.logBitmap(bitmap) + &quot;, is mutable: &quot; + bitmap.isMutable() + &quot;, is allowed config: &quot; + allowedConfigs.contains(bitmap.getConfig())); &#125; bitmap.recycle(); return; &#125; final int size = strategy.getSize(bitmap); strategy.put(bitmap); tracker.add(bitmap); puts++; currentSize += size; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Put bitmap in pool=&quot; + strategy.logBitmap(bitmap)); &#125; dump(); evict(); &#125; private void evict() &#123; trimToSize(maxSize); &#125; @Override @NonNull public Bitmap get(int width, int height, Bitmap.Config config) &#123; Bitmap result = getDirtyOrNull(width, height, config); if (result != null) &#123; // Bitmaps in the pool contain random data that in some cases must be cleared for an image // to be rendered correctly. we shouldn&#x27;t force all consumers to independently erase the // contents individually, so we do so here. See issue #131. result.eraseColor(Color.TRANSPARENT); &#125; else &#123; result = createBitmap(width, height, config); &#125; return result; &#125; @NonNull @Override public Bitmap getDirty(int width, int height, Bitmap.Config config) &#123; Bitmap result = getDirtyOrNull(width, height, config); if (result == null) &#123; result = createBitmap(width, height, config); &#125; return result; &#125; @NonNull private static Bitmap createBitmap(int width, int height, @Nullable Bitmap.Config config) &#123; return Bitmap.createBitmap(width, height, config != null ? config : DEFAULT_CONFIG); &#125; @TargetApi(Build.VERSION_CODES.O) private static void assertNotHardwareConfig(Bitmap.Config config) &#123; // Avoid short circuiting on sdk int since it breaks on some versions of Android. if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123; return; &#125; if (config == Bitmap.Config.HARDWARE) &#123; throw new IllegalArgumentException( &quot;Cannot create a mutable Bitmap with config: &quot; + config + &quot;. Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your&quot; + &quot; RequestOptions and/or in GlideBuilder.setDefaultRequestOptions&quot;); &#125; &#125; @Nullable private synchronized Bitmap getDirtyOrNull( int width, int height, @Nullable Bitmap.Config config) &#123; assertNotHardwareConfig(config); // Config will be null for non public config types, which can lead to transformations naively // passing in null as the requested config here. See issue #194. final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG); if (result == null) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Missing bitmap=&quot; + strategy.logBitmap(width, height, config)); &#125; misses++; &#125; else &#123; hits++; currentSize -= strategy.getSize(result); tracker.remove(result); normalize(result); &#125; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Get bitmap=&quot; + strategy.logBitmap(width, height, config)); &#125; dump(); return result; &#125; // Setting these two values provides Bitmaps that are essentially equivalent to those returned // from Bitmap.createBitmap. private static void normalize(Bitmap bitmap) &#123; bitmap.setHasAlpha(true); maybeSetPreMultiplied(bitmap); &#125; @TargetApi(Build.VERSION_CODES.KITKAT) private static void maybeSetPreMultiplied(Bitmap bitmap) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; bitmap.setPremultiplied(true); &#125; &#125; @Override public void clearMemory() &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;clearMemory&quot;); &#125; trimToSize(0); &#125; @SuppressLint(&quot;InlinedApi&quot;) @Override public void trimMemory(int level) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;trimMemory, level=&quot; + level); &#125; if ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) || ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &amp;&amp; (level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN))) &#123; clearMemory(); &#125; else if ((level &gt;= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) || (level == ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL)) &#123; trimToSize(getMaxSize() / 2); &#125; &#125; private synchronized void trimToSize(long size) &#123; while (currentSize &gt; size) &#123; final Bitmap removed = strategy.removeLast(); // TODO: This shouldn&#x27;t ever happen, see #331. if (removed == null) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, &quot;Size mismatch, resetting&quot;); dumpUnchecked(); &#125; currentSize = 0; return; &#125; tracker.remove(removed); currentSize -= strategy.getSize(removed); evictions++; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Evicting bitmap=&quot; + strategy.logBitmap(removed)); &#125; dump(); removed.recycle(); &#125; &#125; private void dump() &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; dumpUnchecked(); &#125; &#125; private void dumpUnchecked() &#123; Log.v( TAG, &quot;Hits=&quot; + hits + &quot;, misses=&quot; + misses + &quot;, puts=&quot; + puts + &quot;, evictions=&quot; + evictions + &quot;, currentSize=&quot; + currentSize + &quot;, maxSize=&quot; + maxSize + &quot;\\nStrategy=&quot; + strategy); &#125; private static LruPoolStrategy getDefaultStrategy() &#123; final LruPoolStrategy strategy; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; strategy = new SizeConfigStrategy(); &#125; else &#123; strategy = new AttributeStrategy(); &#125; return strategy; &#125; @TargetApi(Build.VERSION_CODES.O) private static Set&lt;Bitmap.Config&gt; getDefaultAllowedConfigs() &#123; Set&lt;Bitmap.Config&gt; configs = new HashSet&lt;&gt;(Arrays.asList(Bitmap.Config.values())); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; // GIFs, among other types, end up with a native Bitmap config that doesn&#x27;t map to a java // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured // and are suitable for re-use. configs.add(null); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; configs.remove(Bitmap.Config.HARDWARE); &#125; return Collections.unmodifiableSet(configs); &#125; private interface BitmapTracker &#123; void add(Bitmap bitmap); void remove(Bitmap bitmap); &#125; @SuppressWarnings(&quot;unused&quot;) // Only used for debugging private static class ThrowingBitmapTracker implements BitmapTracker &#123; private final Set&lt;Bitmap&gt; bitmaps = Collections.synchronizedSet(new HashSet&lt;Bitmap&gt;()); @Override public void add(Bitmap bitmap) &#123; if (bitmaps.contains(bitmap)) &#123; throw new IllegalStateException( &quot;Can&#x27;t add already added bitmap: &quot; + bitmap + &quot; [&quot; + bitmap.getWidth() + &quot;x&quot; + bitmap.getHeight() + &quot;]&quot;); &#125; bitmaps.add(bitmap); &#125; @Override public void remove(Bitmap bitmap) &#123; if (!bitmaps.contains(bitmap)) &#123; throw new IllegalStateException(&quot;Cannot remove bitmap not in tracker&quot;); &#125; bitmaps.remove(bitmap); &#125; &#125; private static final class NullBitmapTracker implements BitmapTracker &#123; @Synthetic NullBitmapTracker() &#123;&#125; @Override public void add(Bitmap bitmap) &#123; // Do nothing. &#125; @Override public void remove(Bitmap bitmap) &#123; // Do nothing. &#125; &#125;&#125; 下面对代码进行逐段分析： 导入相关的包和类。 定义了一个名为 “LruBitmapPool” 的类，实现了 “BitmapPool” 接口，用于管理位图内存池。 定义了一些常量，如默认的位图配置和日志标签。 声明了一些成员变量，包括内存池策略、允许的位图配置、最大大小、当前大小、命中次数、未命中次数、添加次数和驱逐次数等。 构造函数，初始化内存池大小、策略和允许的位图配置等。 提供了一些公开方法用于获取统计信息，如命中次数、未命中次数、驱逐次数、当前大小等。 实现了 “BitmapPool” 接口中的一些方法，包括 setSizeMultiplier、put、get、getDirty、clearMemory、trimMemory 等。 定义了一些辅助方法，如 evict、assertNotHardwareConfig、normalize、maybeSetPreMultiplied、getDirtyOrNull、trimToSize、dump 和 dumpUnchecked 等。 定义了 “BitmapTracker” 接口，其中包含了添加和移除位图的方法。 定义了一些实现了 “BitmapTracker” 接口的类，如 “ThrowingBitmapTracker” 和 “NullBitmapTracker”。 总体来说，这段代码实现了一个基于 LRU（Least Recently Used）算法的位图内存池，用于管理位图对象的内存分配和回收。它可以跟踪位图的使用情况，限制内存池的大小，通过策略进行位图的管理和驱逐，以及提供一些统计信息用于优化和调试。 Gilde 是如何实现 Bitmap 复用的？在这段代码中，实现位图复用的核心思想是通过内存池策略（LruPoolStrategy）来管理位图的存储和获取。下面我将详细解释如何实现位图的复用： put(Bitmap bitmap) 方法：当你想要回收一个位图时，会调用这个方法。它会首先判断位图是否为空、是否已经被回收、是否是可变的位图，位图大小是否超过了内存池的最大大小，以及位图的配置是否允许被放入内存池。如果这些条件都满足，它会将位图放入内存池策略中，并更新当前内存池的大小。 get(int width, int height, Bitmap.Config config) 和 getDirty(int width, int height, Bitmap.Config config) 方法：当你想要获取一个位图时，会调用这两个方法之一。它首先会尝试从内存池策略中获取满足条件的位图，如果找到则返回该位图，否则会创建一个新的位图并返回。这里的位图创建使用了 Bitmap.createBitmap() 方法，确保了返回的位图是可复用的。 trimToSize(long size) 方法：当内存池的当前大小超过了最大限制时，会调用这个方法进行驱逐。它会循环地从内存池策略中移除最近未使用的位图，直到当前内存池大小小于等于指定的大小。 LruPoolStrategy 接口的实现：这个接口定义了位图内存池策略的规范，包括位图的添加、获取、移除等操作。在这段代码中，有两个实现类：SizeConfigStrategy 和 AttributeStrategy，分别在不同的 Android 版本上进行位图的管理。 通过这些机制，当位图被回收时，它会被添加到内存池中，下次需要位图时会优先从内存池中获取，以达到位图复用的效果。这样可以减少内存分配和回收的开销，提高性能和效率。 BitMap 创建，内存申请与内存模型相关内容整理参考自 作者：红橙Darren链接：https://www.jianshu.com/p/8e8ad414237e来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 具体回收细节参考自 版权声明：本文为CSDN博主「shihongyu12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/shihongyu12345/article/details/89681948 NativeAllocationRegistry 的原理与设计思想 摘录自 作者：彭旭锐链接：https://www.jianshu.com/p/6f042f9e47a8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 部分相关知识来自于 chat-GPT 3.5","categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"6. N 字形变换","slug":"算法/算法题目/6 N 字形变换","date":"2023-08-10T23:03:03.198Z","updated":"2023-08-10T23:16:29.104Z","comments":true,"path":"2023/08/11/算法/算法题目/6 N 字形变换/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"","text":"题目将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1： 12输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot; 示例 2： 1234567输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P I NA L S I GY A H RP I 示例 3： 12输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由英文字母（小写和大写）、&#39;,&#39; 和 &#39;.&#39; 组成 1 &lt;= numRows &lt;= 1000 简介1234重点不在字形，重点在变换是什么变换关键词：一维函数变二维函数往复变化函数 正文我们思考，为什么这个算法难写分析 N字形 的离散函数，我们面临着一个唯一的 x 对应着 1- N 个 y在 x 变化的时候，我们首先要算该 x 对应了几个 y这根本不符合函数的定义函数是指一个集合中的每个元素都有且仅有一个映射到另一个集合中的元素，这种关系被称为函数映射 推出我们需要把一个一维度线性离线函数 s &#x3D; f(n) 变成二维离散函数 s &#x3D; g(x, y)注意，这里好玩的是 y 和 x 其实是数列即 s &#x3D; g(x(n), y(n))我们开始推导 123456789101112x(n) = x(n-1) + 1函数 x(n) 很简单，我们怎么表达 y(n) 呢我们发现 y(n) 是一个往复的等差数列对于本题有y(n) = y(n - 1) + step(n)step 是一个往复函数用 flag 代表往复函数的方向 | -1 当 y(n - 1) 到达最大值或者最小值时flag = | 1 其他step(n) = flag * step(n-1) 当 y(n - 1) 到达最大值或者最小值时 | -step(n-1) 其他step(n) = | step(n) 1234567891011121314151617class Solution &#123; fun convert(s: String, numRows: Int): String &#123; 推出 (numRows &lt; 2) return s val rows: MutableList&lt;StringBuilder&gt; = ArrayList() for (i in 0 until numRows) rows.add(StringBuilder()) var i = 0 var step = -1 for (c in s.toCharArray()) &#123; rows[i].append(c) if (i == 0 || i == numRows - 1) step = -step i += step &#125; val res = StringBuilder() for (row in rows) res.append(row) return res.toString() &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.1 - 中等","slug":"0-算法/0-1-算法题目/0-1-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-1-%E4%B8%AD%E7%AD%89/"}],"tags":[]},{"title":"5. 最长回文子串","slug":"算法/算法题目/5 最长回文子串","date":"2023-08-10T23:02:44.060Z","updated":"2023-08-10T23:16:25.534Z","comments":true,"path":"2023/08/11/算法/算法题目/5 最长回文子串/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 简介12345介绍 Manacher 算法理解回文串的对称性，减少与回文串相交的字符串的计算量关键词情况一：完全包含，直接赋值情况二：部分相交。直接从后一位接续计算 正文数据预处理： 首先回文子串有两种形式 奇数 与 偶数 也就有两种对应的指针操作方式 假定有字符数组 ababaabc 改成 # a # b # a # b # a # a # b # c # 将偶数数组变成奇数统一处理 索性改成 ^ # a # b # a # b # a # a # b # c # $，头尾清晰这样就可以通过把每个字符作为回文子串的中心向两边扩展，找出最长回文子串 时间复杂度是 O(n^2) 现在需要我们观察回文子串的规律，简化计算 123456789101112131415161718192021 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ^ # a # b # a # b # a # a # b # c # $0 ^ P[0] = 01 ^ P[1] = 02 --^-- p[2] = 13 ^ P[3] = 04 ------^------ P[4] = 35 ^ P[5] = 06 ----------^---------- P[6] = 57 ^ P[7] = 08 ------^------ P[8] = 39 ^ P[9] = 010 --^-- P[10] = 111 --------^-------- P[11] = 212 --^-- P[12] = 013 ^ P[13] = 014 --^-- P[14] = 115 ^ P[15] = 016 --^-- P[16] = 117 ^ P[17] = 018 ^ P[18] = 0 情况一： 12310 --^-- P[10] = 111 --------^-------- P[11] = 212 --^-- P[12] = 0 第 10 行，第 12 行 都是 第 11 行 的子串，完全包含在 第 11 行 之中，由于回文串的对称性 此时直接有 P[10] &#x3D; P[12] 情况二： 1234 ------^------ P[4] = 36 ----------^---------- P[6] = 58 ------^------ P[8] = 3 第 4 行，第 8 行 都是 第 6 行 的子串，分别位于字符串的两端，当我们知道 第 4 行 的信息之后，我们知道 第 8 行 至少有 第 4 行 那么长，至于会不会更长，继续试着向两边扩展即可 此时需要干两件事 1. 将 P[8] &#x3D; P[4]; 2. 继续向外扩展 情况三： 8 ——^—— P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 第 8 行 部分与 第 11 行 重叠，第 14 行 是 第 11 行 的子串，非常简单，舍弃超出部分 8 –^– P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 当成这样处理即可 定义遍历指针 i ，指向回文的中心的指针 center 和 指向回文串右边界的指针 r 此时需要干两件事 1. 将 P[8] &#x3D; r - i ; 2. 继续向外扩展 好，我们现在已经理解了 Manacher 算法的精髓了 我们思考一下算法该怎么写 P[i] 计算过程 123456789101112131415161718192021 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ^ # a # b # a # b # a # a # b # c # $0 ^ P[0] = 0 -- 起始，不必计算，更新 r1 ^ P[1] = 0 -- 暴力计算，一次计算，更新 r2 --^-- p[2] = 1 -- 暴力计算，二次计算，更新 r3 ^ P[3] = 0 -- 情况二，一次计算4 ------^------ P[4] = 3 -- 暴力计算，四次计算，更新 r5 ^ P[5] = 0 -- 情况一，零次计算6 ----------^---------- P[6] = 5 -- 情况二，六次计算，更新 r7 ^ P[7] = 0 -- 情况一，零次计算8 ------^------ P[8] = 3 -- 情况二，一次计算9 ^ P[9] = 0 -- 情况一，零次计算10 --^-- P[10] = 1 -- 情况二，一次计算11 --------^-------- P[11] = 2 -- 情况二，五次计算，更新 r12 --^-- P[12] = 0 -- 情况一，零次计算13 ^ P[13] = 0 -- 情况一，零次计算14 --^-- P[14] = 1 -- 情况三，一次计算15 ^ P[15] = 0 -- 情况二，一次计算16 --^-- P[16] = 1 -- 暴力计算，两次计算，更新 r17 ^ P[17] = 0 -- 情况二，一次计算18 ^ P[18] = 0 -- 终止 我列出了每次计算面对的情况，计算的次数以及是否需要 r 我希望大家思考 当新计算出的 r 与旧的 r 相等时，是否应该更新 center ？ 当然不应该，我们肯定更倾向于选择更长的回文串 是这样吗？ 我们思考一种情况 1234567892 --^-- p[2] = 13 ^ P[3] = 04 ------^------ P[4] = 35 ^ P[5] = 06 ----------^---------- P[6] = 57 ^ P[7] = 08 ------^------ P[8] = 39 ^ P[9] = 010 --^-- P[10] = 1 第 6 行 较长有什么用呢，有用的只是 i 到 r 这一小截而已，不更新是因为都一样，没必要更新，所以只有当我们发现了更右边的 r 更新即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; private fun formatString(s: String): String&#123; val tString : StringBuffer = StringBuffer(&quot;^#&quot;) for ( i in s.indices )&#123; tString.append(s[i]) tString.append(&#x27;#&#x27;) &#125; return tString.append(&#x27;$&#x27;).toString() &#125; private fun extend(s: String, leftIndex: Int, rightIndex: Int): Int &#123; var r = 0 var left = leftIndex var right = rightIndex while (left &gt; 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] == s[right])&#123; r ++ left -- right ++ &#125; return r &#125; fun longestPalindrome(s: String): String &#123; val tString = formatString(s) var maxR = 0 var maxCenter = 0 var center = -1 var R = 0 val p = Array&lt;Int&gt;(tString.length) &#123; 0 &#125; for ( i in tString.indices )&#123; val iMirror = center - (i - center) var rightIndex = i var leftIndex = i val maxLength = R - i val hasMirrorIndex = i &lt; R &amp;&amp; center - maxLength &gt; 0 val case1CompletelyIncluded = hasMirrorIndex &amp;&amp; i &gt; center &amp;&amp; p[iMirror] &lt; R - i val case2NotCompletelyInclude = hasMirrorIndex &amp;&amp; !case1CompletelyIncluded if(!hasMirrorIndex)&#123; p[i] = 0 rightIndex = i + 1 leftIndex = i - 1 &#125; else &#123; if(case1CompletelyIncluded) &#123; p[i] = p[iMirror] continue &#125; else if (case2NotCompletelyInclude) &#123; p[i] = maxLength rightIndex = R + 1 leftIndex = i - (rightIndex - i) &#125; &#125; p[i] += extend(tString, leftIndex, rightIndex) // 更新最右边的 R 和 center if(i + p[i] &gt; R)&#123; R = i + p[i] center = i &#125; // 判断是不是最长的回文串 if(p[i] &gt; maxR)&#123; maxR = p[i] maxCenter = i &#125; &#125; if(maxR == 0) return &quot;&quot; val start = maxCenter - maxR val end = maxCenter + maxR return tString.substring(start..end).replace(&quot;#&quot;, &quot;&quot;) &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.1 - 中等","slug":"0-算法/0-1-算法题目/0-1-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-1-%E4%B8%AD%E7%AD%89/"}],"tags":[]},{"title":"4. 寻找两个正序数组的中位数","slug":"算法/算法题目/4 寻找两个正序数组的中位数","date":"2023-08-10T23:02:39.591Z","updated":"2023-08-10T23:16:22.327Z","comments":true,"path":"2023/08/11/算法/算法题目/4 寻找两个正序数组的中位数/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"题目给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 123输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 123输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6 简介123456789101112讨论在两个有序数组中寻找中位数的问题观察单个有序数组，通过比较元素大小找到舍弃的元素，确定中位数。类推两个有序数组，准备两个区间来存放偏小值和偏大值。根据区间需要满足必要条件，使得偏小区间的元素都小于偏大区间。问题转化为在单个有序数组中查找满足条件的关键元素位置，可以使用二分查找。关键词:偏小区间偏大区间二分查找 正文首先思考我们是否可以避免全排序找到中位数 我们有一种想法就是通过比较元素的大小找到需要舍弃的元素 我们观察一个有序数组，我们准备两个区间 RSmall, RBig 分别存放这个数组的偏小值与偏大值（相对中位数而言） 分别用 left，right 指针从两头操作偏小值与偏大值，将他们依次放入对应的数组 直到 「偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1」，中位数显然易得 好，现在我们来看两个有序数组的复杂情况 我们同样准备两个区间 RSmall, RBig，同样我们需要将数组偏小值放进 RSmall，偏大值放进 RBig 与一个有序数组不同的是，现在我们必须综合考虑两个有序数组的情况 所以 RSmall 区间里可能既包含 num1 数组的偏小元素也包含 num2 数组的偏小元素，对于RBig也是一样 这就让我们的思考变得复杂了，这使得 RSmall，RBig 变得无序 现在将这个 RSmall 再细分为 RSmallN1 区间，以及 RSmallN2 区间，同样有 RBigN1，RBigN2 区间 想要得到中位数，那么偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1 也就有 「 必要条件一： 偶数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size 奇数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size +1 」 同时 RSmall 区间内任何一个元素都必须小于 RBig 区间 自然有 Small 区间的子区间的任何一个元素都小于 Big 区间的子区间的任何一个元素 所以得到 「 必要条件二： RSmallN1 的最大值 &lt; RBigN1 的最小值 ( 因为数组有序，这是不用判断的 ) RSmallN1 的最大值 &lt; RBigN2 的最小值 RSmallN2 的最大值 &lt; RBigN1 的最小值 RSmallN2 的最大值 &lt; RBigN2 的最小值 ( 因为数组有序，这是不用判断的 )」 简化一下 「 必要条件二： maxOf( RSmallN1 ) &lt; minOf ( RBigN2 ) maxOf( RSmallN2 ) &lt; minOf ( RBigN1 ) 」 显然必要条件一加上必要条件二就是充分必要条件 现在我们要得到这四个区间，或者说要在两个有序数组分别划分出这四个区间 我们要在这两个数组中分别找到关键的那个分隔元素 因为必要条件一的原因，我们找到了 num1 数组的分割元素，我们也就找到了 num2 数组的分割元素 这非常好理解，因为 Small 区间和 Big 区间的数量是固定的，RSmallN1 多了一个元素，RSmallN2 就要对应减少一个元素 所以我们只要找到 num1 数组的分隔元素即可 至此，问题成功转化成了 在 num1 数组中查找出一个关键元素位置，这个关键元素满足上述两条必要条件 这是一个典型的有判断条件的查找问题，我们就可以使用二分查找，测试每个元素是否符合上述两个条件 关于二分查找这里不再赘述。 以下是基于二分查找的 Kotlin 代码实现，用于找出两个有序数组的中位数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 该函数用于在两个已排序整数数组中找到它们的中位数，返回类型为 Double。fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123; // 获取 nums1 和 nums2 的长度。 val n1 = nums1.size val n2 = nums2.size // 如果 nums1 的长度大于 nums2，则交换它们，确保 nums1 的长度小于等于 nums2。 if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1) &#125; // 设置左右指针的初始值。 var left = 0 // 如果把 num1 和 num2 合并元素重新排序，最左边 var right = n1 // 如果把 num1 和 num2 合并元素重新排序，相当于 num2 最左边 // 当左指针小于等于右指针时，执行二分查找。 while (left &lt;= right) &#123; // 因为 n1 &lt; n2 // 计算 nums1 中间的索引 i 和 nums2 中间的索引 j。 val num1HalfIndex = (left + right) / 2 val num2HalfIndex = ((n1 + n2 + 1) / 2) - num1HalfIndex // 计算 nums1 和 nums2 的左侧和右侧的最大值和最小值。 val maxOfNum1SmallRange = if (num1HalfIndex == 0) Int.MIN_VALUE else nums1[num1HalfIndex - 1] // nums1 小区间的最大值 val minOfNum1BigRange = if (num1HalfIndex == n1) Int.MAX_VALUE else nums1[num1HalfIndex] // nums1 大区间的最小值 val maxOfNum2SmallRange = if (j == 0) Int.MIN_VALUE else nums2[j - 1] // nums2 小区间的最大值 val minOfNum2BigRange = if (j == n2) Int.MAX_VALUE else nums2[j] // nums2 大区间的最小值 // 如果满足条件，则返回中位数。 if (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; // num1小 &lt; num2大 &amp;&amp; num2小 &lt; num1大, 也就是说“小区间都小于大区间” return if ((n1 + n2) % 2 == 0) &#123; // 如果 nums1 和 nums2 的长度之和为偶数 // 则返回左右两侧最大值和最小值的平均值。 (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / 2.0 &#125; else &#123; // 如果 nums1 和 nums2 的长度之和为奇数，则返回左侧最大值。 maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() &#125; &#125; else if (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; // num1大 &lt; num2小 // 如果 nums1 的左侧最大值大于 nums2 的右侧最小值，则需要将 num1HalfIndex 向左移动。 /* left num1HalfIndex right | | | 1 1 1 1 1 1 1 1 1 1 1 1 E 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ right = num1HalfIndex - 1 /* num1HalfIndex left | right | | | 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ &#125; else &#123; // 如果 nums2 的左侧最大值大于 nums1 的右侧最小值，则需要将 num1HalfIndex 向右移动。 /* left num1HalfIndex right | | | 1 1 1 1 1 1 1 1 1 1 1 1 E 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ left = num1HalfIndex + 1 /* 留给大家画 */ &#125; &#125; // 如果找不到中位数，则返回 0.0。 return 0.0&#125; 1234567891011121314151617181920212223242526272829fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123; val n1 = nums1.size val n2 = nums2.size if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1) &#125; var left = 0 var right = n1 while (left &lt;= right) &#123; // 因为 n1 &lt; n2 val num1HalfIndex = (left + right) / 2 val num2HalfIndex = ((n1 + n2 + 1) / 2) - num1HalfIndex val maxOfNum1SmallRange = if (num1HalfIndex == 0) Int.MIN_VALUE else nums1[num1HalfIndex - 1] val minOfNum1BigRange = if (num1HalfIndex == n1) Int.MAX_VALUE else nums1[num1HalfIndex] val maxOfNum2SmallRange = if (j == 0) Int.MIN_VALUE else nums2[j - 1] val minOfNum2BigRange = if (j == n2) Int.MAX_VALUE else nums2[j] if (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; return if ((n1 + n2) % 2 == 0) &#123; (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / 2.0 &#125; else &#123; maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() &#125; &#125; else if (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; right = num1HalfIndex - 1 &#125; else &#123; left = num1HalfIndex + 1 &#125; &#125; return 0.0&#125; 留给大家一个问题，问 N 个有序数组的中位数怎么求？","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.2 - 困难","slug":"0-算法/0-1-算法题目/0-1-2-困难","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-2-%E5%9B%B0%E9%9A%BE/"}],"tags":[]},{"title":"3. 无重复字符的最长子串","slug":"算法/算法题目/3 无重复字符的最长子串","date":"2023-08-10T23:02:32.022Z","updated":"2023-08-10T23:16:19.119Z","comments":true,"path":"2023/08/11/算法/算法题目/3 无重复字符的最长子串/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 简介12345巧妙的使用 HashMap&lt;Char, Int&gt; 记录每个字符的最新的位置巧妙的确定了每个元素对应的滑动窗口的左边界关键词：HashMap &lt;Char, Int&gt;用以查找位置窗口长度不固定，遍历指针作为左边界 正文本题的巧妙在于使用 HashMap 和 遍历指针构建了一个滑动窗口 在寻找滑动窗口的时候，我们总是固定住一端位置去寻找另一端的位置，通常需要我们找到两个端点之间的关系 来分析滑动窗口的性质：左边届位置，右边界的位置，滑动窗口的长度三者有以下这些关系：滑动窗口的长度 = 滑动窗口右边届 - 滑动窗口左边界无论算法如何变化，我们知二求一 我们分析，遍历指针和左右边界的关系有三情况一：遍历指针是滑动窗口的左边界情况二：遍历指针是滑动窗口的右边界情况三：遍历指针在滑动窗口的中间 结合滑动窗口的性质情况一：知道窗口的长度，以遍历指针为左边界情况二：窗口长度不固定，新增的元素决定窗口的长度，也就是左边界的位置情况三：对于滑动窗口算法，通常情况下遍历指针要么位于窗口的左边界，要么位于右边界，用于控制窗口的扩展和收缩。在常规的滑动窗口算法中，遍历指针并不位于窗口的中间位置。 显然这种是情况二 当滑动窗口的位置和长度变化受制于新增的元素时，我们将遍历指针设置为 12345678910111213141516171819class Solution &#123; fun lengthOfLongestSubstring(s: String): Int &#123; var maxLen = 0 // 最长不含重复字符子串的长度 var left = 0 // 窗口左边界 val map = HashMap&lt;Char, Int&gt;() // 哈希表记录字符最后出现的位置 for(right in s.indices)&#123; val char = s[right] if(map.containsKey(char) &amp;&amp; map[char]!! &gt;= left)&#123; left = (map[char]?: 0) + 1 &#125; map[char] = right maxLen = maxOf(maxLen, right - left + 1) &#125; return maxLen &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.1 - 中等","slug":"0-算法/0-1-算法题目/0-1-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-1-%E4%B8%AD%E7%AD%89/"}],"tags":[]},{"title":"2. 两数相加","slug":"算法/算法题目/2 两数相加","date":"2023-08-10T23:02:27.535Z","updated":"2023-08-10T23:16:14.223Z","comments":true,"path":"2023/08/11/算法/算法题目/2 两数相加/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"题目给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 简介1234遍历两个链表，元素相加生成新列表。关键词：哨兵节点 val dummy = ListNode(0)关键返回值 dummy?.next 正文12345678910111213141516171819202122232425262728293031323334class Solution &#123; fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123; // 定义两个指针 p1 和 p2，分别指向两个链表的头节点 var p1 = l1 var p2 = l2 // 定义一个哨兵节点 dummy，作为结果链表的头节点 val dummy = ListNode(0) // 定义一个节点 cur, 作为结果链表的尾节点 var cur = dummy var carry = 0 while(p1 != null || p2 != null)&#123; val x = p1?.`val` ?: 0 val y = p2?.`val` ?: 0 var sum = x + y + carry carry = sum / 10 sum = sum % 10 cur?.next = ListNode(sum) p1 = p1?.next p2 = p2?.next cur = cur?.next &#125; if(carry &gt; 0)&#123; cur?.next = ListNode(carry) &#125; return dummy?.next &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.0 - 简单","slug":"0-算法/0-1-算法题目/0-1-0-简单","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-0-%E7%AE%80%E5%8D%95/"}],"tags":[]},{"title":"1. 两数之和","slug":"算法/算法题目/1 两数之和","date":"2023-08-10T23:02:20.609Z","updated":"2023-08-10T23:16:09.490Z","comments":true,"path":"2023/08/11/算法/算法题目/1 两数之和/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10^4 -109 &lt;= nums[i] &lt;= 10^9 -109 &lt;= target &lt;= 10^9 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 简介1234这道题的关键在于对 hashmap 查找时间复杂度 O(1) 的应用关键词：HashMap&lt;Key, Value&gt;hashmap.containsKey(Value) 正文12345678910111213class Solution &#123; fun twoSum(nums: IntArray, target: Int): IntArray &#123; val hashmap = HashMap&lt;Int, Int&gt;() for(i in nums.indices)&#123; val complement = target - nums[i] if(hashmap.containsKey(complement))&#123; return intArrayOf(hashmap[complement]!!, i) &#125; hashmap[nums[i]] = i &#125; return intArrayOf() &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.0 - 简单","slug":"0-算法/0-1-算法题目/0-1-0-简单","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-0-%E7%AE%80%E5%8D%95/"}],"tags":[]},{"title":"01. 双指针-只有一个输入, 从两端开始遍历","slug":"算法/算法模板/01 双指针-只有一个输入, 从两端开始遍历","date":"2023-08-10T22:45:12.929Z","updated":"2023-08-10T23:13:59.328Z","comments":true,"path":"2023/08/11/算法/算法模板/01 双指针-只有一个输入, 从两端开始遍历/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/01%20%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%BB%8E%E4%B8%A4%E7%AB%AF%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86/","excerpt":"","text":"正文123456789101112131415fun doublePointer(arr: IntArray): Int &#123; var left = 0 var right = arr.size - 1 while (left &lt; right) &#123; // 根据 left 和 right 相关的条件进行操作 if (CONDITION) &#123; left++ &#125; else &#123; right-- &#125; &#125; return 0 // 返回需要的结果&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"02. 双指针-有两个输入, 两个都需要遍历完","slug":"算法/算法模板/02 双指针-有两个输入, 两个都需要遍历完","date":"2023-08-10T22:45:09.249Z","updated":"2023-08-10T23:14:20.949Z","comments":true,"path":"2023/08/11/算法/算法模板/02 双指针-有两个输入, 两个都需要遍历完/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/02%20%E5%8F%8C%E6%8C%87%E9%92%88-%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5,%20%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%E5%AE%8C/","excerpt":"","text":"正文1234567891011121314151617181920212223242526fun twoPointers(nums1: IntArray, nums2: IntArray) &#123; var pointer1 = 0 var pointer2 = 0 while (pointer1 &lt; nums1.size &amp;&amp; pointer2 &lt; nums2.size) &#123; // 处理指针1和指针2对应位置的元素 // ... // 移动指针 pointer1++ pointer2++ &#125; // 处理剩余未遍历完的元素 while (pointer1 &lt; nums1.size) &#123; // 处理指针1对应位置的元素 // ... pointer1++ &#125; while (pointer2 &lt; nums2.size) &#123; // 处理指针2对应位置的元素 // ... pointer2++ &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"03. 滑动窗口","slug":"算法/算法模板/03 滑动窗口","date":"2023-08-10T22:45:03.277Z","updated":"2023-08-10T23:14:27.087Z","comments":true,"path":"2023/08/11/算法/算法模板/03 滑动窗口/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/03%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"正文12345678910111213141516171819202122fun slidingWindow(nums: IntArray, k: Int): Int &#123; val n = nums.size var sum = 0 var maxSum = 0 // 计算第一个窗口的和 for (i in 0 until k) &#123; sum += nums[i] &#125; maxSum = sum // 滑动窗口 for (i in k until n) &#123; // 新窗口的和等于之前窗口的和加上新进入窗口的元素，减去滑出窗口的元素 sum += nums[i] - nums[i - k] // 更新最大和 maxSum = maxOf(maxSum, sum) &#125; return maxSum&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"04. 构建前缀和","slug":"算法/算法模板/04 构建前缀和","date":"2023-08-10T22:44:59.534Z","updated":"2023-08-10T23:14:46.896Z","comments":true,"path":"2023/08/11/算法/算法模板/04 构建前缀和/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/04%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"正文以下是一个前缀和算法的常见模板： 12345678910fun prefixSum(nums: IntArray): IntArray &#123; val prefixSum = IntArray(nums.size + 1) // 计算前缀和数组 for (i in 1..nums.size) &#123; prefixSum[i] = prefixSum[i - 1] + nums[i - 1] &#125; return prefixSum&#125; 在这个模板中，我们使用一个额外的数组 prefixSum 来存储原始数组 nums 的前缀和。通过遍历原始数组，我们可以计算每个位置的前缀和并存储在 prefixSum 中。 使用前缀和数组 prefixSum，我们可以高效地回答多个查询，例如计算某个区间的和。假设我们需要计算区间 [left, right] 的和，我们可以使用如下方式获取结果： 1val sum = prefixSum[right + 1] - prefixSum[left 这个计算结果即为原始数组中从位置 left 到位置 right 的元素之和。请注意，在模板中，前缀和数组 prefixSum 的长度比原始数组 nums 的长度多了一个元素。这是为了方便计算区间和时的边界情况。","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"05. 高效的字符串构建","slug":"算法/算法模板/05 高效的字符串构建","date":"2023-08-10T22:44:55.554Z","updated":"2023-08-10T23:14:50.683Z","comments":true,"path":"2023/08/11/算法/算法模板/05 高效的字符串构建/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/05%20%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E5%BB%BA/","excerpt":"","text":"正文以下是一个高效的字符串构建算法模板： 123456789fun buildString(chars: List&lt;Char&gt;): String &#123; val sb = StringBuilder() for (ch in chars) &#123; sb.append(ch) &#125; return sb.toString()&#125; 在这个模板中，我们使用 StringBuilder 来构建字符串。StringBuilder 是可变的字符串类，可以高效地进行字符串的拼接操作。 我们通过遍历字符列表 chars，逐个将字符添加到 StringBuilder 中。最后，通过调用 toString() 方法，将 StringBuilder 转换为最终的字符串结果并返回。 使用 StringBuilder 的好处是它避免了在每次拼接字符串时创建新的字符串对象，从而提高了性能和效率。特别是在需要频繁拼接大量字符串的情况下，使用 StringBuilder 可以避免不必要的性能损耗。 使用这个模板，你可以根据具体需求构建字符串。可以根据问题的要求在遍历过程中进行一些字符处理、条件判断等操作。","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"06. 链表-快慢指针","slug":"算法/算法模板/06 链表-快慢指针","date":"2023-08-10T22:44:43.627Z","updated":"2023-08-10T23:14:54.419Z","comments":true,"path":"2023/08/11/算法/算法模板/06 链表-快慢指针/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/06%20%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","excerpt":"","text":"正文在模板中，我们使用两个指针，一个指针每次向后移动一个节点，另一个指针每次向后移动两个节点。如果链表中存在循环，快指针最终会追上慢指针，这样我们就可以判断出链表有循环。如果链表没有循环，快指针会先到达链表的末尾，此时我们就可以判断链表没有循环。 123456789101112131415fun hasCycle(head: ListNode?): Boolean &#123; var slow = head var fast = head while (fast?.next != null &amp;&amp; fast.next?.next != null) &#123; slow = slow?.next fast = fast.next?.next if (slow == fast) &#123; return true &#125; &#125; return false&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"07. 反转链表","slug":"算法/算法模板/07 反转链表","date":"2023-08-10T22:44:30.298Z","updated":"2023-08-10T23:14:57.303Z","comments":true,"path":"2023/08/11/算法/算法模板/07 反转链表/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/07%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"正文123456789101112131415class ListNode(var value: Int) &#123; var next: ListNode? = null&#125;fun reverseList(head: ListNode?): ListNode? &#123; var prev: ListNode? = null var current = head while (current != null) &#123; val nextNode = current.next current.next = prev prev = current current = nextNode&#125;return prev","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"08. 找到符合确切条件的子数组数","slug":"算法/算法模板/08 找到符合确切条件的子数组数","date":"2023-08-10T22:44:25.824Z","updated":"2023-08-10T23:15:00.995Z","comments":true,"path":"2023/08/11/算法/算法模板/08 找到符合确切条件的子数组数/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/08%20%E6%89%BE%E5%88%B0%E7%AC%A6%E5%90%88%E7%A1%AE%E5%88%87%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0/","excerpt":"","text":"正文123456789101112131415161718192021222324252627fun numSubarraysWithSum(nums: IntArray, goal: Int): Int &#123; var count = 0 var total = 0 var left = 0 for (right in nums.indices) &#123; total += nums[right] while (left &lt;= right &amp;&amp; total &gt; goal) &#123; total -= nums[left] left++ &#125; if (total == goal) &#123; count++ // 统计连续的0 var temp = left while (temp &lt;= right &amp;&amp; nums[temp] == 0) &#123; count++ temp++ &#125; &#125; &#125; return count&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"09. 单调递增栈","slug":"算法/算法模板/09 单调递增栈","date":"2023-08-10T22:44:20.120Z","updated":"2023-08-10T23:15:03.827Z","comments":true,"path":"2023/08/11/算法/算法模板/09 单调递增栈/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/09%20%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88/","excerpt":"","text":"正文1234567891011121314151617181920fun monotonicStack(nums: IntArray): IntArray &#123; val stack = mutableListOf&lt;Int&gt;() val result = IntArray(nums.size) &#123; -1 &#125; for (i in nums.indices) &#123; while (stack.isNotEmpty() &amp;&amp; stack.last() &lt; nums[i]) &#123; stack.removeAt(stack.size - 1) &#125; // 在这里可以根据题目需求进行处理 // 例如：找到栈中元素的下一个更大元素 if (stack.isNotEmpty()) &#123; result[i] = stack.last() &#125; stack.add(nums[i]) &#125; return result&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"10. 二叉树-DFS (递归)","slug":"算法/算法模板/10 二叉树-DFS (递归)","date":"2023-08-10T22:44:12.699Z","updated":"2023-08-10T23:15:06.641Z","comments":true,"path":"2023/08/11/算法/算法模板/10 二叉树-DFS (递归)/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/10%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E9%80%92%E5%BD%92)/","excerpt":"","text":"正文123456789101112131415161718// 定义二叉树的节点类class TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;// 二叉树的深度优先搜索（递归）fun dfs(root: TreeNode?) &#123; if (root == null) &#123; return &#125; // 在这里处理节点操作，例如输出节点值 println(root.value) dfs(root.left) // 递归遍历左子树 dfs(root.right) // 递归遍历右子树&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"11. 二叉树-DFS (迭代)","slug":"算法/算法模板/11 二叉树-DFS (迭代)","date":"2023-08-10T22:44:07.656Z","updated":"2023-08-10T23:15:09.510Z","comments":true,"path":"2023/08/11/算法/算法模板/11 二叉树-DFS (迭代)/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/11%20%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%20(%E8%BF%AD%E4%BB%A3)/","excerpt":"","text":"正文12345678910111213141516171819202122class TreeNode(var `val`: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun dfs(root: TreeNode?) &#123; if (root == null) return val stack = ArrayDeque&lt;TreeNode&gt;() stack.push(root) while (!stack.isEmpty()) &#123; val node = stack.pop() // 在这里处理当前节点 // ... // 将右子节点先入栈，保证左子节点先出栈 node.right?.let &#123; stack.push(it) &#125; // 将左子节点入栈 node.left?.let &#123; stack.push(it) &#125; &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"12. 二叉树-BFS","slug":"算法/算法模板/12 二叉树-BFS","date":"2023-08-10T22:44:00.987Z","updated":"2023-08-10T23:15:13.115Z","comments":true,"path":"2023/08/11/算法/算法模板/12 二叉树-BFS/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/12%20%E4%BA%8C%E5%8F%89%E6%A0%91-BFS/","excerpt":"","text":"正文1234567891011121314151617181920212223242526272829303132import java.util.LinkedListimport java.util.Queueclass TreeNode(var value: Int) &#123; var left: TreeNode? = null var right: TreeNode? = null&#125;fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123; val result: MutableList&lt;List&lt;Int&gt;&gt; = mutableListOf() if (root == null) return result val queue: Queue&lt;TreeNode&gt; = LinkedList() queue.offer(root) while (queue.isNotEmpty()) &#123; val levelSize = queue.size val currentLevel: MutableList&lt;Int&gt; = mutableListOf() for (i in 0 until levelSize) &#123; val node = queue.poll() currentLevel.add(node.value) node.left?.let &#123; queue.offer(it) &#125; node.right?.let &#123; queue.offer(it) &#125; &#125; result.add(currentLevel) &#125; return result&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"13. 图-DFS (递归)","slug":"算法/算法模板/13 图-DFS (递归)","date":"2023-08-10T22:43:53.790Z","updated":"2023-08-10T23:15:16.126Z","comments":true,"path":"2023/08/11/算法/算法模板/13 图-DFS (递归)/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/13%20%E5%9B%BE-DFS%20(%E9%80%92%E5%BD%92)/","excerpt":"","text":"正文123456789101112131415161718192021222324252627282930313233343536373839class Graph &#123; private val adjList: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = mutableMapOf() fun addEdge(u: Int, v: Int) &#123; adjList.getOrPut(u) &#123; mutableListOf() &#125;.add(v) &#125; fun dfs(vertex: Int) &#123; val visited = mutableSetOf&lt;Int&gt;() dfsHelper(vertex, visited) &#125; private fun dfsHelper(vertex: Int, visited: MutableSet&lt;Int&gt;) &#123; visited.add(vertex) println(vertex) // 在这里可以对当前节点进行相关操作 val neighbors = adjList[vertex] if (neighbors != null) &#123; for (neighbor in neighbors) &#123; if (!visited.contains(neighbor)) &#123; dfsHelper(neighbor, visited) &#125; &#125; &#125; &#125;&#125;fun main() &#123; val graph = Graph() // 添加图的边 graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 3) graph.addEdge(2, 4) graph.addEdge(3, 4) // 从节点 0 开始进行深度优先搜索 graph.dfs(0)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"14. 图-DFS (迭代)","slug":"算法/算法模板/14 图-DFS-(迭代)","date":"2023-08-10T22:43:38.896Z","updated":"2023-08-10T23:15:19.003Z","comments":true,"path":"2023/08/11/算法/算法模板/14 图-DFS-(迭代)/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/14%20%E5%9B%BE-DFS-(%E8%BF%AD%E4%BB%A3)/","excerpt":"","text":"正文123456789101112131415161718192021222324252627282930313233343536373839404142class Graph &#123; private val adjacencyList: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = mutableMapOf() fun addEdge(u: Int, v: Int) &#123; adjacencyList.computeIfAbsent(u) &#123; mutableListOf() &#125;.add(v) &#125; fun dfs(start: Int) &#123; val visited = mutableSetOf&lt;Int&gt;() val stack = mutableListOf&lt;Int&gt;() stack.add(start) while (stack.isNotEmpty()) &#123; val vertex = stack.removeAt(stack.size - 1) if (!visited.contains(vertex)) &#123; visited.add(vertex) println(&quot;Visited vertex: $vertex&quot;) adjacencyList[vertex]?.reversed()?.forEach &#123; neighbor -&gt; if (!visited.contains(neighbor)) &#123; stack.add(neighbor) &#125; &#125; &#125; &#125; &#125;&#125;fun main() &#123; val graph = Graph() // 添加图的边 graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 3) graph.addEdge(1, 4) graph.addEdge(2, 5) graph.addEdge(2, 6) // 从顶点0开始进行DFS graph.dfs(0)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"15. 图-BFS","slug":"算法/算法模板/15 图-BFS","date":"2023-08-10T22:43:26.640Z","updated":"2023-08-10T23:15:30.528Z","comments":true,"path":"2023/08/11/算法/算法模板/15 图-BFS/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/15%20%E5%9B%BE-BFS/","excerpt":"","text":"正文12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*class Graph &#123; private val adjacencyList: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = HashMap() fun addEdge(src: Int, dest: Int) &#123; adjacencyList.computeIfAbsent(src) &#123; mutableListOf() &#125;.add(dest) adjacencyList.computeIfAbsent(dest) &#123; mutableListOf() &#125; &#125; fun bfs(startVertex: Int) &#123; val visited = BooleanArray(adjacencyList.size) val queue: Queue&lt;Int&gt; = LinkedList() visited[startVertex] = true queue.offer(startVertex) while (!queue.isEmpty()) &#123; val currentVertex = queue.poll() print(&quot;$currentVertex &quot;) val neighbors = adjacencyList[currentVertex] if (neighbors != null) &#123; for (neighbor in neighbors) &#123; if (!visited[neighbor]) &#123; visited[neighbor] = true queue.offer(neighbor) &#125; &#125; &#125; &#125; &#125;&#125;fun main() &#123; val graph = Graph() graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 2) graph.addEdge(2, 0) graph.addEdge(2, 3) graph.addEdge(3, 3) println(&quot;BFS traversal starting from vertex 2:&quot;) graph.bfs(2)&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"16. 找到堆的前 k 个元素","slug":"算法/算法模板/16 找到堆的前 k 个元素","date":"2023-08-10T22:43:20.795Z","updated":"2023-08-10T23:15:33.577Z","comments":true,"path":"2023/08/11/算法/算法模板/16 找到堆的前 k 个元素/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/16%20%E6%89%BE%E5%88%B0%E5%A0%86%E7%9A%84%E5%89%8D%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"正文1234567891011121314151617fun findKthLargest(nums: IntArray, k: Int): Int &#123; // 创建最小堆 val minHeap = PriorityQueue&lt;Int&gt;() // 将数组中的元素依次加入最小堆 for (num in nums) &#123; minHeap.offer(num) // 如果最小堆的大小超过 k，移除堆顶元素 if (minHeap.size &gt; k) &#123; minHeap.poll() &#125; &#125; // 返回堆顶元素，即第 k 大的元素 return minHeap.peek()&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"17. 二分查找","slug":"算法/算法模板/17 二分查找","date":"2023-08-10T22:43:12.371Z","updated":"2023-08-10T23:15:37.130Z","comments":true,"path":"2023/08/11/算法/算法模板/17 二分查找/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/17%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"正文123456789101112131415161718fun binarySearch(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 if (nums[mid] == target) &#123; return mid &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; &#125; return -1&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"18. 二分查找-重复元素，最左边的插入点","slug":"算法/算法模板/18 二分查找-重复元素，最左边的插入点","date":"2023-08-10T22:43:07.616Z","updated":"2023-08-10T23:15:39.998Z","comments":true,"path":"2023/08/11/算法/算法模板/18 二分查找-重复元素，最左边的插入点/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/18%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/","excerpt":"","text":"正文12345678910111213141516171819202122fun searchInsert(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 if (nums[mid] == target) &#123; // 找到了目标元素，返回索引 return mid &#125; else if (nums[mid] &lt; target) &#123; // 目标元素在右半部分，更新左边界 left = mid + 1 &#125; else &#123; // 目标元素在左半部分，更新右边界 right = mid - 1 &#125; &#125; // 目标元素不存在，返回插入位置 return left&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"19. 二分查找-重复元素，最右边的插入点","slug":"算法/算法模板/19 二分查找-重复元素，最右边的插入点","date":"2023-08-10T22:43:02.221Z","updated":"2023-08-10T23:15:43.598Z","comments":true,"path":"2023/08/11/算法/算法模板/19 二分查找-重复元素，最右边的插入点/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/19%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9/","excerpt":"","text":"正文123456789101112131415161718192021fun searchInsert(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 var result = nums.size // 默认插入到最右边 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 if (nums[mid] &lt;= target) &#123; if (nums[mid] == target) &#123; // 找到目标元素，更新结果为当前索引 result = mid &#125; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; &#125; return result&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"20. 二分查找-贪心问题","slug":"算法/算法模板/20 二分查找-贪心问题","date":"2023-08-10T22:42:58.138Z","updated":"2023-08-10T23:15:46.556Z","comments":true,"path":"2023/08/11/算法/算法模板/20 二分查找-贪心问题/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"正文12345678910111213141516fun binarySearch(nums: IntArray, target: Int): Int &#123; var left = 0 var right = nums.size - 1 while (left &lt;= right) &#123; val mid = left + (right - left) / 2 when &#123; nums[mid] == target -&gt; return mid nums[mid] &lt; target -&gt; left = mid + 1 else -&gt; right = mid - 1 &#125; &#125; return -1&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"21. 回溯","slug":"算法/算法模板/21 回溯","date":"2023-08-10T22:42:52.870Z","updated":"2023-08-10T23:15:49.375Z","comments":true,"path":"2023/08/11/算法/算法模板/21 回溯/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/21%20%E5%9B%9E%E6%BA%AF/","excerpt":"","text":"正文1234567891011121314151617181920fun backtrack(...) &#123; // 检查是否达到结束条件 if (满足结束条件) &#123; // 处理结果 处理结果 return &#125; // 遍历所有可能的选择 for (选择 in 可选列表) &#123; // 做选择 做选择 // 进入下一层决策树 backtrack(...) // 撤销选择 撤销选择 &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"22. 动态规划-自顶向下法","slug":"算法/算法模板/22 动态规划-自顶向下法","date":"2023-08-10T22:42:47.937Z","updated":"2023-08-10T23:15:52.125Z","comments":true,"path":"2023/08/11/算法/算法模板/22 动态规划-自顶向下法/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/22%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B3%95/","excerpt":"","text":"正文12345678910111213141516fun dp(n: Int, memo: IntArray): Int &#123; // 检查是否已经计算过该值 if (memo[n] != -1) &#123; return memo[n] &#125; // 边界条件 if (n == 0 || n == 1) &#123; memo[n] = n return n &#125; // 递归计算并保存结果 memo[n] = dp(n - 1, memo) + dp(n - 2, memo) return memo[n]&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"23. 构建前缀树（字典树）","slug":"算法/算法模板/23 构建前缀树（字典树）","date":"2023-08-10T22:42:42.492Z","updated":"2023-08-10T23:15:55.565Z","comments":true,"path":"2023/08/11/算法/算法模板/23 构建前缀树（字典树）/","link":"","permalink":"http://example.com/2023/08/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/23%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89/","excerpt":"","text":"正文1234567891011121314151617181920212223242526272829303132333435363738394041class TrieNode &#123; val children = HashMap&lt;Char, TrieNode&gt;() var isWord = false&#125;class Trie &#123; private val root = TrieNode() fun insert(word: String) &#123; var node = root for (char in word) &#123; if (!node.children.containsKey(char)) &#123; node.children[char] = TrieNode() &#125; node = node.children[char]!! &#125; node.isWord = true &#125; fun search(word: String): Boolean &#123; var node = root for (char in word) &#123; if (!node.children.containsKey(char)) &#123; return false &#125; node = node.children[char]!! &#125; return node.isWord &#125; fun startsWith(prefix: String): Boolean &#123; var node = root for (char in prefix) &#123; if (!node.children.containsKey(char)) &#123; return false &#125; node = node.children[char]!! &#125; return true &#125;&#125;","categories":[{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"}],"tags":[]},{"title":"协程中的取消和异常 （取消操作详解）","slug":"Kotlin/Kotlin 协程/协程中的取消和异常 （取消操作详解）","date":"2023-06-17T05:55:03.131Z","updated":"2023-08-10T23:19:11.306Z","comments":true,"path":"2023/06/17/Kotlin/Kotlin 协程/协程中的取消和异常 （取消操作详解）/","link":"","permalink":"http://example.com/2023/06/17/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/","excerpt":"","text":"正文在开发中，我们要避免不必要的的任务来节约设备的内存和电量的使用，协程也是如此。在使用的过程我们需要控制好它的生命周期，在不需要它的取消它。 调用cancel方法取消作用域会取消它的子协程当启动了很多个协程，我们一个个协程的取消比较麻烦，我们可以通过取消整个作用域来解决这个问题，因为取消作用域可以取消该作用域创建的所有协程。 123456/ 假设我们已经定义了一个作用域val job1 = scope.launch &#123; … &#125;val job2 = scope.launch &#123; … &#125;scope.cancel() 假设我们创建了一个作用域scope,并创建了两个协程job1和job2。我们通过调用scope.cancel()，取消作用域，将会把job1 和job2两个协程都取消。 单独取消某个协程，不会影响他的兄弟协程我们创建了两个协程，job1和job2.我们单独取消job1，不会影响到job2 1234567// 假设我们已经定义了一个作用域val job1 = scope.launch &#123; … &#125;val job2 = scope.launch &#123; … &#125; // 第一个协程将会被取消，而另一个则不受任何影响job1.cancel() 协程通过抛出一个特殊的异常 CancellationException 来处理取消操作在调用cancel函数的时候，我们需要传入一个CancellationException对象,如果我们没有传入，那就用默认的defaultCancellationException。 1234// external cancel with cause, never invoked implicitly from internal machinery public override fun cancel(cause: CancellationException?) &#123; cancelInternal(cause ?: defaultCancellationException()) &#125; 一旦抛出了CancellationException，我们就可以通过这一机制来处理协程的取消。在底层的实现中，子协程会通过抛出异常的方式将取消的情况通知它的父级，父协程通过传入的取消原因决定是否处理该异常。 不能在已取消的作用域中再次启动新的协程调用了 cancel 方法为什么协程处理的任务没有停止？不同的Diapatcher不同的区别，下一篇文章将介绍。 我们以Dispatchers.Default为例子 12345678910111213141516171819202122import kotlinx.coroutines.*suspend fun main() = runBlocking &#123; var startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; var nextTime = startTime var i = 0 while (i &lt; 5) &#123; if (System.currentTimeMillis() &gt;= nextTime) &#123; println(&quot;这是第$&#123;i&#125;次&quot;) i++ //1000毫秒执行一次 nextTime += 1000 &#125; &#125; &#125; delay(1000) println(&quot;取消&quot;) job.cancel() println(&quot;取消完毕&quot;)&#125; 1234567这是第0次这是第1次取消取消完毕这是第2次这是第3次这是第4次 调用cancel方法之后，协程的任务依然在运行。调用cancel方法的时候，此时协程处于cancelling正在取消的状态，接着我们打印了2，3，4，处理任务结束之后，协程变成cancelled已经取消的状态，这是以Default举例，Default调度会等待协程任务处理完毕才取消。 让协程可以被取消协程处理任务都是协作式的，协作的意思就是我们的处理任务要配合协程取消做处理。因此在执行任务期间我们要定时检查协程的状态是否已经取消，例如我们从磁盘读取文件之前我们先检查协程是否被取消了。 123456val job = launch &#123; for(file in files) &#123; // TODO 检查协程是否被取消 readFile(file) &#125;&#125; 协程中的挂起函数都是可取消的，使用他们的时候，我们不需要检查协程是否已取消。例如withContext，delay 。如果没有这些挂起函数，为了让我们的代码配合协程取消，可以使用一下两种方法： 检查 job.isActive 或者使用 ensureActive() 使用 yield() 来让其他任务进行 检查 job 的活跃状态先看一下第一种方法，在我们的 while(i&lt;5) 循环中添加对于协程状态的检查: 12// 因为处于 launch 的代码块中，可以访问到 job.isActive 属性while (i &lt; 5 &amp;&amp; isActive) 使用 yield() 函数运行其他任务Job.join 和 Deferred.await cancellation等待协程处理结果有两种方法，launch启动的job可以调用join，async 返回的Deferred 可以调用await方法 job.join会让协程挂起，直到等待协程处理任务完毕，我们可以配合cancel使用 deferred.await()如果我们关心协程的处理结果，我们可以使用deferred。结果由deferred.await返回。也是job类型，也可以被取消。 处理协程取消的副作用当我们需要在协程取消 后处理一些清理的工作，或者做一些打印日志。我们有几种办法： 通过检查协程的状态 123456789while (i &lt; 5 &amp;&amp; isActive) &#123; if (…) &#123; println(“Hello $&#123;i++&#125;”) nextPrintTime += 500L &#125;&#125; // 协程所处理的任务已经完成，因此我们可以做一些清理工作println(“Clean up!” 当判断协程不是isActive状态的时候，我们可以做一些清理 try catch finally 我们知道协程的取消会抛出CancellationException 异常，我们可以在协程提中使用try catch finally，在finally中做我们的一些清理的工作，或者打印日志 1234567891011121314val job = launch &#123; try &#123; work() &#125; catch (e: CancellationException)&#123; println(“Work cancelled!”) &#125; finally &#123; println(“Clean up!”) &#125;&#125;delay(1000L)println(“Cancel!”)job.cancel()println(“Done! 已经取消的协程，不能再被挂起已经取消的协程，不能再被挂起，但是当我们需要在取消的协程中调用挂起函数，那么我们可以在finally中使用NonCancellable ，意思是让协程挂起，直到处理挂起函数中的代码完毕，协程才会取消。 1234567891011121314151617val job = launch &#123; try &#123; work() &#125; catch (e: CancellationException)&#123; println(“Work cancelled!”) &#125; finally &#123; withContext(NonCancellable)&#123; delay(1000L) // 或一些其他的挂起函数 println(“Cleanup done!”) &#125; &#125;&#125;delay(1000L)println(“Cancel!”)job.cancel()println(“Done! 在jetpack中使用viewModelScope 或者lifecycleScope 中定义的作用域，他们在scope完成后取消他们的处理任务。如果我们手动创建自己的作用域CoroutineScope，我们需要协作协程，将我们的作用域和job绑定，在需要的时候取消。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"Kotlin 的协程本质到底什么","slug":"Kotlin/Kotlin 协程/Kotlin 的协程本质到底什么","date":"2023-06-17T05:52:43.121Z","updated":"2023-08-10T23:19:02.780Z","comments":true,"path":"2023/06/17/Kotlin/Kotlin 协程/Kotlin 的协程本质到底什么/","link":"","permalink":"http://example.com/2023/06/17/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/","excerpt":"","text":"正文几乎就是用阻塞的写法来完成非阻塞的任务。Kotlin-JVM中所谓的协程是假协程Kotlin-JVM中所谓的 协程挂起 ，就是开启了一个子线程去执行任务 对于Java来说，不管你用什么方法，只要你没有魔改JVM，那么最终你代码里start几个线程，操作系统就会创建几个线程，是1比1的关系。Kotlin官网中那个创建10w个Kotlin协程没有oom的例子其实有误导性，本质上那10w个Kotlin协程就是10w个并发任务仅此而已，他下面运行的就是一个单线程的线程池。你往一个线程池里面丢多少个任务都不会OOM的（前提是你的线程池创建的时候设定了对应的拒绝策略，否则无界队列下，任务过多一定会OOM），因为在运行的始终是那几个线程。 创建协程的方式有五种： 12345GlobalScope.launch&#123;&#125;launch&#123;&#125;runBlocking&#123;&#125;coroutineScope&#123;&#125;async&#123;&#125;","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"Kotlin中的惰性操作容器——Sequence","slug":"Kotlin/Kotlin 基础/Kotlin中的惰性操作容器——Sequence","date":"2023-06-17T05:23:26.204Z","updated":"2023-08-10T23:18:52.360Z","comments":true,"path":"2023/06/17/Kotlin/Kotlin 基础/Kotlin中的惰性操作容器——Sequence/","link":"","permalink":"http://example.com/2023/06/17/Kotlin/Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/","excerpt":"","text":"Sequence序列Sequence 是Kotlin标准库提供的一种容器类型。它和Iterable一样具备对集合进行多步骤操作能力，但是却是采用了一种完全不同于Iterable的实现方式： 12345678val map = (0..3).filter &#123; println(&quot;filter:$it&quot;) it % 2 == 0&#125;.map &#123; println(&quot;map:$it&quot;) it + 1&#125;println(map) 上面的代码用来演示Iterable进行连续操作的情况。它的输出如下： 1234567filter:0filter:1filter:2filter:3map:0map:2[1, 3] 像map和filter这些链式集合函数它们都会立即执行并创建中间临时集用来保存数据。当原始数据不多时，这并不会有什么影响。但是，当原始数据量非常大的时候。这就会变的非常低效。而此时，就可以借助Sequence提高效率。 123456789val sequence = (0..3).asSequence().filter &#123; println(&quot;filter:$it&quot;) it % 2 == 0&#125;.map &#123; println(&quot;map:$it&quot;) it + 1&#125;println(&quot;准备开始执行&quot;)println(sequence.toList()) 上面的代码执行结果如下： 12345678准备开始执行filter:0map:0filter:1filter:2map:2filter:3[1, 3] 对比Iterable和Sequence： Iterable是即时的、Sequence是惰性的：前者会要求尽早的计算结果，因此在多步骤处理链的每一环都会有中间产物也就是新的集合产生；后者会尽可能的延迟计算结果，Sequence处理的中间函数不进行任何计算。相反，他们返回一个新Sequence的，用新的操作装饰前一个，所有的这些计算都只是在类似toList的终端操作期间进行。 区分中间操作符和末端操作符的方式也很简单：如果操作符返回的是一个Sequence类型的数据，它就是中间操作符。 在操作的执行方式上也有所不同：Iterable每次都是在整个集合执行完操作后再进行下一步操作——采用第一个操作并将其应用于整个集合，然后移动到下一个操作，官方将其称呼为急切式或者按步骤执行（Eager&#x2F;step-by-step）；而Sequence则是逐个对每个元素执行所有操作。是一种惰性顺序——取第一个元素并应用所有操作，然后取下一个元素，依此类推。官方将其称呼为惰性式或者按元素执行（Lazy&#x2F;element-by-element) 序列的惰性会带来一下几个优点： 它们的操作按照元素的自然顺序进行； 只做最少的操作； 元素可以是无限多个； 不需要在每一步都创建集合 Sequence可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。但是，惰性性质也会带来一些运行开销。所以在使用时要权衡惰性开销和中间步骤开销，在Sequence和Iterable中选择更加合适的实现方式。 执行的顺序1234567891011sequenceOf(1,2,3) .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125; .map &#123; print(&quot;M$it, &quot;); it * 2 &#125; .forEach &#123; print(&quot;E$it, &quot;) &#125; // Prints: F1, M1, E2, F2, F3, M3, E6,listOf(1,2,3) .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125; .map &#123; print(&quot;M$it, &quot;); it * 2 &#125; .forEach &#123; print(&quot;E$it, &quot;) &#125;// Prints: F1, F2, F3, M1, M3, E2, E6, sequence的执行时按照元素进行的，依次对元素执行所有的操作，对一个元素而言，所有操作时依次全部执行的。而普通集合操作则是以操作步骤进行的，当所有的元素执行完当前操作后才会进入下一个操作。 只做最少的操作试想一下我们有一千万个数字，我们要经过几次变换取出20个，使用下面的代码对比一下序列和不同集合操作的性能： 12345678910111213141516171819fun main()&#123; val fFlow = FFlow() fFlow.demoList() fFlow.demoSequence()&#125;fun demoSequence() &#123; val currentTimeMillis = System.currentTimeMillis() val list = (0..10000000).asSequence().map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList() println(&quot;demoSequence:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)&#125;fun demoList() &#123; val currentTimeMillis = System.currentTimeMillis() val list = (0..10000000).map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList() println(&quot;demoList:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)&#125; 输出的结果如下： 12demoSequence:20ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]demoList:4106ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37] 这就是只执行最少操作的意思，序列按照元素顺序执行，当取够29个元素之后便会立即停止计算。而不同的集合则不同，没有中间操作的概念。它的每次操作都会对整个数组中的所有元素执行完才会进行下一个——也就是前两个map都要执行一千万次。 序列可以是无限的看如下代码： 123456var list = emptyArray&lt;Int&gt;()var i = 0while(true)&#123; list[i] = i++&#125;list.take(10) 很明显，这段代码是没法正常运行的，因为这里有一个死循环。我们也无法创建一个无限长度的集合。但是：因为序列式按步骤依照需求进行处理的，所哟我们可以创建无限序列： 123456789val noEnd = sequence &#123; var i = 1 while (true) &#123; yield(i) i *= 2 &#125;&#125;noEnd.take(4).toList()//输出:[1, 2, 4, 8] 但是一定要注意，我们虽然可以这么写，但是务必不能真的让while一直循环。我们不能直接使用toList。必须提供一个能结束循环的操作符，也就是不能取出所有元素（无限个）——要么使用类似take的操作来限制它们的数量，要么使用不需要所有元素的终端操作，例如first, find, any, all, indexOf等。 序列不会在每个步骤创建集合普通的集合会在每次变换之后都会创建新的集合取存储所有变换后的元素。而每次创建集合和填入数据都会带来不小的性能开销。尤其是当我们处理大量或大量的集合时，性能问题会愈发凸显。而序列的按元素操作，则不会有这个问题。除非手动调用了终端操作符，否则不会生成新的集合。 Sequence的基本使用Sequence序列的使用和普通的Iterable极其相似，实际上其内部也还是借助Iterable实现的。在研究它的内部实现原理之前，想从Sequence的创建和基本的序列操作来演示Sequence的基本用法。 序列的创建创建Sequence的方式大概可以分为。分别是由元素创建、通过Iterable、借助函数以及由代码块创建。 由元素创建：通过调用顶级函数sequenceOf实现： 12val ints = sequenceOf(1, 2, 3, 4, 5, 6, 7)val strings = sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) 通过Iterable转化：借助Iterable的扩展函数asSequence实现： 12val ints = listOf(1, 2, 3, 4, 5, 6, 7).asSequence()val strings = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence() 通过generateSequence实现：该方法有三个： 123generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; 最终都是通过GeneratorSequence实现的，这里先不进行源码分析。只讨论使用方式： 其中三个函数都有的形参nextFunction可以理解为元素生成器，序列里的元素都通过调用该函数生成，当它返回为null是，序列停止生成（所以，nextFunction必须要在某个情况下返回null，否则会因为序列元素是无限多个触发java.lang.OutOfMemoryError: Java heap space异常）。 而另外两个的seedFunction和seed形参都是为了确定数据初始值的。区别在于一个直接指明，一个通过调用函数获取。 分别用这三个函数生成0~100的序列，代码如下： 12345678910111213141516171819202122val generateSequenceOne = generateSequence &#123; if (i &lt; 100) &#123; i++ &#125; else &#123; null &#125;&#125;val generateSequenceTwo = generateSequence(0) &#123; if (it &lt; 100) &#123; it+1//此处的it是上一个元素 &#125; else &#123; null &#125;&#125;val generateSequenceThree = generateSequence(&#123; 0 &#125;) &#123; if (it &lt; 100) &#123; it+1//此处的it是上一个元素 &#125; else &#123; null &#125;&#125; 由代码块生成：借助sequence(block: suspend SequenceScope.() -&gt; Unit)函数。改函数接受一个挂起函数，该函数会接受一个SequenceScope实例，这个实例无需我们创建（后面源码分析会讲到）。SequenceScope提供了yield和yieldAll方法复杂返回序列元素给调用者，并暂停序列的执行，直到使用者请求下一个元素。 用该函数生成0~100的序列，代码如下： 12345val ints = sequence &#123; repeat(100) &#123; yield(it) &#125;&#125; 序列的操作对序列的操作可以分为中间操作和末端操作两种。它们只要有一下另种区别： 中间操作返回惰性生成的一个新的序列，而末端序列则为其他普通的数据类型； 中间操作不会立刻执行代码，仅当执行了末端操作序列才会开始执行。 常见的中间操作包括：map、fliter、first、last、take等；它们会序列提供数据变化过滤等增强功能基本上和kotlin提供的集合操作符有着相同的功能。 常见的末端操作有：toList、toMutableList、sum、count等。它们在提供序列操作功能的同时，还会触发序列的运行。 Sequence源码分析上文对序列做了简单的入门介绍。接下来深入源码去了解一下Sequence的实现方式。 Sequence是什么？Kotlin对的定义Sequence很简单： 123public interface Sequence &lt;out T&gt; &#123; public operator fun iterator(): Iterator&lt;T&gt;&#125; 就是一个接口，定义了一个返回Iterator的方法。接口本身只定义了Sequence具有返回一个迭代器的能力。具体的功能实现还是靠它的实现类完成。 可以概括一些：序列就是一个具备提供了迭代器能力的类。 序列的创建方式分析结合上文中提到的序列的四种创建方式，我们依次分析一下它的创建流程。 我们首先以比较常用的通过Iterable转化获取序列，它需要借助asSequence方法分析一下，使用listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()生成一个序列。调用链如下： 1234567public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123; return Sequence &#123; this.iterator() &#125;&#125;public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 流程很简单，一个扩展函数加一个内联函数。最终通过匿名内部类的方式创建一个Sequence并返回。代码很好理解，实际上它的实现逻辑等同于下面的代码： 1234567val sequence = MySequence(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).iterator())class MySequence&lt;T&gt;(private val iterator:Iterator&lt;T&gt;):Sequence&lt;T&gt;&#123; override fun iterator(): Iterator&lt;T&gt; &#123; return iterator &#125;&#125; 接着看一下通过调用顶级函数sequenceOf实现，以sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)为例，它的调用逻辑如下： 1public fun &lt;T&gt; sequenceOf(vararg elements: T): Sequence&lt;T&gt; = if (elements.isEmpty()) emptySequence() else elements.asSequence() 可以看到依旧是借助asSequence实现的。 接下来看一下代码块和generateSequence的实现方式，这两个方式会比较复杂一点，毕竟前面两个都是借助List进行转换，而List本身就能提供迭代器Iterator。后面两个明显需要提供新的迭代器。 首先看一下代码看的实现方式： 12345val ints = sequence &#123; repeat(100) &#123; yield(it) &#125; &#125; 其中sequence的调用逻辑如下： 123456789101112public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; iterator(block) &#125;public fun &lt;T&gt; iterator(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123; //创建迭代器 val iterator = SequenceBuilderIterator&lt;T&gt;() iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator) return iterator&#125;public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 可以发现：该方法和asSequence一样最终也是通过匿名内部类的方式创建了一个Sequence。不过区别在于，该方法需要创建一个新的迭代器，也就是SequenceBuilderIterator 。同样以MySequence为例，它的创建流程等同于一下代码： 123456789101112131415fun mian()&#123; create&lt;Int&gt; &#123; myblock() &#125;&#125;suspend fun SequenceScope&lt;Int&gt;.myblock()&#123; repeat(100) &#123; yield(it) &#125;&#125;fun &lt;Int&gt; create(block: suspend SequenceScope&lt;Int&gt;.() -&gt; Unit):Sequence&lt;Int&gt;&#123; val iterator = SequenceBuilderIterator&lt;Int&gt;() iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator) return MySequence(iterator)&#125; 当然，这是不可能实现的，因为SequenceBuilderIterator是被private修饰了，我们是无法直接访问的。这里强制写出来演示一下它的流程。 最后看一下通过generateSequence方法创建序列的源码，一共有三个： 123456789101112public fun &lt;T : Any&gt; generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = GeneratorSequence(seedFunction, nextFunction)public fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = if (seed == null) EmptySequence else GeneratorSequence(&#123; seed &#125;, nextFunction)public fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; &#123; return GeneratorSequence(nextFunction, &#123; nextFunction() &#125;).constrainOnce()&#125; 最终都是创建了GeneratorSequence的一个实例并返回，而GeneratorSequence实现了Sequence接口并重写了iterator()方法： 1234567891011121314151617181920212223242526272829private class GeneratorSequence&lt;T : Any&gt;(private val getInitialValue: () -&gt; T?, private val getNextValue: (T) -&gt; T?) : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; var nextItem: T? = null var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue private fun calcNext() &#123; nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!) nextState = if (nextItem == null) 0 else 1 &#125; override fun next(): T &#123; if (nextState &lt; 0) calcNext() if (nextState == 0) throw NoSuchElementException() val result = nextItem as T // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue nextState = -1 return result &#125; override fun hasNext(): Boolean &#123; if (nextState &lt; 0) calcNext() return nextState == 1 &#125; &#125;&#125; 总结一下Sequence的创建大致可以分为三类： 使用List自带的迭代器通过匿名的方式创建Sequence实例，sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)和listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()就是这种方式； 创建新的SequenceBuilderIterator迭代器，并通过匿名的方式创建Sequence实例。例如使用代码块的创建方式。 创建GeneratorSequence，通过重写iterator()方法，使用匿名的方式创建Iterator。GeneratorSequence方法就是采用的这种方式。 看完创建方式，也没什么奇特的，就是一个提供迭代器的普通类。还是看不出是如何惰性执行操作的。接下来就分析一下惰性操作的原理。 序列的惰性原理以最常用的map操作符为例：普通的集合操作源码如下： 123456789101112public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123; //出啊年一个新的ArrayList，并调用mapTo方法 return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)&#125;public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123; //遍历原始的集合，进行变换操作，然后将变换后的数据依次加入到新创建的集合 for (item in this) destination.add(transform(item)) //返回新集合 return destination&#125; 可以看到：当List.map被调用后，便会立即创建新的集合，然后遍历老数据并进行变换操作。最后返回一个新的数据。这印证了上面提到的普通集合的操作时按照步骤且会立刻执行的理论。 接下来看一下序列的map方法，它的源码如下： 1234567891011121314151617181920212223public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123; return TransformingSequence(this, transform)&#125;internal class TransformingSequence&lt;T, R&gt;constructor(private val sequence: Sequence&lt;T&gt;, private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123; override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123; //注释一：TransformingSequence的iterator持有上一个序列的迭代器 val iterator = sequence.iterator() override fun next(): R &#123; //注释二：在开始执行迭代时，向上调用前一个序列的迭代器。 return transformer(iterator.next()) &#125; override fun hasNext(): Boolean &#123; return iterator.hasNext() &#125; &#125; internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123; return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator) &#125;&#125; 代码并不复杂，它接收用户提供的变换函数和序列，然后创建了一个TransformingSequence并返回。TransformingSequence本身和上文中提到的序列没什么区别，唯一的区别在于它的迭代器：在通过next依次取数据的时候，并不是直接返回元素。而是先调用调用者提供的函数进行变换。返回变换后的数据——这也没什么新鲜的，和普通集合的map操作符和RxJava的Map都是同样的原理。 但是，这里却又有点不一样。操作符里没有任何开启迭代的代码，它只是对序列以及迭代进行了嵌套处理，并不会开启迭代.如果用户不手动调用（后者间接调用）迭代器的next函数，序列就不会被执行——这就是惰性执行的机制的原理所在。 而且，由于操作符返回的是一个Sequence类型的值，当你重复不断调用map时，例如下面的代码： 12345678(0..10).asSequence().map&#123;add(it)&#125;.map&#123;add(it)&#125;.map&#123;add(it)&#125;.toList()//等同于val sequence1 = (0..10).asSequence()val sequence2 = sequence1.map &#123; it+1 &#125;val sequence3 = sequence2.map &#123; it+1 &#125;sequence3.toList() 最终，序列sequence3的结构持有如下：sequence3-&gt; sequence2 -&gt; sequence1。而它们都有各自的迭代器。迭代器里都重写了各自的变换逻辑: 123456789override fun next(): R &#123; return transformer(iterator.next())&#125;//由于这里都是执行的+1操作，所以变换逻辑transformer可以认为等同于如下操作:override fun next(): R &#123; return iterator.next()+1&#125; 而当我们通过sequence3.toList执行代码时，它的流程如下： 123456789101112131415161718public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123; return this.toMutableList().optimizeReadOnlyList()&#125;public fun &lt;T&gt; Sequence&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123; //末端操作符，此处才会开始创建新的集合 return toCollection(ArrayList&lt;T&gt;())&#125;public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123; //执行迭代器next操作 //当调用（末端操作符）走到这里时，便会和普通结合的操作符一样 //此时为新创建的集合赋值 for (item in this) &#123; destination.add(item) &#125; return destination&#125; 经过几次扩展函数调用，最终在toCollection里开始执行迭代(Iterator的典型的操作)，也就是获取了sequence3的iterator实例，并不断通过next取出数据。而在上文中的TransformingSequence源码里可以看到，TransformingSequence会持有上一个迭代器的实例（代码注释一）。 并且在迭代开始后，在进行transformer操作（也就是执行+1操作）前，会调用上一个迭代器的next方法进行迭代（代码注释二）。这样不断的迭代，最终，最终会调用到sequence1的next方法。再结合上文中的序列创建里的分析——sequence1里所持有的迭代器就是就是原始数据里的迭代器。 那么当最终执行toList方法时，它会循环sequence3.iterator方法。而在每次循环内，都会首先执行sequence3所持有的sequence2.iterator的next方法。sequence2依次类推执行到sequence1的sequence1.iterator&#96;方法，最终执行到我们原始数组的迭代器next方法： 整个流程如下： 原理就是这么简单：中间操作符通过序列嵌套，实现对迭代器iterator的嵌套。这样在进行迭代的时候，会依次调用各个iterator迭代器直到调用到原始集合数据里的迭代器开始并返回元素。而当元素返回时，会依次执行各个迭代器持有变换操作方法实现对数据的变换。 而其他操作符，也是遵循这个基本的规则。无非就是增加一些其他的操作。 总结 序列通过中间操作符对迭代器进行嵌套和复写，以此实现按元素操作执行变换； 中间操作符只负责根据需求创建并嵌套迭代器，并不负责开启迭代器。以此实现惰性操作且不产生临时集合； 末端操作符负责开启迭代，按照嵌套顺序执行迭代操作。依次获取操作后的数据，并且会创建新的集合用来存储最终数据； 序列不是万能的，因为要引入新的对象。在带来惰性和顺序执行的优势时，这些对象必然会带来性能开销。所以要依需求在集合和序列之间进行选择，使用合适的方式进行迭代。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"RESTful API","slug":"网络通信/RESTful API","date":"2023-06-02T00:25:43.991Z","updated":"2023-08-09T22:07:49.126Z","comments":true,"path":"2023/06/02/网络通信/RESTful API/","link":"","permalink":"http://example.com/2023/06/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/RESTful%20API/","excerpt":"","text":"当我们谈到RESTful API，”RESTful”是表示”Representational State Transfer”的缩写。它是一种设计和构建网络应用程序的架构风格，用于创建可伸缩、可维护和可扩展的Web服务。 以下是RESTful API的一些关键概念： 资源（Resource）：在RESTful API中，所有的事物都被视为资源。资源可以是具体的实体（例如用户、文章、订单等），也可以是抽象的概念（例如用户登录、搜索等）。 统一的接口（Uniform Interface）：RESTful API使用统一的接口进行资源的操作。这包括使用标准的HTTP方法（GET、POST、PUT、DELETE等）对资源进行操作，并使用URL来标识和定位资源。 状态无关（Stateless）：RESTful API是无状态的，每个请求都应该包含足够的信息来理解和处理请求，服务器不应该保存客户端的状态。客户端可以在每个请求中提供必要的信息来完成请求的处理。 资源的表示（Representation）：资源的表示指的是以某种格式（如JSON、XML等）将资源的状态传递给客户端。客户端可以通过获取资源的表示来了解和操作资源的状态。 超媒体驱动（HATEOAS）：RESTful API可以通过在资源的表示中提供超媒体链接，使客户端能够动态地发现和导航到相关资源。这样客户端可以根据链接进行进一步的操作，而无需事先了解所有可能的操作。 通过遵循RESTful API的原则，可以使API设计更加简洁、可读性高，并提供灵活性和可扩展性。RESTful API也更加符合Web的原生特性，易于理解和使用。 在使用Retrofit或其他网络请求库时，通常会将RESTful API作为后端服务的接口，通过发送HTTP请求来与后端进行通信，获取、创建、更新或删除资源的数据。了解RESTful API的概念可以帮助你更好地理解和使用这些API。","categories":[],"tags":[]},{"title":"synchronized 关键字为什么会引入锁的竞争","slug":"Java/多线程/synchronized 关键字为什么会引入锁的竞争","date":"2023-05-27T21:24:39.188Z","updated":"2023-08-10T23:17:49.981Z","comments":true,"path":"2023/05/28/Java/多线程/synchronized 关键字为什么会引入锁的竞争/","link":"","permalink":"http://example.com/2023/05/28/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/","excerpt":"","text":"正文synchronized 关键字用于实现线程同步，它可以保证在同一时间只有一个线程能够执行被 synchronized 修饰的代码块或方法。当一个线程获取了对象的锁，其他线程需要等待该线程释放锁才能继续执行。 当多个线程同时竞争同一个锁时，就会发生锁的竞争。这种竞争会导致多个线程按顺序排队等待锁的释放，从而引入性能问题。具体来说，锁的竞争可能导致以下情况： 线程争用：多个线程同时竞争同一个锁，会导致线程进行上下文切换，从而增加了线程切换的开销。 阻塞等待：当一个线程获取了锁，其他线程需要等待，直到该线程释放锁。这会导致其他线程阻塞，降低了并发性能。 锁饥饿：如果某个线程频繁地获取锁，其他线程无法获得执行的机会，会导致其他线程长时间等待锁，造成锁饥饿的情况。 因此，当多个线程同时竞争同一个锁时，就会引入锁的竞争问题，进而影响程序的性能。在高并发场景中，合理设计并发控制机制，避免不必要的锁竞争，可以提高程序的并发性能。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 多线程","slug":"2-Java/2-0-Java-多线程","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"java.util.Stack 类为什么是线程安全的","slug":"Java/Java程序基础/java.util.Stack 类为什么是线程安全的_2023_05_28 周日- 5_24_39.15","date":"2023-05-27T21:24:39.157Z","updated":"2023-08-10T23:17:22.605Z","comments":true,"path":"2023/05/28/Java/Java程序基础/java.util.Stack 类为什么是线程安全的_2023_05_28 周日- 5_24_39.15/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/","excerpt":"","text":"正文在Java中，java.util.Stack 类是线程安全的，这是因为它是通过在每个方法上添加synchronized关键字来实现同步的。synchronized关键字可以确保在同一时间只有一个线程可以访问被标记为synchronized的方法或代码块。当一个线程执行一个被synchronized关键字修饰的方法时，它将获得一个锁，其他线程必须等待该锁释放才能访问相同的方法。这样可以确保在任何给定的时刻只有一个线程可以修改Stack的状态，从而防止并发访问导致的数据不一致或竞态条件。然而，需要注意的是，虽然Stack类本身是线程安全的，但在某些情况下，使用synchronized关键字可能会降低性能，特别是在高并发环境下。因此，在Java中，推荐使用java.util.concurrent包提供的并发集合类，如java.util.concurrent.ArrayDeque或java.util.concurrent.LinkedBlockingDeque，它们提供了更高效和灵活的线程安全操作。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略","slug":"Java/Java程序基础/ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略_2023_05_28 周日- 5_24_39.07","date":"2023-05-27T21:24:39.079Z","updated":"2023-08-10T23:17:14.053Z","comments":true,"path":"2023/05/28/Java/Java程序基础/ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略_2023_05_28 周日- 5_24_39.07/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/","excerpt":"","text":"ArrayDeque 和 java.util.Stack 和 MutableList 的区别是什么ArrayDeque、java.util.Stack 和 MutableList（如 ArrayList）是实现栈的不同方式，它们有一些区别： 实现接口：ArrayDeque 实现了 Deque 接口，而 java.util.Stack 继承自 Vector 类，MutableList 则是 Kotlin 标准库中的可变列表接口。 内部数据结构：ArrayDeque 使用循环数组（circular array）作为内部数据结构，而 java.util.Stack 内部使用数组（Array），MutableList 则可以使用数组、链表或其他数据结构。 动态扩容：ArrayDeque 和 MutableList 都支持动态扩容，可以根据需要自动调整容量，而 java.util.Stack 不支持动态扩容，需要手动调整容量。 性能：ArrayDeque 在大多数操作上具有更好的性能，因为它使用了循环数组和更优化的实现。而 java.util.Stack 是一个遗留类，性能可能相对较差。MutableList 的性能取决于具体实现。 综上所述，如果你想要使用性能较好且功能丰富的栈实现，推荐使用 ArrayDeque。如果你需要与现有的代码兼容或使用特定的接口，可以选择 java.util.Stack 或 MutableList。 ArrayDeque 怎么用循环数组实现的ArrayDeque 使用循环数组（circular array）实现，它在内部维护了一个固定大小的数组来存储元素。下面是简单介绍 ArrayDeque 如何使用循环数组实现的一些关键点： 内部数组：ArrayDeque 内部有一个对象数组来存储元素，通常使用 elements 或 array 字段表示。 头部和尾部指针：ArrayDeque 有两个指针，分别指向头部和尾部。通常使用 head 和 tail 字段表示。 循环数组特性：ArrayDeque 的关键之处在于利用循环数组的性质。当头部或尾部指针到达数组的边界时，它们会回绕到数组的另一侧，形成循环效果。 扩容和缩容：当元素数量达到数组容量时，ArrayDeque 会自动扩容。在扩容时，会创建一个更大的数组，并将原始数组中的元素按照循环顺序复制到新数组中。类似地，当元素数量较少时，ArrayDeque 也会自动缩容。 添加和移除元素：添加元素时，头部指针向前移动一个位置，并将元素放入头部位置。移除元素时，头部指针向后移动一个位置，并返回头部位置的元素。 通过这种方式，ArrayDeque 可以在不断添加和移除元素的过程中高效地利用数组空间，并保持循环数组的特性。这使得 ArrayDeque 在栈和队列等数据结构的实现中具有较高的性能和灵活性。 ArrayList 和 ArrayDeque 的区别两种实现之间的主要区别在于调整大小的策略。 ArrayList 的调整大小策略是将其调整为 oldCapacity + (oldCapacity &gt;&gt; 1) 的新大小，增加了约 50%。默认容量为 10，在调整大小后的容量为 15、22、33、49、73、109、163、244、366… ArrayDeque 总是调整为 2 的幂次方。在调整大小时，容量会加倍。从默认值 16 开始，调整大小后的容量为 32、64、128、256… 因此，ArrayDeque 达到了更高的容量，而调整大小的操作更少，这是因为数组的复制操作很耗费资源。例如，要在默认大小的 ArrayList 中存储 256，需要进行 9 次调整大小操作，而 ArrayDeque 只需要 4 次。数组的复制操作可能很快，但也可能需要 GC 来释放一些空间用于新的数据集，此外还需要进行内存复制操作（ArrayDeque 可能在这方面表现更好，因为它对齐到 2 的幂次方）。 这两种数据结构的最佳情况复杂度为 O(1)。ArrayList 的 push 和 pop 操作通过直接访问头部和尾部（ArrayDeque）来实现，而 add 和 removeLast 操作（ArrayList）则是通过直接访问大小来实现。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ArrayDeque 的接口","slug":"Java/Java程序基础/ArrayDeque 的接口","date":"2023-05-27T21:07:27.450Z","updated":"2023-08-10T23:17:08.499Z","comments":true,"path":"2023/05/28/Java/Java程序基础/ArrayDeque 的接口/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"正文ArrayDeque 实现了 Deque 接口，该接口继承自 Queue 接口。下面是 Deque 接口中定义的一些主要方法： 添加元素操作： addFirst(element: E)：将元素添加到双端队列的开头。 addLast(element: E)：将元素添加到双端队列的末尾。 offerFirst(element: E)：将元素添加到双端队列的开头，并返回是否成功。 offerLast(element: E)：将元素添加到双端队列的末尾，并返回是否成功。 获取元素操作： getFirst(): E：获取双端队列的第一个元素，但不删除它。 getLast(): E：获取双端队列的最后一个元素，但不删除它。 peekFirst(): E：获取双端队列的第一个元素，如果队列为空则返回 null。 peekLast(): E：获取双端队列的最后一个元素，如果队列为空则返回 null。 移除元素操作： removeFirst(): E：移除并返回双端队列的第一个元素。 removeLast(): E：移除并返回双端队列的最后一个元素。 pollFirst(): E：移除并返回双端队列的第一个元素，如果队列为空则返回 null。 pollLast(): E：移除并返回双端队列的最后一个元素，如果队列为空则返回 null。 此外，ArrayDeque 还实现了 Queue 接口中定义的方法，如 offer(element: E)、remove(): E、poll(): E 等。 需要注意的是，ArrayDeque 是一个可变大小的数组双端队列，可以在队列的两端进行高效的插入和删除操作，同时也支持随机访问。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java Stack 过时了吗","slug":"Java/Java程序基础/Java Stack 过时了吗","date":"2023-05-27T21:04:38.144Z","updated":"2023-08-10T23:17:19.095Z","comments":true,"path":"2023/05/28/Java/Java程序基础/Java Stack 过时了吗/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/","excerpt":"","text":"正文在 Java 中，Stack 类并没有过时，仍然可以使用。然而，根据 Java 官方文档的建议，推荐使用 Deque 接口的实现类 ArrayDeque 来代替 Stack。 Stack 类是基于向量（Vector）实现的，而 Vector 是线程安全的、同步的，因此在性能上可能会有一些开销。而 ArrayDeque 是基于数组实现的双端队列，性能更高，并且在大多数情况下能够提供与 Stack 类相同的功能。 此外，Deque 接口提供了更丰富的操作方法，例如在队首或队尾插入、删除元素等，使得其更灵活且更符合现代编程的需求。 因此，尽管 Stack 类仍然可用，但在新的代码中，推荐使用 ArrayDeque 或其他实现了 Deque 接口的类来代替 Stack。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]}],"categories":[{"name":"3 - Android","slug":"3-Android","permalink":"http://example.com/categories/3-Android/"},{"name":"3.1 - FrameWork","slug":"3-Android/3-1-FrameWork","permalink":"http://example.com/categories/3-Android/3-1-FrameWork/"},{"name":"3.0 - 性能优化","slug":"3-Android/3-0-性能优化","permalink":"http://example.com/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"0 - 算法","slug":"0-算法","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/"},{"name":"0.1 - 算法题目","slug":"0-算法/0-1-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"0.1.1 - 中等","slug":"0-算法/0-1-算法题目/0-1-1-中等","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-1-%E4%B8%AD%E7%AD%89/"},{"name":"0.1.2 - 困难","slug":"0-算法/0-1-算法题目/0-1-2-困难","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-2-%E5%9B%B0%E9%9A%BE/"},{"name":"0.1.0 - 简单","slug":"0-算法/0-1-算法题目/0-1-0-简单","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-0-%E7%AE%80%E5%8D%95/"},{"name":"0.0 - 算法模版","slug":"0-算法/0-0-算法模版","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"},{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 多线程","slug":"2-Java/2-0-Java-多线程","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]}