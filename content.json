{"meta":{"title":"喵星科技报","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"About Author","date":"2023-08-09T03:40:47.000Z","updated":"2023-08-09T17:43:32.561Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-08-08T22:26:40.000Z","updated":"2023-08-08T23:16:57.285Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-09T03:39:01.000Z","updated":"2023-08-09T03:39:55.133Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"最长回文子串","slug":"算法题目/5 最长回文子串","date":"2023-08-08T23:05:00.606Z","updated":"2023-08-10T05:50:11.634Z","comments":true,"path":"2023/08/09/算法题目/5 最长回文子串/","link":"","permalink":"http://example.com/2023/08/09/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 简介12345介绍 Manacher 算法理解回文串的对称性，减少与回文串相交的字符串的计算量关键词情况一：完全包含，直接赋值情况二：部分相交。直接从后一位接续计算 正文数据预处理： 首先回文子串有两种形式 奇数 与 偶数 也就有两种对应的指针操作方式 假定有字符数组 ababaabc 改成 # a # b # a # b # a # a # b # c # 将偶数数组变成奇数统一处理 索性改成 ^ # a # b # a # b # a # a # b # c # $，头尾清晰这样就可以通过把每个字符作为回文子串的中心向两边扩展，找出最长回文子串 时间复杂度是 O(n^2) 现在需要我们观察回文子串的规律，简化计算 123456789101112131415161718192021 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ^ # a # b # a # b # a # a # b # c # $0 ^ P[0] = 01 ^ P[1] = 02 --^-- p[2] = 13 ^ P[3] = 04 ------^------ P[4] = 35 ^ P[5] = 06 ----------^---------- P[6] = 57 ^ P[7] = 08 ------^------ P[8] = 39 ^ P[9] = 010 --^-- P[10] = 111 --------^-------- P[11] = 212 --^-- P[12] = 013 ^ P[13] = 014 --^-- P[14] = 115 ^ P[15] = 016 --^-- P[16] = 117 ^ P[17] = 018 ^ P[18] = 0 情况一： 12310 --^-- P[10] = 111 --------^-------- P[11] = 212 --^-- P[12] = 0 第 10 行，第 12 行 都是 第 11 行 的子串，完全包含在 第 11 行 之中，由于回文串的对称性 此时直接有 P[10] &#x3D; P[12] 情况二： 1234 ------^------ P[4] = 36 ----------^---------- P[6] = 58 ------^------ P[8] = 3 第 4 行，第 8 行 都是 第 6 行 的子串，分别位于字符串的两端，当我们知道 第 4 行 的信息之后，我们知道 第 8 行 至少有 第 4 行 那么长，至于会不会更长，继续试着向两边扩展即可 此时需要干两件事 1. 将 P[8] &#x3D; P[4]; 2. 继续向外扩展 情况三： 8 ——^—— P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 第 8 行 部分与 第 11 行 重叠，第 14 行 是 第 11 行 的子串，非常简单，舍弃超出部分 8 –^– P[8] &#x3D; 3 11 ——–^——– P[11] &#x3D; 2 14 –^– P[14] &#x3D; 1 当成这样处理即可 定义遍历指针 i ，指向回文的中心的指针 center 和 指向回文串右边界的指针 r 此时需要干两件事 1. 将 P[8] &#x3D; r - i ; 2. 继续向外扩展 好，我们现在已经理解了 Manacher 算法的精髓了 我们思考一下算法该怎么写 P[i] 计算过程 123456789101112131415161718192021 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ^ # a # b # a # b # a # a # b # c # $0 ^ P[0] = 0 -- 起始，不必计算，更新 r1 ^ P[1] = 0 -- 暴力计算，一次计算，更新 r2 --^-- p[2] = 1 -- 暴力计算，二次计算，更新 r3 ^ P[3] = 0 -- 情况二，一次计算4 ------^------ P[4] = 3 -- 暴力计算，四次计算，更新 r5 ^ P[5] = 0 -- 情况一，零次计算6 ----------^---------- P[6] = 5 -- 情况二，六次计算，更新 r7 ^ P[7] = 0 -- 情况一，零次计算8 ------^------ P[8] = 3 -- 情况二，一次计算9 ^ P[9] = 0 -- 情况一，零次计算10 --^-- P[10] = 1 -- 情况二，一次计算11 --------^-------- P[11] = 2 -- 情况二，五次计算，更新 r12 --^-- P[12] = 0 -- 情况一，零次计算13 ^ P[13] = 0 -- 情况一，零次计算14 --^-- P[14] = 1 -- 情况三，一次计算15 ^ P[15] = 0 -- 情况二，一次计算16 --^-- P[16] = 1 -- 暴力计算，两次计算，更新 r17 ^ P[17] = 0 -- 情况二，一次计算18 ^ P[18] = 0 -- 终止 我列出了每次计算面对的情况，计算的次数以及是否需要 r 我希望大家思考 当新计算出的 r 与旧的 r 相等时，是否应该更新 center ？ 当然不应该，我们肯定更倾向于选择更长的回文串 是这样吗？ 我们思考一种情况 1234567892 --^-- p[2] = 13 ^ P[3] = 04 ------^------ P[4] = 35 ^ P[5] = 06 ----------^---------- P[6] = 57 ^ P[7] = 08 ------^------ P[8] = 39 ^ P[9] = 010 --^-- P[10] = 1 第 6 行 较长有什么用呢，有用的只是 i 到 r 这一小截而已，不更新是因为都一样，没必要更新，所以只有当我们发现了更右边的 r 更新即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; private fun formatString(s: String): String&#123; val tString : StringBuffer = StringBuffer(&quot;^#&quot;) for ( i in s.indices )&#123; tString.append(s[i]) tString.append(&#x27;#&#x27;) &#125; return tString.append(&#x27;$&#x27;).toString() &#125; private fun extend(s: String, leftIndex: Int, rightIndex: Int): Int &#123; var r = 0 var left = leftIndex var right = rightIndex while (left &gt; 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] == s[right])&#123; r ++ left -- right ++ &#125; return r &#125; fun longestPalindrome(s: String): String &#123; val tString = formatString(s) var maxR = 0 var maxCenter = 0 var center = -1 var R = 0 val p = Array&lt;Int&gt;(tString.length) &#123; 0 &#125; for ( i in tString.indices )&#123; val iMirror = center - (i - center) var rightIndex = i var leftIndex = i val maxLength = R - i val hasMirrorIndex = i &lt; R &amp;&amp; center - maxLength &gt; 0 val case1CompletelyIncluded = hasMirrorIndex &amp;&amp; i &gt; center &amp;&amp; p[iMirror] &lt; R - i val case2NotCompletelyInclude = hasMirrorIndex &amp;&amp; !case1CompletelyIncluded if(!hasMirrorIndex)&#123; p[i] = 0 rightIndex = i + 1 leftIndex = i - 1 &#125; else &#123; if(case1CompletelyIncluded) &#123; p[i] = p[iMirror] continue &#125; else if (case2NotCompletelyInclude) &#123; p[i] = maxLength rightIndex = R + 1 leftIndex = i - (rightIndex - i) &#125; &#125; p[i] += extend(tString, leftIndex, rightIndex) // 更新最右边的 R 和 center if(i + p[i] &gt; R)&#123; R = i + p[i] center = i &#125; // 判断是不是最长的回文串 if(p[i] &gt; maxR)&#123; maxR = p[i] maxCenter = i &#125; &#125; if(maxR == 0) return &quot;&quot; val start = maxCenter - maxR val end = maxCenter + maxR return tString.substring(start..end).replace(&quot;#&quot;, &quot;&quot;) &#125;&#125;","categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"00.1 - 算法 - 中等","slug":"00-1-算法-中等","permalink":"http://example.com/tags/00-1-%E7%AE%97%E6%B3%95-%E4%B8%AD%E7%AD%89/"}]},{"title":"寻找两个正序数组的中位数","slug":"算法题目/4 寻找两个正序数组的中位数","date":"2023-08-08T23:05:00.603Z","updated":"2023-08-10T05:50:06.787Z","comments":true,"path":"2023/08/09/算法题目/4 寻找两个正序数组的中位数/","link":"","permalink":"http://example.com/2023/08/09/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/4%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"题目给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 123输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 123输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6 简介123456789101112讨论在两个有序数组中寻找中位数的问题观察单个有序数组，通过比较元素大小找到舍弃的元素，确定中位数。类推两个有序数组，准备两个区间来存放偏小值和偏大值。根据区间需要满足必要条件，使得偏小区间的元素都小于偏大区间。问题转化为在单个有序数组中查找满足条件的关键元素位置，可以使用二分查找。关键词:偏小区间偏大区间二分查找 正文首先思考我们是否可以避免全排序找到中位数 我们有一种想法就是通过比较元素的大小找到需要舍弃的元素 我们观察一个有序数组，我们准备两个区间 RSmall, RBig 分别存放这个数组的偏小值与偏大值（相对中位数而言） 分别用 left，right 指针从两头操作偏小值与偏大值，将他们依次放入对应的数组 直到 「偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1」，中位数显然易得 好，现在我们来看两个有序数组的复杂情况 我们同样准备两个区间 RSmall, RBig，同样我们需要将数组偏小值放进 RSmall，偏大值放进 RBig 与一个有序数组不同的是，现在我们必须综合考虑两个有序数组的情况 所以 RSmall 区间里可能既包含 num1 数组的偏小元素也包含 num2 数组的偏小元素，对于RBig也是一样 这就让我们的思考变得复杂了，这使得 RSmall，RBig 变得无序 现在将这个 RSmall 再细分为 RSmallN1 区间，以及 RSmallN2 区间，同样有 RBigN1，RBigN2 区间 想要得到中位数，那么偶数时 RSmall.size &#x3D; RBig.size 或者 奇数时 RSmall.size &#x3D; RBig.size + 1 也就有 「 必要条件一： 偶数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size 奇数时 RSmallN1.size + RSmallN2.size &#x3D; RBigN1.size + RBigN2.size +1 」 同时 RSmall 区间内任何一个元素都必须小于 RBig 区间 自然有 Small 区间的子区间的任何一个元素都小于 Big 区间的子区间的任何一个元素 所以得到 「 必要条件二： RSmallN1 的最大值 &lt; RBigN1 的最小值 ( 因为数组有序，这是不用判断的 ) RSmallN1 的最大值 &lt; RBigN2 的最小值 RSmallN2 的最大值 &lt; RBigN1 的最小值 RSmallN2 的最大值 &lt; RBigN2 的最小值 ( 因为数组有序，这是不用判断的 )」 简化一下 「 必要条件二： maxOf( RSmallN1 ) &lt; minOf ( RBigN2 ) maxOf( RSmallN2 ) &lt; minOf ( RBigN1 ) 」 显然必要条件一加上必要条件二就是充分必要条件 现在我们要得到这四个区间，或者说要在两个有序数组分别划分出这四个区间 我们要在这两个数组中分别找到关键的那个分隔元素 因为必要条件一的原因，我们找到了 num1 数组的分割元素，我们也就找到了 num2 数组的分割元素 这非常好理解，因为 Small 区间和 Big 区间的数量是固定的，RSmallN1 多了一个元素，RSmallN2 就要对应减少一个元素 所以我们只要找到 num1 数组的分隔元素即可 至此，问题成功转化成了 在 num1 数组中查找出一个关键元素位置，这个关键元素满足上述两条必要条件 这是一个典型的有判断条件的查找问题，我们就可以使用二分查找，测试每个元素是否符合上述两个条件 关于二分查找这里不再赘述。 以下是基于二分查找的 Kotlin 代码实现，用于找出两个有序数组的中位数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 该函数用于在两个已排序整数数组中找到它们的中位数，返回类型为 Double。fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123; // 获取 nums1 和 nums2 的长度。 val n1 = nums1.size val n2 = nums2.size // 如果 nums1 的长度大于 nums2，则交换它们，确保 nums1 的长度小于等于 nums2。 if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1) &#125; // 设置左右指针的初始值。 var left = 0 // 如果把 num1 和 num2 合并元素重新排序，最左边 var right = n1 // 如果把 num1 和 num2 合并元素重新排序，相当于 num2 最左边 // 当左指针小于等于右指针时，执行二分查找。 while (left &lt;= right) &#123; // 因为 n1 &lt; n2 // 计算 nums1 中间的索引 i 和 nums2 中间的索引 j。 val num1HalfIndex = (left + right) / 2 val num2HalfIndex = ((n1 + n2 + 1) / 2) - num1HalfIndex // 计算 nums1 和 nums2 的左侧和右侧的最大值和最小值。 val maxOfNum1SmallRange = if (num1HalfIndex == 0) Int.MIN_VALUE else nums1[num1HalfIndex - 1] // nums1 小区间的最大值 val minOfNum1BigRange = if (num1HalfIndex == n1) Int.MAX_VALUE else nums1[num1HalfIndex] // nums1 大区间的最小值 val maxOfNum2SmallRange = if (j == 0) Int.MIN_VALUE else nums2[j - 1] // nums2 小区间的最大值 val minOfNum2BigRange = if (j == n2) Int.MAX_VALUE else nums2[j] // nums2 大区间的最小值 // 如果满足条件，则返回中位数。 if (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; // num1小 &lt; num2大 &amp;&amp; num2小 &lt; num1大, 也就是说“小区间都小于大区间” return if ((n1 + n2) % 2 == 0) &#123; // 如果 nums1 和 nums2 的长度之和为偶数 // 则返回左右两侧最大值和最小值的平均值。 (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / 2.0 &#125; else &#123; // 如果 nums1 和 nums2 的长度之和为奇数，则返回左侧最大值。 maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() &#125; &#125; else if (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; // num1大 &lt; num2小 // 如果 nums1 的左侧最大值大于 nums2 的右侧最小值，则需要将 num1HalfIndex 向左移动。 /* left num1HalfIndex right | | | 1 1 1 1 1 1 1 1 1 1 1 1 E 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ right = num1HalfIndex - 1 /* num1HalfIndex left | right | | | 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ &#125; else &#123; // 如果 nums2 的左侧最大值大于 nums1 的右侧最小值，则需要将 num1HalfIndex 向右移动。 /* left num1HalfIndex right | | | 1 1 1 1 1 1 1 1 1 1 1 1 E 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 E | num2HalfIndex */ left = num1HalfIndex + 1 /* 留给大家画 */ &#125; &#125; // 如果找不到中位数，则返回 0.0。 return 0.0&#125; 1234567891011121314151617181920212223242526272829fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123; val n1 = nums1.size val n2 = nums2.size if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1) &#125; var left = 0 var right = n1 while (left &lt;= right) &#123; // 因为 n1 &lt; n2 val num1HalfIndex = (left + right) / 2 val num2HalfIndex = ((n1 + n2 + 1) / 2) - num1HalfIndex val maxOfNum1SmallRange = if (num1HalfIndex == 0) Int.MIN_VALUE else nums1[num1HalfIndex - 1] val minOfNum1BigRange = if (num1HalfIndex == n1) Int.MAX_VALUE else nums1[num1HalfIndex] val maxOfNum2SmallRange = if (j == 0) Int.MIN_VALUE else nums2[j - 1] val minOfNum2BigRange = if (j == n2) Int.MAX_VALUE else nums2[j] if (maxOfNum1SmallRange &lt;= minOfNum2BigRange &amp;&amp; maxOfNum2SmallRange &lt;= minOfNumBigRange) &#123; return if ((n1 + n2) % 2 == 0) &#123; (maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() + minOf(minOfNum1BigRange, minOfNum2BigRange).toDouble()) / 2.0 &#125; else &#123; maxOf(maxOfNum1SmallRange, maxOfNum2SmallRange).toDouble() &#125; &#125; else if (maxOfNum1SmallRange &gt; minOfNum2BigRange) &#123; right = num1HalfIndex - 1 &#125; else &#123; left = num1HalfIndex + 1 &#125; &#125; return 0.0&#125; 留给大家一个问题，问 N 个有序数组的中位数怎么求？","categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"00.2 - 算法 - 困难","slug":"00-2-算法-困难","permalink":"http://example.com/tags/00-2-%E7%AE%97%E6%B3%95-%E5%9B%B0%E9%9A%BE/"}]},{"title":"无重复字符的最长子串","slug":"算法题目/3 无重复字符的最长子串","date":"2023-08-08T23:05:00.599Z","updated":"2023-08-10T05:49:58.738Z","comments":true,"path":"2023/08/09/算法题目/3 无重复字符的最长子串/","link":"","permalink":"http://example.com/2023/08/09/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/3%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 简介12345巧妙的使用 HashMap&lt;Char, Int&gt; 记录每个字符的最新的位置巧妙的确定了每个元素对应的滑动窗口的左边界关键词：HashMap &lt;Char, Int&gt;用以查找位置窗口长度不固定，遍历指针作为左边界 正文本题的巧妙在于使用 HashMap 和 遍历指针构建了一个滑动窗口 在寻找滑动窗口的时候，我们总是固定住一端位置去寻找另一端的位置，通常需要我们找到两个端点之间的关系 来分析滑动窗口的性质：左边届位置，右边界的位置，滑动窗口的长度三者有以下这些关系：滑动窗口的长度 = 滑动窗口右边届 - 滑动窗口左边界无论算法如何变化，我们知二求一 我们分析，遍历指针和左右边界的关系有三情况一：遍历指针是滑动窗口的左边界情况二：遍历指针是滑动窗口的右边界情况三：遍历指针在滑动窗口的中间 结合滑动窗口的性质情况一：知道窗口的长度，以遍历指针为左边界情况二：窗口长度不固定，新增的元素决定窗口的长度，也就是左边界的位置情况三：对于滑动窗口算法，通常情况下遍历指针要么位于窗口的左边界，要么位于右边界，用于控制窗口的扩展和收缩。在常规的滑动窗口算法中，遍历指针并不位于窗口的中间位置。 显然这种是情况二 当滑动窗口的位置和长度变化受制于新增的元素时，我们将遍历指针设置为 12345678910111213141516171819class Solution &#123; fun lengthOfLongestSubstring(s: String): Int &#123; var maxLen = 0 // 最长不含重复字符子串的长度 var left = 0 // 窗口左边界 val map = HashMap&lt;Char, Int&gt;() // 哈希表记录字符最后出现的位置 for(right in s.indices)&#123; val char = s[right] if(map.containsKey(char) &amp;&amp; map[char]!! &gt;= left)&#123; left = (map[char]?: 0) + 1 &#125; map[char] = right maxLen = maxOf(maxLen, right - left + 1) &#125; return maxLen &#125;&#125;","categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"00.1 - 算法 - 中等","slug":"00-1-算法-中等","permalink":"http://example.com/tags/00-1-%E7%AE%97%E6%B3%95-%E4%B8%AD%E7%AD%89/"}]},{"title":"两数之和","slug":"算法题目/1 两数之和","date":"2023-08-08T23:05:00.596Z","updated":"2023-08-10T05:49:48.708Z","comments":true,"path":"2023/08/09/算法题目/1 两数之和/","link":"","permalink":"http://example.com/2023/08/09/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10^4 -109 &lt;= nums[i] &lt;= 10^9 -109 &lt;= target &lt;= 10^9 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 简介1234这道题的关键在于对 hashmap 查找时间复杂度 O(1) 的应用关键词：HashMap&lt;Key, Value&gt;hashmap.containsKey(Value) 正文12345678910111213class Solution &#123; fun twoSum(nums: IntArray, target: Int): IntArray &#123; val hashmap = HashMap&lt;Int, Int&gt;() for(i in nums.indices)&#123; val complement = target - nums[i] if(hashmap.containsKey(complement))&#123; return intArrayOf(hashmap[complement]!!, i) &#125; hashmap[nums[i]] = i &#125; return intArrayOf() &#125;&#125;","categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"00.0 - 算法 - 简单","slug":"00-0-算法-简单","permalink":"http://example.com/tags/00-0-%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95/"}]},{"title":"两数相加","slug":"算法题目/2 两数相加","date":"2023-08-08T23:05:00.592Z","updated":"2023-08-10T05:49:53.442Z","comments":true,"path":"2023/08/09/算法题目/2 两数相加/","link":"","permalink":"http://example.com/2023/08/09/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/2%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"题目给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 简介1234遍历两个链表，元素相加生成新列表。关键词：哨兵节点 val dummy = ListNode(0)关键返回值 dummy?.next 正文12345678910111213141516171819202122232425262728293031323334class Solution &#123; fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123; // 定义两个指针 p1 和 p2，分别指向两个链表的头节点 var p1 = l1 var p2 = l2 // 定义一个哨兵节点 dummy，作为结果链表的头节点 val dummy = ListNode(0) // 定义一个节点 cur, 作为结果链表的尾节点 var cur = dummy var carry = 0 while(p1 != null || p2 != null)&#123; val x = p1?.`val` ?: 0 val y = p2?.`val` ?: 0 var sum = x + y + carry carry = sum / 10 sum = sum % 10 cur?.next = ListNode(sum) p1 = p1?.next p2 = p2?.next cur = cur?.next &#125; if(carry &gt; 0)&#123; cur?.next = ListNode(carry) &#125; return dummy?.next &#125;&#125;","categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"00.0 - 算法 - 简单","slug":"00-0-算法-简单","permalink":"http://example.com/tags/00-0-%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95/"}]},{"title":"N 字形变换","slug":"算法题目/6 N 字形变换","date":"2023-08-08T22:45:56.063Z","updated":"2023-08-10T05:50:16.119Z","comments":true,"path":"2023/08/09/算法题目/6 N 字形变换/","link":"","permalink":"http://example.com/2023/08/09/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/6%20N%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"","text":"题目将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1： 12输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot; 示例 2： 1234567输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P I NA L S I GY A H RP I 示例 3： 12输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由英文字母（小写和大写）、&#39;,&#39; 和 &#39;.&#39; 组成 1 &lt;= numRows &lt;= 1000 简介1234重点不在字形，重点在变换是什么变换关键词：一维函数变二维函数往复变化函数 正文我们思考，为什么这个算法难写分析 N字形 的离散函数，我们面临着一个唯一的 x 对应着 1- N 个 y在 x 变化的时候，我们首先要算该 x 对应了几个 y这根本不符合函数的定义函数是指一个集合中的每个元素都有且仅有一个映射到另一个集合中的元素，这种关系被称为函数映射 推出我们需要把一个一维度线性离线函数 s &#x3D; f(n) 变成二维离散函数 s &#x3D; g(x, y)注意，这里好玩的是 y 和 x 其实是数列即 s &#x3D; g(x(n), y(n))我们开始推导 123456789101112x(n) = x(n-1) + 1函数 x(n) 很简单，我们怎么表达 y(n) 呢我们发现 y(n) 是一个往复的等差数列对于本题有y(n) = y(n - 1) + step(n)step 是一个往复函数用 flag 代表往复函数的方向 | -1 当 y(n - 1) 到达最大值或者最小值时flag = | 1 其他step(n) = flag * step(n-1) 当 y(n - 1) 到达最大值或者最小值时 | -step(n-1) 其他step(n) = | step(n) 1234567891011121314151617class Solution &#123; fun convert(s: String, numRows: Int): String &#123; 推出 (numRows &lt; 2) return s val rows: MutableList&lt;StringBuilder&gt; = ArrayList() for (i in 0 until numRows) rows.add(StringBuilder()) var i = 0 var step = -1 for (c in s.toCharArray()) &#123; rows[i].append(c) if (i == 0 || i == numRows - 1) step = -step i += step &#125; val res = StringBuilder() for (row in rows) res.append(row) return res.toString() &#125;&#125;","categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"00.1 - 算法 - 中等","slug":"00-1-算法-中等","permalink":"http://example.com/tags/00-1-%E7%AE%97%E6%B3%95-%E4%B8%AD%E7%AD%89/"}]},{"title":"协程中的取消和异常 （取消操作详解）","slug":"Kotlin/Kotlin 协程/协程中的取消和异常 （取消操作详解）","date":"2023-06-17T05:55:03.131Z","updated":"2023-08-09T22:07:48.346Z","comments":true,"path":"2023/06/17/Kotlin/Kotlin 协程/协程中的取消和异常 （取消操作详解）/","link":"","permalink":"http://example.com/2023/06/17/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/","excerpt":"","text":"正文在开发中，我们要避免不必要的的任务来节约设备的内存和电量的使用，协程也是如此。在使用的过程我们需要控制好它的生命周期，在不需要它的取消它。 调用cancel方法取消作用域会取消它的子协程当启动了很多个协程，我们一个个协程的取消比较麻烦，我们可以通过取消整个作用域来解决这个问题，因为取消作用域可以取消该作用域创建的所有协程。 123456/ 假设我们已经定义了一个作用域val job1 = scope.launch &#123; … &#125;val job2 = scope.launch &#123; … &#125;scope.cancel() 假设我们创建了一个作用域scope,并创建了两个协程job1和job2。我们通过调用scope.cancel()，取消作用域，将会把job1 和job2两个协程都取消。 单独取消某个协程，不会影响他的兄弟协程我们创建了两个协程，job1和job2.我们单独取消job1，不会影响到job2 1234567// 假设我们已经定义了一个作用域val job1 = scope.launch &#123; … &#125;val job2 = scope.launch &#123; … &#125; // 第一个协程将会被取消，而另一个则不受任何影响job1.cancel() 协程通过抛出一个特殊的异常 CancellationException 来处理取消操作在调用cancel函数的时候，我们需要传入一个CancellationException对象,如果我们没有传入，那就用默认的defaultCancellationException。 1234// external cancel with cause, never invoked implicitly from internal machinery public override fun cancel(cause: CancellationException?) &#123; cancelInternal(cause ?: defaultCancellationException()) &#125; 一旦抛出了CancellationException，我们就可以通过这一机制来处理协程的取消。在底层的实现中，子协程会通过抛出异常的方式将取消的情况通知它的父级，父协程通过传入的取消原因决定是否处理该异常。 不能在已取消的作用域中再次启动新的协程调用了 cancel 方法为什么协程处理的任务没有停止？不同的Diapatcher不同的区别，下一篇文章将介绍。 我们以Dispatchers.Default为例子 12345678910111213141516171819202122import kotlinx.coroutines.*suspend fun main() = runBlocking &#123; var startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; var nextTime = startTime var i = 0 while (i &lt; 5) &#123; if (System.currentTimeMillis() &gt;= nextTime) &#123; println(&quot;这是第$&#123;i&#125;次&quot;) i++ //1000毫秒执行一次 nextTime += 1000 &#125; &#125; &#125; delay(1000) println(&quot;取消&quot;) job.cancel() println(&quot;取消完毕&quot;)&#125; 1234567这是第0次这是第1次取消取消完毕这是第2次这是第3次这是第4次 调用cancel方法之后，协程的任务依然在运行。调用cancel方法的时候，此时协程处于cancelling正在取消的状态，接着我们打印了2，3，4，处理任务结束之后，协程变成cancelled已经取消的状态，这是以Default举例，Default调度会等待协程任务处理完毕才取消。 让协程可以被取消协程处理任务都是协作式的，协作的意思就是我们的处理任务要配合协程取消做处理。因此在执行任务期间我们要定时检查协程的状态是否已经取消，例如我们从磁盘读取文件之前我们先检查协程是否被取消了。 123456val job = launch &#123; for(file in files) &#123; // TODO 检查协程是否被取消 readFile(file) &#125;&#125; 协程中的挂起函数都是可取消的，使用他们的时候，我们不需要检查协程是否已取消。例如withContext，delay 。如果没有这些挂起函数，为了让我们的代码配合协程取消，可以使用一下两种方法： 检查 job.isActive 或者使用 ensureActive() 使用 yield() 来让其他任务进行 检查 job 的活跃状态先看一下第一种方法，在我们的 while(i&lt;5) 循环中添加对于协程状态的检查: 12// 因为处于 launch 的代码块中，可以访问到 job.isActive 属性while (i &lt; 5 &amp;&amp; isActive) 使用 yield() 函数运行其他任务Job.join 和 Deferred.await cancellation等待协程处理结果有两种方法，launch启动的job可以调用join，async 返回的Deferred 可以调用await方法 job.join会让协程挂起，直到等待协程处理任务完毕，我们可以配合cancel使用 deferred.await()如果我们关心协程的处理结果，我们可以使用deferred。结果由deferred.await返回。也是job类型，也可以被取消。 处理协程取消的副作用当我们需要在协程取消 后处理一些清理的工作，或者做一些打印日志。我们有几种办法： 通过检查协程的状态 123456789while (i &lt; 5 &amp;&amp; isActive) &#123; if (…) &#123; println(“Hello $&#123;i++&#125;”) nextPrintTime += 500L &#125;&#125; // 协程所处理的任务已经完成，因此我们可以做一些清理工作println(“Clean up!” 当判断协程不是isActive状态的时候，我们可以做一些清理 try catch finally 我们知道协程的取消会抛出CancellationException 异常，我们可以在协程提中使用try catch finally，在finally中做我们的一些清理的工作，或者打印日志 1234567891011121314val job = launch &#123; try &#123; work() &#125; catch (e: CancellationException)&#123; println(“Work cancelled!”) &#125; finally &#123; println(“Clean up!”) &#125;&#125;delay(1000L)println(“Cancel!”)job.cancel()println(“Done! 已经取消的协程，不能再被挂起已经取消的协程，不能再被挂起，但是当我们需要在取消的协程中调用挂起函数，那么我们可以在finally中使用NonCancellable ，意思是让协程挂起，直到处理挂起函数中的代码完毕，协程才会取消。 1234567891011121314151617val job = launch &#123; try &#123; work() &#125; catch (e: CancellationException)&#123; println(“Work cancelled!”) &#125; finally &#123; withContext(NonCancellable)&#123; delay(1000L) // 或一些其他的挂起函数 println(“Cleanup done!”) &#125; &#125;&#125;delay(1000L)println(“Cancel!”)job.cancel()println(“Done! 在jetpack中使用viewModelScope 或者lifecycleScope 中定义的作用域，他们在scope完成后取消他们的处理任务。如果我们手动创建自己的作用域CoroutineScope，我们需要协作协程，将我们的作用域和job绑定，在需要的时候取消。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"Kotlin 的协程本质到底什么","slug":"Kotlin/Kotlin 协程/Kotlin 的协程本质到底什么","date":"2023-06-17T05:52:43.121Z","updated":"2023-08-09T22:07:48.254Z","comments":true,"path":"2023/06/17/Kotlin/Kotlin 协程/Kotlin 的协程本质到底什么/","link":"","permalink":"http://example.com/2023/06/17/Kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/","excerpt":"","text":"正文几乎就是用阻塞的写法来完成非阻塞的任务。Kotlin-JVM中所谓的协程是假协程Kotlin-JVM中所谓的 协程挂起 ，就是开启了一个子线程去执行任务 对于Java来说，不管你用什么方法，只要你没有魔改JVM，那么最终你代码里start几个线程，操作系统就会创建几个线程，是1比1的关系。Kotlin官网中那个创建10w个Kotlin协程没有oom的例子其实有误导性，本质上那10w个Kotlin协程就是10w个并发任务仅此而已，他下面运行的就是一个单线程的线程池。你往一个线程池里面丢多少个任务都不会OOM的（前提是你的线程池创建的时候设定了对应的拒绝策略，否则无界队列下，任务过多一定会OOM），因为在运行的始终是那几个线程。 创建协程的方式有五种： 12345GlobalScope.launch&#123;&#125;launch&#123;&#125;runBlocking&#123;&#125;coroutineScope&#123;&#125;async&#123;&#125;","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"}],"tags":[]},{"title":"Kotlin中的惰性操作容器——Sequence","slug":"Kotlin/Kotlin 基础/Kotlin中的惰性操作容器——Sequence","date":"2023-06-17T05:23:26.204Z","updated":"2023-08-09T22:07:48.438Z","comments":true,"path":"2023/06/17/Kotlin/Kotlin 基础/Kotlin中的惰性操作容器——Sequence/","link":"","permalink":"http://example.com/2023/06/17/Kotlin/Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/","excerpt":"","text":"Sequence序列Sequence 是Kotlin标准库提供的一种容器类型。它和Iterable一样具备对集合进行多步骤操作能力，但是却是采用了一种完全不同于Iterable的实现方式： 12345678val map = (0..3).filter &#123; println(&quot;filter:$it&quot;) it % 2 == 0&#125;.map &#123; println(&quot;map:$it&quot;) it + 1&#125;println(map) 上面的代码用来演示Iterable进行连续操作的情况。它的输出如下： 1234567filter:0filter:1filter:2filter:3map:0map:2[1, 3] 像map和filter这些链式集合函数它们都会立即执行并创建中间临时集用来保存数据。当原始数据不多时，这并不会有什么影响。但是，当原始数据量非常大的时候。这就会变的非常低效。而此时，就可以借助Sequence提高效率。 123456789val sequence = (0..3).asSequence().filter &#123; println(&quot;filter:$it&quot;) it % 2 == 0&#125;.map &#123; println(&quot;map:$it&quot;) it + 1&#125;println(&quot;准备开始执行&quot;)println(sequence.toList()) 上面的代码执行结果如下： 12345678准备开始执行filter:0map:0filter:1filter:2map:2filter:3[1, 3] 对比Iterable和Sequence： Iterable是即时的、Sequence是惰性的：前者会要求尽早的计算结果，因此在多步骤处理链的每一环都会有中间产物也就是新的集合产生；后者会尽可能的延迟计算结果，Sequence处理的中间函数不进行任何计算。相反，他们返回一个新Sequence的，用新的操作装饰前一个，所有的这些计算都只是在类似toList的终端操作期间进行。 区分中间操作符和末端操作符的方式也很简单：如果操作符返回的是一个Sequence类型的数据，它就是中间操作符。 在操作的执行方式上也有所不同：Iterable每次都是在整个集合执行完操作后再进行下一步操作——采用第一个操作并将其应用于整个集合，然后移动到下一个操作，官方将其称呼为急切式或者按步骤执行（Eager&#x2F;step-by-step）；而Sequence则是逐个对每个元素执行所有操作。是一种惰性顺序——取第一个元素并应用所有操作，然后取下一个元素，依此类推。官方将其称呼为惰性式或者按元素执行（Lazy&#x2F;element-by-element) 序列的惰性会带来一下几个优点： 它们的操作按照元素的自然顺序进行； 只做最少的操作； 元素可以是无限多个； 不需要在每一步都创建集合 Sequence可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。但是，惰性性质也会带来一些运行开销。所以在使用时要权衡惰性开销和中间步骤开销，在Sequence和Iterable中选择更加合适的实现方式。 执行的顺序1234567891011sequenceOf(1,2,3) .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125; .map &#123; print(&quot;M$it, &quot;); it * 2 &#125; .forEach &#123; print(&quot;E$it, &quot;) &#125; // Prints: F1, M1, E2, F2, F3, M3, E6,listOf(1,2,3) .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125; .map &#123; print(&quot;M$it, &quot;); it * 2 &#125; .forEach &#123; print(&quot;E$it, &quot;) &#125;// Prints: F1, F2, F3, M1, M3, E2, E6, sequence的执行时按照元素进行的，依次对元素执行所有的操作，对一个元素而言，所有操作时依次全部执行的。而普通集合操作则是以操作步骤进行的，当所有的元素执行完当前操作后才会进入下一个操作。 只做最少的操作试想一下我们有一千万个数字，我们要经过几次变换取出20个，使用下面的代码对比一下序列和不同集合操作的性能： 12345678910111213141516171819fun main()&#123; val fFlow = FFlow() fFlow.demoList() fFlow.demoSequence()&#125;fun demoSequence() &#123; val currentTimeMillis = System.currentTimeMillis() val list = (0..10000000).asSequence().map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList() println(&quot;demoSequence:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)&#125;fun demoList() &#123; val currentTimeMillis = System.currentTimeMillis() val list = (0..10000000).map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList() println(&quot;demoList:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)&#125; 输出的结果如下： 12demoSequence:20ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]demoList:4106ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37] 这就是只执行最少操作的意思，序列按照元素顺序执行，当取够29个元素之后便会立即停止计算。而不同的集合则不同，没有中间操作的概念。它的每次操作都会对整个数组中的所有元素执行完才会进行下一个——也就是前两个map都要执行一千万次。 序列可以是无限的看如下代码： 123456var list = emptyArray&lt;Int&gt;()var i = 0while(true)&#123; list[i] = i++&#125;list.take(10) 很明显，这段代码是没法正常运行的，因为这里有一个死循环。我们也无法创建一个无限长度的集合。但是：因为序列式按步骤依照需求进行处理的，所哟我们可以创建无限序列： 123456789val noEnd = sequence &#123; var i = 1 while (true) &#123; yield(i) i *= 2 &#125;&#125;noEnd.take(4).toList()//输出:[1, 2, 4, 8] 但是一定要注意，我们虽然可以这么写，但是务必不能真的让while一直循环。我们不能直接使用toList。必须提供一个能结束循环的操作符，也就是不能取出所有元素（无限个）——要么使用类似take的操作来限制它们的数量，要么使用不需要所有元素的终端操作，例如first, find, any, all, indexOf等。 序列不会在每个步骤创建集合普通的集合会在每次变换之后都会创建新的集合取存储所有变换后的元素。而每次创建集合和填入数据都会带来不小的性能开销。尤其是当我们处理大量或大量的集合时，性能问题会愈发凸显。而序列的按元素操作，则不会有这个问题。除非手动调用了终端操作符，否则不会生成新的集合。 Sequence的基本使用Sequence序列的使用和普通的Iterable极其相似，实际上其内部也还是借助Iterable实现的。在研究它的内部实现原理之前，想从Sequence的创建和基本的序列操作来演示Sequence的基本用法。 序列的创建创建Sequence的方式大概可以分为。分别是由元素创建、通过Iterable、借助函数以及由代码块创建。 由元素创建：通过调用顶级函数sequenceOf实现： 12val ints = sequenceOf(1, 2, 3, 4, 5, 6, 7)val strings = sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) 通过Iterable转化：借助Iterable的扩展函数asSequence实现： 12val ints = listOf(1, 2, 3, 4, 5, 6, 7).asSequence()val strings = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence() 通过generateSequence实现：该方法有三个： 123generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; 最终都是通过GeneratorSequence实现的，这里先不进行源码分析。只讨论使用方式： 其中三个函数都有的形参nextFunction可以理解为元素生成器，序列里的元素都通过调用该函数生成，当它返回为null是，序列停止生成（所以，nextFunction必须要在某个情况下返回null，否则会因为序列元素是无限多个触发java.lang.OutOfMemoryError: Java heap space异常）。 而另外两个的seedFunction和seed形参都是为了确定数据初始值的。区别在于一个直接指明，一个通过调用函数获取。 分别用这三个函数生成0~100的序列，代码如下： 12345678910111213141516171819202122val generateSequenceOne = generateSequence &#123; if (i &lt; 100) &#123; i++ &#125; else &#123; null &#125;&#125;val generateSequenceTwo = generateSequence(0) &#123; if (it &lt; 100) &#123; it+1//此处的it是上一个元素 &#125; else &#123; null &#125;&#125;val generateSequenceThree = generateSequence(&#123; 0 &#125;) &#123; if (it &lt; 100) &#123; it+1//此处的it是上一个元素 &#125; else &#123; null &#125;&#125; 由代码块生成：借助sequence(block: suspend SequenceScope.() -&gt; Unit)函数。改函数接受一个挂起函数，该函数会接受一个SequenceScope实例，这个实例无需我们创建（后面源码分析会讲到）。SequenceScope提供了yield和yieldAll方法复杂返回序列元素给调用者，并暂停序列的执行，直到使用者请求下一个元素。 用该函数生成0~100的序列，代码如下： 12345val ints = sequence &#123; repeat(100) &#123; yield(it) &#125;&#125; 序列的操作对序列的操作可以分为中间操作和末端操作两种。它们只要有一下另种区别： 中间操作返回惰性生成的一个新的序列，而末端序列则为其他普通的数据类型； 中间操作不会立刻执行代码，仅当执行了末端操作序列才会开始执行。 常见的中间操作包括：map、fliter、first、last、take等；它们会序列提供数据变化过滤等增强功能基本上和kotlin提供的集合操作符有着相同的功能。 常见的末端操作有：toList、toMutableList、sum、count等。它们在提供序列操作功能的同时，还会触发序列的运行。 Sequence源码分析上文对序列做了简单的入门介绍。接下来深入源码去了解一下Sequence的实现方式。 Sequence是什么？Kotlin对的定义Sequence很简单： 123public interface Sequence &lt;out T&gt; &#123; public operator fun iterator(): Iterator&lt;T&gt;&#125; 就是一个接口，定义了一个返回Iterator的方法。接口本身只定义了Sequence具有返回一个迭代器的能力。具体的功能实现还是靠它的实现类完成。 可以概括一些：序列就是一个具备提供了迭代器能力的类。 序列的创建方式分析结合上文中提到的序列的四种创建方式，我们依次分析一下它的创建流程。 我们首先以比较常用的通过Iterable转化获取序列，它需要借助asSequence方法分析一下，使用listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()生成一个序列。调用链如下： 1234567public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123; return Sequence &#123; this.iterator() &#125;&#125;public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 流程很简单，一个扩展函数加一个内联函数。最终通过匿名内部类的方式创建一个Sequence并返回。代码很好理解，实际上它的实现逻辑等同于下面的代码： 1234567val sequence = MySequence(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).iterator())class MySequence&lt;T&gt;(private val iterator:Iterator&lt;T&gt;):Sequence&lt;T&gt;&#123; override fun iterator(): Iterator&lt;T&gt; &#123; return iterator &#125;&#125; 接着看一下通过调用顶级函数sequenceOf实现，以sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)为例，它的调用逻辑如下： 1public fun &lt;T&gt; sequenceOf(vararg elements: T): Sequence&lt;T&gt; = if (elements.isEmpty()) emptySequence() else elements.asSequence() 可以看到依旧是借助asSequence实现的。 接下来看一下代码块和generateSequence的实现方式，这两个方式会比较复杂一点，毕竟前面两个都是借助List进行转换，而List本身就能提供迭代器Iterator。后面两个明显需要提供新的迭代器。 首先看一下代码看的实现方式： 12345val ints = sequence &#123; repeat(100) &#123; yield(it) &#125; &#125; 其中sequence的调用逻辑如下： 123456789101112public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; iterator(block) &#125;public fun &lt;T&gt; iterator(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123; //创建迭代器 val iterator = SequenceBuilderIterator&lt;T&gt;() iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator) return iterator&#125;public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 可以发现：该方法和asSequence一样最终也是通过匿名内部类的方式创建了一个Sequence。不过区别在于，该方法需要创建一个新的迭代器，也就是SequenceBuilderIterator 。同样以MySequence为例，它的创建流程等同于一下代码： 123456789101112131415fun mian()&#123; create&lt;Int&gt; &#123; myblock() &#125;&#125;suspend fun SequenceScope&lt;Int&gt;.myblock()&#123; repeat(100) &#123; yield(it) &#125;&#125;fun &lt;Int&gt; create(block: suspend SequenceScope&lt;Int&gt;.() -&gt; Unit):Sequence&lt;Int&gt;&#123; val iterator = SequenceBuilderIterator&lt;Int&gt;() iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator) return MySequence(iterator)&#125; 当然，这是不可能实现的，因为SequenceBuilderIterator是被private修饰了，我们是无法直接访问的。这里强制写出来演示一下它的流程。 最后看一下通过generateSequence方法创建序列的源码，一共有三个： 123456789101112public fun &lt;T : Any&gt; generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = GeneratorSequence(seedFunction, nextFunction)public fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = if (seed == null) EmptySequence else GeneratorSequence(&#123; seed &#125;, nextFunction)public fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; &#123; return GeneratorSequence(nextFunction, &#123; nextFunction() &#125;).constrainOnce()&#125; 最终都是创建了GeneratorSequence的一个实例并返回，而GeneratorSequence实现了Sequence接口并重写了iterator()方法： 1234567891011121314151617181920212223242526272829private class GeneratorSequence&lt;T : Any&gt;(private val getInitialValue: () -&gt; T?, private val getNextValue: (T) -&gt; T?) : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; var nextItem: T? = null var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue private fun calcNext() &#123; nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!) nextState = if (nextItem == null) 0 else 1 &#125; override fun next(): T &#123; if (nextState &lt; 0) calcNext() if (nextState == 0) throw NoSuchElementException() val result = nextItem as T // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue nextState = -1 return result &#125; override fun hasNext(): Boolean &#123; if (nextState &lt; 0) calcNext() return nextState == 1 &#125; &#125;&#125; 总结一下Sequence的创建大致可以分为三类： 使用List自带的迭代器通过匿名的方式创建Sequence实例，sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)和listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()就是这种方式； 创建新的SequenceBuilderIterator迭代器，并通过匿名的方式创建Sequence实例。例如使用代码块的创建方式。 创建GeneratorSequence，通过重写iterator()方法，使用匿名的方式创建Iterator。GeneratorSequence方法就是采用的这种方式。 看完创建方式，也没什么奇特的，就是一个提供迭代器的普通类。还是看不出是如何惰性执行操作的。接下来就分析一下惰性操作的原理。 序列的惰性原理以最常用的map操作符为例：普通的集合操作源码如下： 123456789101112public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123; //出啊年一个新的ArrayList，并调用mapTo方法 return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)&#125;public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123; //遍历原始的集合，进行变换操作，然后将变换后的数据依次加入到新创建的集合 for (item in this) destination.add(transform(item)) //返回新集合 return destination&#125; 可以看到：当List.map被调用后，便会立即创建新的集合，然后遍历老数据并进行变换操作。最后返回一个新的数据。这印证了上面提到的普通集合的操作时按照步骤且会立刻执行的理论。 接下来看一下序列的map方法，它的源码如下： 1234567891011121314151617181920212223public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123; return TransformingSequence(this, transform)&#125;internal class TransformingSequence&lt;T, R&gt;constructor(private val sequence: Sequence&lt;T&gt;, private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123; override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123; //注释一：TransformingSequence的iterator持有上一个序列的迭代器 val iterator = sequence.iterator() override fun next(): R &#123; //注释二：在开始执行迭代时，向上调用前一个序列的迭代器。 return transformer(iterator.next()) &#125; override fun hasNext(): Boolean &#123; return iterator.hasNext() &#125; &#125; internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123; return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator) &#125;&#125; 代码并不复杂，它接收用户提供的变换函数和序列，然后创建了一个TransformingSequence并返回。TransformingSequence本身和上文中提到的序列没什么区别，唯一的区别在于它的迭代器：在通过next依次取数据的时候，并不是直接返回元素。而是先调用调用者提供的函数进行变换。返回变换后的数据——这也没什么新鲜的，和普通集合的map操作符和RxJava的Map都是同样的原理。 但是，这里却又有点不一样。操作符里没有任何开启迭代的代码，它只是对序列以及迭代进行了嵌套处理，并不会开启迭代.如果用户不手动调用（后者间接调用）迭代器的next函数，序列就不会被执行——这就是惰性执行的机制的原理所在。 而且，由于操作符返回的是一个Sequence类型的值，当你重复不断调用map时，例如下面的代码： 12345678(0..10).asSequence().map&#123;add(it)&#125;.map&#123;add(it)&#125;.map&#123;add(it)&#125;.toList()//等同于val sequence1 = (0..10).asSequence()val sequence2 = sequence1.map &#123; it+1 &#125;val sequence3 = sequence2.map &#123; it+1 &#125;sequence3.toList() 最终，序列sequence3的结构持有如下：sequence3-&gt; sequence2 -&gt; sequence1。而它们都有各自的迭代器。迭代器里都重写了各自的变换逻辑: 123456789override fun next(): R &#123; return transformer(iterator.next())&#125;//由于这里都是执行的+1操作，所以变换逻辑transformer可以认为等同于如下操作:override fun next(): R &#123; return iterator.next()+1&#125; 而当我们通过sequence3.toList执行代码时，它的流程如下： 123456789101112131415161718public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123; return this.toMutableList().optimizeReadOnlyList()&#125;public fun &lt;T&gt; Sequence&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123; //末端操作符，此处才会开始创建新的集合 return toCollection(ArrayList&lt;T&gt;())&#125;public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123; //执行迭代器next操作 //当调用（末端操作符）走到这里时，便会和普通结合的操作符一样 //此时为新创建的集合赋值 for (item in this) &#123; destination.add(item) &#125; return destination&#125; 经过几次扩展函数调用，最终在toCollection里开始执行迭代(Iterator的典型的操作)，也就是获取了sequence3的iterator实例，并不断通过next取出数据。而在上文中的TransformingSequence源码里可以看到，TransformingSequence会持有上一个迭代器的实例（代码注释一）。 并且在迭代开始后，在进行transformer操作（也就是执行+1操作）前，会调用上一个迭代器的next方法进行迭代（代码注释二）。这样不断的迭代，最终，最终会调用到sequence1的next方法。再结合上文中的序列创建里的分析——sequence1里所持有的迭代器就是就是原始数据里的迭代器。 那么当最终执行toList方法时，它会循环sequence3.iterator方法。而在每次循环内，都会首先执行sequence3所持有的sequence2.iterator的next方法。sequence2依次类推执行到sequence1的sequence1.iterator&#96;方法，最终执行到我们原始数组的迭代器next方法： 整个流程如下： 原理就是这么简单：中间操作符通过序列嵌套，实现对迭代器iterator的嵌套。这样在进行迭代的时候，会依次调用各个iterator迭代器直到调用到原始集合数据里的迭代器开始并返回元素。而当元素返回时，会依次执行各个迭代器持有变换操作方法实现对数据的变换。 而其他操作符，也是遵循这个基本的规则。无非就是增加一些其他的操作。 总结 序列通过中间操作符对迭代器进行嵌套和复写，以此实现按元素操作执行变换； 中间操作符只负责根据需求创建并嵌套迭代器，并不负责开启迭代器。以此实现惰性操作且不产生临时集合； 末端操作符负责开启迭代，按照嵌套顺序执行迭代操作。依次获取操作后的数据，并且会创建新的集合用来存储最终数据； 序列不是万能的，因为要引入新的对象。在带来惰性和顺序执行的优势时，这些对象必然会带来性能开销。所以要依需求在集合和序列之间进行选择，使用合适的方式进行迭代。","categories":[{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"RESTful API","slug":"网络通信/RESTful API","date":"2023-06-02T00:25:43.991Z","updated":"2023-08-09T22:07:49.126Z","comments":true,"path":"2023/06/02/网络通信/RESTful API/","link":"","permalink":"http://example.com/2023/06/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/RESTful%20API/","excerpt":"","text":"当我们谈到RESTful API，”RESTful”是表示”Representational State Transfer”的缩写。它是一种设计和构建网络应用程序的架构风格，用于创建可伸缩、可维护和可扩展的Web服务。 以下是RESTful API的一些关键概念： 资源（Resource）：在RESTful API中，所有的事物都被视为资源。资源可以是具体的实体（例如用户、文章、订单等），也可以是抽象的概念（例如用户登录、搜索等）。 统一的接口（Uniform Interface）：RESTful API使用统一的接口进行资源的操作。这包括使用标准的HTTP方法（GET、POST、PUT、DELETE等）对资源进行操作，并使用URL来标识和定位资源。 状态无关（Stateless）：RESTful API是无状态的，每个请求都应该包含足够的信息来理解和处理请求，服务器不应该保存客户端的状态。客户端可以在每个请求中提供必要的信息来完成请求的处理。 资源的表示（Representation）：资源的表示指的是以某种格式（如JSON、XML等）将资源的状态传递给客户端。客户端可以通过获取资源的表示来了解和操作资源的状态。 超媒体驱动（HATEOAS）：RESTful API可以通过在资源的表示中提供超媒体链接，使客户端能够动态地发现和导航到相关资源。这样客户端可以根据链接进行进一步的操作，而无需事先了解所有可能的操作。 通过遵循RESTful API的原则，可以使API设计更加简洁、可读性高，并提供灵活性和可扩展性。RESTful API也更加符合Web的原生特性，易于理解和使用。 在使用Retrofit或其他网络请求库时，通常会将RESTful API作为后端服务的接口，通过发送HTTP请求来与后端进行通信，获取、创建、更新或删除资源的数据。了解RESTful API的概念可以帮助你更好地理解和使用这些API。","categories":[],"tags":[]},{"title":"synchronized 关键字为什么会引入锁的竞争","slug":"Java/多线程/synchronized 关键字为什么会引入锁的竞争","date":"2023-05-27T21:24:39.188Z","updated":"2023-08-09T22:07:46.279Z","comments":true,"path":"2023/05/28/Java/多线程/synchronized 关键字为什么会引入锁的竞争/","link":"","permalink":"http://example.com/2023/05/28/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E5%85%A5%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89/","excerpt":"","text":"正文synchronized 关键字用于实现线程同步，它可以保证在同一时间只有一个线程能够执行被 synchronized 修饰的代码块或方法。当一个线程获取了对象的锁，其他线程需要等待该线程释放锁才能继续执行。 当多个线程同时竞争同一个锁时，就会发生锁的竞争。这种竞争会导致多个线程按顺序排队等待锁的释放，从而引入性能问题。具体来说，锁的竞争可能导致以下情况： 线程争用：多个线程同时竞争同一个锁，会导致线程进行上下文切换，从而增加了线程切换的开销。 阻塞等待：当一个线程获取了锁，其他线程需要等待，直到该线程释放锁。这会导致其他线程阻塞，降低了并发性能。 锁饥饿：如果某个线程频繁地获取锁，其他线程无法获得执行的机会，会导致其他线程长时间等待锁，造成锁饥饿的情况。 因此，当多个线程同时竞争同一个锁时，就会引入锁的竞争问题，进而影响程序的性能。在高并发场景中，合理设计并发控制机制，避免不必要的锁竞争，可以提高程序的并发性能。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 多线程","slug":"2-Java/2-0-Java-多线程","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"java.util.Stack 类为什么是线程安全的","slug":"Java/Java程序基础/java.util.Stack 类为什么是线程安全的_2023_05_28 周日- 5_24_39.15","date":"2023-05-27T21:24:39.157Z","updated":"2023-08-09T22:07:46.113Z","comments":true,"path":"2023/05/28/Java/Java程序基础/java.util.Stack 类为什么是线程安全的_2023_05_28 周日- 5_24_39.15/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/java.util.Stack%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.15/","excerpt":"","text":"正文在Java中，java.util.Stack 类是线程安全的，这是因为它是通过在每个方法上添加synchronized关键字来实现同步的。synchronized关键字可以确保在同一时间只有一个线程可以访问被标记为synchronized的方法或代码块。当一个线程执行一个被synchronized关键字修饰的方法时，它将获得一个锁，其他线程必须等待该锁释放才能访问相同的方法。这样可以确保在任何给定的时刻只有一个线程可以修改Stack的状态，从而防止并发访问导致的数据不一致或竞态条件。然而，需要注意的是，虽然Stack类本身是线程安全的，但在某些情况下，使用synchronized关键字可能会降低性能，特别是在高并发环境下。因此，在Java中，推荐使用java.util.concurrent包提供的并发集合类，如java.util.concurrent.ArrayDeque或java.util.concurrent.LinkedBlockingDeque，它们提供了更高效和灵活的线程安全操作。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略","slug":"Java/Java程序基础/ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略_2023_05_28 周日- 5_24_39.07","date":"2023-05-27T21:24:39.079Z","updated":"2023-08-09T22:07:46.038Z","comments":true,"path":"2023/05/28/Java/Java程序基础/ArrayDeque 和 java.util.Stack 和 MutableList 实现与扩容策略_2023_05_28 周日- 5_24_39.07/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E5%92%8C%20java.util.Stack%20%E5%92%8C%20MutableList%20%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5_2023_05_28%20%E5%91%A8%E6%97%A5-%205_24_39.07/","excerpt":"","text":"ArrayDeque 和 java.util.Stack 和 MutableList 的区别是什么ArrayDeque、java.util.Stack 和 MutableList（如 ArrayList）是实现栈的不同方式，它们有一些区别： 实现接口：ArrayDeque 实现了 Deque 接口，而 java.util.Stack 继承自 Vector 类，MutableList 则是 Kotlin 标准库中的可变列表接口。 内部数据结构：ArrayDeque 使用循环数组（circular array）作为内部数据结构，而 java.util.Stack 内部使用数组（Array），MutableList 则可以使用数组、链表或其他数据结构。 动态扩容：ArrayDeque 和 MutableList 都支持动态扩容，可以根据需要自动调整容量，而 java.util.Stack 不支持动态扩容，需要手动调整容量。 性能：ArrayDeque 在大多数操作上具有更好的性能，因为它使用了循环数组和更优化的实现。而 java.util.Stack 是一个遗留类，性能可能相对较差。MutableList 的性能取决于具体实现。 综上所述，如果你想要使用性能较好且功能丰富的栈实现，推荐使用 ArrayDeque。如果你需要与现有的代码兼容或使用特定的接口，可以选择 java.util.Stack 或 MutableList。 ArrayDeque 怎么用循环数组实现的ArrayDeque 使用循环数组（circular array）实现，它在内部维护了一个固定大小的数组来存储元素。下面是简单介绍 ArrayDeque 如何使用循环数组实现的一些关键点： 内部数组：ArrayDeque 内部有一个对象数组来存储元素，通常使用 elements 或 array 字段表示。 头部和尾部指针：ArrayDeque 有两个指针，分别指向头部和尾部。通常使用 head 和 tail 字段表示。 循环数组特性：ArrayDeque 的关键之处在于利用循环数组的性质。当头部或尾部指针到达数组的边界时，它们会回绕到数组的另一侧，形成循环效果。 扩容和缩容：当元素数量达到数组容量时，ArrayDeque 会自动扩容。在扩容时，会创建一个更大的数组，并将原始数组中的元素按照循环顺序复制到新数组中。类似地，当元素数量较少时，ArrayDeque 也会自动缩容。 添加和移除元素：添加元素时，头部指针向前移动一个位置，并将元素放入头部位置。移除元素时，头部指针向后移动一个位置，并返回头部位置的元素。 通过这种方式，ArrayDeque 可以在不断添加和移除元素的过程中高效地利用数组空间，并保持循环数组的特性。这使得 ArrayDeque 在栈和队列等数据结构的实现中具有较高的性能和灵活性。 ArrayList 和 ArrayDeque 的区别两种实现之间的主要区别在于调整大小的策略。 ArrayList 的调整大小策略是将其调整为 oldCapacity + (oldCapacity &gt;&gt; 1) 的新大小，增加了约 50%。默认容量为 10，在调整大小后的容量为 15、22、33、49、73、109、163、244、366… ArrayDeque 总是调整为 2 的幂次方。在调整大小时，容量会加倍。从默认值 16 开始，调整大小后的容量为 32、64、128、256… 因此，ArrayDeque 达到了更高的容量，而调整大小的操作更少，这是因为数组的复制操作很耗费资源。例如，要在默认大小的 ArrayList 中存储 256，需要进行 9 次调整大小操作，而 ArrayDeque 只需要 4 次。数组的复制操作可能很快，但也可能需要 GC 来释放一些空间用于新的数据集，此外还需要进行内存复制操作（ArrayDeque 可能在这方面表现更好，因为它对齐到 2 的幂次方）。 这两种数据结构的最佳情况复杂度为 O(1)。ArrayList 的 push 和 pop 操作通过直接访问头部和尾部（ArrayDeque）来实现，而 add 和 removeLast 操作（ArrayList）则是通过直接访问大小来实现。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ArrayDeque 的接口","slug":"Java/Java程序基础/ArrayDeque 的接口","date":"2023-05-27T21:07:27.450Z","updated":"2023-08-09T22:07:45.931Z","comments":true,"path":"2023/05/28/Java/Java程序基础/ArrayDeque 的接口/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"正文ArrayDeque 实现了 Deque 接口，该接口继承自 Queue 接口。下面是 Deque 接口中定义的一些主要方法： 添加元素操作： addFirst(element: E)：将元素添加到双端队列的开头。 addLast(element: E)：将元素添加到双端队列的末尾。 offerFirst(element: E)：将元素添加到双端队列的开头，并返回是否成功。 offerLast(element: E)：将元素添加到双端队列的末尾，并返回是否成功。 获取元素操作： getFirst(): E：获取双端队列的第一个元素，但不删除它。 getLast(): E：获取双端队列的最后一个元素，但不删除它。 peekFirst(): E：获取双端队列的第一个元素，如果队列为空则返回 null。 peekLast(): E：获取双端队列的最后一个元素，如果队列为空则返回 null。 移除元素操作： removeFirst(): E：移除并返回双端队列的第一个元素。 removeLast(): E：移除并返回双端队列的最后一个元素。 pollFirst(): E：移除并返回双端队列的第一个元素，如果队列为空则返回 null。 pollLast(): E：移除并返回双端队列的最后一个元素，如果队列为空则返回 null。 此外，ArrayDeque 还实现了 Queue 接口中定义的方法，如 offer(element: E)、remove(): E、poll(): E 等。 需要注意的是，ArrayDeque 是一个可变大小的数组双端队列，可以在队列的两端进行高效的插入和删除操作，同时也支持随机访问。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java Stack 过时了吗","slug":"Java/Java程序基础/Java Stack 过时了吗","date":"2023-05-27T21:04:38.144Z","updated":"2023-08-09T22:07:46.194Z","comments":true,"path":"2023/05/28/Java/Java程序基础/Java Stack 过时了吗/","link":"","permalink":"http://example.com/2023/05/28/Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Java%20Stack%20%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/","excerpt":"","text":"正文在 Java 中，Stack 类并没有过时，仍然可以使用。然而，根据 Java 官方文档的建议，推荐使用 Deque 接口的实现类 ArrayDeque 来代替 Stack。 Stack 类是基于向量（Vector）实现的，而 Vector 是线程安全的、同步的，因此在性能上可能会有一些开销。而 ArrayDeque 是基于数组实现的双端队列，性能更高，并且在大多数情况下能够提供与 Stack 类相同的功能。 此外，Deque 接口提供了更丰富的操作方法，例如在队首或队尾插入、删除元素等，使得其更灵活且更符合现代编程的需求。 因此，尽管 Stack 类仍然可用，但在新的代码中，推荐使用 ArrayDeque 或其他实现了 Deque 接口的类来代替 Stack。","categories":[{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]}],"categories":[{"name":"0 - 算法题目","slug":"0-算法题目","permalink":"http://example.com/categories/0-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"},{"name":"1 - Kotlin","slug":"1-Kotlin","permalink":"http://example.com/categories/1-Kotlin/"},{"name":"1.1 - Kotlin 协程","slug":"1-Kotlin/1-1-Kotlin-协程","permalink":"http://example.com/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/"},{"name":"1.0 - Kotlin 基础","slug":"1-Kotlin/1-0-Kotlin-基础","permalink":"http://example.com/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/"},{"name":"2 - Java","slug":"2-Java","permalink":"http://example.com/categories/2-Java/"},{"name":"2.0 - Java 多线程","slug":"2-Java/2-0-Java-多线程","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"2.0 - Java 基础","slug":"2-Java/2-0-Java-基础","permalink":"http://example.com/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"00.1 - 算法 - 中等","slug":"00-1-算法-中等","permalink":"http://example.com/tags/00-1-%E7%AE%97%E6%B3%95-%E4%B8%AD%E7%AD%89/"},{"name":"00.2 - 算法 - 困难","slug":"00-2-算法-困难","permalink":"http://example.com/tags/00-2-%E7%AE%97%E6%B3%95-%E5%9B%B0%E9%9A%BE/"},{"name":"00.0 - 算法 - 简单","slug":"00-0-算法-简单","permalink":"http://example.com/tags/00-0-%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95/"}]}