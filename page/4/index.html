<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | 喵星科技报</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="喵星科技报">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="喵星科技报">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="喵星科技报" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 5.4.2"></head>

<a target="_blank" rel="noopener" href="https://github.com/CatJason">
<img decoding="async" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" loading="lazy" data-recalc-dims="1">
</a>


  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="喵星科技报" rel="home"> 喵星科技报 </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="/"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="archives"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="categories"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="tags"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="about"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-0 算法/03 基础算法80道/02 统计素数个数 埃氏筛选法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/02%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E5%9F%83%E6%B0%8F%E7%AD%9B%E9%80%89%E6%B3%95/">02/80 统计素数个数-埃氏筛选法</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/02%20%E7%BB%9F%E8%AE%A1%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%20%E5%9F%83%E6%B0%8F%E7%AD%9B%E9%80%89%E6%B3%95/" class="article-date">
	  <time datetime="2023-08-10T23:14:00.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a>, <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>埃拉托斯特尼筛法（简称埃氏筛）是一种高效的查找素数的算法，它通过排除从2开始到给定数n的所有非素数来找出所有小于或等于n的素数。使用埃氏筛选法改进统计数组中素数元素的个数的算法，我们可以先通过筛法找出数组中所有可能的素数，然后再统计数组中这些素数的个数。</p>
<p>这里是如何用Kotlin实现基于埃氏筛选法来统计一个数组中素数元素的个数：</p>
<ol>
<li>构建埃氏筛: 根据数组中的最大值构建埃氏筛，以找到所有可能的素数。</li>
<li>统计素数: 遍历数组，利用构建的埃氏筛判断每个元素是否为素数，并计算素数的总数。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countPrimesInArrayWithSieve</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出数组中的最大值，以便构建足够大的筛</span></span><br><span class="line">    <span class="keyword">val</span> max = arr.maxOrNull() ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建埃氏筛</span></span><br><span class="line">    <span class="keyword">val</span> isPrime = BooleanArray(max + <span class="number">1</span>) &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (isPrime.size &gt; <span class="number">1</span>) isPrime[<span class="number">1</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.Math.sqrt(max.toDouble()).toInt()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i * i..max step i) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中的素数个数</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">2</span> &amp;&amp; isPrime[num]) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arr = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>)</span><br><span class="line">    println(<span class="string">&quot;Count of prime numbers in the array with sieve: <span class="subst">$&#123;countPrimesInArrayWithSieve(arr)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实现中，<code>countPrimesInArrayWithSieve</code> 函数首先找出数组中的最大值，以此来确定筛的大小。接着，它通过遍历2到<code>sqrt(max)</code>的数来构建筛，标记所有这些数的倍数为非素数。最后，它遍历数组，统计那些标记为素数的元素个数。</p>
<p>埃氏筛选法的时间复杂度通常为 O(n log log n)，相比暴力法的 O(n^2)，它在处理大量数据时更加高效。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a>, <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-0 算法/03 基础算法80道/03 删除排序数组中的重复项"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/03%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">03/80 删除排序数组中的重复项</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/03%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" class="article-date">
	  <time datetime="2023-08-10T23:14:00.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a>, <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeDuplicates</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span> <span class="comment">// 返回不重复数组的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nums = intArrayOf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> length = removeDuplicates(nums)</span><br><span class="line">    println(<span class="string">&quot;新的数组长度: <span class="variable">$length</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until length) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;nums[i]&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a>, <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-0 算法/03 基础算法80道/04 寻找数组的中心下标"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/04%20%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/">04/80 寻找数组的中心下标</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/0%20%E7%AE%97%E6%B3%95/03%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9580%E9%81%93/04%20%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/" class="article-date">
	  <time datetime="2023-08-10T23:14:00.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a>, <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>要在Kotlin中实现寻找数组的中心下标的算法，你可以遵循这个基本思路：遍历数组，对于每个下标，计算其左侧所有元素的和与右侧所有元素的和。如果在某个下标位置，这两个和相等，那么这个下标就是数组的中心下标。</p>
<p>下面是一个具体的实现示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findPivotIndex</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> totalSum = nums.sum()</span><br><span class="line">    <span class="keyword">var</span> leftSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ((index, value) <span class="keyword">in</span> nums.withIndex()) &#123;</span><br><span class="line">        <span class="comment">// 如果左侧和的两倍加上当前值等于总和，则当前索引是中心索引</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * leftSum + value == totalSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="comment">// 如果没有找到，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数<code>findPivotIndex</code>接受一个整数数组<code>nums</code>作为参数，并返回中心下标。它首先计算数组的总和，然后遍历数组。在遍历过程中，它更新一个名为<code>leftSum</code>的变量，该变量存储当前索引左侧所有元素的和。对于每个元素，它检查<code>2 * leftSum + value</code>是否等于<code>totalSum</code>。如果等于，这意味着左侧所有元素的和等于右侧所有元素的和，因此当前索引是中心下标，函数返回该索引。如果遍历完整个数组都没有找到这样的索引，函数返回-1。</p>
<p>要使用这个函数，你可以像这样调用它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nums = intArrayOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> pivotIndex = findPivotIndex(nums)</span><br><span class="line">    println(pivotIndex) <span class="comment">// 输出中心下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例会输出数组<code>[1, 7, 3, 6, 5, 6]</code>的中心下标。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a>, <a class="article-category-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-1 Kotlin/02 Kotlin 基础/Kotlin中的惰性操作容器——Sequence"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/">Kotlin中的惰性操作容器——Sequence</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94Sequence/" class="article-date">
	  <time datetime="2023-08-10T23:18:54.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Sequence序列"><a href="#Sequence序列" class="headerlink" title="Sequence序列"></a>Sequence序列</h3><p>Sequence 是Kotlin标准库提供的一种容器类型。它和Iterable一样具备对集合进行多步骤操作能力，但是却是采用了一种完全不同于Iterable的实现方式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val map = (0..3).filter &#123;</span><br><span class="line">    println(&quot;filter:$it&quot;)</span><br><span class="line">    it % 2 == 0</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    println(&quot;map:$it&quot;)</span><br><span class="line">    it + 1</span><br><span class="line">&#125;</span><br><span class="line">println(map)</span><br></pre></td></tr></table></figure>

<p>上面的代码用来演示Iterable进行连续操作的情况。它的输出如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter:0</span><br><span class="line">filter:1</span><br><span class="line">filter:2</span><br><span class="line">filter:3</span><br><span class="line">map:0</span><br><span class="line">map:2</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure>

<p>像<code>map</code>和<code>filter</code>这些链式集合函数它们都会立即执行并创建中间临时集用来保存数据。当原始数据不多时，这并不会有什么影响。但是，当原始数据量非常大的时候。这就会变的非常低效。而此时，就可以借助<code>Sequence</code>提高效率。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val sequence = (0..3).asSequence().filter &#123;</span><br><span class="line">    println(&quot;filter:$it&quot;)</span><br><span class="line">    it % 2 == 0</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    println(&quot;map:$it&quot;)</span><br><span class="line">    it + 1</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;准备开始执行&quot;)</span><br><span class="line">println(sequence.toList())</span><br></pre></td></tr></table></figure>

<p>上面的代码执行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">准备开始执行</span><br><span class="line">filter:0</span><br><span class="line">map:0</span><br><span class="line">filter:1</span><br><span class="line">filter:2</span><br><span class="line">map:2</span><br><span class="line">filter:3</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure>

<p>对比Iterable和Sequence：</p>
<p>Iterable是即时的、Sequence是惰性的：前者会要求尽早的计算结果，因此在多步骤处理链的每一环都会有中间产物也就是新的集合产生；<strong>后者会尽可能的延迟计算结果，Sequence处理的中间函数不进行任何计算。相反，他们返回一个新Sequence的，用新的操作装饰前一个，所有的这些计算都只是在类似toList的终端操作期间进行。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-f3db64c81524b0df40edf073b68f1ac9_1440w.webp" alt="img"></p>
<p>区分中间操作符和末端操作符的方式也很简单：<strong>如果操作符返回的是一个Sequence类型的数据，它就是中间操作符。</strong></p>
<p>在操作的执行方式上也有所不同：Iterable每次都是在整个集合执行完操作后再进行下一步操作——采用第一个操作并将其应用于整个集合，然后移动到下一个操作，官方将其称呼为急切式或者按步骤执行（Eager&#x2F;step-by-step）；<strong>而Sequence则是逐个对每个元素执行所有操作。是一种惰性顺序——取第一个元素并应用所有操作，然后取下一个元素，依此类推。</strong>官方将其称呼为惰性式或者按元素执行（Lazy&#x2F;element-by-element)</p>
<p>序列的惰性会带来一下几个优点：</p>
<ul>
<li>它们的操作按照元素的自然顺序进行；</li>
<li>只做最少的操作；</li>
<li>元素可以是无限多个；</li>
<li>不需要在每一步都创建集合</li>
</ul>
<p><strong>Sequence可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。但是，惰性性质也会带来一些运行开销。所以在使用时要权衡惰性开销和中间步骤开销，在Sequence和Iterable中选择更加合适的实现方式。</strong></p>
<h3 id="执行的顺序"><a href="#执行的顺序" class="headerlink" title="执行的顺序"></a>执行的顺序</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceOf(1,2,3)</span><br><span class="line">    .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125;</span><br><span class="line">    .map &#123; print(&quot;M$it, &quot;); it * 2 &#125;</span><br><span class="line">    .forEach &#123; print(&quot;E$it, &quot;) &#125; </span><br><span class="line">// Prints: F1, M1, E2, F2, F3, M3, E6,</span><br><span class="line"></span><br><span class="line">listOf(1,2,3)</span><br><span class="line">    .filter &#123; print(&quot;F$it, &quot;); it % 2 == 1 &#125;</span><br><span class="line">    .map &#123; print(&quot;M$it, &quot;); it * 2 &#125;</span><br><span class="line">    .forEach &#123; print(&quot;E$it, &quot;) &#125;</span><br><span class="line">// Prints: F1, F2, F3, M1, M3, E2, E6,</span><br></pre></td></tr></table></figure>

<p>sequence的执行时按照元素进行的，依次对元素执行所有的操作，对一个元素而言，所有操作时依次全部执行的。而普通集合操作则是以操作步骤进行的，当所有的元素执行完当前操作后才会进入下一个操作。</p>
<p><img src="https://pic1.zhimg.com/80/v2-27021cdfe12cadb333ac2f9c5991f8ec_1440w.webp" alt="img"></p>
<h3 id="只做最少的操作"><a href="#只做最少的操作" class="headerlink" title="只做最少的操作"></a>只做最少的操作</h3><p>试想一下我们有一千万个数字，我们要经过几次变换取出20个，使用下面的代码对比一下序列和不同集合操作的性能：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val fFlow = FFlow()</span><br><span class="line">    fFlow.demoList()</span><br><span class="line">    fFlow.demoSequence()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demoSequence() &#123;</span><br><span class="line">    val currentTimeMillis = System.currentTimeMillis()</span><br><span class="line">    val list =</span><br><span class="line">    (0..10000000).asSequence().map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList()</span><br><span class="line">    println(&quot;demoSequence:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demoList() &#123;</span><br><span class="line">    val currentTimeMillis = System.currentTimeMillis()</span><br><span class="line">    val list =</span><br><span class="line">    (0..10000000).map &#123; it * 2 &#125;.map &#123; it - 1 &#125;.take(20).toList()</span><br><span class="line">    println(&quot;demoList:$&#123;System.currentTimeMillis() - currentTimeMillis&#125;：$list&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demoSequence:20ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]</span><br><span class="line">demoList:4106ms：[-1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37]</span><br></pre></td></tr></table></figure>

<p>这就是只执行最少操作的意思，序列按照元素顺序执行，当取够29个元素之后便会立即停止计算。而不同的集合则不同，没有中间操作的概念。它的每次操作都会对整个数组中的所有元素执行完才会进行下一个——也就是前两个map都要执行一千万次。</p>
<p><img src="https://pic2.zhimg.com/80/v2-76965bb77961ce0d47ccef581ac2c2e9_1440w.webp" alt="img"></p>
<h3 id="序列可以是无限的"><a href="#序列可以是无限的" class="headerlink" title="序列可以是无限的"></a>序列可以是无限的</h3><p>看如下代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var list = emptyArray&lt;Int&gt;()</span><br><span class="line">var  i = 0</span><br><span class="line">while(true)&#123;</span><br><span class="line">    list[i] = i++</span><br><span class="line">&#125;</span><br><span class="line">list.take(10)</span><br></pre></td></tr></table></figure>

<p>很明显，这段代码是没法正常运行的，因为这里有一个死循环。我们也无法创建一个无限长度的集合。但是：因为序列式按步骤依照需求进行处理的，所哟我们可以创建无限序列：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val noEnd = sequence &#123;</span><br><span class="line">    var i = 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        yield(i)</span><br><span class="line">        i *= 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">noEnd.take(4).toList()</span><br><span class="line">//输出:[1, 2, 4, 8]</span><br></pre></td></tr></table></figure>

<p>但是一定要注意，我们虽然可以这么写，但是务必不能真的让while一直循环。我们不能直接使用toList。必须提供一个能结束循环的操作符，也就是不能取出所有元素（无限个）——要么使用类似take的操作来限制它们的数量，要么使用不需要所有元素的终端操作，例如first, find, any, all, indexOf等。</p>
<h3 id="序列不会在每个步骤创建集合"><a href="#序列不会在每个步骤创建集合" class="headerlink" title="序列不会在每个步骤创建集合"></a>序列不会在每个步骤创建集合</h3><p>普通的集合会在每次变换之后都会创建新的集合取存储所有变换后的元素。而每次创建集合和填入数据都会带来不小的性能开销。尤其是当我们处理大量或大量的集合时，性能问题会愈发凸显。而序列的按元素操作，则不会有这个问题。除非手动调用了终端操作符，否则不会生成新的集合。</p>
<h3 id="Sequence的基本使用"><a href="#Sequence的基本使用" class="headerlink" title="Sequence的基本使用"></a>Sequence的基本使用</h3><p>Sequence序列的使用和普通的Iterable极其相似，实际上其内部也还是借助Iterable实现的。在研究它的内部实现原理之前，想从Sequence的创建和基本的序列操作来演示Sequence的基本用法。</p>
<h3 id="序列的创建"><a href="#序列的创建" class="headerlink" title="序列的创建"></a>序列的创建</h3><p>创建Sequence的方式大概可以分为。分别是由元素创建、通过Iterable、借助函数以及由代码块创建。</p>
<p>由元素创建：通过调用顶级函数<code>sequenceOf</code>实现：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequenceOf(1, 2, 3, 4, 5, 6, 7)</span><br><span class="line">val strings = sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</span><br></pre></td></tr></table></figure>

<p>通过Iterable转化：借助Iterable的扩展函数<code>asSequence</code>实现：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ints = listOf(1, 2, 3, 4, 5, 6, 7).asSequence()</span><br><span class="line">val strings = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</span><br></pre></td></tr></table></figure>

<p>通过generateSequence实现：该方法有三个：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; </span><br><span class="line">generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;</span><br><span class="line">generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>最终都是通过<code>GeneratorSequence</code>实现的，这里先不进行源码分析。只讨论使用方式：</p>
<ul>
<li>其中三个函数都有的形参nextFunction可以理解为元素生成器，序列里的元素都通过调用该函数生成，当它返回为null是，序列停止生成（所以，nextFunction必须要在某个情况下返回null，否则会因为序列元素是无限多个触发java.lang.OutOfMemoryError: Java heap space异常）。</li>
<li>而另外两个的seedFunction和seed形参都是为了确定数据初始值的。区别在于一个直接指明，一个通过调用函数获取。</li>
</ul>
<p>分别用这三个函数生成0~100的序列，代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val generateSequenceOne = generateSequence &#123;</span><br><span class="line">    if (i &lt; 100) &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val generateSequenceTwo = generateSequence(0) &#123;</span><br><span class="line">    if (it &lt; 100) &#123;</span><br><span class="line">        it+1//此处的it是上一个元素</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val generateSequenceThree = generateSequence(&#123; 0 &#125;) &#123;</span><br><span class="line">    if (it &lt; 100) &#123;</span><br><span class="line">        it+1//此处的it是上一个元素</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码块生成：借助sequence(block: suspend SequenceScope.() -&gt; Unit)函数。改函数接受一个挂起函数，该函数会接受一个<code>SequenceScope</code>实例，这个实例无需我们创建（后面源码分析会讲到）。SequenceScope提供了<code>yield</code>和<code>yieldAll</code>方法复杂返回序列元素给调用者，并暂停序列的执行，直到使用者请求下一个元素。</p>
<p>用该函数生成0~100的序列，代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequence &#123;</span><br><span class="line">    repeat(100) &#123;</span><br><span class="line">        yield(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列的操作"><a href="#序列的操作" class="headerlink" title="序列的操作"></a>序列的操作</h3><p>对序列的操作可以分为中间操作和末端操作两种。它们只要有一下另种区别：</p>
<ul>
<li>中间操作返回惰性生成的一个新的序列，而末端序列则为其他普通的数据类型；</li>
<li>中间操作不会立刻执行代码，仅当执行了末端操作序列才会开始执行。</li>
</ul>
<p>常见的中间操作包括：map、fliter、first、last、take等；它们会序列提供数据变化过滤等增强功能基本上和kotlin提供的集合操作符有着相同的功能。</p>
<p>常见的末端操作有：toList、toMutableList、sum、count等。它们在提供序列操作功能的同时，还会触发序列的运行。</p>
<h3 id="Sequence源码分析"><a href="#Sequence源码分析" class="headerlink" title="Sequence源码分析"></a>Sequence源码分析</h3><p>上文对序列做了简单的入门介绍。接下来深入源码去了解一下Sequence的实现方式。</p>
<h3 id="Sequence是什么？"><a href="#Sequence是什么？" class="headerlink" title="Sequence是什么？"></a>Sequence是什么？</h3><p>Kotlin对的定义Sequence很简单：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Sequence &lt;out T&gt; &#123;</span><br><span class="line">    public operator fun iterator(): Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是一个接口，定义了一个返回Iterator的方法。接口本身只定义了Sequence具有返回一个迭代器的能力。具体的功能实现还是靠它的实现类完成。</p>
<p>可以概括一些：<strong>序列就是一个具备提供了迭代器能力的类。</strong></p>
<h3 id="序列的创建方式分析"><a href="#序列的创建方式分析" class="headerlink" title="序列的创建方式分析"></a>序列的创建方式分析</h3><p>结合上文中提到的序列的四种创建方式，我们依次分析一下它的创建流程。</p>
<p>我们首先以比较常用的通过Iterable转化获取序列，它需要借助<code>asSequence</code>方法分析一下，使用<code>listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</code>生成一个序列。调用链如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123;</span><br><span class="line">    return Sequence &#123; this.iterator() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程很简单，一个扩展函数加一个内联函数。最终通过匿名内部类的方式创建一个Sequence并返回。代码很好理解，实际上它的实现逻辑等同于下面的代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val sequence = MySequence(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).iterator())</span><br><span class="line"></span><br><span class="line">class MySequence&lt;T&gt;(private val iterator:Iterator&lt;T&gt;):Sequence&lt;T&gt;&#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; &#123;</span><br><span class="line">        return iterator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看一下通过调用顶级函数<code>sequenceOf</code>实现，以<code>sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</code>为例，它的调用逻辑如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; sequenceOf(vararg elements: T): Sequence&lt;T&gt; = if (elements.isEmpty()) emptySequence() else elements.asSequence()</span><br></pre></td></tr></table></figure>

<p>可以看到依旧是借助asSequence实现的。</p>
<p>接下来看一下代码块和generateSequence的实现方式，这两个方式会比较复杂一点，毕竟前面两个都是借助List进行转换，而List本身就能提供迭代器Iterator。后面两个明显需要提供新的迭代器。 首先看一下代码看的实现方式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val ints = sequence &#123;</span><br><span class="line">        repeat(100) &#123;</span><br><span class="line">            yield(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中sequence的调用逻辑如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; iterator(block) &#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T&gt; iterator(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123;</span><br><span class="line">    //创建迭代器</span><br><span class="line">    val iterator = SequenceBuilderIterator&lt;T&gt;()</span><br><span class="line">    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)</span><br><span class="line">    return iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现：该方法和asSequence一样最终也是通过匿名内部类的方式创建了一个Sequence。不过区别在于，该方法需要创建一个新的迭代器，也就是<code>SequenceBuilderIterator</code> 。同样以MySequence为例，它的创建流程等同于一下代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun mian()&#123;</span><br><span class="line">    create&lt;Int&gt; &#123; myblock() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun  SequenceScope&lt;Int&gt;.myblock()&#123;</span><br><span class="line">    repeat(100) &#123;</span><br><span class="line">        yield(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;Int&gt; create(block: suspend SequenceScope&lt;Int&gt;.() -&gt; Unit):Sequence&lt;Int&gt;&#123;</span><br><span class="line">    val iterator = SequenceBuilderIterator&lt;Int&gt;()</span><br><span class="line">    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)</span><br><span class="line">    return MySequence(iterator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这是不可能实现的，因为SequenceBuilderIterator是被private修饰了，我们是无法直接访问的。这里强制写出来演示一下它的流程。</p>
<p>最后看一下通过generateSequence方法创建序列的源码，一共有三个：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T : Any&gt; generateSequence(seedFunction: () -&gt; T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; =</span><br><span class="line">    GeneratorSequence(seedFunction, nextFunction)</span><br><span class="line"></span><br><span class="line">public fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; =</span><br><span class="line">    if (seed == null)</span><br><span class="line">        EmptySequence</span><br><span class="line">    else</span><br><span class="line">        GeneratorSequence(&#123; seed &#125;, nextFunction)</span><br><span class="line"></span><br><span class="line">public fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt; &#123;</span><br><span class="line">    return GeneratorSequence(nextFunction, &#123; nextFunction() &#125;).constrainOnce()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终都是创建了<code>GeneratorSequence</code>的一个实例并返回，而<code>GeneratorSequence</code>实现了<code>Sequence</code>接口并重写了<code>iterator()</code>方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class GeneratorSequence&lt;T : Any&gt;(private val getInitialValue: () -&gt; T?, private val getNextValue: (T) -&gt; T?) : Sequence&lt;T&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123;</span><br><span class="line">        var nextItem: T? = null</span><br><span class="line">        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue</span><br><span class="line"></span><br><span class="line">        private fun calcNext() &#123;</span><br><span class="line">            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)</span><br><span class="line">            nextState = if (nextItem == null) 0 else 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun next(): T &#123;</span><br><span class="line">            if (nextState &lt; 0)</span><br><span class="line">                calcNext()</span><br><span class="line"></span><br><span class="line">            if (nextState == 0)</span><br><span class="line">                throw NoSuchElementException()</span><br><span class="line">            val result = nextItem as T</span><br><span class="line">            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue</span><br><span class="line">            nextState = -1</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun hasNext(): Boolean &#123;</span><br><span class="line">            if (nextState &lt; 0)</span><br><span class="line">                calcNext()</span><br><span class="line">            return nextState == 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下Sequence的创建大致可以分为三类：</p>
<ul>
<li>使用List自带的迭代器通过匿名的方式创建Sequence实例，<code>sequenceOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</code>和<code>listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;).asSequence()</code>就是这种方式；</li>
<li>创建新的<code>SequenceBuilderIterator</code>迭代器，并通过匿名的方式创建Sequence实例。例如使用代码块的创建方式。</li>
<li>创建<code>GeneratorSequence</code>，通过重写iterator()方法，使用匿名的方式创建Iterator。GeneratorSequence方法就是采用的这种方式。</li>
</ul>
<p>看完创建方式，也没什么奇特的，就是一个提供迭代器的普通类。还是看不出是如何惰性执行操作的。接下来就分析一下惰性操作的原理。</p>
<h3 id="序列的惰性原理"><a href="#序列的惰性原理" class="headerlink" title="序列的惰性原理"></a>序列的惰性原理</h3><p>以最常用的map操作符为例：普通的集合操作源码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;</span><br><span class="line">    //出啊年一个新的ArrayList，并调用mapTo方法</span><br><span class="line">    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123;</span><br><span class="line">    //遍历原始的集合，进行变换操作，然后将变换后的数据依次加入到新创建的集合</span><br><span class="line">    for (item in this)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    //返回新集合    </span><br><span class="line">    return destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：当List.map被调用后，便会立即创建新的集合，然后遍历老数据并进行变换操作。最后返回一个新的数据。这印证了上面提到的普通集合的操作时按照步骤且会立刻执行的理论。</p>
<p>接下来看一下序列的map方法，它的源码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123;</span><br><span class="line">    return TransformingSequence(this, transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal class TransformingSequence&lt;T, R&gt;</span><br><span class="line">constructor(private val sequence: Sequence&lt;T&gt;, private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123;</span><br><span class="line">    override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123;</span><br><span class="line">          //注释一：TransformingSequence的iterator持有上一个序列的迭代器</span><br><span class="line">        val iterator = sequence.iterator()</span><br><span class="line">        override fun next(): R &#123;</span><br><span class="line">            //注释二：在开始执行迭代时，向上调用前一个序列的迭代器。</span><br><span class="line">            return transformer(iterator.next())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun hasNext(): Boolean &#123;</span><br><span class="line">            return iterator.hasNext()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123;</span><br><span class="line">        return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码并不复杂，它接收用户提供的变换函数和序列，然后创建了一个TransformingSequence并返回。TransformingSequence本身和上文中提到的序列没什么区别，唯一的区别在于它的迭代器：在通过next依次取数据的时候，并不是直接返回元素。而是先调用调用者提供的函数进行变换。返回变换后的数据——这也没什么新鲜的，和普通集合的map操作符和RxJava的Map都是同样的原理。</p>
<p>但是，这里却又有点不一样。<strong>操作符里没有任何开启迭代的代码，它只是对序列以及迭代进行了嵌套处理，并不会开启迭代.如果用户不手动调用（后者间接调用）迭代器的next函数，序列就不会被执行</strong>——这就是惰性执行的机制的原理所在。</p>
<p>而且，由于操作符返回的是一个Sequence类型的值，当你重复不断调用map时，例如下面的代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(0..10).asSequence().map&#123;add(it)&#125;.map&#123;add(it)&#125;.map&#123;add(it)&#125;.toList()</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line"></span><br><span class="line">val sequence1 = (0..10).asSequence()</span><br><span class="line">val sequence2 = sequence1.map &#123; it+1 &#125;</span><br><span class="line">val sequence3 = sequence2.map &#123; it+1 &#125;</span><br><span class="line">sequence3.toList()</span><br></pre></td></tr></table></figure>

<p>最终，序列sequence3的结构持有如下：sequence3-&gt; sequence2 -&gt; sequence1。而它们都有各自的迭代器。迭代器里都重写了各自的变换逻辑:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun next(): R &#123;</span><br><span class="line">    return transformer(iterator.next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//由于这里都是执行的+1操作，所以变换逻辑transformer可以认为等同于如下操作:</span><br><span class="line"></span><br><span class="line">override fun next(): R &#123;</span><br><span class="line">    return iterator.next()+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当我们通过<code>sequence3.toList</code>执行代码时，它的流程如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123;</span><br><span class="line">    return this.toMutableList().optimizeReadOnlyList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T&gt; Sequence&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; &#123;</span><br><span class="line">    //末端操作符，此处才会开始创建新的集合</span><br><span class="line">    return toCollection(ArrayList&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123;</span><br><span class="line">    //执行迭代器next操作</span><br><span class="line">    //当调用（末端操作符）走到这里时，便会和普通结合的操作符一样</span><br><span class="line">    //此时为新创建的集合赋值</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        destination.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">    return destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过几次扩展函数调用，最终在toCollection里开始执行迭代(Iterator的典型的操作)，也就是获取了sequence3的iterator实例，并不断通过next取出数据。而在上文中的TransformingSequence源码里可以看到，TransformingSequence会持有上一个迭代器的实例（代码注释一）。</p>
<p>并且在迭代开始后，在进行transformer操作（也就是执行+1操作）前，会调用上一个迭代器的next方法进行迭代（代码注释二）。这样不断的迭代，最终，最终会调用到sequence1的next方法。再结合上文中的序列创建里的分析——sequence1里所持有的迭代器就是就是原始数据里的迭代器。</p>
<p>那么当最终执行toList方法时，它会循环<code>sequence3.iterator</code>方法。而在每次循环内，都会首先执行sequence3所持有的sequence2.iterator的next方法。sequence2依次类推执行到sequence1的sequence1.iterator&#96;方法，最终执行到我们原始数组的迭代器next方法：</p>
<p>整个流程如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d8485553b786d4cb8def81a27cffd361_1440w.webp" alt="img"></p>
<p>原理就是这么简单：中间操作符通过序列嵌套，实现对迭代器iterator的嵌套。这样在进行迭代的时候，会依次调用各个iterator迭代器直到调用到原始集合数据里的迭代器开始并返回元素。而当元素返回时，会依次执行各个迭代器持有变换操作方法实现对数据的变换。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e34ba780f0b283f6fc8b6a9fb52f5243_1440w.webp" alt="img"></p>
<p>而其他操作符，也是遵循这个基本的规则。无非就是增加一些其他的操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>序列通过中间操作符对迭代器进行嵌套和复写，以此实现按元素操作执行变换；</li>
<li>中间操作符只负责根据需求创建并嵌套迭代器，并不负责开启迭代器。以此实现惰性操作且不产生临时集合；</li>
<li>末端操作符负责开启迭代，按照嵌套顺序执行迭代操作。依次获取操作后的数据，并且会创建新的集合用来存储最终数据；</li>
<li>序列不是万能的，因为要引入新的对象。在带来惰性和顺序执行的优势时，这些对象必然会带来性能开销。所以要依需求在集合和序列之间进行选择，使用合适的方式进行迭代。</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-1 Kotlin/02 Kotlin 基础/Kotlin中的自动拆装箱"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2024/04/14/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/">Kotlin中的自动拆装箱</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2024/04/14/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/" class="article-date">
	  <time datetime="2024-04-14T04:47:49.083Z" itemprop="datePublished">April 14, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 Kotlin 中，对于基本数据类型的包装类，比如 <code>Integer</code>、<code>Boolean</code> 等，Kotlin 设计了一套特殊的类，被称为原生类型的包装类或者叫做原生类型的对象，例如 <code>Int</code>、<code>Boolean</code> 等。这些类的行为表现得如同 Java 的基本类型，同时它们具备了对象的一些特性。在编译阶段，Kotlin 会尽量使用 JVM 的原生类型来提高性能，但在需要时（例如作为泛型参数时），这些原生类型会自动装箱。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>Kotlin 处理原生类型和装箱类型的自动转换，以保证性能同时提供丰富的类库支持。这个过程包括两个部分：自动装箱（boxing）和自动拆箱（unboxing）。</p>
<ul>
<li><strong>装箱（Boxing）</strong>：当一个原生类型的值需要作为对象处理时，它会自动被装入对应的包装类。例如，当你将一个 <code>int</code> 值放入一个泛型集合如 <code>List&lt;Int&gt;</code> 时，这个值会自动被装箱成 <code>Integer</code>。</li>
<li><strong>拆箱（Unboxing）</strong>：当从对象中需要一个原生类型的值时，这个包装对象会自动被拆箱。例如，从 <code>List&lt;Int&gt;</code> 中取出一个元素时，它会自动从 <code>Integer</code> 转换为 <code>int</code>。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">val</span> x: <span class="built_in">Int</span> = list[<span class="number">0</span>]                   <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，整数列表中的数字自动被装箱成 <code>Integer</code> 类型的对象以存入 <code>List&lt;Int&gt;</code>。当从列表中检索一个整数时，它自动拆箱回 <code>Int</code> 类型。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>虽然 Kotlin 试图隐藏装箱和拆箱的复杂性，但在某些情况下，装箱对象的身份不会保留。例如，两个独立装箱的整数可能不会在内存中具有相同的引用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">println(boxedA === anotherBoxedA)  <span class="comment">// 可能输出 false</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>boxedA</code> 和 <code>anotherBoxedA</code> 是相同原始值的两个独立的装箱实例。使用 <code>===</code> 比较它们的引用时可能得到 <code>false</code>，因为它们可能指向不同的对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 在编写代码时提供了类似于基本数据类型的简洁性和效率，同时也保留了对象的灵活性。通过自动装箱和拆箱，Kotlin 旨在提供无缝的集合操作和泛型支持，同时减少需要程序员关注的底层细节。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-1 Kotlin/02 Kotlin 基础/Kotlin中有哪些类"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB/">Kotlin中有哪些类</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB/" class="article-date">
	  <time datetime="2023-08-10T23:18:54.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 Kotlin 中，类的概念是非常广泛的，包括各种类型的类设计用于不同的目的和场景。Kotlin 提供了丰富的类类型以支持现代软件开发的需要。下面是一些在 Kotlin 中常见的类类型：</p>
<h3 id="1-数据类（Data-Class）"><a href="#1-数据类（Data-Class）" class="headerlink" title="1. 数据类（Data Class）"></a>1. <strong>数据类（Data Class）</strong></h3><p>数据类是专门用于存储数据的类。Kotlin 的数据类通过 <code>data</code> 关键字定义，它自动从所声明的属性中派生出 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 等方法，以及 <code>copy()</code> 函数和 <code>componentN()</code> 函数（按声明顺序对应于所有属性）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-枚举类（Enum-Class）"><a href="#2-枚举类（Enum-Class）" class="headerlink" title="2. 枚举类（Enum Class）"></a>2. <strong>枚举类（Enum Class）</strong></h3><p>枚举类用于定义一组命名常量。Kotlin 中的枚举不仅可以有属性，还可以有自己的方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH, SOUTH, EAST, WEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-密封类（Sealed-Class）"><a href="#3-密封类（Sealed-Class）" class="headerlink" title="3. 密封类（Sealed Class）"></a>3. <strong>密封类（Sealed Class）</strong></h3><p>密封类用于表示受限的类层次结构，即一个值只能是有限集合中的某个类型，而不能是任何其他类型。这对于当你在使用 <code>when</code> 表达式时，想要确保覆盖所有可能的类型非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br></pre></td></tr></table></figure>

<h3 id="4-抽象类（Abstract-Class）"><a href="#4-抽象类（Abstract-Class）" class="headerlink" title="4. 抽象类（Abstract Class）"></a>4. <strong>抽象类（Abstract Class）</strong></h3><p>抽象类是不能被实例化的类，通常用作其他类的基类。抽象类可以包含抽象方法（没有实现的方法）和非抽象方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">park</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Parked&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-内部类（Inner-Class）"><a href="#5-内部类（Inner-Class）" class="headerlink" title="5. 内部类（Inner Class）"></a>5. <strong>内部类（Inner Class）</strong></h3><p>内部类是定义在另一个类内部的类。内部类持有其外部类的一个引用，因此可以访问其成员。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-嵌套类（Nested-Class）"><a href="#6-嵌套类（Nested-Class）" class="headerlink" title="6. 嵌套类（Nested Class）"></a>6. <strong>嵌套类（Nested Class）</strong></h3><p>与内部类相比，嵌套类没有对外部类的隐式引用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-对象声明（Object-Declaration）"><a href="#7-对象声明（Object-Declaration）" class="headerlink" title="7. 对象声明（Object Declaration）"></a>7. <strong>对象声明（Object Declaration）</strong></h3><p>Kotlin 支持对象声明，这是实现单例模式的一种方式。对象声明的实例自动成为一个单例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Provider registered: <span class="variable">$provider</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-伴生对象（Companion-Object）"><a href="#8-伴生对象（Companion-Object）" class="headerlink" title="8. 伴生对象（Companion Object）"></a>8. <strong>伴生对象（Companion Object）</strong></h3><p>在 Kotlin 中，没有静态方法，但可以用伴生对象来模拟静态方法的效果。伴生对象的成员可以通过类名直接访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-接口（Interface）"><a href="#9-接口（Interface）" class="headerlink" title="9. 接口（Interface）"></a>9. <strong>接口（Interface）</strong></h3><p>虽然不是类，但接口在 Kotlin 中用于定义可以由类实现或继承的协定。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drivable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Driving&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些类类型展示了 Kotlin 语言的灵活性和现代特性，旨在提供简洁而强大的语法来支持各种编程范式和设计模式。</p>
<h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><p>在 Kotlin 中，密封类（sealed class）是一种特殊的类，它用于表示严格的类层次结构。使用密封类，你可以定义一个类的可能的子类集合，而且这些子类只能在与密封类相同的文件中定义。这种限制确保了除文件内定义的子类之外，无法有其他子类存在，从而使得使用时更加安全和维护更加方便。</p>
<h3 id="密封类的主要特点和优势："><a href="#密封类的主要特点和优势：" class="headerlink" title="密封类的主要特点和优势："></a>密封类的主要特点和优势：</h3><ol>
<li><p><strong>受限的继承</strong>：</p>
<ul>
<li>密封类本身是抽象的，不能直接实例化，只能通过其子类进行实例化。</li>
<li>所有的子类必须与密封类在同一个文件中声明，这提高了可维护性，因为所有扩展都在一个集中的位置。</li>
</ul>
</li>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li>密封类非常适合用在 <code>when</code> 表达式中，因为它们可以确保覆盖所有可能的情况，不需要再添加一个 <code>else</code> 子句。这是因为编译器能够检测到所有定义的子类。</li>
</ul>
</li>
<li><p><strong>更精确的控制</strong>：</p>
<ul>
<li>使用密封类可以精确控制类的继承结构，这对于构建不可变数据类型和状态管理非常有用。</li>
</ul>
</li>
</ol>
<h3 id="密封类的用法示例："><a href="#密封类的用法示例：" class="headerlink" title="密封类的用法示例："></a>密封类的用法示例：</h3><p>首先，定义一个密封类，然后在同一个文件中定义其所有子类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line">    <span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    Expr.NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Expr</code> 是一个密封类，有三个子类：<code>Const</code>、<code>Sum</code> 和 <code>NotANumber</code>。这使得 <code>eval</code> 函数可以安全地使用 <code>when</code> 表达式来处理所有可能的 <code>Expr</code> 类型，而不需要 <code>else</code> 分支，因为编译器知道所有可能的子类。</p>
<h3 id="使用密封类的场景："><a href="#使用密封类的场景：" class="headerlink" title="使用密封类的场景："></a>使用密封类的场景：</h3><ul>
<li><strong>状态管理</strong>：在应用程序状态管理或者在处理有限状态机（FSM）时，密封类提供了一种清晰的方式来表示所有可能的状态。</li>
<li><strong>返回类型的多样性</strong>：在函数需要返回多种类型的结果时，可以使用密封类来封装这些不同类型的返回值。</li>
<li><strong>在模式匹配中增强类型安全</strong>：如上面示例中的 <code>eval</code> 函数，使用密封类可以确保 <code>when</code> 表达式已经处理了所有可能的情况，这在处理复杂的逻辑分支时非常有帮助。</li>
</ul>
<p>通过这种方式，Kotlin 的密封类增加了代码的安全性和清晰度，特别是在需要表达一个有限的类层次结构时。</p>
<h1 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h1><p>Kotlin 1.3 引入了内联类，主要目的是提供一种无开销的抽象方式。内联类允许你创建一个包含单个属性的类，当这个类被使用时，它会在编译时被内联，即直接替换为它包含的那个值，从而避免了额外的内存分配和间接访问。</p>
<h3 id="内联类的定义和使用"><a href="#内联类的定义和使用" class="headerlink" title="内联类的定义和使用"></a>内联类的定义和使用</h3><p>内联类定义时需要使用 <code>inline</code> 关键字，且必须有一个主构造函数，该构造函数恰好接收一个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">val</span> value: String)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>Password</code> 类包裹了一个字符串，但在编译后，Kotlin 编译器会尽可能将 <code>Password</code> 类的实例替换为简单的 <code>String</code> 类型，从而减少对象创建的开销。当你在代码中使用 <code>Password</code> 类型时，例如将它作为函数参数或从函数中返回时，实际上传递的将是一个 <code>String</code> 类型。</p>
<h3 id="内联类的特点和优势"><a href="#内联类的特点和优势" class="headerlink" title="内联类的特点和优势"></a>内联类的特点和优势</h3><ol>
<li><strong>性能优化</strong>：内联类主要用于性能优化，可以避免对象分配，并减少方法调用的层次。</li>
<li><strong>类型安全</strong>：虽然内联类在运行时表现为它们包装的类型（例如 <code>String</code> 或 <code>Int</code>），但在编译时，它们是不同的类型。这意味着你可以用它们来实现类型安全的操作，例如防止将普通字符串与经过验证的密码字符串混淆。</li>
<li><strong>限制</strong>：内联类不能有初始化块 (<code>init</code> 块)，它们也不能包含其他属性或构造函数。此外，内联类可以实现接口，但不能从其他类继承。</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Password</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">takePassword</span><span class="params">(password: <span class="type">Password</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Password is <span class="subst">$&#123;password.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> password = Password(<span class="string">&quot;my_secret_password&quot;</span>)</span><br><span class="line">    takePassword(password)  <span class="comment">// 在这里，password 被内联，实际传递的是一个 String 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，尽管我们定义了一个名为 <code>Password</code> 的内联类，并在函数 <code>takePassword</code> 中使用它，实际上，在编译后，这些函数调用会直接使用 <code>String</code> 类型，而不会有任何包装和解包的性能开销。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>内联类是 Kotlin 提供的一种非常有用的特性，特别适合那些需要通过类型来提供更丰富语义但又不想引入运行时开销的场景。通过内联类，Kotlin 开发者可以在享受类型安全的同时，保持代码的高性能。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-1 Kotlin/01 Kotlin 协程/Kotlin 的协程本质到底什么"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/">Kotlin 的协程本质到底什么</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88/" class="article-date">
	  <time datetime="2023-08-10T23:19:04.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>几乎就是用阻塞的写法来完成非阻塞的任务。<br>Kotlin-JVM中所谓的协程是假协程<br>Kotlin-JVM中所谓的 协程挂起 ，就是开启了一个子线程去执行任务</p>
<p>对于Java来说，不管你用什么方法，只要你没有魔改JVM，那么最终你代码里start几个线程，操作系统就会创建几个线程，是1比1的关系。<br>Kotlin官网中那个创建10w个Kotlin协程没有oom的例子其实有误导性，本质上那10w个Kotlin协程就是10w个并发任务仅此而已，他下面运行的就是一个单线程的线程池。你往一个线程池里面丢多少个任务都不会OOM的（前提是你的线程池创建的时候设定了对应的拒绝策略，否则无界队列下，任务过多一定会OOM），因为在运行的始终是那几个线程。</p>
<p>创建协程的方式有五种：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope<span class="selector-class">.launch</span>&#123;&#125;</span><br><span class="line">launch&#123;&#125;</span><br><span class="line">runBlocking&#123;&#125;</span><br><span class="line">coroutineScope&#123;&#125;</span><br><span class="line">async&#123;&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-1 Kotlin/01 Kotlin 协程/协程中的取消和异常 （取消操作详解）"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/">协程中的取消和异常 （取消操作详解）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%20%EF%BC%88%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%89/" class="article-date">
	  <time datetime="2023-08-10T23:19:12.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在开发中，我们要避免不必要的的任务来节约设备的内存和电量的使用，协程也是如此。在使用的过程我们需要控制好它的生命周期，在不需要它的取消它。</p>
<h3 id="调用cancel方法"><a href="#调用cancel方法" class="headerlink" title="调用cancel方法"></a>调用cancel方法</h3><h4 id="取消作用域会取消它的子协程"><a href="#取消作用域会取消它的子协程" class="headerlink" title="取消作用域会取消它的子协程"></a>取消作用域会取消它的子协程</h4><p>当启动了很多个协程，我们一个个协程的取消比较麻烦，我们可以通过取消整个作用域来解决这个问题，因为取消作用域可以取消该作用域创建的所有协程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ 假设我们已经定义了一个作用域</span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">job1</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">job2</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"></span><br><span class="line">scope.cancel()</span><br></pre></td></tr></table></figure>

<p>假设我们创建了一个作用域scope,并创建了两个协程job1和job2。我们通过调用scope.cancel()，取消作用域，将会把job1 和job2两个协程都取消。</p>
<h4 id="单独取消某个协程，不会影响他的兄弟协程"><a href="#单独取消某个协程，不会影响他的兄弟协程" class="headerlink" title="单独取消某个协程，不会影响他的兄弟协程"></a>单独取消某个协程，不会影响他的兄弟协程</h4><p>我们创建了两个协程，job1和job2.我们单独取消job1，不会影响到job2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们已经定义了一个作用域</span></span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">job1</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">job2</span> <span class="operator">=</span> scope.launch &#123; … &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个协程将会被取消，而另一个则不受任何影响</span></span><br><span class="line">job1.cancel()</span><br></pre></td></tr></table></figure>

<h4 id="协程通过抛出一个特殊的异常-CancellationException-来处理取消操作"><a href="#协程通过抛出一个特殊的异常-CancellationException-来处理取消操作" class="headerlink" title="协程通过抛出一个特殊的异常 CancellationException 来处理取消操作"></a>协程通过抛出一个特殊的异常 CancellationException 来处理取消操作</h4><p>在调用cancel函数的时候，我们需要传入一个CancellationException对象,如果我们没有传入，那就用默认的defaultCancellationException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// external cancel with cause, never invoked implicitly from internal machinery</span></span><br><span class="line">   <span class="keyword">public</span> override fun <span class="title function_">cancel</span><span class="params">(cause: CancellationException?)</span> &#123;</span><br><span class="line">       cancelInternal(cause ?: defaultCancellationException())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>一旦抛出了CancellationException，我们就可以通过这一机制来处理协程的取消。在底层的实现中，子协程会通过抛出异常的方式将取消的情况通知它的父级，父协程通过传入的取消原因决定是否处理该异常。</p>
<h4 id="不能在已取消的作用域中再次启动新的协程"><a href="#不能在已取消的作用域中再次启动新的协程" class="headerlink" title="不能在已取消的作用域中再次启动新的协程"></a>不能在已取消的作用域中再次启动新的协程</h4><h4 id="调用了-cancel-方法为什么协程处理的任务没有停止？"><a href="#调用了-cancel-方法为什么协程处理的任务没有停止？" class="headerlink" title="调用了 cancel 方法为什么协程处理的任务没有停止？"></a>调用了 cancel 方法为什么协程处理的任务没有停止？</h4><p>不同的Diapatcher不同的区别，下一篇文章将介绍。<br> 我们以Dispatchers.Default为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line">suspend fun <span class="title function_">main</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line">    <span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">nextTime</span> <span class="operator">=</span> startTime</span><br><span class="line">        <span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;这是第$&#123;i&#125;次&quot;</span>)</span><br><span class="line">                i++</span><br><span class="line">                <span class="comment">//1000毫秒执行一次</span></span><br><span class="line">                nextTime += <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;取消&quot;</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    println(<span class="string">&quot;取消完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是第<span class="number">0</span>次</span><br><span class="line">这是第<span class="number">1</span>次</span><br><span class="line">取消</span><br><span class="line">取消完毕</span><br><span class="line">这是第<span class="number">2</span>次</span><br><span class="line">这是第<span class="number">3</span>次</span><br><span class="line">这是第<span class="number">4</span>次</span><br></pre></td></tr></table></figure>

<p>调用cancel方法之后，协程的任务依然在运行。调用cancel方法的时候，此时协程处于cancelling正在取消的状态，接着我们打印了2，3，4，处理任务结束之后，协程变成cancelled已经取消的状态，这是以Default举例，Default调度会等待协程任务处理完毕才取消。</p>
<h4 id="让协程可以被取消"><a href="#让协程可以被取消" class="headerlink" title="让协程可以被取消"></a>让协程可以被取消</h4><p>协程处理任务都是协作式的，协作的意思就是我们的处理任务要配合协程取消做处理。因此在执行任务期间我们要定时检查协程的状态是否已经取消，例如我们从磁盘读取文件之前我们先检查协程是否被取消了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">    <span class="keyword">for</span>(file in files) &#123;</span><br><span class="line">        <span class="comment">// TODO 检查协程是否被取消</span></span><br><span class="line">        readFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协程中的挂起函数都是可取消的，使用他们的时候，我们不需要检查协程是否已取消。例如withContext，delay 。如果没有这些挂起函数，为了让我们的代码配合协程取消，可以使用一下两种方法：</p>
<ul>
<li>检查 job.isActive 或者使用 ensureActive()</li>
<li>使用 yield() 来让其他任务进行</li>
</ul>
<h4 id="检查-job-的活跃状态"><a href="#检查-job-的活跃状态" class="headerlink" title="检查 job 的活跃状态"></a>检查 job 的活跃状态</h4><p>先看一下第一种方法，在我们的 while(i&lt;5) 循环中添加对于协程状态的检查:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为处于 launch 的代码块中，可以访问到 job.isActive 属性</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive)</span><br></pre></td></tr></table></figure>

<h4 id="使用-yield-函数运行其他任务"><a href="#使用-yield-函数运行其他任务" class="headerlink" title="使用 yield() 函数运行其他任务"></a>使用 yield() 函数运行其他任务</h4><h4 id="Job-join-和-Deferred-await-cancellation"><a href="#Job-join-和-Deferred-await-cancellation" class="headerlink" title="Job.join 和 Deferred.await cancellation"></a>Job.join 和 Deferred.await cancellation</h4><p>等待协程处理结果有两种方法，launch启动的job可以调用join，async 返回的Deferred 可以调用await方法</p>
<ul>
<li>job.join会让协程挂起，直到等待协程处理任务完毕，我们可以配合cancel使用</li>
<li>deferred.await()如果我们关心协程的处理结果，我们可以使用deferred。结果由deferred.await返回。也是job类型，也可以被取消。</li>
</ul>
<h4 id="处理协程取消的副作用"><a href="#处理协程取消的副作用" class="headerlink" title="处理协程取消的副作用"></a>处理协程取消的副作用</h4><p>当我们需要在协程取消 后处理一些清理的工作，或者做一些打印日志。我们有几种办法：</p>
<ul>
<li>通过检查协程的状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (…) &#123;</span><br><span class="line">        println(“Hello $&#123;i++&#125;”)</span><br><span class="line">        nextPrintTime += <span class="number">500L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 协程所处理的任务已经完成，因此我们可以做一些清理工作</span></span><br><span class="line">println(“Clean up!”</span><br></pre></td></tr></table></figure>

<p>当判断协程不是isActive状态的时候，我们可以做一些清理</p>
<ul>
<li>try catch finally<br> 我们知道协程的取消会抛出CancellationException 异常，我们可以在协程提中使用try catch finally，在finally中做我们的一些清理的工作，或者打印日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      work()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: CancellationException)&#123;</span><br><span class="line">      println(“Work cancelled!”)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(“Clean up!”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000L</span>)</span><br><span class="line">println(“Cancel!”)</span><br><span class="line">job.cancel()</span><br><span class="line">println(“Done!</span><br></pre></td></tr></table></figure>

<h4 id="已经取消的协程，不能再被挂起"><a href="#已经取消的协程，不能再被挂起" class="headerlink" title="已经取消的协程，不能再被挂起"></a>已经取消的协程，不能再被挂起</h4><p>已经取消的协程，不能再被挂起，但是当我们需要在取消的协程中调用挂起函数，那么我们可以在finally中使用NonCancellable ，意思是让协程挂起，直到处理挂起函数中的代码完毕，协程才会取消。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      work()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: CancellationException)&#123;</span><br><span class="line">      println(“Work cancelled!”)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      withContext(NonCancellable)&#123;</span><br><span class="line">         delay(<span class="number">1000L</span>) <span class="comment">// 或一些其他的挂起函数</span></span><br><span class="line">         println(“Cleanup done!”)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000L</span>)</span><br><span class="line">println(“Cancel!”)</span><br><span class="line">job.cancel()</span><br><span class="line">println(“Done!</span><br></pre></td></tr></table></figure>

<p>在jetpack中使用viewModelScope 或者lifecycleScope 中定义的作用域，他们在scope完成后取消他们的处理任务。如果我们手动创建自己的作用域CoroutineScope，我们需要协作协程，将我们的作用域和job绑定，在需要的时候取消。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-1 Kotlin/01 Kotlin 协程/Kotlin 的协程本质到底什么 copy"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/">协程核心概念的理解与应用(一)--翻译翻译什么是 CoroutineScope</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/1%20Kotlin/01%20Kotlin%20%E5%8D%8F%E7%A8%8B/Kotlin%20%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%20copy/" class="article-date">
	  <time datetime="2023-08-10T23:19:04.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://s21.ax1x.com/2024/03/09/pFymrC9.jpg" alt="图片描述"></p>
<p>作者：朕小猫与GPT4</p>
<h1 id="Android-如何在一个非-LifecycleOwner-的类中使用协程"><a href="#Android-如何在一个非-LifecycleOwner-的类中使用协程" class="headerlink" title="Android 如何在一个非 LifecycleOwner 的类中使用协程"></a>Android 如何在一个非 LifecycleOwner 的类中使用协程</h1><p>在非<code>LifecycleOwner</code>的类中使用协程，你不能直接使用与生命周期相关的作用域，如<code>lifecycleScope</code>或<code>viewModelScope</code>。不过，你可以使用<code>CoroutineScope</code>来创建自己的作用域。使用<code>CoroutineScope</code>，你可以定义一个作用域，并指定一个<code>Dispatcher</code>来控制协程的执行线程。此外，你还需要手动管理协程的生命周期，以避免内存泄漏。</p>
<p>以下是如何在非<code>LifecycleOwner</code>类中使用协程的一个基本示例：</p>
<ol>
<li><p><strong>定义协程作用域</strong>：首先，定义一个协程作用域，通常是类的成员变量。这个作用域应当与你希望协程执行的生命周期绑定。例如，如果你在一个普通类中工作，你可能需要在类被销毁时取消所有协程。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.CoroutineScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Job</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> job = Job()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutineScope = CoroutineScope(Dispatchers.Main + job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在协程作用域内启动协程</strong>：使用定义的协程作用域启动协程，执行异步操作。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ...前面的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineScope.launch &#123;</span><br><span class="line">            <span class="comment">// 在这里执行协程代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>管理协程生命周期</strong>：为避免内存泄漏，确保在不需要协程运行时取消它们。如果你的类有一个明确的生命周期结束点（如自定义视图的<code>onDetachedFromWindow</code>或者一个对象的<code>close</code>方法），你应当在那里取消作用域中的所有协程。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    job.cancel() <span class="comment">// 取消与这个作用域相关的所有协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过以上步骤，你可以在不依赖于<code>LifecycleOwner</code>的情况下，安全地在任何类中使用协程。记住，手动管理协程的生命周期是避免内存泄漏的关键。</p>
<h1 id="如何理解-CoroutineContext"><a href="#如何理解-CoroutineContext" class="headerlink" title="如何理解 CoroutineContext"></a>如何理解 CoroutineContext</h1><p><code>CoroutineContext</code>是Kotlin协程中用于持有协程相关配置的接口。它由一组元素组成，每个元素都实现了<code>CoroutineContext.Element</code>接口，并且通过一个唯一的<code>Key</code>进行标识。<code>CoroutineContext</code>的实现并不限于某些固定的子类，而是通过组合不同的<code>Element</code>实例来扩展其功能。这意味着<code>CoroutineContext</code>的“子类”实际上是指一系列标准库或自定义库中定义的实现了<code>CoroutineContext.Element</code>接口的类，这些类代表了不同的协程配置和特性。以下是一些常见的<code>CoroutineContext.Element</code>实现，它们在Kotlin协程的使用中扮演着关键角色：</p>
<ol>
<li><p><strong><code>Job</code></strong>: 控制协程的生命周期，允许启动、取消、和查询协程的状态。<code>Job</code>是协程工作的基本单位，可以被用来取消协程。</p>
</li>
<li><p><strong><code>CoroutineDispatcher</code></strong>: 决定协程在哪个线程或线程池上执行。<code>Dispatchers.Main</code>、<code>Dispatchers.IO</code>、和<code>Dispatchers.Default</code>是最常用的几种调度器。</p>
</li>
<li><p><strong><code>CoroutineName</code></strong>: 提供协程的名称，有助于调试。</p>
</li>
<li><p><strong><code>CoroutineExceptionHandler</code></strong>: 定义了协程如何处理未捕获的异常。可以用来全局或局部地处理异常。</p>
</li>
</ol>
<p>除了上述提到的标准元素外，开发者还可以实现自定义的<code>CoroutineContext.Element</code>来扩展协程的功能。每个元素都可以通过其<code>Key</code>加入到<code>CoroutineContext</code>中，同时保证<code>CoroutineContext</code>中的每个<code>Key</code>都是唯一的。</p>
<p>在实际应用中，这些元素可以通过<code>+</code>操作符组合在一起，形成一个包含多个配置的<code>CoroutineContext</code>，用于启动和管理协程。这种设计允许协程上下文在保持灵活性的同时，能够非常精确地控制协程的行为和环境。</p>
<h1 id="协程的-号代表什么"><a href="#协程的-号代表什么" class="headerlink" title="协程的 + 号代表什么"></a>协程的 + 号代表什么</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a context containing elements from this context and elements from  other [context].</span></span><br><span class="line"><span class="comment"> * The elements from this context with the same key as in the other one are dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> operator fun <span class="title function_">plus</span><span class="params">(context: CoroutineContext)</span>: CoroutineContext =</span><br><span class="line">    <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="built_in">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">        context.fold(<span class="built_in">this</span>) &#123; acc, element -&gt;</span><br><span class="line">            <span class="type">val</span> <span class="variable">removed</span> <span class="operator">=</span> acc.minusKey(element.key)</span><br><span class="line">            <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">interceptor</span> <span class="operator">=</span> removed[ContinuationInterceptor]</span><br><span class="line">                <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">val</span> <span class="variable">left</span> <span class="operator">=</span> removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                    <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                        CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>plus</code>函数是<code>CoroutineContext</code>的一个操作符函数，用于合并两个协程上下文（<code>CoroutineContext</code>），返回一个包含两者元素的新上下文。如果两个上下文中有相同键（<code>key</code>）的元素，那么原上下文（<code>this</code>）中的元素会被丢弃。这个函数的主要逻辑可以分解为几个关键步骤：</p>
<ol>
<li><p><strong>快速路径检查</strong>：如果要添加的上下文（<code>context</code>）是一个空的协程上下文（<code>EmptyCoroutineContext</code>），则直接返回当前上下文（<code>this</code>），因为没有新元素需要添加。</p>
</li>
<li><p><strong>遍历合并</strong>：使用<code>fold</code>方法遍历<code>context</code>中的每个元素。<code>fold</code>接收一个初始累加值（这里是<code>this</code>，即当前上下文）和一个操作函数。操作函数定义了如何将<code>context</code>中的元素合并到累加值中。</p>
</li>
<li><p><strong>去除相同键的元素</strong>：对于<code>context</code>中的每个元素，先从累加值（即目前合并的结果）中移除具有相同键的元素。这一步确保了如果有相同键的元素，那么<code>this</code>中的元素会被<code>context</code>中的元素替换。</p>
</li>
<li><p><strong>合并上下文</strong>：如果移除相同键元素后的上下文是空的（<code>EmptyCoroutineContext</code>），则只添加当前遍历到的元素。否则，检查是否存在<code>ContinuationInterceptor</code>元素（协程拦截器），因为拦截器应当始终位于上下文中的最后，以便快速获取。</p>
</li>
<li><p><strong>调整拦截器位置</strong>：如果存在<code>ContinuationInterceptor</code>，将其移动到合并后的上下文的最后。这涉及到在没有拦截器的剩余上下文中添加当前元素，然后再添加拦截器。</p>
</li>
<li><p><strong>返回新的合并上下文</strong>：最终返回包含了<code>this</code>和<code>context</code>元素（且<code>context</code>中的元素优先）的新上下文。如果存在<code>ContinuationInterceptor</code>，确保它位于最后。</p>
</li>
</ol>
<p>简而言之，这个函数通过合并两个协程上下文并调整元素顺序，确保了新上下文中不会有重复的键，且<code>ContinuationInterceptor</code>（如果存在）总是位于最后，以优化性能。</p>
<h1 id="如何理解其中的-CoroutineContext-与-key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。"><a href="#如何理解其中的-CoroutineContext-与-key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。" class="headerlink" title="如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。"></a>如何理解其中的 CoroutineContext 与 key，为什么context中的元素优先，为什么如果存在ContinuationInterceptor，确保它位于最后。</h1><p><code>CoroutineContext</code>在Kotlin协程中是一个关键概念，它是一组各种元素的集合，这些元素定义了协程的行为。每个元素都有一个<code>Key</code>，用于唯一标识该元素的类型，这样<code>CoroutineContext</code>就可以通过键值对的方式存储和检索协程的配置和状态信息。这里的“相同键（key）的元素”意味着两个元素属于同一类型，或者说执行相同的功能或角色。</p>
<h3 id="CoroutineContext和-key"><a href="#CoroutineContext和-key" class="headerlink" title="CoroutineContext和 key"></a><code>CoroutineContext</code>和 key</h3><ul>
<li><p>**<code>CoroutineContext</code><strong>：是一个集合，包含了控制协程行为的各种元素，例如调度器（<code>Dispatcher</code>）、协程名称、协程的异常处理器等。每个元素通过一个唯一的键（</strong><code>Key</code>**）来识别，键通常由元素类型本身提供。</p>
</li>
<li><p><strong>相同键的元素</strong>：如果两个<code>CoroutineContext</code>元素具有相同的键，它们被视为同一类型的配置或状态信息。在合并上下文时，不能有重复键的元素，否则会产生冲突。</p>
</li>
</ul>
<h3 id="为什么context中的元素优先"><a href="#为什么context中的元素优先" class="headerlink" title="为什么context中的元素优先"></a>为什么<code>context</code>中的元素优先</h3><p>在合并两个<code>CoroutineContext</code>时，如果存在相同键的元素，<code>context</code>参数中的元素会替换当前上下文（<code>this</code>）中的元素。这个设计选择是基于函数式编程中常见的不可变性原则，以及配置更新的需求：新提供的配置（即<code>context</code>参数中的）被认为是最新的，应优先于旧的配置。这样，开发者可以灵活更新协程的行为，而无需担心旧上下文的状态。</p>
<h3 id="为什么ContinuationInterceptor位于最后"><a href="#为什么ContinuationInterceptor位于最后" class="headerlink" title="为什么ContinuationInterceptor位于最后"></a>为什么<code>ContinuationInterceptor</code>位于最后</h3><p><code>ContinuationInterceptor</code>是<code>CoroutineContext</code>中的一个特殊元素，用于拦截协程的执行。它是协程调度器（如<code>Dispatchers.Main</code>）的基础，控制着协程的执行线程。将<code>ContinuationInterceptor</code>放在合并后的<code>CoroutineContext</code>的最后，是出于性能考虑：</p>
<ul>
<li><p><strong>快速访问</strong>：协程在执行时频繁查询<code>ContinuationInterceptor</code>以确定执行线程。将其置于上下文的末尾可以优化这一查询过程，因为在<code>CoroutineContext</code>的实现中，较后的元素可以更快地被访问到。</p>
</li>
<li><p><strong>避免冲突</strong>：确保<code>ContinuationInterceptor</code>总是最后一个被添加，意味着即使合并多个上下文，也能保证只有一个有效的调度器在最终的上下文中生效，这避免了多个调度器可能导致的潜在冲突。</p>
</li>
</ul>
<p>综上所述，<code>CoroutineContext</code>及其键的概念允许协程行为的灵活配置和更新，而在合并上下文时优先考虑新的元素以及保持<code>ContinuationInterceptor</code>在最后，是出于更新优先级和性能优化的考虑。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/1-Kotlin/">1 - Kotlin</a>, <a class="article-category-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-2 Java/Java程序基础/ArrayDeque 的接口"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/">ArrayDeque 的接口</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/11/2%20Java/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/ArrayDeque%20%E7%9A%84%E6%8E%A5%E5%8F%A3/" class="article-date">
	  <time datetime="2023-08-10T23:17:10.000Z" itemprop="datePublished">August 11, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/2-Java/">2 - Java</a>, <a class="article-category-link" href="/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/">2.0 - Java 基础</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>ArrayDeque</code> 实现了 <code>Deque</code> 接口，该接口继承自 <code>Queue</code> 接口。下面是 <code>Deque</code> 接口中定义的一些主要方法：</p>
<ol>
<li><p>添加元素操作：</p>
<ul>
<li><code>addFirst(element: E)</code>：将元素添加到双端队列的开头。</li>
<li><code>addLast(element: E)</code>：将元素添加到双端队列的末尾。</li>
<li><code>offerFirst(element: E)</code>：将元素添加到双端队列的开头，并返回是否成功。</li>
<li><code>offerLast(element: E)</code>：将元素添加到双端队列的末尾，并返回是否成功。</li>
</ul>
</li>
<li><p>获取元素操作：</p>
<ul>
<li><code>getFirst(): E</code>：获取双端队列的第一个元素，但不删除它。</li>
<li><code>getLast(): E</code>：获取双端队列的最后一个元素，但不删除它。</li>
<li><code>peekFirst(): E</code>：获取双端队列的第一个元素，如果队列为空则返回 null。</li>
<li><code>peekLast(): E</code>：获取双端队列的最后一个元素，如果队列为空则返回 null。</li>
</ul>
</li>
<li><p>移除元素操作：</p>
<ul>
<li><code>removeFirst(): E</code>：移除并返回双端队列的第一个元素。</li>
<li><code>removeLast(): E</code>：移除并返回双端队列的最后一个元素。</li>
<li><code>pollFirst(): E</code>：移除并返回双端队列的第一个元素，如果队列为空则返回 null。</li>
<li><code>pollLast(): E</code>：移除并返回双端队列的最后一个元素，如果队列为空则返回 null。</li>
</ul>
</li>
</ol>
<p>此外，<code>ArrayDeque</code> 还实现了 <code>Queue</code> 接口中定义的方法，如 <code>offer(element: E)</code>、<code>remove(): E</code>、<code>poll(): E</code> 等。</p>
<p>需要注意的是，<code>ArrayDeque</code> 是一个可变大小的数组双端队列，可以在队列的两端进行高效的插入和删除操作，同时也支持随机访问。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/2-Java/">2 - Java</a>, <a class="article-category-link" href="/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/">2.0 - Java 基础</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a target="_blank" rel="noopener" href="https://github.com/CatJason" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a target="_blank" rel="noopener" href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a target="_blank" rel="noopener" href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a target="_blank" rel="noopener" href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a target="_blank" rel="noopener" href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a target="_blank" rel="noopener" href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a target="_blank" rel="noopener" href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/">0 - 算法</a><span class="category-list-count">33</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-0-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/">0.0 - 算法模版</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/">0.1 - 算法题目</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-0-%E7%AE%80%E5%8D%95/">0.1.0 - 简单</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-1-%E4%B8%AD%E7%AD%89/">0.1.1 - 中等</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-1-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/0-1-2-%E5%9B%B0%E9%9A%BE/">0.1.2 - 困难</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/0-%E7%AE%97%E6%B3%95/0-2-80-%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">0.2 - 80 道基础算法</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/1-Kotlin/">1 - Kotlin</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/1-Kotlin/1-0-Kotlin-%E5%9F%BA%E7%A1%80/">1.0 - Kotlin 基础</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/1-Kotlin/1-1-Kotlin-%E5%8D%8F%E7%A8%8B/">1.1 - Kotlin 协程</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">10 - 计算机网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/11-%E9%9F%B3%E8%A7%86%E9%A2%91/">11 - 音视频</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/11-%E9%9F%B3%E8%A7%86%E9%A2%91/11-1-%E6%92%AD%E6%94%BE%E5%99%A8/">11.1 - 播放器</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/2-Java/">2 - Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/2-Java/2-0-Java-%E5%9F%BA%E7%A1%80/">2.0 - Java 基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2-Java/2-0-Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">2.0 - Java 多线程</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/3-Android/">3 - Android</a><span class="category-list-count">21</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/3-Android/3-0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">3.0 - 性能优化</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/3-Android/3-1-Framework/">3.1 - Framework</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/3-Android/3-2-Arouter/">3.2 - Arouter</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/3-Android/3-4-Jetpacket/">3.4 - Jetpacket</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/">4 - 架构方案设计</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-1-MVI/">4.1 - MVI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-1-%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/">4.1 - 播放器架构方案设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/4-%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/4-2-Android-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/">4.2 - Android 存储文件方案设计</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/">6 - Android 打包编译</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-1-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/">6.1 - 文件分析</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/6-Android-%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91/6-2-%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84-gradle-%E4%BA%91%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE/">6.2 - 简单好用的 gradle 云编译设置</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/">7 - 复杂代码模版</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-1-UI-%E7%BB%98%E5%88%B6%E6%A8%A1%E7%89%88/">7.1 - UI 绘制模版</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/7-%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/7-2-%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/">7.2 - 手势分发</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/8-C/">8 - C++</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/8-C/8-1-C-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">8.1 - C++理论基础</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/">8 - 渲染引擎</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-1-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%8B%86%E8%A7%A3/">8.1 - 基础项目拆解</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/8-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/8-2-OpenGL-ES-3-0/">8.2 - OpenGL ES 3.0</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/9-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/">9 - 第三方网站分享</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">63</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2025/01/04/11%20%E9%9F%B3%E8%A7%86%E9%A2%91/01%20%E6%92%AD%E6%94%BE%E5%99%A8/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%80%E4%B8%AA-Android-%E6%92%AD%E6%94%BE%E5%99%A8/">从零开始写一个 Android 播放器（一）</a></h6>
              <span>January 4, 2025</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2024/11/02/6%20Android%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/CMake-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">CMake 中的静态连接和动态链接</a></h6>
              <span>November 2, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2024/04/14/1%20Kotlin/02%20Kotlin%20%E5%9F%BA%E7%A1%80/Kotlin%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/">Kotlin中的自动拆装箱</a></h6>
              <span>April 14, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2024/04/01/3%20Android/Jetpacket/VideoModel/0%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%80)/">ViewModel 源代码分析 (一)</a></h6>
              <span>April 1, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2024/04/01/3%20Android/Jetpacket/VideoModel/1%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%BA%8C)/">ViewModel 源代码分析 (二)</a></h6>
              <span>April 1, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2024/04/01/3%20Android/Jetpacket/VideoModel/2%20ViewModel%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20(%E4%B8%89)%20/">ViewModel 源代码分析 (三)</a></h6>
              <span>April 1, 2024</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2025 喵星科技报 All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/CatJason" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
