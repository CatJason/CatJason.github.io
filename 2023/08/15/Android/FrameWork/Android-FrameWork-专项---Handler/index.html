<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android FrameWork 专项 - Handler（一） | 喵星科技报</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein  Q：一个线程有几个 Handler？ Q: 线程间的通信的原理是怎样的？">
<meta property="og:type" content="article">
<meta property="og:title" content="Android FrameWork 专项 - Handler（一）">
<meta property="og:url" content="http://example.com/2023/08/15/Android/FrameWork/Android-FrameWork-%E4%B8%93%E9%A1%B9---Handler/index.html">
<meta property="og:site_name" content="喵星科技报">
<meta property="og:description" content="问题12The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.― Albert Einstein  Q：一个线程有几个 Handler？ Q: 线程间的通信的原理是怎样的？">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-08-14T21:02:48.688Z">
<meta property="article:modified_time" content="2023-08-15T11:14:35.781Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="喵星科技报" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 5.4.2"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="喵星科技报" rel="home"> 喵星科技报 </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="/"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="archives"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="categories"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="tags"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="about"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Android/FrameWork/Android-FrameWork-专项---Handler" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Android FrameWork 专项 - Handler（一）
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/08/15/Android/FrameWork/Android-FrameWork-%E4%B8%93%E9%A1%B9---Handler/" class="article-date">
	  <time datetime="2023-08-14T21:02:48.688Z" itemprop="datePublished">August 15, 2023</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/3-Android/">3 - Android</a>, <a class="article-category-link" href="/categories/3-Android/3-1-FrameWork/">3.1 - FrameWork</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The formulation of the problem is often more essential than its solution, which may be merely a matter of mathematical or experimental skill.</span><br><span class="line">― Albert Einstein</span><br></pre></td></tr></table></figure>

<p>Q：一个线程有几个 Handler？</p>
<p>Q: 线程间的通信的原理是怎样的？</p>
<p>Q: Handler 内存泄漏的原因？为什么其他的内部类没有说过这个问题？</p>
<p>Q: 为何主线程可以 new Handler ？如果想要在子线程中 new Handler 要做些什么准备？</p>
<p>Q: 子线程中维护的 Looper，消息队列无消息的时候的处理方案是什么？有什么用？</p>
<p>Q: 既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个 Handler 可能处于不同线程），那它内部时如何确保线程安全的？</p>
<p>Q: Looper 死循环为什么不会导致应用卡死</p>
<p>Q: 为什么主线程不需要自己创建和管理消息循环</p>
<h3 id="Handler-在-Android-中的作用"><a href="#Handler-在-Android-中的作用" class="headerlink" title="Handler 在 Android 中的作用"></a>Handler 在 Android 中的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler 是针对 Android 系统中与 UI 线程通信而专门设计的多线程通信机制</span><br></pre></td></tr></table></figure>

<p>Retorfit，eventbus，rxjava，Looper</p>
<h3 id="Handler-源代码分析"><a href="#Handler-源代码分析" class="headerlink" title="Handler 源代码分析"></a>Handler 源代码分析</h3><h4 id="子线程-发送-MSG"><a href="#子线程-发送-MSG" class="headerlink" title="子线程 发送 MSG"></a>子线程 发送 MSG</h4><p>​	android.os.Handler#sendMessage -&gt;<br>​	android.os.Handler#sendMessageDelayed -&gt;<br>​	android.os.Handler#sendMessageAtTime -&gt;<br>​	android.os.Handler#enqueueMessage -&gt;<br>​	android.os.MessageQueue#enqueueMessage -&gt;<br>​	android.os.Looper#loop</p>
<h5 id="android-os-Handler-sendMessage"><a href="#android-os-Handler-sendMessage" class="headerlink" title="android.os.Handler#sendMessage"></a>android.os.Handler#sendMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes a message onto the end of the message queue after all pending messages</span></span><br><span class="line"><span class="comment">     * before the current time. It will be received in &#123;<span class="doctag">@link</span> #handleMessage&#125;,</span></span><br><span class="line"><span class="comment">     * in the thread attached to this handler.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment">     *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">     *         looper processing the message queue is exiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有挂起的消息之后将消息推送到消息队列的末尾</span></span><br><span class="line"><span class="comment">     * 当前时间之前。它将在 &#123;<span class="doctag">@link</span> #handleMessage&#125; 中收到，</span></span><br><span class="line"><span class="comment">     * 在附加到该处理程序的线程中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果消息成功放入则返回 true</span></span><br><span class="line"><span class="comment">     * 消息队列。失败时返回 false，通常是因为</span></span><br><span class="line"><span class="comment">     * 处理消息队列的 looper 正在退出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="android-os-Handler-sendMessageDelayed"><a href="#android-os-Handler-sendMessageDelayed" class="headerlink" title="android.os.Handler#sendMessageDelayed"></a>android.os.Handler#sendMessageDelayed</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before (current time + delayMillis). You will receive it in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached to this handler.</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一条消息放入消息队列中，位于所有挂起的消息之后</span></span><br><span class="line"><span class="comment"> * 之前（当前时间+delayMillis）。您将在以下时间收到它：</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #handleMessage&#125;，在附加到该处理程序的线程中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果消息成功放入则返回 true</span></span><br><span class="line"><span class="comment"> * 消息队列。失败时返回 false，通常是因为</span></span><br><span class="line"><span class="comment"> * 处理消息队列的 looper 正在退出。请注意，一个</span></span><br><span class="line"><span class="comment"> * true 的结果并不意味着该消息将被处理 -- 如果</span></span><br><span class="line"><span class="comment"> * Looper 在消息发送之前退出</span></span><br><span class="line"><span class="comment"> * 发生则消息将被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="android-os-Handler-sendMessageAtTime"><a href="#android-os-Handler-sendMessageAtTime" class="headerlink" title="android.os.Handler#sendMessageAtTime"></a>android.os.Handler#sendMessageAtTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * Time spent in deep sleep will add an additional delay to execution.</span></span><br><span class="line"><span class="comment"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment"> * to this handler.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment"> *         delivered, using the</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将消息排队到消息队列中，在绝对时间（以毫秒为单位）&lt;var&gt;uptimeMillis&lt;/var&gt;之后的所有挂起消息之后。</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;时间基准是 &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * 在深度睡眠期间花费的时间将会额外延迟执行。</span></span><br><span class="line"><span class="comment"> * 您将在&#123;<span class="doctag">@link</span> #handleMessage&#125;中接收它，该方法会在与此处理程序连接的线程中执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis 消息应该传递的绝对时间，使用&#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;作为时间基准。</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果消息成功放置到消息队列中，则返回 true 。如果失败，则返回 false ，通常是因为处理消息队列的消息循环正在退出。</span></span><br><span class="line"><span class="comment"> * 请注意，返回true并不意味着消息将被处理 - 如果消息传递时间之前消息循环被退出，则消息将被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="android-os-Handler-enqueueMessage"><a href="#android-os-Handler-enqueueMessage" class="headerlink" title="android.os.Handler#enqueueMessage"></a>android.os.Handler#enqueueMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，发送流程都没什么好说的</p>
<h5 id="重点：android-os-Handler-handleMessage"><a href="#重点：android-os-Handler-handleMessage" class="headerlink" title="重点：android.os.Handler#handleMessage"></a>重点：android.os.Handler#handleMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="msg-target-是什么"><a href="#msg-target-是什么" class="headerlink" title="msg.target 是什么"></a>msg.target 是什么</h6><p>注意：<strong>这里 msg.target 就是 msg 持有的 handler 也是 为什么会有内存泄漏风险的原因。</strong></p>
<p>分析代码：</p>
<h6 id="Handler-内存泄漏原因"><a href="#Handler-内存泄漏原因" class="headerlink" title="Handler 内存泄漏原因"></a>Handler 内存泄漏原因</h6><p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler持有，这样最终就导致 Activity 泄露。</p>
<p>它的主要作用是将消息按照时间顺序插入到消息队列中，并在必要时唤醒队列以处理这些消息。下面逐步分析代码的功能和逻辑。</p>
<ol>
<li><p>首先，代码对传入的消息 <code>msg</code> 进行一些验证。它确保消息有一个非空的目标（<code>msg.target != null</code>），否则抛出 <code>IllegalArgumentException</code>。</p>
</li>
<li><p>然后，代码在同步块内执行以下操作：</p>
<ul>
<li><p>检查消息是否已经在使用中，如果是，则抛出 <code>IllegalStateException</code>。这可能是为了防止重复使用消息，确保每个消息只被处理一次。</p>
</li>
<li><p>检查当前处理器是否正在退出（<code>mQuitting</code> 标志），如果是，就回收消息并返回 false，表示消息未被成功加入队列。</p>
</li>
<li><p>将消息标记为正在使用，并设置消息的触发时间 <code>msg.when</code> 为传入的 <code>when</code>。</p>
</li>
<li><p>获取消息队列的头部消息 <code>p</code>。</p>
</li>
</ul>
</li>
<li><p>接下来，代码根据以下条件进行处理：</p>
<ul>
<li><p>如果消息队列为空，或者传入的触发时间 <code>when</code> 为 0，或者传入的 <code>when</code> 小于队列头部消息的触发时间 <code>p.when</code>，则将新消息插入到队列头部。如果队列当前被阻塞（<code>mBlocked</code> 标志），则设置需要唤醒队列（<code>needWake = true</code>）。</p>
</li>
<li><p>否则，如果消息需要插入队列中间，则根据条件判断是否需要唤醒队列。具体判断条件是：队列被阻塞、队列头部消息的目标为 null，且传入的消息是异步消息。然后，代码在一个循环中遍历消息队列，找到合适的位置插入新消息。循环会一直迭代，直到找到合适的位置或者遍历完整个队列。</p>
</li>
<li><p>在找到合适的位置后，代码将新消息 <code>msg</code> 插入到队列中。具体做法是，将 <code>msg.next</code> 设置为当前消息 <code>p</code>，然后将前一个消息 <code>prev.next</code> 设置为新消息 <code>msg</code>。</p>
</li>
</ul>
</li>
<li><p>最后，代码根据之前的标志 <code>needWake</code> 来决定是否唤醒队列。如果需要唤醒，则调用本地的 <code>nativeWake</code> 方法（可能是一个底层的本地方法）来唤醒消息队列。</p>
</li>
<li><p>整个同步块结束后，代码返回 true，表示消息已经成功加入队列。</p>
</li>
</ol>
<p>这段代码的核心功能是在消息队列中插入消息并进行适当的排序，以确保消息按照触发时间顺序进行处理。同时，它还处理了一些异常情况，如消息已经在使用中或者处理器正在退出。唤醒队列的逻辑也在代码的最后部分进行处理。</p>
<p>让我们逐步分析 MSG 插入队列的位置：</p>
<h6 id="第一种插入头部的情况："><a href="#第一种插入头部的情况：" class="headerlink" title="第一种插入头部的情况："></a>第一种插入头部的情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">      <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">      needWake = mBlocked;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果消息队列为空，意味着<strong>当前没有任何消息在队列中等待处理</strong>。在这种情况下，不需要比较触发时间，<strong>直接将新消息插入到队列的头部</strong>。这会让新消息成为队列的第一个要处理的消息。</li>
<li>如果<strong>传入的触发时间 <code>when</code> 为 0</strong>，这可能表示<strong>该消息需要尽快处理</strong>，因此同样将它插入到队列的头部。</li>
<li>如果<strong>传入的触发时间</strong> <code>when</code> <strong>小于队列头部消息的触发时间</strong> <code>p.when</code>，这意味着新消息应该在队列中位于当前头部消息之前，因此<strong>同样将它插入到队列的头部</strong>。</li>
</ol>
<p>综合上述情况，无论是<strong>队列为空</strong>，还是<strong>传入的 <code>when</code> 值为 0</strong>，或者<strong>传入的 <code>when</code> 值小于队列头部消息的触发时间</strong>，都会<strong>将新消息插入到队列的头部</strong>。</p>
<h6 id="第二种插入中间的情况："><a href="#第二种插入中间的情况：" class="headerlink" title="第二种插入中间的情况："></a>第二种插入中间的情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">       <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">       <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">       needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">       Message prev;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                needWake = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">       prev.next = msg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，如果不满足前面提到的条件（消息队列为空，传入的触发时间为0，或传入的触发时间小于队列头部消息的触发时间），那么意味着要插入的新消息 <code>msg</code> 应该位于队列中间。</li>
<li>在这种情况下，代码会进入一个循环。这个循环的目的是遍历消息队列，以找到合适的位置将新消息 <code>msg</code> 插入队列中。</li>
<li>循环的条件是 <code>for (;;)</code>，这将创建一个无限循环，直到内部的某个条件满足而跳出循环。</li>
<li>在每次循环迭代中，代码会做以下事情：<ul>
<li>将当前消息 <code>p</code> 的引用赋值给 <code>prev</code>，这样可以记录下前一个消息。</li>
<li>将 <code>p</code> 移动到下一个消息（<code>p = p.next</code>）。</li>
</ul>
</li>
<li>然后，代码检查两个条件：<ul>
<li>如果当前消息 <code>p</code> 为空，意味着已经遍历了整个队列，或者队列只有一个消息且当前消息是最后一个消息。</li>
<li>如果传入的触发时间 <code>when</code> 小于队列中当前消息 <code>p</code> 的触发时间 <code>p.when</code>。</li>
</ul>
</li>
<li>如果满足以上任一条件，循环会被中断，这表示找到了合适的位置将新消息 <code>msg</code> 插入到消息队列中。</li>
<li>在循环的每个迭代中，代码还会检查以下条件：<ul>
<li>如果需要唤醒队列（<code>needWake = true</code>），并且当前消息 <code>p</code> 是异步消息（<code>p.isAsynchronous()</code> 返回 true），则将 <code>needWake</code> 设置为 false。这个步骤可能是为了控制是否需要在队列中插入异步消息时唤醒队列。</li>
</ul>
</li>
<li>一旦找到了合适的位置，代码会执行以下操作：<ul>
<li>将新消息 <code>msg</code> 的 <code>next</code> 指针指向当前消息 <code>p</code>，这相当于将新消息插入到当前消息 <code>p</code> 之前。</li>
<li>将前一个消息 <code>prev</code> 的 <code>next</code> 指针指向新消息 <code>msg</code>，以确保队列中消息的连接关系正确。</li>
</ul>
</li>
<li>循环结束后，新消息 <code>msg</code> 已经被插入到队列的合适位置，保持了消息队列的有序性。</li>
</ol>
<p>总之，这段代码的目的是在消息队列中将新消息插入到适当的位置，以保持消息的时间顺序。在找到合适位置时，会根据一些条件来决定是否需要唤醒队列，这可能与队列的处理机制相关。</p>
<p>此外，如果当前消息队列被阻塞（<code>mBlocked</code> 为 true），则将标志 <code>needWake</code> 设置为 true。这是为了确保在需要唤醒队列以处理消息的情况下，能够在适当的时候执行唤醒操作。唤醒队列的操作可能涉及到一些底层机制，具体如何唤醒可能需要查看更多上下文代码。</p>
<p>总的来说，这段代码逻辑的目的是在特定条件下将新消息插入到消息队列的头部，并根据当前队列的阻塞状态决定是否需要唤醒队列以确保消息能够被及时处理。</p>
<h4 id="主线程-取出-MSG"><a href="#主线程-取出-MSG" class="headerlink" title="主线程 取出 MSG"></a>主线程 取出 MSG</h4><p>​	android.os.Looper#loop -&gt;<br>​	android.os.MessageQueue#next -&gt;<br>​	android.os.Handler#dispatchMessage -&gt;<br>​	android.os.Handler#handleMessage</p>
<h6 id="主线程中的-Loop"><a href="#主线程中的-Loop" class="headerlink" title="主线程中的 Loop"></a>主线程中的 Loop</h6><p>我们来看主线程的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format &quot;seq=114&quot;</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 handler 相关的关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">  	...</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">		···</span><br><span class="line">      </span><br><span class="line">    Looper.loop();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>准备</strong> Looper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure>

<p>android.os.Looper#prepareMainLooper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>android.os.Looper#prepare(boolean)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备 Handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>android.app.ActivityThread#getHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">	   <span class="keyword">public</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">	   <span class="keyword">return</span> mH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>android.app.ActivityThread#mH</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br></pre></td></tr></table></figure>

<p>开启循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>

<h5 id="重点：android-os-Looper-loop"><a href="#重点：android-os-Looper-loop" class="headerlink" title="重点：android.os.Looper#loop"></a>重点：android.os.Looper#loop</h5><h6 id="loop"><a href="#loop" class="headerlink" title="#loop"></a>#loop</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是 Android 框架中 Looper 类的 <code>loop()</code> 方法的实现，负责在当前线程的消息循环中执行消息的分发和处理。</p>
<ol>
<li>首先，通过 <code>myLooper()</code> 获取当前线程的 Looper 实例 <code>me</code>，如果没有 Looper 实例则抛出异常，表示未调用 <code>Looper.prepare()</code> 来准备 Looper。</li>
<li>检查 <code>me.mInLoop</code>，如果当前线程已经在消息循环中，则打印警告日志。</li>
<li>将 <code>me.mInLoop</code> 标志设置为 <code>true</code>，表示当前线程正在消息循环中。</li>
<li>使用 <code>Binder.clearCallingIdentity()</code> 来清除当前线程的调用标识，然后再次调用它并将返回的标识 <code>ident</code> 保存下来。</li>
<li>获取一个可能的系统属性覆盖值 <code>thresholdOverride</code>，用于调整慢分发的阈值。</li>
<li>将 <code>me.mSlowDeliveryDetected</code> 设置为 <code>false</code>，用于标记是否检测到慢投递。</li>
<li>进入一个无限循环，不断地执行消息分发和处理。</li>
<li>在循环中，调用 <code>loopOnce(me, ident, thresholdOverride)</code> 来执行一次消息分发。如果返回值为 <code>false</code>，表示没有更多的消息需要分发，退出循环。</li>
</ol>
<p>总之，这段代码描述了 Android 中消息循环的核心逻辑。它会在一个无限循环中，不断地从消息队列中获取消息并执行消息分发和处理，直到没有更多的消息需要处理为止。在循环中，还会检查是否有慢分发阈值的系统属性覆盖，并根据需要清除调用标识。如果发现当前线程已经在消息循环中，则会打印警告信息。</p>
<h6 id="loopOnce"><a href="#loopOnce" class="headerlink" title="#loopOnce"></a>#loopOnce</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">        <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">        <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">            <span class="keyword">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                    me.mSlowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是 Android 框架中 Looper 类的一个方法 <code>loopOnce</code> 的实现，主要负责处理消息队列中的消息分发过程。我会逐步解释代码的功能。</p>
<ol>
<li><p>首先，通过 <code>me.mQueue.next()</code> 获取下一个消息，如果没有消息则表示消息队列正在退出，函数返回 <code>false</code>。</p>
</li>
<li><p>如果获取到了消息，则会根据是否设置了日志打印，打印消息的分发信息。</p>
</li>
<li><p>获取当前的观察者对象和跟踪标签。</p>
</li>
<li><p>根据阈值覆盖值，更新慢分发和慢投递的阈值。</p>
</li>
<li><p>判断是否需要记录开始时间和结束时间，如果需要，则记录当前时间作为分发开始时间。</p>
</li>
<li><p>如果设置了跟踪标签且跟踪标签是启用的，则开始跟踪。</p>
</li>
<li><p>设置开始分发时间，并获取一个 token 以用于观察者的消息分发起始回调。</p>
</li>
<li><p>设置当前线程的工作源为消息的工作源 UID。</p>
</li>
<li><p>使用目标 Handler（Handler 是消息处理的目标）来分发消息。</p>
</li>
<li><p>如果设置了观察者，通知观察者消息已分发。</p>
</li>
<li><p>结束分发，记录结束时间。</p>
</li>
<li><p>如果发生异常，通知观察者分发过程中出现异常，并将异常抛出。</p>
</li>
<li><p>最终，无论是否发生异常，都会恢复线程的工作源，并根据跟踪标签是否启用，结束跟踪。</p>
</li>
<li><p>如果设置了慢投递日志，会根据条件判断是否记录慢投递日志。</p>
</li>
<li><p>如果设置了慢分发日志，会根据条件记录慢分发日志。</p>
</li>
<li><p>如果设置了日志打印，会打印消息分发完成信息。</p>
</li>
<li><p>最后，检查分发过程中线程标识是否被更改，如果发生改变，会打印警告日志。</p>
</li>
<li><p>回收消息对象并返回 <code>true</code>，表示成功分发消息。</p>
</li>
</ol>
<p>总之，这段代码描述了 Android 中消息队列中消息的分发过程，涵盖了消息的跟踪、日志记录、观察者通知等多个方面，确保消息能够按照正确的顺序分发到目标处理程序。</p>
<h5 id="重点：android-os-MessageQueue-next"><a href="#重点：android-os-MessageQueue-next" class="headerlink" title="重点：android.os.MessageQueue#next"></a>重点：android.os.MessageQueue#next</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个 Android 消息循环（Message Loop）的一部分，它用于处理消息队列中的消息。消息循环是 Android 应用程序的核心部分，用于处理用户界面事件、线程间通信等。</p>
<p>以下是代码的主要功能和逻辑：</p>
<ol>
<li><p>代码开头使用了一个注解 <code>@UnsupportedAppUsage</code>，这是 Android 的一个标记注解，用于标识不推荐使用的 API 或方法。</p>
</li>
<li><p><code>next()</code> 方法是一个消息循环的主要函数。它会循环从消息队列中获取消息，然后处理这些消息。</p>
</li>
<li><p>首先，代码会获取 <code>mPtr</code>，这是一个表示消息队列的指针。如果 <code>ptr</code> 为 0，表示消息队列已经被释放，函数会返回 <code>null</code>。</p>
</li>
<li><p>接下来，进入一个无限循环 <code>for (;;) &#123;...&#125;</code>，在循环内部做以下操作：</p>
<ul>
<li><p>如果 <code>nextPollTimeoutMillis</code> 不为 0，会刷新待处理的 Binder 命令（一种 Android 进程间通信机制）。</p>
</li>
<li><p>调用 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>，它是一个本地方法，用于轮询获取下一个消息。</p>
</li>
<li><p>进入同步块，开始处理消息队列中的消息。</p>
</li>
<li><p>首先，获取当前时间 <code>now</code>，然后尝试获取下一个消息。如果消息的目标为 <code>null</code>，表示该消息是一个异步消息（可能由于障碍而被阻塞），会查找下一个异步消息。</p>
</li>
<li><p>如果找到消息并且消息的触发时间在当前时间之后，会设置一个定时器来在消息准备好时唤醒循环。</p>
</li>
<li><p>如果消息已经准备好（触发时间已到），会将消息从队列中移除，并返回该消息。</p>
</li>
<li><p>如果没有找到消息，会将 <code>nextPollTimeoutMillis</code> 设为 -1，表示没有更多消息。</p>
</li>
<li><p>如果 <code>mQuitting</code> 为 true，表示消息队列已经被停止，会调用 <code>dispose()</code> 释放资源，并返回 <code>null</code>。</p>
</li>
<li><p>如果是第一次空闲（没有消息待处理），会获取待运行的空闲处理器数量。</p>
</li>
<li><p>如果没有空闲处理器需要运行，会将 <code>mBlocked</code> 设为 true，继续等待。</p>
</li>
<li><p>如果有待运行的空闲处理器，会将它们放入 <code>mPendingIdleHandlers</code> 数组中。</p>
</li>
<li><p>执行空闲处理器的 <code>queueIdle()</code> 方法，该方法用于处理空闲状态。</p>
</li>
<li><p>如果 <code>queueIdle()</code> 返回 false，表示该空闲处理器不再需要运行，会将其从列表中移除。</p>
</li>
<li><p>重置空闲处理器数量为 0，以防止重复运行。</p>
</li>
<li><p>在处理完空闲处理器后，将 <code>nextPollTimeoutMillis</code> 设为 0，以便立即查找待处理的消息。</p>
</li>
</ul>
</li>
</ol>
<p>以上就是这段代码的主要逻辑。它负责不断地从消息队列中获取消息并处理，同时也处理了一些特殊情况，如消息队列已停止、空闲处理等。这种消息循环机制保证了 Android 应用程序的响应性和流畅性。</p>
<h6 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h6><p>给定代码中最重要的部分是主循环，该循环处理消息并运行空闲处理程序，在Android消息循环系统中负责处理消息并及时有效地运行空闲处理程序。让我们逐步分解关键组成部分及其重要性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 收到一条消息。</span></span><br><span class="line">                mBlocked = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 从队列中移除消息并返回。</span></span><br><span class="line">                <span class="comment">// 这是消息处理的核心操作。</span></span><br><span class="line">                <span class="comment">// 它允许根据其预定时间依次执行消息。</span></span><br><span class="line">                <span class="comment">// 返回的“msg”对象包含用于处理的数据和指令。</span></span><br><span class="line">                msg.markInUse();</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有更多消息。</span></span><br><span class="line">            nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理退出消息并处理空闲处理程序。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行空闲处理程序。</span></span><br><span class="line">        <span class="comment">// 该块遍历待处理的空闲处理程序并执行它们。</span></span><br><span class="line">        <span class="comment">// 空闲处理程序用于在消息队列为空时执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置空闲处理程序计数并检查是否有新消息。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键部分及其重要性如下：</p>
<ol>
<li><code>nativePollOnce(ptr, nextPollTimeoutMillis);</code>：这个本地方法用于轮询来自底层系统的传入消息和事件。它等待指定的超时时间以获取新的消息。</li>
<li>消息处理：<ul>
<li>循环检查是否有待处理的消息，并根据其预定时间（<code>msg.when</code>）对其进行处理。</li>
<li>如果一条消息准备好执行，它会从队列中移除并返回（<code>return msg;</code>）。</li>
<li>这是消息循环的核心，消息按照它们被发布的顺序逐个执行。</li>
<li><code>markInUse()</code> 方法表示消息正在被处理。</li>
</ul>
</li>
<li>退出消息和空闲处理程序：<ul>
<li>循环检查消息循环是否正在退出（<code>mQuitting</code>）并在需要时释放资源。</li>
<li>还会处理空闲处理程序，这些程序在没有待处理消息时执行。</li>
<li>空闲处理程序是在消息循环处于非活动状态时执行任务的函数。</li>
</ul>
</li>
</ol>
<p>总的来说，这段代码片段代表了Android消息循环的核心机制，它对于管理异步任务、UI交互和基于事件的编程在Android应用中至关重要。这个循环的正常运行对于维持响应迅速、交互式的用户体验至关重要。</p>
<h5 id="android-os-Handler-dispatchMessage"><a href="#android-os-Handler-dispatchMessage" class="headerlink" title="android.os.Handler#dispatchMessage"></a>android.os.Handler#dispatchMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个 Android 消息分发方法，用于处理系统消息。在 Android 中，消息分发是消息循环的一部分，用于将消息传递给相应的处理方法或回调函数。</p>
<p>以下是代码的主要功能和逻辑：</p>
<ol>
<li><p>方法名为 <code>dispatchMessage</code>，接受一个非空的 <code>Message</code> 对象作为参数，用于处理系统消息。</p>
</li>
<li><p>首先，代码检查 <code>msg</code> 中是否存在一个非空的回调函数 <code>callback</code>。如果存在，表示该消息具有一个回调函数，将调用 <code>handleCallback(msg)</code> 来处理该回调函数。</p>
</li>
<li><p>如果 <code>msg</code> 中没有回调函数，代码会进入下一步判断。</p>
</li>
<li><p>首先，检查是否存在一个非空的成员变量 <code>mCallback</code>，它是一个消息处理器的回调接口。如果存在 <code>mCallback</code>，代码会调用 <code>handleMessage(msg)</code> 来处理消息。如果 <code>mCallback.handleMessage(msg)</code> 返回 <code>true</code>，表示消息已经被处理，函数会直接返回，不会继续执行后续的 <code>handleMessage(msg)</code>。</p>
</li>
<li><p>如果 <code>mCallback.handleMessage(msg)</code> 返回 <code>false</code>，表示 <code>mCallback</code> 没有处理该消息，代码会调用当前类的 <code>handleMessage(msg)</code> 方法来处理消息。</p>
</li>
</ol>
<p>综合起来，这段代码实现了一个消息分发的逻辑，首先检查消息是否有回调函数，然后尝试使用回调函数处理消息。如果没有回调函数，它会检查是否存在一个全局的消息处理器 <code>mCallback</code>，尝试让它处理消息。如果都没有成功处理，最后会调用当前类的 <code>handleMessage(msg)</code> 方法来处理消息。</p>
<p>这种消息分发机制使得消息能够在不同的处理方法和回调函数之间进行传递和处理，提高了代码的灵活性和可扩展性。</p>
<h5 id="android-os-Handler-handleMessage"><a href="#android-os-Handler-handleMessage" class="headerlink" title="android.os.Handler#handleMessage"></a>android.os.Handler#handleMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个方法声明，用于在子类中实现消息处理的逻辑。在 Android 中，消息处理是一种常见的模式，用于处理来自消息队列的不同类型的消息。</p>
<p>以下是代码的主要功能和逻辑：</p>
<ol>
<li><p>方法名为 <code>handleMessage</code>，接受一个非空的 <code>Message</code> 对象作为参数，用于处理消息。</p>
</li>
<li><p>这是一个抽象方法，没有具体的实现，因此需要在子类中进行实现。</p>
</li>
<li><p>子类必须重写这个方法，并根据具体的业务逻辑来处理传递进来的消息。</p>
</li>
<li><p>通过在子类中实现不同的 <code>handleMessage</code> 方法，可以实现不同类型的消息处理，从而达到分离不同功能的目的。</p>
</li>
</ol>
<p>在 Android 应用程序开发中，常常会使用这种消息处理机制来进行异步任务的处理、UI 更新、线程间通信等。子类可以根据不同的需求，实现不同的消息处理逻辑，使代码结构更加清晰和模块化。</p>
<h5 id="使用-handler-通信机制由主线程向子线程发送消息"><a href="#使用-handler-通信机制由主线程向子线程发送消息" class="headerlink" title="使用 handler 通信机制由主线程向子线程发送消息"></a>使用 handler 通信机制由主线程向子线程发送消息</h5><p>我们已经了解了主线程中会创建 Looper 和 handler，也明白了期运行逻辑<br>下面我们在子线程中创建这一套通信机制，用于主线程向子线程发送消息</p>
<h6 id="创建一个-CustomLooperThread"><a href="#创建一个-CustomLooperThread" class="headerlink" title="创建一个 CustomLooperThread"></a>创建一个 CustomLooperThread</h6><p> 手动创建子线程的 <code>Looper</code> 和关联的 <code>Handler</code>，以便在子线程中处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomLooperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mLooper) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mHandler.post(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            mLooper.quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二: <strong>使用 <code>HandlerThread</code>：</strong> 使用 <code>HandlerThread</code> 类封装了子线程的 <code>Looper</code> 和关联的 <code>Handler</code> 创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLooperThread</span> <span class="keyword">extends</span> <span class="title class_">HandlerThread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomLooperThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在子线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageToThread</span><span class="params">(<span class="type">int</span> what)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> mHandler.obtainMessage(what);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建一个-MyThreadManager"><a href="#创建一个-MyThreadManager" class="headerlink" title="创建一个 MyThreadManager"></a>创建一个 MyThreadManager</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyThread mThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程并启动</span></span><br><span class="line">        mThread = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在线程的消息循环中创建 Handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 在线程中处理消息</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到线程中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> mHandler.obtainMessage(what);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务在线程中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTaskInThread</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mThread.executeTask(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程和消息循环</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mThread.quit();</span><br><span class="line">            mThread = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h5><h6 id="方式一，自定义-Looper-和-Handler-创建的-CustomLooperThread-中的-getLooper-有没有问题？"><a href="#方式一，自定义-Looper-和-Handler-创建的-CustomLooperThread-中的-getLooper-有没有问题？" class="headerlink" title="方式一，自定义 Looper 和 Handler 创建的 CustomLooperThread 中的 getLooper 有没有问题？"></a>方式一，自定义 <code>Looper</code> 和 <code>Handler</code> 创建的 CustomLooperThread 中的 getLooper 有没有问题？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mThread.start();</span><br></pre></td></tr></table></figure>
<p>是在子线程中执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线程的消息循环中创建 Handler</span></span><br><span class="line">mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mThread.getLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 在线程中处理消息</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;thread.start()是在子线程中</span><br></pre></td></tr></table></figure>
<p>是在主线程执行的<br>也就是说在 mThread.getLooper() 时，有可能 mThread.start() 还没执行完<br>所以这里有<strong>多线程并发问题</strong></p>
<p>我们看一下 HandlerThread 中是怎么解决的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment"> * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment"> * has been started, this method will block until the looper has been initialized.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasInterrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                wasInterrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We may need to restore the thread&#x27;s interrupted flag, because it may</span></span><br><span class="line"><span class="comment">     * have been cleared above since we eat InterruptedExceptions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h6 id="Thread-中的-Handler-和-MyThreadManager-中-Handler-有什么不同，为什么需要两个-Handler？"><a href="#Thread-中的-Handler-和-MyThreadManager-中-Handler-有什么不同，为什么需要两个-Handler？" class="headerlink" title="Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同，为什么需要两个 Handler？"></a>Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同，为什么需要两个 Handler？</h6><ol>
<li><strong><code>MyThread</code> 类中的 <code>Handler</code>：</strong> 在 <code>MyThread</code> 类中的 <code>Handler</code> 用于处理子线程 <code>MyThread</code> 中的消息。它负责监听并处理从 <code>MyThread</code> 类的消息循环中传递过来的消息。这个 <code>Handler</code> 是在 <code>MyThread</code> 类的 <code>run()</code> 方法中创建并与 <code>Looper</code> 关联，以便在 <code>MyThread</code> 线程中处理消息。</li>
<li><strong><code>MyThreadManager</code> 类中的 <code>Handler</code>：</strong> 在 <code>MyThreadManager</code> 类中的 <code>Handler</code> 用于将消息发送到 <code>MyThread</code> 线程。它负责将来自主线程或其他地方的消息发送给 <code>MyThread</code> 线程的消息循环。这个 <code>Handler</code> 负责与 <code>MyThread</code> 线程进行通信，从而实现了在主线程或其他线程中触发 <code>MyThread</code> 线程执行特定任务。</li>
</ol>
<p>为什么需要两个 <code>Handler</code>？</p>
<ul>
<li><p><strong>分离职责：</strong> 这两个 <code>Handler</code> 所在的类分别负责不同的职责。<code>MyThread</code> 类负责创建子线程和处理子线程中的消息，而 <code>MyThreadManager</code> 类负责在其他地方发送消息到子线程中。</p>
</li>
<li><p><strong>线程隔离：</strong> 子线程中的 <code>Handler</code> 用于处理子线程中的任务，以确保任务在子线程中执行。而 <code>MyThreadManager</code> 类中的 <code>Handler</code> 用于从主线程或其他线程向子线程发送消息，使得主线程和子线程之间的通信变得更安全和方便。</p>
<p>这里我们提到了消息循环，我们下一章说 MessageQueue</p>
</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/3-Android/">3 - Android</a>, <a class="article-category-link" href="/categories/3-Android/3-1-FrameWork/">3.1 - FrameWork</a>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/08/12/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android-Bitmap-%E6%80%A7%E8%83%BD%E4%B8%93%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android Bitmap 性能专题 - Bitmap 内存从申请到回收</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler-%E5%9C%A8-Android-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">Handler 在 Android 中的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">Handler 源代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B-%E5%8F%91%E9%80%81-MSG"><span class="nav-number">3.1.</span> <span class="nav-text">子线程 发送 MSG</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#android-os-Handler-sendMessage"><span class="nav-number">3.1.1.</span> <span class="nav-text">android.os.Handler#sendMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android-os-Handler-sendMessageDelayed"><span class="nav-number">3.1.2.</span> <span class="nav-text">android.os.Handler#sendMessageDelayed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android-os-Handler-sendMessageAtTime"><span class="nav-number">3.1.3.</span> <span class="nav-text">android.os.Handler#sendMessageAtTime</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.1.4.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android-os-Handler-enqueueMessage"><span class="nav-number">3.1.5.</span> <span class="nav-text">android.os.Handler#enqueueMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9Aandroid-os-Handler-handleMessage"><span class="nav-number">3.1.6.</span> <span class="nav-text">重点：android.os.Handler#handleMessage</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#msg-target-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">msg.target 是什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Handler-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">Handler 内存泄漏原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%8F%92%E5%85%A5%E5%A4%B4%E9%83%A8%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">第一种插入头部的情况：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%8F%92%E5%85%A5%E4%B8%AD%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">3.1.6.4.</span> <span class="nav-text">第二种插入中间的情况：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B-%E5%8F%96%E5%87%BA-MSG"><span class="nav-number">3.2.</span> <span class="nav-text">主线程 取出 MSG</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84-Loop"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">主线程中的 Loop</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9Aandroid-os-Looper-loop"><span class="nav-number">3.2.1.</span> <span class="nav-text">重点：android.os.Looper#loop</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#loop"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">#loop</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#loopOnce"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">#loopOnce</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9Aandroid-os-MessageQueue-next"><span class="nav-number">3.2.2.</span> <span class="nav-text">重点：android.os.MessageQueue#next</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">核心代码：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android-os-Handler-dispatchMessage"><span class="nav-number">3.2.3.</span> <span class="nav-text">android.os.Handler#dispatchMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android-os-Handler-handleMessage"><span class="nav-number">3.2.4.</span> <span class="nav-text">android.os.Handler#handleMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-handler-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%94%B1%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%91%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">3.2.5.</span> <span class="nav-text">使用 handler 通信机制由主线程向子线程发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-CustomLooperThread"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">创建一个 CustomLooperThread</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-MyThreadManager"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">创建一个 MyThreadManager</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.6.</span> <span class="nav-text">引出问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89-Looper-%E5%92%8C-Handler-%E5%88%9B%E5%BB%BA%E7%9A%84-CustomLooperThread-%E4%B8%AD%E7%9A%84-getLooper-%E6%9C%89%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">方式一，自定义 Looper 和 Handler 创建的 CustomLooperThread 中的 getLooper 有没有问题？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Thread-%E4%B8%AD%E7%9A%84-Handler-%E5%92%8C-MyThreadManager-%E4%B8%AD-Handler-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA-Handler%EF%BC%9F"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">Thread 中的 Handler 和  MyThreadManager 中 Handler 有什么不同，为什么需要两个 Handler？</span></a></li></ol></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2023 喵星科技报 All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/CatJason" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
